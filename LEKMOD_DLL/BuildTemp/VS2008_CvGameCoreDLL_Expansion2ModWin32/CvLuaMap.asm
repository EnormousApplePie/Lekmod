; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Documents\GitHub\Lekmod\LEKMOD_DLL\CvGameCoreDLL_Expansion2\Lua\CvLuaMap.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG219448 DB	'Map', 00H
$SG219456 DB	'Areas', 00H
	ORG $+2
$SG219457 DB	'FindBiggestArea', 00H
$SG219458 DB	'FindWater', 00H
	ORG $+2
$SG219459 DB	'GetClimate', 00H
	ORG $+1
$SG219460 DB	'GetFractalFlags', 00H
$SG219461 DB	'GetGridSize', 00H
$SG219462 DB	'GetNumPlots', 00H
$SG219463 DB	'GetNumResources', 00H
$SG219464 DB	'GetNumResourcesOnLand', 00H
	ORG $+2
$SG219465 DB	'GetPlot', 00H
$SG219466 DB	'GetPlotByIndex', 00H
	ORG $+1
$SG219467 DB	'GetPlotXY', 00H
	ORG $+2
$SG219468 DB	'GetArea', 00H
$SG219469 DB	'GetIndexAfterLastArea', 00H
	ORG $+2
$SG219470 DB	'GetLandPlots', 00H
	ORG $+3
$SG219471 DB	'GetNumAreas', 00H
$SG219472 DB	'GetNumLandAreas', 00H
$SG219473 DB	'GetRandomResourceQuantity', 00H
	ORG $+2
$SG219474 DB	'GetSeaLevel', 00H
$SG219475 DB	'GetWorldSize', 00H
	ORG $+3
$SG219476 DB	'IsPlot', 00H
	ORG $+1
$SG219477 DB	'IsWrapX', 00H
$SG219478 DB	'IsWrapY', 00H
$SG219479 DB	'MaxPlotDistance', 00H
$SG219480 DB	'Rand', 00H
	ORG $+3
$SG219481 DB	'CalculateAreas', 00H
	ORG $+1
$SG219482 DB	'RecalculateAreas', 00H
	ORG $+3
$SG219483 DB	'PlotDistance', 00H
	ORG $+3
$SG219484 DB	'PlotXYWithRangeCheck', 00H
	ORG $+3
$SG219485 DB	'PlotDirection', 00H
	ORG $+2
$SG219486 DB	'DefaultContinentStamper', 00H
$SG219487 DB	'DoPlaceNaturalWonders', 00H
	ORG $+2
$SG219488 DB	'GetCustomOption', 00H
$SG219489 DB	'UpdateDeferredFog', 00H
	ORG $+2
$SG219490 DB	'ChangeAIMapHint', 00H
$SG219491 DB	'GetAIMapHint', 00H
	ORG $+3
$SG219559 DB	'FRAC_WRAP_X', 00H
$SG219561 DB	'FRAC_WRAP_Y', 00H
$SG219759 DB	'__instances', 00H
$SG219760 DB	'__mode', 00H
	ORG $+1
$SG219761 DB	'v', 00H
	ORG $+2
$SG219763 DB	'__instances', 00H
$SG219766 DB	'__instance', 00H
	ORG $+1
$SG219767 DB	'__index', 00H
$SG219788 DB	'__instances', 00H
$SG219789 DB	'__mode', 00H
	ORG $+1
$SG219790 DB	'v', 00H
	ORG $+2
$SG219792 DB	'__instances', 00H
$SG219795 DB	'__instance', 00H
	ORG $+1
$SG219796 DB	'__index', 00H
$SG219811 DB	'__instance', 00H
	ORG $+1
$SG219817 DB	'Not a valid instance.  Either the instance is NULL or yo'
	DB	'u used ''.'' instead of '':''.', 00H
CONST	ENDS
PUBLIC	?wrapCoordDifference@@YAHHI_N@Z			; wrapCoordDifference
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?wrapCoordDifference@@YAHHI_N@Z
_TEXT	SEGMENT
_iDiff$ = 8						; size = 4
_uiRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?wrapCoordDifference@@YAHHI_N@Z PROC			; wrapCoordDifference, COMDAT

; 57   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iDiff$[esp-4]
	je	SHORT $LN5@wrapCoordD

; 58   : 	{
; 59   : 		if(iDiff > (int)(uiRange >> 1))		// Using an unsigned int so we can safely assume that value >> 1 == value / 2

	mov	edx, DWORD PTR _uiRange$[esp-4]
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN3@wrapCoordD

; 60   : 		{
; 61   : 			return (iDiff - (int)uiRange);

	sub	eax, edx

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
$LN3@wrapCoordD:

; 62   : 		}
; 63   : 		else if(iDiff < -(int)(uiRange >> 1))

	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN5@wrapCoordD

; 64   : 		{
; 65   : 			return (iDiff + (int)uiRange);

	add	eax, edx
$LN5@wrapCoordD:

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
?wrapCoordDifference@@YAHHI_N@Z ENDP			; wrapCoordDifference
_TEXT	ENDS
PUBLIC	?xToHexspaceX@@YAHHH@Z				; xToHexspaceX
; Function compile flags: /Ogtpy
;	COMDAT ?xToHexspaceX@@YAHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?xToHexspaceX@@YAHHH@Z PROC				; xToHexspaceX, COMDAT

; 86   : 	return iX - ((iY >= 0) ? (iY>>1) : ((iY - 1)/2));

	mov	ecx, DWORD PTR _iY$[esp-4]
	test	ecx, ecx
	jge	SHORT $LN5@xToHexspac
	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
	mov	ecx, eax
$LN5@xToHexspac:
	mov	eax, DWORD PTR _iX$[esp-4]
	sar	ecx, 1
	sub	eax, ecx

; 87   : }

	ret	0
?xToHexspaceX@@YAHHH@Z ENDP				; xToHexspaceX
_TEXT	ENDS
PUBLIC	?hexspaceXToX@@YAHHH@Z				; hexspaceXToX
; Function compile flags: /Ogtpy
;	COMDAT ?hexspaceXToX@@YAHHH@Z
_TEXT	SEGMENT
_iHexspaceX$ = 8					; size = 4
_iHexspaceY$ = 12					; size = 4
?hexspaceXToX@@YAHHH@Z PROC				; hexspaceXToX, COMDAT

; 91   : 	return iHexspaceX + ((iHexspaceY >= 0) ? (iHexspaceY>>1) : ((iHexspaceY - 1)/2));

	mov	eax, DWORD PTR _iHexspaceY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@hexspaceXT
	mov	ecx, DWORD PTR _iHexspaceX$[esp-4]
	sar	eax, 1
	add	eax, ecx

; 92   : }

	ret	0
$LN3@hexspaceXT:

; 91   : 	return iHexspaceX + ((iHexspaceY >= 0) ? (iHexspaceY>>1) : ((iHexspaceY - 1)/2));

	dec	eax
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _iHexspaceX$[esp-4]
	sar	eax, 1
	add	eax, edx

; 92   : }

	ret	0
?hexspaceXToX@@YAHHH@Z ENDP				; hexspaceXToX
_TEXT	ENDS
PUBLIC	?GetInstanceName@CvLuaMap@@SAPBDXZ		; CvLuaMap::GetInstanceName
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\lua\cvluamap.cpp
;	COMDAT ?GetInstanceName@CvLuaMap@@SAPBDXZ
_TEXT	SEGMENT
?GetInstanceName@CvLuaMap@@SAPBDXZ PROC			; CvLuaMap::GetInstanceName, COMDAT

; 30   : 	return "Map";

	mov	eax, OFFSET $SG219448

; 31   : }

	ret	0
?GetInstanceName@CvLuaMap@@SAPBDXZ ENDP			; CvLuaMap::GetInstanceName
_TEXT	ENDS
PUBLIC	?lGetCustomOption@CvLuaMap@@KAHPAUlua_State@@@Z	; CvLuaMap::lGetCustomOption
EXTRN	_lua_pushinteger:PROC
EXTRN	?GetMapOption@CvPreGame@@YA_NPBDAAH@Z:PROC	; CvPreGame::GetMapOption
EXTRN	_luaL_checklstring:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?lGetCustomOption@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_i$ = -4						; size = 4
_L$ = 8							; size = 4
?lGetCustomOption@CvLuaMap@@KAHPAUlua_State@@@Z PROC	; CvLuaMap::lGetCustomOption, COMDAT

; 429  : {

	push	ecx
	push	esi

; 430  : 	const char* szOptionName = luaL_checkstring(L, 1);

	mov	esi, DWORD PTR _L$[esp+4]
	push	0
	push	1
	push	esi
	call	_luaL_checklstring

; 431  : 	int i = 0;
; 432  : 	if(CvPreGame::GetMapOption(szOptionName, i))

	lea	ecx, DWORD PTR _i$[esp+20]
	push	ecx
	push	eax
	mov	DWORD PTR _i$[esp+28], 0
	call	?GetMapOption@CvPreGame@@YA_NPBDAAH@Z	; CvPreGame::GetMapOption
	add	esp, 20					; 00000014H
	test	al, al
	je	SHORT $LN1@lGetCustom

; 433  : 	{
; 434  : 		lua_pushinteger(L, i);

	mov	edx, DWORD PTR _i$[esp+8]
	push	edx
	push	esi
	call	_lua_pushinteger
	add	esp, 8

; 435  : 		return 1;

	mov	eax, 1
	pop	esi

; 439  : }

	pop	ecx
	ret	0
$LN1@lGetCustom:

; 436  : 	}
; 437  : 
; 438  : 	return 0;

	xor	eax, eax
	pop	esi

; 439  : }

	pop	ecx
	ret	0
?lGetCustomOption@CvLuaMap@@KAHPAUlua_State@@@Z ENDP	; CvLuaMap::lGetCustomOption
_TEXT	ENDS
PUBLIC	?Push@?$CvLuaScopedInstance@VCvLuaArea@@VCvArea@@@@SAXPAUlua_State@@PAVCvArea@@@Z ; CvLuaScopedInstance<CvLuaArea,CvArea>::Push
EXTRN	_lua_pushnil:PROC
EXTRN	_lua_remove:PROC
EXTRN	_lua_pushlightuserdata:PROC
EXTRN	_lua_rawget:PROC
EXTRN	?PushMethods@CvLuaArea@@SAXPAUlua_State@@H@Z:PROC ; CvLuaArea::PushMethods
EXTRN	_lua_gettop:PROC
EXTRN	_lua_setfield:PROC
EXTRN	_lua_pushvalue:PROC
EXTRN	_lua_setmetatable:PROC
EXTRN	_lua_rawset:PROC
EXTRN	_lua_pushstring:PROC
EXTRN	_lua_createtable:PROC
EXTRN	_lua_settop:PROC
EXTRN	_lua_type:PROC
EXTRN	_lua_getfield:PROC
EXTRN	?GetTypeName@CvLuaArea@@SAPBDXZ:PROC		; CvLuaArea::GetTypeName
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\lua\cvluascopedinstance.h
;	COMDAT ?Push@?$CvLuaScopedInstance@VCvLuaArea@@VCvArea@@@@SAXPAUlua_State@@PAVCvArea@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_pkType$ = 12						; size = 4
?Push@?$CvLuaScopedInstance@VCvLuaArea@@VCvArea@@@@SAXPAUlua_State@@PAVCvArea@@@Z PROC ; CvLuaScopedInstance<CvLuaArea,CvArea>::Push, COMDAT

; 39   : {

	push	edi

; 40   : 	//Pushing an instance involves more than just actually pushing a pointer into the
; 41   : 	//Lua stack.  There are some caching optimizations that are done as well as some
; 42   : 	//checks.
; 43   : 	//The first step is to load or create a global table <Typename> to store all member
; 44   : 	//methods and all pushed instances.  This conserves memory and offers faster pushing
; 45   : 	//speed.
; 46   : 	//If <Typename>.__instances[pkType] is not nil, return that value.
; 47   : 	//otherwise push a new instance and assign it to __instances.
; 48   : 
; 49   : 	//NOTE: Raw gets and sets are used as an optimization over using lua_[get,set]field
; 50   : 	if(pkType)

	mov	edi, DWORD PTR _pkType$[esp]
	test	edi, edi
	je	$LN4@Push
	push	ebx
	push	ebp
	push	esi

; 51   : 	{
; 52   : 		//const int t = lua_gettop(L);
; 53   : 
; 54   : 		lua_getglobal(L, Derived::GetTypeName());

	call	?GetTypeName@CvLuaArea@@SAPBDXZ		; CvLuaArea::GetTypeName
	mov	esi, DWORD PTR _L$[esp+12]
	push	eax
	push	-10002					; ffffd8eeH
	push	esi
	call	_lua_getfield

; 55   : 		if(lua_isnil(L, -1))

	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	$LN7@Push

; 56   : 		{
; 57   : 			//Typename wasn't found, time to build it.
; 58   : 			lua_pop(L, 1);

	push	-2					; fffffffeH
	push	esi
	call	_lua_settop

; 59   : 			lua_newtable(L);

	push	0
	push	0
	push	esi
	call	_lua_createtable

; 60   : 
; 61   : 			//Create weak __instances table.
; 62   : 			lua_pushstring(L, "__instances");

	push	OFFSET $SG219759
	push	esi
	call	_lua_pushstring

; 63   : 			lua_newtable(L);

	push	0
	push	0
	push	esi
	call	_lua_createtable

; 64   : 
; 65   : 			//Create __instances.mt
; 66   : 			lua_newtable(L);

	push	0
	push	0
	push	esi
	call	_lua_createtable

; 67   : 			lua_pushstring(L, "__mode");

	push	OFFSET $SG219760
	push	esi
	call	_lua_pushstring

; 68   : 			lua_pushstring(L, "v");

	push	OFFSET $SG219761
	push	esi
	call	_lua_pushstring
	add	esp, 68					; 00000044H

; 69   : 			lua_rawset(L, -3);				// mt.__mode = "v";

	push	-3					; fffffffdH
	push	esi
	call	_lua_rawset

; 70   : 			lua_setmetatable(L, -2);

	push	-2					; fffffffeH
	push	esi
	call	_lua_setmetatable

; 71   : 
; 72   : 			lua_rawset(L, -3);				//type.__instances = t;

	push	-3					; fffffffdH
	push	esi
	call	_lua_rawset

; 73   : 
; 74   : 
; 75   : 			lua_pushvalue(L, -1);

	push	-1
	push	esi
	call	_lua_pushvalue

; 76   : 			lua_setglobal(L, Derived::GetTypeName());

	call	?GetTypeName@CvLuaArea@@SAPBDXZ		; CvLuaArea::GetTypeName
	push	eax
	push	-10002					; ffffd8eeH
	push	esi
	call	_lua_setfield

; 77   : 
; 78   : 			Derived::PushMethods(L, lua_gettop(L));

	push	esi
	call	_lua_gettop
	push	eax
	push	esi
	call	?PushMethods@CvLuaArea@@SAXPAUlua_State@@H@Z ; CvLuaArea::PushMethods
	add	esp, 56					; 00000038H
$LN7@Push:

; 79   : 		}
; 80   : 		const int type_index = lua_gettop(L);

	push	esi
	call	_lua_gettop

; 81   : 
; 82   : 		lua_pushstring(L, "__instances");

	push	OFFSET $SG219763
	push	esi
	mov	ebx, eax
	call	_lua_pushstring

; 83   : 		lua_rawget(L, -2);

	push	-2					; fffffffeH
	push	esi
	call	_lua_rawget

; 84   : 
; 85   : 		const int instances_index = lua_gettop(L);

	push	esi
	call	_lua_gettop

; 86   : 
; 87   : 		lua_pushlightuserdata(L, pkType);

	push	edi
	push	esi
	mov	ebp, eax
	call	_lua_pushlightuserdata

; 88   : 
; 89   : 		lua_rawget(L, -2);					//retrieve type.__instances[pkType]

	push	-2					; fffffffeH
	push	esi
	call	_lua_rawget

; 90   : 
; 91   : 		if(lua_isnil(L, -1))

	push	-1
	push	esi
	call	_lua_type
	add	esp, 48					; 00000030H
	test	eax, eax
	jne	SHORT $LN2@Push

; 92   : 		{
; 93   : 			lua_pop(L, 1);

	push	-2					; fffffffeH
	push	esi
	call	_lua_settop

; 94   : 
; 95   : 			//Push new instance
; 96   : 			lua_createtable(L, 0, 1);

	push	1
	push	0
	push	esi
	call	_lua_createtable

; 97   : 			lua_pushlightuserdata(L, pkType);

	push	edi
	push	esi
	call	_lua_pushlightuserdata

; 98   : 			lua_setfield(L, -2, "__instance");

	push	OFFSET $SG219766
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield

; 99   : 
; 100  : 			lua_createtable(L, 0, 1);			// create mt

	push	1
	push	0
	push	esi
	call	_lua_createtable

; 101  : 			lua_pushstring(L, "__index");

	push	OFFSET $SG219767
	push	esi
	call	_lua_pushstring

; 102  : 			lua_pushvalue(L, type_index);

	push	ebx
	push	esi
	call	_lua_pushvalue
	add	esp, 68					; 00000044H

; 103  : 			lua_rawset(L, -3);					// mt.__index = Type

	push	-3					; fffffffdH
	push	esi
	call	_lua_rawset

; 104  : 			lua_setmetatable(L, -2);

	push	-2					; fffffffeH
	push	esi
	call	_lua_setmetatable

; 105  : 
; 106  : 			//Assign it in instances
; 107  : 			lua_pushlightuserdata(L, pkType);

	push	edi
	push	esi
	call	_lua_pushlightuserdata

; 108  : 			lua_pushvalue(L, -2);

	push	-2					; fffffffeH
	push	esi
	call	_lua_pushvalue

; 109  : 			lua_rawset(L, instances_index);				//__instances[pkType] = t;

	push	ebp
	push	esi
	call	_lua_rawset
	add	esp, 40					; 00000028H
$LN2@Push:

; 110  : 		}
; 111  : 
; 112  : 		//VERIFY(instances_index > type_index);
; 113  : 		lua_remove(L, instances_index);

	push	ebp
	push	esi
	call	_lua_remove

; 114  : 		lua_remove(L, type_index);

	push	ebx
	push	esi
	call	_lua_remove
	add	esp, 16					; 00000010H
	pop	esi
	pop	ebp
	pop	ebx
	pop	edi

; 122  : 	}
; 123  : }

	ret	0
$LN4@Push:

; 115  : 
; 116  : 		//const int dt = lua_gettop(L);
; 117  : 		//VERIFY(dt == t + 1)
; 118  : 	}
; 119  : 	else
; 120  : 	{
; 121  : 		lua_pushnil(L);

	mov	eax, DWORD PTR _L$[esp]
	push	eax
	call	_lua_pushnil
	add	esp, 4
	pop	edi

; 122  : 	}
; 123  : }

	ret	0
?Push@?$CvLuaScopedInstance@VCvLuaArea@@VCvArea@@@@SAXPAUlua_State@@PAVCvArea@@@Z ENDP ; CvLuaScopedInstance<CvLuaArea,CvArea>::Push
_TEXT	ENDS
PUBLIC	?RegisterMethod@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAXPAUlua_State@@P6AH0@ZPBD@Z ; CvLuaStaticInstance<CvLuaMap,CvMap>::RegisterMethod
EXTRN	_lua_pushcclosure:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvluastaticinstance.h
;	COMDAT ?RegisterMethod@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAXPAUlua_State@@P6AH0@ZPBD@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_func$ = 12						; size = 4
_funcName$ = 16						; size = 4
?RegisterMethod@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAXPAUlua_State@@P6AH0@ZPBD@Z PROC ; CvLuaStaticInstance<CvLuaMap,CvMap>::RegisterMethod, COMDAT

; 59   : 	lua_pushcclosure(L, func, 0);

	mov	eax, DWORD PTR _func$[esp-4]
	push	esi
	mov	esi, DWORD PTR _L$[esp]
	push	0
	push	eax
	push	esi
	call	_lua_pushcclosure

; 60   : 	lua_setfield(L, -2, funcName);

	mov	ecx, DWORD PTR _funcName$[esp+12]
	push	ecx
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield
	add	esp, 24					; 00000018H
	pop	esi

; 61   : }

	ret	0
?RegisterMethod@?$CvLuaStaticInstance@VCvLuaMap@@VCvMap@@@@KAXPAUlua_State@@P6AH0@ZPBD@Z ENDP ; CvLuaStaticInstance<CvLuaMap,CvMap>::RegisterMethod
_TEXT	ENDS
PUBLIC	?Push@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAXPAUlua_State@@PAVCvPlot@@@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::Push
EXTRN	?PushMethods@CvLuaPlot@@SAXPAUlua_State@@H@Z:PROC ; CvLuaPlot::PushMethods
EXTRN	?GetTypeName@CvLuaPlot@@SAPBDXZ:PROC		; CvLuaPlot::GetTypeName
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\lua\cvluascopedinstance.h
;	COMDAT ?Push@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAXPAUlua_State@@PAVCvPlot@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_pkType$ = 12						; size = 4
?Push@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAXPAUlua_State@@PAVCvPlot@@@Z PROC ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::Push, COMDAT

; 39   : {

	push	edi

; 40   : 	//Pushing an instance involves more than just actually pushing a pointer into the
; 41   : 	//Lua stack.  There are some caching optimizations that are done as well as some
; 42   : 	//checks.
; 43   : 	//The first step is to load or create a global table <Typename> to store all member
; 44   : 	//methods and all pushed instances.  This conserves memory and offers faster pushing
; 45   : 	//speed.
; 46   : 	//If <Typename>.__instances[pkType] is not nil, return that value.
; 47   : 	//otherwise push a new instance and assign it to __instances.
; 48   : 
; 49   : 	//NOTE: Raw gets and sets are used as an optimization over using lua_[get,set]field
; 50   : 	if(pkType)

	mov	edi, DWORD PTR _pkType$[esp]
	test	edi, edi
	je	$LN4@Push@2
	push	ebx
	push	ebp
	push	esi

; 51   : 	{
; 52   : 		//const int t = lua_gettop(L);
; 53   : 
; 54   : 		lua_getglobal(L, Derived::GetTypeName());

	call	?GetTypeName@CvLuaPlot@@SAPBDXZ		; CvLuaPlot::GetTypeName
	mov	esi, DWORD PTR _L$[esp+12]
	push	eax
	push	-10002					; ffffd8eeH
	push	esi
	call	_lua_getfield

; 55   : 		if(lua_isnil(L, -1))

	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	$LN7@Push@2

; 56   : 		{
; 57   : 			//Typename wasn't found, time to build it.
; 58   : 			lua_pop(L, 1);

	push	-2					; fffffffeH
	push	esi
	call	_lua_settop

; 59   : 			lua_newtable(L);

	push	0
	push	0
	push	esi
	call	_lua_createtable

; 60   : 
; 61   : 			//Create weak __instances table.
; 62   : 			lua_pushstring(L, "__instances");

	push	OFFSET $SG219788
	push	esi
	call	_lua_pushstring

; 63   : 			lua_newtable(L);

	push	0
	push	0
	push	esi
	call	_lua_createtable

; 64   : 
; 65   : 			//Create __instances.mt
; 66   : 			lua_newtable(L);

	push	0
	push	0
	push	esi
	call	_lua_createtable

; 67   : 			lua_pushstring(L, "__mode");

	push	OFFSET $SG219789
	push	esi
	call	_lua_pushstring

; 68   : 			lua_pushstring(L, "v");

	push	OFFSET $SG219790
	push	esi
	call	_lua_pushstring
	add	esp, 68					; 00000044H

; 69   : 			lua_rawset(L, -3);				// mt.__mode = "v";

	push	-3					; fffffffdH
	push	esi
	call	_lua_rawset

; 70   : 			lua_setmetatable(L, -2);

	push	-2					; fffffffeH
	push	esi
	call	_lua_setmetatable

; 71   : 
; 72   : 			lua_rawset(L, -3);				//type.__instances = t;

	push	-3					; fffffffdH
	push	esi
	call	_lua_rawset

; 73   : 
; 74   : 
; 75   : 			lua_pushvalue(L, -1);

	push	-1
	push	esi
	call	_lua_pushvalue

; 76   : 			lua_setglobal(L, Derived::GetTypeName());

	call	?GetTypeName@CvLuaPlot@@SAPBDXZ		; CvLuaPlot::GetTypeName
	push	eax
	push	-10002					; ffffd8eeH
	push	esi
	call	_lua_setfield

; 77   : 
; 78   : 			Derived::PushMethods(L, lua_gettop(L));

	push	esi
	call	_lua_gettop
	push	eax
	push	esi
	call	?PushMethods@CvLuaPlot@@SAXPAUlua_State@@H@Z ; CvLuaPlot::PushMethods
	add	esp, 56					; 00000038H
$LN7@Push@2:

; 79   : 		}
; 80   : 		const int type_index = lua_gettop(L);

	push	esi
	call	_lua_gettop

; 81   : 
; 82   : 		lua_pushstring(L, "__instances");

	push	OFFSET $SG219792
	push	esi
	mov	ebx, eax
	call	_lua_pushstring

; 83   : 		lua_rawget(L, -2);

	push	-2					; fffffffeH
	push	esi
	call	_lua_rawget

; 84   : 
; 85   : 		const int instances_index = lua_gettop(L);

	push	esi
	call	_lua_gettop

; 86   : 
; 87   : 		lua_pushlightuserdata(L, pkType);

	push	edi
	push	esi
	mov	ebp, eax
	call	_lua_pushlightuserdata

; 88   : 
; 89   : 		lua_rawget(L, -2);					//retrieve type.__instances[pkType]

	push	-2					; fffffffeH
	push	esi
	call	_lua_rawget

; 90   : 
; 91   : 		if(lua_isnil(L, -1))

	push	-1
	push	esi
	call	_lua_type
	add	esp, 48					; 00000030H
	test	eax, eax
	jne	SHORT $LN2@Push@2

; 92   : 		{
; 93   : 			lua_pop(L, 1);

	push	-2					; fffffffeH
	push	esi
	call	_lua_settop

; 94   : 
; 95   : 			//Push new instance
; 96   : 			lua_createtable(L, 0, 1);

	push	1
	push	0
	push	esi
	call	_lua_createtable

; 97   : 			lua_pushlightuserdata(L, pkType);

	push	edi
	push	esi
	call	_lua_pushlightuserdata

; 98   : 			lua_setfield(L, -2, "__instance");

	push	OFFSET $SG219795
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield

; 99   : 
; 100  : 			lua_createtable(L, 0, 1);			// create mt

	push	1
	push	0
	push	esi
	call	_lua_createtable

; 101  : 			lua_pushstring(L, "__index");

	push	OFFSET $SG219796
	push	esi
	call	_lua_pushstring

; 102  : 			lua_pushvalue(L, type_index);

	push	ebx
	push	esi
	call	_lua_pushvalue
	add	esp, 68					; 00000044H

; 103  : 			lua_rawset(L, -3);					// mt.__index = Type

	push	-3					; fffffffdH
	push	esi
	call	_lua_rawset

; 104  : 			lua_setmetatable(L, -2);

	push	-2					; fffffffeH
	push	esi
	call	_lua_setmetatable

; 105  : 
; 106  : 			//Assign it in instances
; 107  : 			lua_pushlightuserdata(L, pkType);

	push	edi
	push	esi
	call	_lua_pushlightuserdata

; 108  : 			lua_pushvalue(L, -2);

	push	-2					; fffffffeH
	push	esi
	call	_lua_pushvalue

; 109  : 			lua_rawset(L, instances_index);				//__instances[pkType] = t;

	push	ebp
	push	esi
	call	_lua_rawset
	add	esp, 40					; 00000028H
$LN2@Push@2:

; 110  : 		}
; 111  : 
; 112  : 		//VERIFY(instances_index > type_index);
; 113  : 		lua_remove(L, instances_index);

	push	ebp
	push	esi
	call	_lua_remove

; 114  : 		lua_remove(L, type_index);

	push	ebx
	push	esi
	call	_lua_remove
	add	esp, 16					; 00000010H
	pop	esi
	pop	ebp
	pop	ebx
	pop	edi

; 122  : 	}
; 123  : }

	ret	0
$LN4@Push@2:

; 115  : 
; 116  : 		//const int dt = lua_gettop(L);
; 117  : 		//VERIFY(dt == t + 1)
; 118  : 	}
; 119  : 	else
; 120  : 	{
; 121  : 		lua_pushnil(L);

	mov	eax, DWORD PTR _L$[esp]
	push	eax
	call	_lua_pushnil
	add	esp, 4
	pop	edi

; 122  : 	}
; 123  : }

	ret	0
?Push@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAXPAUlua_State@@PAVCvPlot@@@Z ENDP ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::Push
_TEXT	ENDS
PUBLIC	?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
EXTRN	?HandleMissingInstance@CvLuaPlot@@SAXPAUlua_State@@@Z:PROC ; CvLuaPlot::HandleMissingInstance
EXTRN	_luaL_error:PROC
EXTRN	_lua_touserdata:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
_idx$ = 12						; size = 4
_bErrorOnFail$ = 16					; size = 1
?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z PROC ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance, COMDAT

; 127  : {

	push	ebx
	push	ebp
	push	esi

; 128  : 	const int stack_size = lua_gettop(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	mov	ebp, eax

; 129  : 	bool bFail = true;
; 130  : 
; 131  : 	InstanceType* pkInstance = NULL;
; 132  : 	if(lua_type(L, idx) == LUA_TTABLE)

	mov	eax, DWORD PTR _idx$[esp+16]
	push	eax
	push	esi
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN3@GetInstanc

; 133  : 	{
; 134  : 		lua_getfield(L, idx, "__instance");

	mov	ecx, DWORD PTR _idx$[esp+12]
	push	OFFSET $SG219811
	push	ecx
	push	esi
	call	_lua_getfield

; 135  : 		if(lua_type(L, -1) == LUA_TLIGHTUSERDATA)

	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN3@GetInstanc

; 136  : 		{
; 137  : 			pkInstance = static_cast<InstanceType*>(lua_touserdata(L, -1));

	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8

; 138  : 			if(pkInstance)

	test	edi, edi
	je	SHORT $LN3@GetInstanc

; 139  : 			{
; 140  : 				bFail = false;

	xor	bl, bl
$LN3@GetInstanc:

; 141  : 			}
; 142  : 		}
; 143  : 	}
; 144  : 
; 145  : 	lua_settop(L, stack_size);

	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8

; 146  : 
; 147  : 	if(bFail && bErrorOnFail)

	test	bl, bl
	je	SHORT $LN9@GetInstanc
	cmp	BYTE PTR _bErrorOnFail$[esp+12], 0
	je	SHORT $LN9@GetInstanc

; 148  : 	{
; 149  : 		if(idx == 1)

	cmp	DWORD PTR _idx$[esp+12], 1
	jne	SHORT $LN1@GetInstanc

; 150  : 			luaL_error(L, "Not a valid instance.  Either the instance is NULL or you used '.' instead of ':'.");

	push	OFFSET $SG219817
	push	esi
	call	_luaL_error
	add	esp, 8
$LN1@GetInstanc:

; 151  : 		Derived::HandleMissingInstance(L);

	push	esi
	call	?HandleMissingInstance@CvLuaPlot@@SAXPAUlua_State@@@Z ; CvLuaPlot::HandleMissingInstance
	add	esp, 4
$LN9@GetInstanc:

; 152  : 	}
; 153  : 	return pkInstance;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 154  : }

	ret	0
?GetInstance@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAPAVCvPlot@@PAUlua_State@@H_N@Z ENDP ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::GetInstance
_TEXT	ENDS
PUBLIC	??$max@H@std@@YAABHABH0@Z			; std::max<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$max@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@H@std@@YAABHABH0@Z PROC				; std::max<int>, COMDAT

; 3384 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN4@max
	mov	eax, ecx
$LN4@max:

; 3385 : 	}

	ret	0
??$max@H@std@@YAABHABH0@Z ENDP				; std::max<int>
_TEXT	ENDS
PUBLIC	?getMap@CvGlobals@@QAEAAVCvMap@@XZ		; CvGlobals::getMap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMap@CvGlobals@@QAEAAVCvMap@@XZ
_TEXT	SEGMENT
?getMap@CvGlobals@@QAEAAVCvMap@@XZ PROC			; CvGlobals::getMap, COMDAT
; _this$ = ecx

; 175  : 		return *m_map;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+52]

; 176  : 	}

	ret	0
?getMap@CvGlobals@@QAEAAVCvMap@@XZ ENDP			; CvGlobals::getMap
_TEXT	ENDS
PUBLIC	?getGame@CvGlobals@@QAEAAVCvGame@@XZ		; CvGlobals::getGame
; Function compile flags: /Ogtpy
;	COMDAT ?getGame@CvGlobals@@QAEAAVCvGame@@XZ
_TEXT	SEGMENT
?getGame@CvGlobals@@QAEAAVCvGame@@XZ PROC		; CvGlobals::getGame, COMDAT
; _this$ = ecx

; 183  : 		return *m_game;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+48]

; 184  : 	}

	ret	0
?getGame@CvGlobals@@QAEAAVCvGame@@XZ ENDP		; CvGlobals::getGame
_TEXT	ENDS
PUBLIC	?getPlotDirectionX@CvGlobals@@QAEPAHXZ		; CvGlobals::getPlotDirectionX
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotDirectionX@CvGlobals@@QAEPAHXZ
_TEXT	SEGMENT
?getPlotDirectionX@CvGlobals@@QAEPAHXZ PROC		; CvGlobals::getPlotDirectionX, COMDAT
; _this$ = ecx

; 191  : 		return m_aiPlotDirectionX;

	lea	eax, DWORD PTR [ecx+112]

; 192  : 	}

	ret	0
?getPlotDirectionX@CvGlobals@@QAEPAHXZ ENDP		; CvGlobals::getPlotDirectionX
_TEXT	ENDS
PUBLIC	?getPlotDirectionY@CvGlobals@@QAEPAHXZ		; CvGlobals::getPlotDirectionY
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotDirectionY@CvGlobals@@QAEPAHXZ
_TEXT	SEGMENT
?getPlotDirectionY@CvGlobals@@QAEPAHXZ PROC		; CvGlobals::getPlotDirectionY, COMDAT
; _this$ = ecx

; 195  : 		return m_aiPlotDirectionY;

	lea	eax, DWORD PTR [ecx+136]

; 196  : 	}

	ret	0
?getPlotDirectionY@CvGlobals@@QAEPAHXZ ENDP		; CvGlobals::getPlotDirectionY
_TEXT	ENDS
PUBLIC	?coordRange@@YAHHH_N@Z				; coordRange
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?coordRange@@YAHHH_N@Z
_TEXT	SEGMENT
_iCoord$ = 8						; size = 4
_iRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?coordRange@@YAHHH_N@Z PROC				; coordRange, COMDAT

; 88   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iCoord$[esp-4]
	je	SHORT $LN5@coordRange

; 89   : 	{
; 90   : 		if(iCoord < 0)
; 91   : 		{
; 92   : 			return (iRange + (iCoord % iRange));

	mov	ecx, DWORD PTR _iRange$[esp-4]
	test	eax, eax
	jge	SHORT $LN3@coordRange
	cdq
	idiv	ecx
	mov	eax, edx
	add	eax, ecx

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
$LN3@coordRange:

; 93   : 		}
; 94   : 		else if(iCoord >= iRange)

	cmp	eax, ecx
	jl	SHORT $LN5@coordRange

; 95   : 		{
; 96   : 			return (iCoord % iRange);

	cdq
	idiv	ecx
	mov	eax, edx
$LN5@coordRange:

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
?coordRange@@YAHHH_N@Z ENDP				; coordRange
_TEXT	ENDS
PUBLIC	?numPlots@CvMap@@QBEHXZ				; CvMap::numPlots
; Function compile flags: /Ogtpy
;	COMDAT ?numPlots@CvMap@@QBEHXZ
_TEXT	SEGMENT
?numPlots@CvMap@@QBEHXZ PROC				; CvMap::numPlots, COMDAT
; _this$ = ecx

; 170  : 		return m_iGridSize;

	mov	eax, DWORD PTR [ecx+4028]

; 171  : 	}

	ret	0
?numPlots@CvMap@@QBEHXZ ENDP				; CvMap::numPlots
_TEXT	ENDS
PUBLIC	?getGridWidth@CvMap@@QBEHXZ			; CvMap::getGridWidth
; Function compile flags: /Ogtpy
;	COMDAT ?getGridWidth@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridWidth@CvMap@@QBEHXZ PROC			; CvMap::getGridWidth, COMDAT
; _this$ = ecx

; 198  : 		return m_iGridWidth;

	mov	eax, DWORD PTR [ecx+4020]

; 199  : 	}

	ret	0
?getGridWidth@CvMap@@QBEHXZ ENDP			; CvMap::getGridWidth
_TEXT	ENDS
PUBLIC	?getGridHeight@CvMap@@QBEHXZ			; CvMap::getGridHeight
; Function compile flags: /Ogtpy
;	COMDAT ?getGridHeight@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridHeight@CvMap@@QBEHXZ PROC			; CvMap::getGridHeight, COMDAT
; _this$ = ecx

; 206  : 		return m_iGridHeight;

	mov	eax, DWORD PTR [ecx+4024]

; 207  : 	}

	ret	0
?getGridHeight@CvMap@@QBEHXZ ENDP			; CvMap::getGridHeight
_TEXT	ENDS
PUBLIC	?isWrapX@CvMap@@QBE_NXZ				; CvMap::isWrapX
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapX@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapX@CvMap@@QBE_NXZ PROC				; CvMap::isWrapX, COMDAT
; _this$ = ecx

; 228  : 		return m_bWrapX;

	mov	al, BYTE PTR [ecx+4056]

; 229  : 	}

	ret	0
?isWrapX@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapX
_TEXT	ENDS
PUBLIC	?isWrapY@CvMap@@QBE_NXZ				; CvMap::isWrapY
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapY@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapY@CvMap@@QBE_NXZ PROC				; CvMap::isWrapY, COMDAT
; _this$ = ecx

; 233  : 		return m_bWrapY;

	mov	al, BYTE PTR [ecx+4057]

; 234  : 	}

	ret	0
?isWrapY@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapY
_TEXT	ENDS
PUBLIC	?plotByIndex@CvMap@@QBEPAVCvPlot@@H@Z		; CvMap::plotByIndex
; Function compile flags: /Ogtpy
;	COMDAT ?plotByIndex@CvMap@@QBEPAVCvPlot@@H@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?plotByIndex@CvMap@@QBEPAVCvPlot@@H@Z PROC		; CvMap::plotByIndex, COMDAT
; _this$ = ecx

; 263  : 		return (((iIndex >= 0) && (iIndex < (numPlots()))) ? &(m_pMapPlots[iIndex]) : NULL);

	mov	eax, DWORD PTR _iIndex$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@plotByInde
	cmp	eax, DWORD PTR [ecx+4028]
	jge	SHORT $LN3@plotByInde
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]

; 264  : 	}

	ret	4
$LN3@plotByInde:

; 263  : 		return (((iIndex >= 0) && (iIndex < (numPlots()))) ? &(m_pMapPlots[iIndex]) : NULL);

	xor	eax, eax

; 264  : 	}

	ret	4
?plotByIndex@CvMap@@QBEPAVCvPlot@@H@Z ENDP		; CvMap::plotByIndex
_TEXT	ENDS
PUBLIC	?dxWrap@@YAHH@Z					; dxWrap
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?dxWrap@@YAHH@Z
_TEXT	SEGMENT
_iDX$ = 8						; size = 4
?dxWrap@@YAHH@Z PROC					; dxWrap, COMDAT

; 74   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

	mov	edx, DWORD PTR [eax+4020]
	cmp	BYTE PTR [eax+4056], 0
	mov	eax, DWORD PTR _iDX$[esp-4]
	je	SHORT $LN13@dxWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dxWrap
	sub	eax, edx

; 76   : }

	ret	0

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

$LN11@dxWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dxWrap
	add	eax, edx
$LN13@dxWrap:

; 76   : }

	ret	0
?dxWrap@@YAHH@Z ENDP					; dxWrap
_TEXT	ENDS
PUBLIC	?dyWrap@@YAHH@Z					; dyWrap
; Function compile flags: /Ogtpy
;	COMDAT ?dyWrap@@YAHH@Z
_TEXT	SEGMENT
_iDY$ = 8						; size = 4
?dyWrap@@YAHH@Z PROC					; dyWrap, COMDAT

; 80   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

	mov	edx, DWORD PTR [eax+4024]
	cmp	BYTE PTR [eax+4057], 0
	mov	eax, DWORD PTR _iDY$[esp-4]
	je	SHORT $LN13@dyWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dyWrap
	sub	eax, edx

; 82   : }

	ret	0

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

$LN11@dyWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dyWrap
	add	eax, edx
$LN13@dyWrap:

; 82   : }

	ret	0
?dyWrap@@YAHH@Z ENDP					; dyWrap
_TEXT	ENDS
PUBLIC	?plotDistance@@YAHHHHH@Z			; plotDistance
; Function compile flags: /Ogtpy
;	COMDAT ?plotDistance@@YAHHHHH@Z
_TEXT	SEGMENT
_iDX$ = 8						; size = 4
_iX1$ = 8						; size = 4
_iY1$ = 12						; size = 4
_iDY$ = 16						; size = 4
_iX2$ = 16						; size = 4
_iY2$ = 20						; size = 4
?plotDistance@@YAHHHHH@Z PROC				; plotDistance, COMDAT

; 145  : 	int iDX;
; 146  : 	int iWrappedDX = dxWrap(iX2 - iX1);

	mov	eax, DWORD PTR _iX2$[esp-4]
	sub	eax, DWORD PTR _iX1$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebx+4056], 0
	mov	edx, DWORD PTR [ebx+4020]
	push	ebp
	push	esi
	je	SHORT $LN13@plotDistan
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN15@plotDistan
	sub	eax, edx
	jmp	SHORT $LN13@plotDistan
$LN15@plotDistan:
	neg	ecx
	cmp	eax, ecx
	lea	ecx, DWORD PTR [edx+eax]
	jl	SHORT $LN17@plotDistan
$LN13@plotDistan:
	mov	ecx, eax
$LN17@plotDistan:

; 147  : 	int iWrappedDY = dyWrap(iY2 - iY1);

	mov	eax, DWORD PTR _iY2$[esp+8]
	mov	esi, DWORD PTR [ebx+4024]
	push	edi
	mov	edi, DWORD PTR _iY1$[esp+12]
	sub	eax, edi
	cmp	BYTE PTR [ebx+4057], 0
	je	SHORT $LN27@plotDistan
	mov	edx, esi
	shr	edx, 1
	cmp	eax, edx
	jle	SHORT $LN29@plotDistan
	sub	eax, esi
	jmp	SHORT $LN27@plotDistan
$LN29@plotDistan:
	neg	edx
	cmp	eax, edx
	lea	ebp, DWORD PTR [esi+eax]
	jl	SHORT $LN31@plotDistan
$LN27@plotDistan:
	mov	ebp, eax
$LN31@plotDistan:

; 148  : 	int iDY = abs(iWrappedDY);

	mov	eax, ebp
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR _iDY$[esp+12], eax

; 149  : 
; 150  : 	// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 151  : 	int iHX1 = xToHexspaceX(iX1, iY1);

	test	edi, edi
	jl	SHORT $LN35@plotDistan
	mov	eax, edi
	jmp	SHORT $LN59@plotDistan
$LN35@plotDistan:
	lea	eax, DWORD PTR [edi-1]
	cdq
	sub	eax, edx
$LN59@plotDistan:
	mov	esi, DWORD PTR _iX1$[esp+12]
	sar	eax, 1
	sub	esi, eax

; 152  : 	int iHX2 = xToHexspaceX(iX1 + iWrappedDX, iY1 + iWrappedDY);

	lea	eax, DWORD PTR [edi+ebp]
	pop	edi
	test	eax, eax
	jge	SHORT $LN60@plotDistan
	dec	eax
	cdq
	sub	eax, edx
$LN60@plotDistan:

; 153  : 
; 154  : 	iDX = abs(dxWrap(iHX2 - iHX1));

	mov	edx, DWORD PTR [ebx+4020]
	sar	eax, 1
	sub	ecx, eax
	add	ecx, DWORD PTR _iX1$[esp+8]
	sub	ecx, esi
	cmp	BYTE PTR [ebx+4056], 0
	je	SHORT $LN49@plotDistan
	mov	eax, edx
	shr	eax, 1
	cmp	ecx, eax
	jle	SHORT $LN51@plotDistan
	mov	eax, ecx
	sub	eax, edx
	jmp	SHORT $LN53@plotDistan
$LN51@plotDistan:
	neg	eax
	cmp	ecx, eax
	lea	eax, DWORD PTR [edx+ecx]
	jl	SHORT $LN53@plotDistan
$LN49@plotDistan:
	mov	eax, ecx
$LN53@plotDistan:
	cdq
	xor	eax, edx
	sub	eax, edx

; 155  : 
; 156  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 157  : 	if (((iHX2 - iHX1) ^ (iWrappedDY)) >= 0)  // the signs match
; 158  : #else
; 159  : 	if((iHX2 - iHX1 >= 0) == (iWrappedDY >= 0))  // the signs match

	xor	edx, edx
	test	ecx, ecx
	setge	dl
	xor	ecx, ecx
	test	ebp, ebp
	setge	cl
	pop	esi
	pop	ebp
	mov	DWORD PTR _iDX$[esp], eax
	pop	ebx
	cmp	edx, ecx
	jne	SHORT $LN2@plotDistan

; 160  : #endif
; 161  : 	{
; 162  : 		return iDX + iDY;

	mov	edx, DWORD PTR _iDY$[esp-4]
	add	eax, edx

; 170  : #endif
; 171  : 	}
; 172  : }

	ret	0
$LN2@plotDistan:

; 163  : 	}
; 164  : 	else
; 165  : 	{
; 166  : #ifdef NQM_FAST_COMP
; 167  : 		return (MAX(iDX, iDY));
; 168  : #else
; 169  : 		return (std::max(iDX, iDY));

	cmp	eax, DWORD PTR _iDY$[esp-4]
	lea	eax, DWORD PTR _iDY$[esp-4]
	jl	SHORT $LN58@plotDistan
	lea	eax, DWORD PTR _iDX$[esp-4]
$LN58@plotDistan:
	mov	eax, DWORD PTR [eax]

; 170  : #endif
; 171  : 	}
; 172  : }

	ret	0
?plotDistance@@YAHHHHH@Z ENDP				; plotDistance
_TEXT	ENDS
PUBLIC	?GetInstance@CvLuaMap@@SAPAVCvMap@@PAUlua_State@@H@Z ; CvLuaMap::GetInstance
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\lua\cvluamap.cpp
;	COMDAT ?GetInstance@CvLuaMap@@SAPAVCvMap@@PAUlua_State@@H@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?GetInstance@CvLuaMap@@SAPAVCvMap@@PAUlua_State@@H@Z PROC ; CvLuaMap::GetInstance, COMDAT

; 35   : 	return &GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 36   : }

	ret	0
?GetInstance@CvLuaMap@@SAPAVCvMap@@PAUlua_State@@H@Z ENDP ; CvLuaMap::GetInstance
_TEXT	ENDS
PUBLIC	?lAreasAux@CvLuaMap@@KAHPAUlua_State@@@Z	; CvLuaMap::lAreasAux
EXTRN	?nextArea@CvMap@@QAEPAVCvArea@@PAH_N@Z:PROC	; CvMap::nextArea
EXTRN	_lua_tointeger:PROC
EXTRN	?firstArea@CvMap@@QAEPAVCvArea@@PAH_N@Z:PROC	; CvMap::firstArea
; Function compile flags: /Ogtpy
;	COMDAT ?lAreasAux@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_it$ = -4						; size = 4
_L$ = 8							; size = 4
?lAreasAux@CvLuaMap@@KAHPAUlua_State@@@Z PROC		; CvLuaMap::lAreasAux, COMDAT

; 85   : {

	push	ecx
	push	esi
	push	edi

; 86   : 	int it = 0;
; 87   : 	CvArea* pkArea = NULL;
; 88   : 
; 89   : 	if(lua_isnoneornil(L, 2))

	mov	edi, DWORD PTR _L$[esp+8]
	push	2
	push	edi
	mov	DWORD PTR _it$[esp+20], 0
	call	_lua_type
	add	esp, 8
	test	eax, eax
	jg	SHORT $LN3@lAreasAux

; 90   : 	{
; 91   : 		pkArea = GC.getMap().firstArea(&it);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	0
	lea	eax, DWORD PTR _it$[esp+16]
	push	eax
	call	?firstArea@CvMap@@QAEPAVCvArea@@PAH_N@Z	; CvMap::firstArea

; 92   : 	}
; 93   : 	else

	jmp	SHORT $LN10@lAreasAux
$LN3@lAreasAux:

; 94   : 	{
; 95   : 		it = lua_tointeger(L, 2);

	push	2
	push	edi
	call	_lua_tointeger
	add	esp, 8

; 96   : 		pkArea = GC.getMap().nextArea(&it);

	push	0
	lea	ecx, DWORD PTR _it$[esp+16]
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _it$[esp+20], eax
	call	?nextArea@CvMap@@QAEPAVCvArea@@PAH_N@Z	; CvMap::nextArea
$LN10@lAreasAux:
	mov	esi, eax

; 97   : 	}
; 98   : 
; 99   : 	if(pkArea)

	test	esi, esi
	je	SHORT $LN1@lAreasAux

; 100  : 	{
; 101  : 		lua_pushinteger(L, it);

	mov	edx, DWORD PTR _it$[esp+12]
	push	edx
	push	edi
	call	_lua_pushinteger

; 102  : 		CvLuaArea::Push(L, pkArea);

	push	esi
	push	edi
	call	?Push@?$CvLuaScopedInstance@VCvLuaArea@@VCvArea@@@@SAXPAUlua_State@@PAVCvArea@@@Z ; CvLuaScopedInstance<CvLuaArea,CvArea>::Push
	add	esp, 16					; 00000010H
	pop	edi

; 103  : 		return 2;

	mov	eax, 2
	pop	esi

; 107  : }

	pop	ecx
	ret	0
$LN1@lAreasAux:
	pop	edi

; 104  : 	}
; 105  : 
; 106  : 	return 0;

	xor	eax, eax
	pop	esi

; 107  : }

	pop	ecx
	ret	0
?lAreasAux@CvLuaMap@@KAHPAUlua_State@@@Z ENDP		; CvLuaMap::lAreasAux
_TEXT	ENDS
PUBLIC	?lFindBiggestArea@CvLuaMap@@KAHPAUlua_State@@@Z	; CvLuaMap::lFindBiggestArea
EXTRN	?findBiggestArea@CvMap@@QAEPAVCvArea@@_N@Z:PROC	; CvMap::findBiggestArea
EXTRN	_lua_toboolean:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?lFindBiggestArea@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_bWater$ = -4						; size = 1
_L$ = 8							; size = 4
?lFindBiggestArea@CvLuaMap@@KAHPAUlua_State@@@Z PROC	; CvLuaMap::lFindBiggestArea, COMDAT

; 110  : {

	push	ecx
	push	esi

; 111  : 	const bool bWater = lua_toboolean(L, 1);

	mov	esi, DWORD PTR _L$[esp+4]
	push	1
	push	esi
	call	_lua_toboolean
	add	esp, 8
	test	eax, eax
	setne	al
	mov	BYTE PTR _bWater$[esp+8], al

; 112  : 
; 113  : 	CvArea* pkArea = GC.getMap().findBiggestArea(bWater);

	mov	ecx, DWORD PTR _bWater$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?findBiggestArea@CvMap@@QAEPAVCvArea@@_N@Z ; CvMap::findBiggestArea

; 114  : 	if(pkArea)

	test	eax, eax
	je	SHORT $LN1@lFindBigge

; 115  : 	{
; 116  : 		CvLuaArea::Push(L, pkArea);

	push	eax
	push	esi
	call	?Push@?$CvLuaScopedInstance@VCvLuaArea@@VCvArea@@@@SAXPAUlua_State@@PAVCvArea@@@Z ; CvLuaScopedInstance<CvLuaArea,CvArea>::Push
	add	esp, 8

; 117  : 		return 1;

	mov	eax, 1
	pop	esi

; 121  : }

	pop	ecx
	ret	0
$LN1@lFindBigge:

; 118  : 	}
; 119  : 
; 120  : 	return 0;

	xor	eax, eax
	pop	esi

; 121  : }

	pop	ecx
	ret	0
?lFindBiggestArea@CvLuaMap@@KAHPAUlua_State@@@Z ENDP	; CvLuaMap::lFindBiggestArea
_TEXT	ENDS
PUBLIC	?lFindWater@CvLuaMap@@KAHPAUlua_State@@@Z	; CvLuaMap::lFindWater
EXTRN	_lua_pushboolean:PROC
EXTRN	?findWater@CvMap@@QAE_NPAVCvPlot@@H_N@Z:PROC	; CvMap::findWater
EXTRN	_luaL_checkinteger:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?lFindWater@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_bFreshWater$ = -4					; size = 1
_L$ = 8							; size = 4
?lFindWater@CvLuaMap@@KAHPAUlua_State@@@Z PROC		; CvLuaMap::lFindWater, COMDAT

; 124  : {

	push	ecx
	push	ebx
	push	ebp
	push	esi

; 125  : 	CvPlot* pkPlot = CvLuaPlot::GetInstance(L, 1);

	mov	esi, DWORD PTR _L$[esp+12]
	push	edi
	push	esi
	call	_lua_gettop
	push	1
	push	esi
	mov	ebp, eax
	mov	bl, 1
	xor	edi, edi
	call	_lua_type
	add	esp, 12					; 0000000cH
	cmp	eax, 5
	jne	SHORT $LN5@lFindWater
	push	OFFSET $SG219811
	push	1
	push	esi
	call	_lua_getfield
	push	-1
	push	esi
	call	_lua_type
	add	esp, 20					; 00000014H
	cmp	eax, 2
	jne	SHORT $LN5@lFindWater
	push	-1
	push	esi
	call	_lua_touserdata
	mov	edi, eax
	add	esp, 8
	test	edi, edi
	je	SHORT $LN5@lFindWater
	xor	bl, bl
$LN5@lFindWater:
	push	ebp
	push	esi
	call	_lua_settop
	add	esp, 8
	test	bl, bl
	je	SHORT $LN4@lFindWater
	push	OFFSET $SG219817
	push	esi
	call	_luaL_error
	push	esi
	call	?HandleMissingInstance@CvLuaPlot@@SAXPAUlua_State@@@Z ; CvLuaPlot::HandleMissingInstance
	add	esp, 12					; 0000000cH
$LN4@lFindWater:

; 126  : 	const int iRange = luaL_checkint(L, 2);

	push	2
	push	esi
	call	_luaL_checkinteger

; 127  : 	const bool bFreshWater = lua_toboolean(L, 3);

	push	3
	push	esi
	mov	ebx, eax
	call	_lua_toboolean
	add	esp, 16					; 00000010H
	test	eax, eax
	setne	al
	mov	BYTE PTR _bFreshWater$[esp+20], al

; 128  : 	const bool bResult = GC.getMap().findWater(pkPlot, iRange, bFreshWater);

	mov	ecx, DWORD PTR _bFreshWater$[esp+20]
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	ebx
	push	edi
	call	?findWater@CvMap@@QAE_NPAVCvPlot@@H_N@Z	; CvMap::findWater

; 129  : 
; 130  : 	lua_pushboolean(L, bResult);

	movzx	edx, al
	push	edx
	push	esi
	call	_lua_pushboolean
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 131  : 	return 1;

	mov	eax, 1
	pop	ebx

; 132  : }

	pop	ecx
	ret	0
?lFindWater@CvLuaMap@@KAHPAUlua_State@@@Z ENDP		; CvLuaMap::lFindWater
_TEXT	ENDS
PUBLIC	?lGetClimate@CvLuaMap@@KAHPAUlua_State@@@Z	; CvLuaMap::lGetClimate
EXTRN	?getClimate@CvMap@@QAE?AW4ClimateTypes@@XZ:PROC	; CvMap::getClimate
; Function compile flags: /Ogtpy
;	COMDAT ?lGetClimate@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetClimate@CvLuaMap@@KAHPAUlua_State@@@Z PROC		; CvLuaMap::lGetClimate, COMDAT

; 136  : 	lua_pushinteger(L, GC.getMap().getClimate());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?getClimate@CvMap@@QAE?AW4ClimateTypes@@XZ ; CvMap::getClimate
	push	eax
	mov	eax, DWORD PTR _L$[esp]
	push	eax
	call	_lua_pushinteger
	add	esp, 8

; 137  : 	return 1;

	mov	eax, 1

; 138  : }

	ret	0
?lGetClimate@CvLuaMap@@KAHPAUlua_State@@@Z ENDP		; CvLuaMap::lGetClimate
_TEXT	ENDS
PUBLIC	?lGetFractalFlags@CvLuaMap@@KAHPAUlua_State@@@Z	; CvLuaMap::lGetFractalFlags
EXTRN	?getMapFractalFlags@CvMap@@QAEHXZ:PROC		; CvMap::getMapFractalFlags
; Function compile flags: /Ogtpy
;	COMDAT ?lGetFractalFlags@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetFractalFlags@CvLuaMap@@KAHPAUlua_State@@@Z PROC	; CvLuaMap::lGetFractalFlags, COMDAT

; 142  : 	int flags = GC.getMap().getMapFractalFlags();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	ebx
	push	esi
	call	?getMapFractalFlags@CvMap@@QAEHXZ	; CvMap::getMapFractalFlags

; 143  : 	lua_createtable(L, 0, 2);

	mov	esi, DWORD PTR _L$[esp+4]
	push	2
	push	0
	push	esi
	mov	ebx, eax
	call	_lua_createtable
	add	esp, 12					; 0000000cH

; 144  : 	if((flags & CvFractal::FRAC_WRAP_X) != 0)

	test	bl, 1
	je	SHORT $LN8@lGetFracta

; 145  : 	{
; 146  : 		lua_pushboolean(L, TRUE);

	push	1
	push	esi
	call	_lua_pushboolean

; 147  : 		lua_setfield(L, -2, "FRAC_WRAP_X");

	push	OFFSET $SG219559
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield
	add	esp, 20					; 00000014H
$LN8@lGetFracta:

; 148  : 	}
; 149  : 
; 150  : 	if((flags & CvFractal::FRAC_WRAP_Y) != 0)

	test	bl, 2
	je	SHORT $LN7@lGetFracta

; 151  : 	{
; 152  : 		lua_pushboolean(L, TRUE);

	push	1
	push	esi
	call	_lua_pushboolean

; 153  : 		lua_setfield(L, -2, "FRAC_WRAP_Y");

	push	OFFSET $SG219561
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield
	add	esp, 20					; 00000014H
$LN7@lGetFracta:
	pop	esi

; 154  : 	}
; 155  : 
; 156  : 	return 1;

	mov	eax, 1
	pop	ebx

; 157  : }

	ret	0
?lGetFractalFlags@CvLuaMap@@KAHPAUlua_State@@@Z ENDP	; CvLuaMap::lGetFractalFlags
_TEXT	ENDS
PUBLIC	?lGetGridSize@CvLuaMap@@KAHPAUlua_State@@@Z	; CvLuaMap::lGetGridSize
; Function compile flags: /Ogtpy
;	COMDAT ?lGetGridSize@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetGridSize@CvLuaMap@@KAHPAUlua_State@@@Z PROC	; CvLuaMap::lGetGridSize, COMDAT

; 161  : 	const int width  = GC.getMap().getGridWidth();
; 162  : 	const int height = GC.getMap().getGridHeight();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	esi
	mov	esi, DWORD PTR [eax+4024]

; 163  : 
; 164  : 	lua_pushinteger(L, width);

	mov	eax, DWORD PTR [eax+4020]
	push	edi
	mov	edi, DWORD PTR _L$[esp+4]
	push	eax
	push	edi
	call	_lua_pushinteger

; 165  : 	lua_pushinteger(L, height);

	push	esi
	push	edi
	call	_lua_pushinteger
	add	esp, 16					; 00000010H
	pop	edi

; 166  : 	return 2;

	mov	eax, 2
	pop	esi

; 167  : }

	ret	0
?lGetGridSize@CvLuaMap@@KAHPAUlua_State@@@Z ENDP	; CvLuaMap::lGetGridSize
_TEXT	ENDS
PUBLIC	?lGetNumPlots@CvLuaMap@@KAHPAUlua_State@@@Z	; CvLuaMap::lGetNumPlots
; Function compile flags: /Ogtpy
;	COMDAT ?lGetNumPlots@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetNumPlots@CvLuaMap@@KAHPAUlua_State@@@Z PROC	; CvLuaMap::lGetNumPlots, COMDAT

; 172  : 	lua_pushinteger(L, GC.getMap().numPlots());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	ecx, DWORD PTR [eax+4028]
	mov	edx, DWORD PTR _L$[esp-4]
	push	ecx
	push	edx
	call	_lua_pushinteger
	add	esp, 8

; 173  : 	return 1;

	mov	eax, 1

; 174  : }

	ret	0
?lGetNumPlots@CvLuaMap@@KAHPAUlua_State@@@Z ENDP	; CvLuaMap::lGetNumPlots
_TEXT	ENDS
PUBLIC	?lGetNumResources@CvLuaMap@@KAHPAUlua_State@@@Z	; CvLuaMap::lGetNumResources
EXTRN	?getNumResources@CvMap@@QAEHW4ResourceTypes@@@Z:PROC ; CvMap::getNumResources
; Function compile flags: /Ogtpy
;	COMDAT ?lGetNumResources@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetNumResources@CvLuaMap@@KAHPAUlua_State@@@Z PROC	; CvLuaMap::lGetNumResources, COMDAT

; 177  : {

	push	esi

; 178  : 	const ResourceTypes eResource = (ResourceTypes)luaL_checkinteger(L, 1);

	mov	esi, DWORD PTR _L$[esp]
	push	1
	push	esi
	call	_luaL_checkinteger

; 179  : 
; 180  : 	const int iResult = GC.getMap().getNumResources(eResource);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	esp, 8
	push	eax
	call	?getNumResources@CvMap@@QAEHW4ResourceTypes@@@Z ; CvMap::getNumResources

; 181  : 	lua_pushinteger(L, iResult);

	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8

; 182  : 	return 1;

	mov	eax, 1
	pop	esi

; 183  : }

	ret	0
?lGetNumResources@CvLuaMap@@KAHPAUlua_State@@@Z ENDP	; CvLuaMap::lGetNumResources
_TEXT	ENDS
PUBLIC	?lGetNumResourcesOnLand@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lGetNumResourcesOnLand
EXTRN	?getNumResourcesOnLand@CvMap@@QAEHW4ResourceTypes@@@Z:PROC ; CvMap::getNumResourcesOnLand
; Function compile flags: /Ogtpy
;	COMDAT ?lGetNumResourcesOnLand@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetNumResourcesOnLand@CvLuaMap@@KAHPAUlua_State@@@Z PROC ; CvLuaMap::lGetNumResourcesOnLand, COMDAT

; 186  : {

	push	esi

; 187  : 	const ResourceTypes eResource = (ResourceTypes)luaL_checkinteger(L, 1);

	mov	esi, DWORD PTR _L$[esp]
	push	1
	push	esi
	call	_luaL_checkinteger

; 188  : 
; 189  : 	const int iResult = GC.getMap().getNumResourcesOnLand(eResource);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	esp, 8
	push	eax
	call	?getNumResourcesOnLand@CvMap@@QAEHW4ResourceTypes@@@Z ; CvMap::getNumResourcesOnLand

; 190  : 	lua_pushinteger(L, iResult);

	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8

; 191  : 	return 1;

	mov	eax, 1
	pop	esi

; 192  : }

	ret	0
?lGetNumResourcesOnLand@CvLuaMap@@KAHPAUlua_State@@@Z ENDP ; CvLuaMap::lGetNumResourcesOnLand
_TEXT	ENDS
PUBLIC	?lGetPlotByIndex@CvLuaMap@@KAHPAUlua_State@@@Z	; CvLuaMap::lGetPlotByIndex
; Function compile flags: /Ogtpy
;	COMDAT ?lGetPlotByIndex@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetPlotByIndex@CvLuaMap@@KAHPAUlua_State@@@Z PROC	; CvLuaMap::lGetPlotByIndex, COMDAT

; 210  : {

	push	esi

; 211  : 	const int iIndex = lua_tointeger(L, 1);

	mov	esi, DWORD PTR _L$[esp]
	push	1
	push	esi
	call	_lua_tointeger
	add	esp, 8

; 212  : 
; 213  : 	CvPlot* pPlot = GC.getMap().plotByIndex(iIndex);

	test	eax, eax
	jl	SHORT $LN1@lGetPlotBy
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	eax, DWORD PTR [ecx+4028]
	jge	SHORT $LN1@lGetPlotBy
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]

; 214  : 	if(pPlot)

	test	eax, eax
	je	SHORT $LN1@lGetPlotBy

; 215  : 	{
; 216  : 		CvLuaPlot::Push(L, pPlot);

	push	eax
	push	esi
	call	?Push@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAXPAUlua_State@@PAVCvPlot@@@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::Push
	add	esp, 8

; 217  : 		return 1;

	mov	eax, 1
	pop	esi

; 220  : }

	ret	0
$LN1@lGetPlotBy:

; 218  : 	}
; 219  : 	return 0;

	xor	eax, eax
	pop	esi

; 220  : }

	ret	0
?lGetPlotByIndex@CvLuaMap@@KAHPAUlua_State@@@Z ENDP	; CvLuaMap::lGetPlotByIndex
_TEXT	ENDS
PUBLIC	?lGetArea@CvLuaMap@@KAHPAUlua_State@@@Z		; CvLuaMap::lGetArea
EXTRN	?getArea@CvMap@@QAEPAVCvArea@@H@Z:PROC		; CvMap::getArea
; Function compile flags: /Ogtpy
;	COMDAT ?lGetArea@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetArea@CvLuaMap@@KAHPAUlua_State@@@Z PROC		; CvLuaMap::lGetArea, COMDAT

; 251  : {

	push	esi

; 252  : 	const int iID = lua_tointeger(L, 1);

	mov	esi, DWORD PTR _L$[esp]
	push	1
	push	esi
	call	_lua_tointeger

; 253  : 
; 254  : 	CvArea* pArea = GC.getMap().getArea(iID);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	esp, 8
	push	eax
	call	?getArea@CvMap@@QAEPAVCvArea@@H@Z	; CvMap::getArea

; 255  : 	if(pArea)

	test	eax, eax
	je	SHORT $LN1@lGetArea

; 256  : 	{
; 257  : 		CvLuaArea::Push(L, pArea);

	push	eax
	push	esi
	call	?Push@?$CvLuaScopedInstance@VCvLuaArea@@VCvArea@@@@SAXPAUlua_State@@PAVCvArea@@@Z ; CvLuaScopedInstance<CvLuaArea,CvArea>::Push
	add	esp, 8

; 258  : 		return 1;

	mov	eax, 1
	pop	esi

; 261  : }

	ret	0
$LN1@lGetArea:

; 259  : 	}
; 260  : 	return 0;

	xor	eax, eax
	pop	esi

; 261  : }

	ret	0
?lGetArea@CvLuaMap@@KAHPAUlua_State@@@Z ENDP		; CvLuaMap::lGetArea
_TEXT	ENDS
PUBLIC	?lGetIndexAfterLastArea@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lGetIndexAfterLastArea
EXTRN	?getIndexAfterLastArea@CvMap@@QAEHXZ:PROC	; CvMap::getIndexAfterLastArea
; Function compile flags: /Ogtpy
;	COMDAT ?lGetIndexAfterLastArea@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetIndexAfterLastArea@CvLuaMap@@KAHPAUlua_State@@@Z PROC ; CvLuaMap::lGetIndexAfterLastArea, COMDAT

; 265  : 	const int iResult = GC.getMap().getIndexAfterLastArea();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?getIndexAfterLastArea@CvMap@@QAEHXZ	; CvMap::getIndexAfterLastArea

; 266  : 	lua_pushinteger(L, iResult);

	push	eax
	mov	eax, DWORD PTR _L$[esp]
	push	eax
	call	_lua_pushinteger
	add	esp, 8

; 267  : 	return 1;

	mov	eax, 1

; 268  : }

	ret	0
?lGetIndexAfterLastArea@CvLuaMap@@KAHPAUlua_State@@@Z ENDP ; CvLuaMap::lGetIndexAfterLastArea
_TEXT	ENDS
PUBLIC	?lGetLandPlots@CvLuaMap@@KAHPAUlua_State@@@Z	; CvLuaMap::lGetLandPlots
EXTRN	?getLandPlots@CvMap@@QAEHXZ:PROC		; CvMap::getLandPlots
; Function compile flags: /Ogtpy
;	COMDAT ?lGetLandPlots@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetLandPlots@CvLuaMap@@KAHPAUlua_State@@@Z PROC	; CvLuaMap::lGetLandPlots, COMDAT

; 272  : 	const int iResult = GC.getMap().getLandPlots();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?getLandPlots@CvMap@@QAEHXZ		; CvMap::getLandPlots

; 273  : 	lua_pushinteger(L, iResult);

	push	eax
	mov	eax, DWORD PTR _L$[esp]
	push	eax
	call	_lua_pushinteger
	add	esp, 8

; 274  : 	return 1;

	mov	eax, 1

; 275  : }

	ret	0
?lGetLandPlots@CvLuaMap@@KAHPAUlua_State@@@Z ENDP	; CvLuaMap::lGetLandPlots
_TEXT	ENDS
PUBLIC	?lGetNumAreas@CvLuaMap@@KAHPAUlua_State@@@Z	; CvLuaMap::lGetNumAreas
EXTRN	?getNumAreas@CvMap@@QAEHXZ:PROC			; CvMap::getNumAreas
; Function compile flags: /Ogtpy
;	COMDAT ?lGetNumAreas@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetNumAreas@CvLuaMap@@KAHPAUlua_State@@@Z PROC	; CvLuaMap::lGetNumAreas, COMDAT

; 279  : 	const int iResult = GC.getMap().getNumAreas();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?getNumAreas@CvMap@@QAEHXZ		; CvMap::getNumAreas

; 280  : 	lua_pushinteger(L, iResult);

	push	eax
	mov	eax, DWORD PTR _L$[esp]
	push	eax
	call	_lua_pushinteger
	add	esp, 8

; 281  : 	return 1;

	mov	eax, 1

; 282  : }

	ret	0
?lGetNumAreas@CvLuaMap@@KAHPAUlua_State@@@Z ENDP	; CvLuaMap::lGetNumAreas
_TEXT	ENDS
PUBLIC	?lGetNumLandAreas@CvLuaMap@@KAHPAUlua_State@@@Z	; CvLuaMap::lGetNumLandAreas
EXTRN	?getNumLandAreas@CvMap@@QAEHXZ:PROC		; CvMap::getNumLandAreas
; Function compile flags: /Ogtpy
;	COMDAT ?lGetNumLandAreas@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetNumLandAreas@CvLuaMap@@KAHPAUlua_State@@@Z PROC	; CvLuaMap::lGetNumLandAreas, COMDAT

; 286  : 	const int iResult = GC.getMap().getNumLandAreas();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?getNumLandAreas@CvMap@@QAEHXZ		; CvMap::getNumLandAreas

; 287  : 	lua_pushinteger(L, iResult);

	push	eax
	mov	eax, DWORD PTR _L$[esp]
	push	eax
	call	_lua_pushinteger
	add	esp, 8

; 288  : 	return 1;

	mov	eax, 1

; 289  : }

	ret	0
?lGetNumLandAreas@CvLuaMap@@KAHPAUlua_State@@@Z ENDP	; CvLuaMap::lGetNumLandAreas
_TEXT	ENDS
PUBLIC	?lGetRandomResourceQuantity@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lGetRandomResourceQuantity
EXTRN	?getRandomResourceQuantity@CvMap@@QAEHW4ResourceTypes@@@Z:PROC ; CvMap::getRandomResourceQuantity
; Function compile flags: /Ogtpy
;	COMDAT ?lGetRandomResourceQuantity@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetRandomResourceQuantity@CvLuaMap@@KAHPAUlua_State@@@Z PROC ; CvLuaMap::lGetRandomResourceQuantity, COMDAT

; 292  : {

	push	esi

; 293  : 	const ResourceTypes eResource = (ResourceTypes)luaL_checkinteger(L, 1);

	mov	esi, DWORD PTR _L$[esp]
	push	1
	push	esi
	call	_luaL_checkinteger

; 294  : 
; 295  : 	const int iResult = GC.getMap().getRandomResourceQuantity(eResource);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	esp, 8
	push	eax
	call	?getRandomResourceQuantity@CvMap@@QAEHW4ResourceTypes@@@Z ; CvMap::getRandomResourceQuantity

; 296  : 	lua_pushinteger(L, iResult);

	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8

; 297  : 	return 1;

	mov	eax, 1
	pop	esi

; 298  : }

	ret	0
?lGetRandomResourceQuantity@CvLuaMap@@KAHPAUlua_State@@@Z ENDP ; CvLuaMap::lGetRandomResourceQuantity
_TEXT	ENDS
PUBLIC	?lGetSeaLevel@CvLuaMap@@KAHPAUlua_State@@@Z	; CvLuaMap::lGetSeaLevel
EXTRN	?getSeaLevel@CvMap@@QAE?AW4SeaLevelTypes@@XZ:PROC ; CvMap::getSeaLevel
; Function compile flags: /Ogtpy
;	COMDAT ?lGetSeaLevel@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetSeaLevel@CvLuaMap@@KAHPAUlua_State@@@Z PROC	; CvLuaMap::lGetSeaLevel, COMDAT

; 302  : 	lua_pushinteger(L, GC.getMap().getSeaLevel());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?getSeaLevel@CvMap@@QAE?AW4SeaLevelTypes@@XZ ; CvMap::getSeaLevel
	push	eax
	mov	eax, DWORD PTR _L$[esp]
	push	eax
	call	_lua_pushinteger
	add	esp, 8

; 303  : 	return 1;

	mov	eax, 1

; 304  : }

	ret	0
?lGetSeaLevel@CvLuaMap@@KAHPAUlua_State@@@Z ENDP	; CvLuaMap::lGetSeaLevel
_TEXT	ENDS
PUBLIC	?lGetWorldSize@CvLuaMap@@KAHPAUlua_State@@@Z	; CvLuaMap::lGetWorldSize
EXTRN	?getWorldSize@CvMap@@QAE?AW4WorldSizeTypes@@XZ:PROC ; CvMap::getWorldSize
; Function compile flags: /Ogtpy
;	COMDAT ?lGetWorldSize@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetWorldSize@CvLuaMap@@KAHPAUlua_State@@@Z PROC	; CvLuaMap::lGetWorldSize, COMDAT

; 308  : 	lua_pushinteger(L, GC.getMap().getWorldSize());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?getWorldSize@CvMap@@QAE?AW4WorldSizeTypes@@XZ ; CvMap::getWorldSize
	push	eax
	mov	eax, DWORD PTR _L$[esp]
	push	eax
	call	_lua_pushinteger
	add	esp, 8

; 309  : 	return 1;

	mov	eax, 1

; 310  : }

	ret	0
?lGetWorldSize@CvLuaMap@@KAHPAUlua_State@@@Z ENDP	; CvLuaMap::lGetWorldSize
_TEXT	ENDS
PUBLIC	?lIsWrapX@CvLuaMap@@KAHPAUlua_State@@@Z		; CvLuaMap::lIsWrapX
; Function compile flags: /Ogtpy
;	COMDAT ?lIsWrapX@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsWrapX@CvLuaMap@@KAHPAUlua_State@@@Z PROC		; CvLuaMap::lIsWrapX, COMDAT

; 325  : 	lua_pushboolean(L, GC.getMap().isWrapX());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	movzx	ecx, BYTE PTR [eax+4056]
	mov	edx, DWORD PTR _L$[esp-4]
	push	ecx
	push	edx
	call	_lua_pushboolean
	add	esp, 8

; 326  : 	return 1;

	mov	eax, 1

; 327  : }

	ret	0
?lIsWrapX@CvLuaMap@@KAHPAUlua_State@@@Z ENDP		; CvLuaMap::lIsWrapX
_TEXT	ENDS
PUBLIC	?lIsWrapY@CvLuaMap@@KAHPAUlua_State@@@Z		; CvLuaMap::lIsWrapY
; Function compile flags: /Ogtpy
;	COMDAT ?lIsWrapY@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsWrapY@CvLuaMap@@KAHPAUlua_State@@@Z PROC		; CvLuaMap::lIsWrapY, COMDAT

; 331  : 	lua_pushboolean(L, GC.getMap().isWrapY());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	movzx	ecx, BYTE PTR [eax+4057]
	mov	edx, DWORD PTR _L$[esp-4]
	push	ecx
	push	edx
	call	_lua_pushboolean
	add	esp, 8

; 332  : 	return 1;

	mov	eax, 1

; 333  : }

	ret	0
?lIsWrapY@CvLuaMap@@KAHPAUlua_State@@@Z ENDP		; CvLuaMap::lIsWrapY
_TEXT	ENDS
PUBLIC	?lMaxPlotDistance@CvLuaMap@@KAHPAUlua_State@@@Z	; CvLuaMap::lMaxPlotDistance
EXTRN	?maxPlotDistance@CvMap@@QAEHXZ:PROC		; CvMap::maxPlotDistance
; Function compile flags: /Ogtpy
;	COMDAT ?lMaxPlotDistance@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lMaxPlotDistance@CvLuaMap@@KAHPAUlua_State@@@Z PROC	; CvLuaMap::lMaxPlotDistance, COMDAT

; 337  : 	int iResult = GC.getMap().maxPlotDistance();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?maxPlotDistance@CvMap@@QAEHXZ		; CvMap::maxPlotDistance

; 338  : 	lua_pushinteger(L, iResult);

	push	eax
	mov	eax, DWORD PTR _L$[esp]
	push	eax
	call	_lua_pushinteger
	add	esp, 8

; 339  : 	return 1;

	mov	eax, 1

; 340  : }

	ret	0
?lMaxPlotDistance@CvLuaMap@@KAHPAUlua_State@@@Z ENDP	; CvLuaMap::lMaxPlotDistance
_TEXT	ENDS
PUBLIC	?lRand@CvLuaMap@@KAHPAUlua_State@@@Z		; CvLuaMap::lRand
EXTRN	?getMapRandNum@CvGame@@QAEHHPBD@Z:PROC		; CvGame::getMapRandNum
; Function compile flags: /Ogtpy
;	COMDAT ?lRand@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lRand@CvLuaMap@@KAHPAUlua_State@@@Z PROC		; CvLuaMap::lRand, COMDAT

; 343  : {

	push	esi

; 344  : 	const int max_num = luaL_checkinteger(L, 1);

	mov	esi, DWORD PTR _L$[esp]
	push	edi
	push	1
	push	esi
	call	_luaL_checkinteger

; 345  : 	const char* strLog = luaL_checkstring(L, 2);

	push	0
	push	2
	push	esi
	mov	edi, eax
	call	_luaL_checklstring

; 346  : 	const int rand_val = GC.getGame().getMapRandNum(max_num, strLog);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	add	esp, 20					; 00000014H
	push	eax
	push	edi
	call	?getMapRandNum@CvGame@@QAEHHPBD@Z	; CvGame::getMapRandNum

; 347  : 
; 348  : 	lua_pushinteger(L, rand_val);

	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 8
	pop	edi

; 349  : 	return 1;

	mov	eax, 1
	pop	esi

; 350  : }

	ret	0
?lRand@CvLuaMap@@KAHPAUlua_State@@@Z ENDP		; CvLuaMap::lRand
_TEXT	ENDS
PUBLIC	?lCalculateAreas@CvLuaMap@@KAHPAUlua_State@@@Z	; CvLuaMap::lCalculateAreas
EXTRN	?calculateAreas@CvMap@@QAEXXZ:PROC		; CvMap::calculateAreas
; Function compile flags: /Ogtpy
;	COMDAT ?lCalculateAreas@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lCalculateAreas@CvLuaMap@@KAHPAUlua_State@@@Z PROC	; CvLuaMap::lCalculateAreas, COMDAT

; 358  : 	GC.getMap().calculateAreas();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?calculateAreas@CvMap@@QAEXXZ		; CvMap::calculateAreas

; 359  : 	return 0;

	xor	eax, eax

; 360  : }//------------------------------------------------------------------------------

	ret	0
?lCalculateAreas@CvLuaMap@@KAHPAUlua_State@@@Z ENDP	; CvLuaMap::lCalculateAreas
_TEXT	ENDS
PUBLIC	?lRecalculateAreas@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lRecalculateAreas
EXTRN	?recalculateAreas@CvMap@@QAEXXZ:PROC		; CvMap::recalculateAreas
; Function compile flags: /Ogtpy
;	COMDAT ?lRecalculateAreas@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lRecalculateAreas@CvLuaMap@@KAHPAUlua_State@@@Z PROC	; CvLuaMap::lRecalculateAreas, COMDAT

; 367  : 	GC.getMap().recalculateAreas();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?recalculateAreas@CvMap@@QAEXXZ		; CvMap::recalculateAreas

; 368  : 	return 0;

	xor	eax, eax

; 369  : }

	ret	0
?lRecalculateAreas@CvLuaMap@@KAHPAUlua_State@@@Z ENDP	; CvLuaMap::lRecalculateAreas
_TEXT	ENDS
PUBLIC	?lPlotDistance@CvLuaMap@@KAHPAUlua_State@@@Z	; CvLuaMap::lPlotDistance
; Function compile flags: /Ogtpy
;	COMDAT ?lPlotDistance@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lPlotDistance@CvLuaMap@@KAHPAUlua_State@@@Z PROC	; CvLuaMap::lPlotDistance, COMDAT

; 372  : {

	push	ebx
	push	ebp
	push	esi

; 373  : 	int iX1 = lua_tointeger(L, 1);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	1
	push	esi
	call	_lua_tointeger

; 374  : 	int iY1 = lua_tointeger(L, 2);

	push	2
	push	esi
	mov	edi, eax
	call	_lua_tointeger

; 375  : 	int iX2 = lua_tointeger(L, 3);

	push	3
	push	esi
	mov	ebx, eax
	call	_lua_tointeger

; 376  : 	int iY2 = lua_tointeger(L, 4);

	push	4
	push	esi
	mov	ebp, eax
	call	_lua_tointeger

; 377  : 
; 378  : 	int iRetVal = plotDistance(iX1, iY1, iX2, iY2);

	push	eax
	push	ebp
	push	ebx
	push	edi
	call	?plotDistance@@YAHHHHH@Z		; plotDistance

; 379  : 
; 380  : 	lua_pushinteger(L, iRetVal);

	push	eax
	push	esi
	call	_lua_pushinteger
	add	esp, 56					; 00000038H
	pop	edi
	pop	esi
	pop	ebp

; 381  : 	return 1;

	mov	eax, 1
	pop	ebx

; 382  : }

	ret	0
?lPlotDistance@CvLuaMap@@KAHPAUlua_State@@@Z ENDP	; CvLuaMap::lPlotDistance
_TEXT	ENDS
PUBLIC	?lDefaultContinentStamper@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lDefaultContinentStamper
EXTRN	?DefaultContinentStamper@CvMap@@QAEXXZ:PROC	; CvMap::DefaultContinentStamper
; Function compile flags: /Ogtpy
;	COMDAT ?lDefaultContinentStamper@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lDefaultContinentStamper@CvLuaMap@@KAHPAUlua_State@@@Z PROC ; CvLuaMap::lDefaultContinentStamper, COMDAT

; 414  : 	GC.getMap().DefaultContinentStamper();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?DefaultContinentStamper@CvMap@@QAEXXZ	; CvMap::DefaultContinentStamper

; 415  : 	return 0;

	xor	eax, eax

; 416  : }

	ret	0
?lDefaultContinentStamper@CvLuaMap@@KAHPAUlua_State@@@Z ENDP ; CvLuaMap::lDefaultContinentStamper
_TEXT	ENDS
PUBLIC	?lDoPlaceNaturalWonders@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lDoPlaceNaturalWonders
EXTRN	?DoPlaceNaturalWonders@CvMap@@QAEXXZ:PROC	; CvMap::DoPlaceNaturalWonders
; Function compile flags: /Ogtpy
;	COMDAT ?lDoPlaceNaturalWonders@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lDoPlaceNaturalWonders@CvLuaMap@@KAHPAUlua_State@@@Z PROC ; CvLuaMap::lDoPlaceNaturalWonders, COMDAT

; 424  : 	GC.getMap().DoPlaceNaturalWonders();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?DoPlaceNaturalWonders@CvMap@@QAEXXZ	; CvMap::DoPlaceNaturalWonders

; 425  : 	return 0;

	xor	eax, eax

; 426  : }

	ret	0
?lDoPlaceNaturalWonders@CvLuaMap@@KAHPAUlua_State@@@Z ENDP ; CvLuaMap::lDoPlaceNaturalWonders
_TEXT	ENDS
PUBLIC	?lUpdateDeferredFog@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lUpdateDeferredFog
EXTRN	?updateDeferredFog@CvMap@@QAEXXZ:PROC		; CvMap::updateDeferredFog
; Function compile flags: /Ogtpy
;	COMDAT ?lUpdateDeferredFog@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lUpdateDeferredFog@CvLuaMap@@KAHPAUlua_State@@@Z PROC	; CvLuaMap::lUpdateDeferredFog, COMDAT

; 447  : 	GC.getMap().updateDeferredFog();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?updateDeferredFog@CvMap@@QAEXXZ	; CvMap::updateDeferredFog

; 448  : 	return 0;

	xor	eax, eax

; 449  : }

	ret	0
?lUpdateDeferredFog@CvLuaMap@@KAHPAUlua_State@@@Z ENDP	; CvLuaMap::lUpdateDeferredFog
_TEXT	ENDS
PUBLIC	?lChangeAIMapHint@CvLuaMap@@KAHPAUlua_State@@@Z	; CvLuaMap::lChangeAIMapHint
EXTRN	?ChangeAIMapHint@CvMap@@QAEXH@Z:PROC		; CvMap::ChangeAIMapHint
; Function compile flags: /Ogtpy
;	COMDAT ?lChangeAIMapHint@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lChangeAIMapHint@CvLuaMap@@KAHPAUlua_State@@@Z PROC	; CvLuaMap::lChangeAIMapHint, COMDAT

; 453  : 	int iHint = lua_tointeger(L, 1);

	mov	eax, DWORD PTR _L$[esp-4]
	push	1
	push	eax
	call	_lua_tointeger

; 454  : 	GC.getMap().ChangeAIMapHint(iHint);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	esp, 8
	push	eax
	call	?ChangeAIMapHint@CvMap@@QAEXH@Z		; CvMap::ChangeAIMapHint

; 455  : 	return 0;

	xor	eax, eax

; 456  : }

	ret	0
?lChangeAIMapHint@CvLuaMap@@KAHPAUlua_State@@@Z ENDP	; CvLuaMap::lChangeAIMapHint
_TEXT	ENDS
PUBLIC	?lGetAIMapHint@CvLuaMap@@KAHPAUlua_State@@@Z	; CvLuaMap::lGetAIMapHint
EXTRN	?GetAIMapHint@CvMap@@QAEHXZ:PROC		; CvMap::GetAIMapHint
; Function compile flags: /Ogtpy
;	COMDAT ?lGetAIMapHint@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetAIMapHint@CvLuaMap@@KAHPAUlua_State@@@Z PROC	; CvLuaMap::lGetAIMapHint, COMDAT

; 460  : 	lua_pushinteger(L, GC.getMap().GetAIMapHint());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?GetAIMapHint@CvMap@@QAEHXZ		; CvMap::GetAIMapHint
	push	eax
	mov	eax, DWORD PTR _L$[esp]
	push	eax
	call	_lua_pushinteger
	add	esp, 8

; 461  : 	return 1;

	mov	eax, 1

; 462  : }

	ret	0
?lGetAIMapHint@CvLuaMap@@KAHPAUlua_State@@@Z ENDP	; CvLuaMap::lGetAIMapHint
_TEXT	ENDS
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	mov	eax, DWORD PTR _iX$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4020]
	jge	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _iY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4024]
	jge	SHORT $LN3@isPlot
	mov	eax, 1

; 161  : #endif
; 162  : 	}

	ret	8
$LN3@isPlot:

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	xor	eax, eax

; 161  : #endif
; 162  : 	}

	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
PUBLIC	?plotNum@CvMap@@QBEHHH@Z			; CvMap::plotNum
; Function compile flags: /Ogtpy
;	COMDAT ?plotNum@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plotNum@CvMap@@QBEHHH@Z PROC				; CvMap::plotNum, COMDAT
; _this$ = ecx

; 183  : 		return ((iY * getGridWidth()) + iX);

	mov	eax, DWORD PTR [ecx+4020]
	imul	eax, DWORD PTR _iY$[esp-4]
	add	eax, DWORD PTR _iX$[esp-4]

; 184  : #endif
; 185  : 	}

	ret	8
?plotNum@CvMap@@QBEHHH@Z ENDP				; CvMap::plotNum
_TEXT	ENDS
PUBLIC	?plot@CvMap@@QBEPAVCvPlot@@HH@Z			; CvMap::plot
; Function compile flags: /Ogtpy
;	COMDAT ?plot@CvMap@@QBEPAVCvPlot@@HH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plot@CvMap@@QBEPAVCvPlot@@HH@Z PROC			; CvMap::plot, COMDAT
; _this$ = ecx

; 273  : 		if((iX == INVALID_PLOT_COORD) || (iY == INVALID_PLOT_COORD))

	mov	eax, DWORD PTR _iX$[esp-4]
	push	ebp
	cmp	eax, -2147483647			; 80000001H
	je	$LN1@plot
	mov	ebp, DWORD PTR _iY$[esp]
	cmp	ebp, -2147483647			; 80000001H
	je	$LN1@plot

; 276  : 		}
; 277  : 		int iMapX = coordRange(iX, getGridWidth(), isWrapX());

	cmp	BYTE PTR [ecx+4056], 0
	push	ebx
	push	esi
	mov	esi, DWORD PTR [ecx+4020]
	push	edi
	je	SHORT $LN11@plot
	test	eax, eax
	jge	SHORT $LN13@plot
	cdq
	idiv	esi
	mov	edi, edx
	add	edi, esi
	jmp	SHORT $LN15@plot
$LN13@plot:
	cmp	eax, esi
	jl	SHORT $LN11@plot
	cdq
	idiv	esi
	mov	edi, edx
	jmp	SHORT $LN15@plot
$LN11@plot:
	mov	edi, eax
$LN15@plot:

; 278  : 		int iMapY = coordRange(iY, getGridHeight(), isWrapY());

	cmp	BYTE PTR [ecx+4057], 0
	mov	ebx, DWORD PTR [ecx+4024]
	je	SHORT $LN40@plot
	test	ebp, ebp
	jge	SHORT $LN23@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN25@plot
$LN23@plot:
	cmp	ebp, ebx
	jl	SHORT $LN40@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	jmp	SHORT $LN25@plot
$LN40@plot:
	mov	edx, ebp
$LN25@plot:

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	test	edi, edi
	jl	SHORT $LN5@plot
	cmp	edi, esi
	jge	SHORT $LN5@plot
	test	edx, edx
	jl	SHORT $LN5@plot
	cmp	edx, ebx
	jge	SHORT $LN5@plot
	imul	esi, edx
	add	esi, edi
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [ecx+4068]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	pop	ebp

; 280  : 	}

	ret	8
$LN5@plot:
	pop	edi
	pop	esi
	pop	ebx

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
$LN1@plot:

; 274  : 		{
; 275  : 			return NULL;

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
?plot@CvMap@@QBEPAVCvPlot@@HH@Z ENDP			; CvMap::plot
_TEXT	ENDS
PUBLIC	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_eDirection$ = 16					; size = 4
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z PROC ; plotDirection, COMDAT

; 194  : 	if(eDirection == NO_DIRECTION)

	mov	ecx, DWORD PTR _eDirection$[esp-4]
	push	ebx
	push	ebp
	push	esi
	push	edi
	cmp	ecx, -1
	jne	$LN2@plotDirect

; 195  : 	{
; 196  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR _iX$[esp+12]
	cmp	eax, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebx, DWORD PTR _iY$[esp+12]
	cmp	ebx, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN99@plotDirect
	test	eax, eax
	jge	SHORT $LN19@plotDirect
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN21@plotDirect
$LN19@plotDirect:
	cmp	eax, ecx
	jl	SHORT $LN99@plotDirect
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN21@plotDirect
$LN99@plotDirect:
	mov	esi, eax
$LN21@plotDirect:
	cmp	BYTE PTR [ebp+4057], 0
	mov	edi, DWORD PTR [ebp+4024]
	je	SHORT $LN101@plotDirect
	test	ebx, ebx
	jge	SHORT $LN29@plotDirect
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN31@plotDirect
$LN29@plotDirect:
	cmp	ebx, edi
	jl	SHORT $LN101@plotDirect
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN31@plotDirect
$LN101@plotDirect:
	mov	edx, ebx
$LN31@plotDirect:
	test	esi, esi
	jl	$LN59@plotDirect
	cmp	esi, ecx
	jge	$LN59@plotDirect
	test	edx, edx
	jl	$LN59@plotDirect
	cmp	edx, edi
	jge	$LN59@plotDirect
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ecx
	pop	ebx

; 209  : 	}
; 210  : }

	ret	0
$LN2@plotDirect:

; 197  : 	}
; 198  : 	else
; 199  : 	{
; 200  : 		// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 201  : 		iX = xToHexspaceX(iX , iY);

	mov	esi, DWORD PTR _iY$[esp+12]
	test	esi, esi
	jl	SHORT $LN47@plotDirect
	mov	eax, esi
	jmp	SHORT $LN103@plotDirect
$LN47@plotDirect:
	lea	eax, DWORD PTR [esi-1]
	cdq
	sub	eax, edx
$LN103@plotDirect:

; 202  : 		iX += GC.getPlotDirectionX()[eDirection];

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A[ecx*4+112]
	mov	edi, DWORD PTR _iX$[esp+12]
	sar	eax, 1
	sub	edx, eax
	add	edi, edx

; 203  : 		iY += GC.getPlotDirectionY()[eDirection];

	add	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A[ecx*4+136]

; 204  : 
; 205  : 		// convert from hex-space coordinates to the storage array
; 206  : 		iX = hexspaceXToX(iX, iY);

	js	SHORT $LN55@plotDirect
	mov	eax, esi
	jmp	SHORT $LN104@plotDirect
$LN55@plotDirect:
	lea	eax, DWORD PTR [esi-1]
	cdq
	sub	eax, edx
$LN104@plotDirect:
	sar	eax, 1
	add	edi, eax

; 207  : 
; 208  : 		return GC.getMap().plot(iX, iY);

	cmp	edi, -2147483647			; 80000001H
	je	$LN59@plotDirect
	cmp	esi, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN69@plotDirect
	test	edi, edi
	jge	SHORT $LN71@plotDirect
	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, edx
	add	edi, ecx
	jmp	SHORT $LN69@plotDirect
$LN71@plotDirect:
	cmp	edi, ecx
	jl	SHORT $LN69@plotDirect
	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, edx
$LN69@plotDirect:
	cmp	BYTE PTR [ebp+4057], 0
	mov	ebx, DWORD PTR [ebp+4024]
	je	SHORT $LN100@plotDirect
	test	esi, esi
	jge	SHORT $LN81@plotDirect
	mov	eax, esi
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN83@plotDirect
$LN81@plotDirect:
	cmp	esi, ebx
	jl	SHORT $LN100@plotDirect
	mov	eax, esi
	cdq
	idiv	ebx
	jmp	SHORT $LN83@plotDirect
$LN100@plotDirect:
	mov	edx, esi
$LN83@plotDirect:
	test	edi, edi
	jl	SHORT $LN59@plotDirect
	cmp	edi, ecx
	jge	SHORT $LN59@plotDirect
	test	edx, edx
	jl	SHORT $LN59@plotDirect
	cmp	edx, ebx
	jge	SHORT $LN59@plotDirect
	imul	ecx, edx
	add	ecx, edi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ecx
	pop	ebx

; 209  : 	}
; 210  : }

	ret	0

; 207  : 
; 208  : 		return GC.getMap().plot(iX, iY);

$LN59@plotDirect:
	pop	edi
	pop	esi
	pop	ebp
	xor	eax, eax
	pop	ebx

; 209  : 	}
; 210  : }

	ret	0
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ENDP ; plotDirection
_TEXT	ENDS
PUBLIC	?plotXY@@YAPAVCvPlot@@HHHH@Z			; plotXY
; Function compile flags: /Ogtpy
;	COMDAT ?plotXY@@YAPAVCvPlot@@HHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
?plotXY@@YAPAVCvPlot@@HHHH@Z PROC			; plotXY, COMDAT

; 214  : 	// convert the start coord to hex-space coordinates
; 215  : 	int iStartHexX = xToHexspaceX(iX, iY);

	mov	ecx, DWORD PTR _iY$[esp-4]
	test	ecx, ecx
	jl	SHORT $LN5@plotXY
	mov	eax, ecx
	jmp	SHORT $LN55@plotXY
$LN5@plotXY:
	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
$LN55@plotXY:
	push	esi

; 216  : 
; 217  : 	int iPlotHexX = iStartHexX + iDX;

	mov	esi, DWORD PTR _iX$[esp]
	sar	eax, 1
	sub	esi, eax

; 218  : 	int iPlotY = iY + iDY; // Y is the same in both coordinate systems

	mov	eax, DWORD PTR _iDY$[esp]
	add	esi, DWORD PTR _iDX$[esp]
	push	edi
	lea	edi, DWORD PTR [ecx+eax]

; 219  : 
; 220  : 	// convert from hex-space coordinates to the storage array
; 221  : 	iPlotHexX = hexspaceXToX(iPlotHexX, iPlotY);

	test	edi, edi
	jl	SHORT $LN9@plotXY
	mov	eax, edi
	jmp	SHORT $LN56@plotXY
$LN9@plotXY:
	lea	eax, DWORD PTR [edi-1]
	cdq
	sub	eax, edx
$LN56@plotXY:
	sar	eax, 1
	add	esi, eax

; 222  : 
; 223  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

	cmp	esi, -2147483647			; 80000001H
	je	$LN13@plotXY
	cmp	edi, -2147483647			; 80000001H
	je	$LN13@plotXY
	push	ebp
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN23@plotXY
	test	esi, esi
	jge	SHORT $LN25@plotXY
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN23@plotXY
$LN25@plotXY:
	cmp	esi, ecx
	jl	SHORT $LN23@plotXY
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
$LN23@plotXY:
	cmp	BYTE PTR [ebp+4057], 0
	push	ebx
	mov	ebx, DWORD PTR [ebp+4024]
	je	SHORT $LN52@plotXY
	test	edi, edi
	jge	SHORT $LN35@plotXY
	mov	eax, edi
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN37@plotXY
$LN35@plotXY:
	cmp	edi, ebx
	jl	SHORT $LN52@plotXY
	mov	eax, edi
	cdq
	idiv	ebx
	jmp	SHORT $LN37@plotXY
$LN52@plotXY:
	mov	edx, edi
$LN37@plotXY:
	test	esi, esi
	jl	SHORT $LN17@plotXY
	cmp	esi, ecx
	jge	SHORT $LN17@plotXY
	test	edx, edx
	jl	SHORT $LN17@plotXY
	cmp	edx, ebx
	jge	SHORT $LN17@plotXY
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	ebx
	pop	ebp
	pop	edi
	mov	eax, ecx
	pop	esi

; 224  : }

	ret	0

; 222  : 
; 223  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

$LN17@plotXY:
	pop	ebx
	pop	ebp
	pop	edi
	xor	eax, eax
	pop	esi

; 224  : }

	ret	0

; 222  : 
; 223  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

$LN13@plotXY:
	pop	edi
	xor	eax, eax
	pop	esi

; 224  : }

	ret	0
?plotXY@@YAPAVCvPlot@@HHHH@Z ENDP			; plotXY
_TEXT	ENDS
PUBLIC	?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z	; plotXYWithRangeCheck
; Function compile flags: /Ogtpy
;	COMDAT ?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
_iRange$ = 24						; size = 4
?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z PROC	; plotXYWithRangeCheck, COMDAT

; 234  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 235  : 	// I'm assuming iDX and iDY are in hex-space
; 236  : 	if (hexDistance(iDX, iDY) > iRange)
; 237  : #else
; 238  : 	int hexRange;
; 239  : 
; 240  : 	// I'm assuming iDX and iDY are in hex-space
; 241  : 	if((iDX >= 0) == (iDY >= 0))  // the signs match

	mov	edx, DWORD PTR _iDX$[esp-4]
	xor	eax, eax
	test	edx, edx
	setge	al
	xor	ecx, ecx
	push	esi
	mov	esi, DWORD PTR _iDY$[esp]
	test	esi, esi
	setge	cl
	cmp	eax, ecx

; 242  : 	{
; 243  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	mov	ecx, edx
	jne	SHORT $LN3@plotXYWith
	test	edx, edx
	jge	SHORT $LN7@plotXYWith
	neg	ecx
$LN7@plotXYWith:

; 244  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	mov	eax, esi
	test	esi, esi
	jge	SHORT $LN9@plotXYWith
	neg	eax
$LN9@plotXYWith:

; 245  : 		hexRange = iAbsDX + iAbsDY;

	add	eax, ecx

; 246  : 	}
; 247  : 	else

	jmp	SHORT $LN14@plotXYWith
$LN3@plotXYWith:

; 248  : 	{
; 249  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	test	edx, edx
	jge	SHORT $LN11@plotXYWith
	neg	ecx
$LN11@plotXYWith:

; 250  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	mov	eax, esi
	test	esi, esi
	jge	SHORT $LN13@plotXYWith
	neg	eax
$LN13@plotXYWith:

; 251  : 		hexRange = iAbsDX >= iAbsDY ? iAbsDX : iAbsDY;

	cmp	ecx, eax
	jl	SHORT $LN14@plotXYWith
	mov	eax, ecx
$LN14@plotXYWith:

; 252  : 	}
; 253  : 
; 254  : 	if(hexRange > iRange)

	cmp	eax, DWORD PTR _iRange$[esp]
	jle	SHORT $LN1@plotXYWith

; 255  : #endif
; 256  : 	{
; 257  : 		return NULL;

	xor	eax, eax
	pop	esi

; 261  : }

	ret	0
$LN1@plotXYWith:

; 258  : 	}
; 259  : 
; 260  : 	return plotXY(iX, iY, iDX, iDY);

	mov	eax, DWORD PTR _iX$[esp]
	push	esi
	push	edx
	mov	edx, DWORD PTR _iY$[esp+8]
	push	edx
	push	eax
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	add	esp, 16					; 00000010H
	pop	esi

; 261  : }

	ret	0
?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z ENDP	; plotXYWithRangeCheck
_TEXT	ENDS
PUBLIC	?lAreas@CvLuaMap@@KAHPAUlua_State@@@Z		; CvLuaMap::lAreas
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\lua\cvluamap.cpp
;	COMDAT ?lAreas@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lAreas@CvLuaMap@@KAHPAUlua_State@@@Z PROC		; CvLuaMap::lAreas, COMDAT

; 80   : 	lua_pushcclosure(L, CvLuaMap::lAreasAux, 0);

	mov	eax, DWORD PTR _L$[esp-4]
	push	0
	push	OFFSET ?lAreasAux@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lAreasAux
	push	eax
	call	_lua_pushcclosure
	add	esp, 12					; 0000000cH

; 81   : 	return 1;

	mov	eax, 1

; 82   : }

	ret	0
?lAreas@CvLuaMap@@KAHPAUlua_State@@@Z ENDP		; CvLuaMap::lAreas
_TEXT	ENDS
PUBLIC	?lGetPlot@CvLuaMap@@KAHPAUlua_State@@@Z		; CvLuaMap::lGetPlot
; Function compile flags: /Ogtpy
;	COMDAT ?lGetPlot@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetPlot@CvLuaMap@@KAHPAUlua_State@@@Z PROC		; CvLuaMap::lGetPlot, COMDAT

; 195  : {

	push	ebx
	push	ebp
	push	esi
	push	edi

; 196  : 	const int x = lua_tointeger(L, 1);

	mov	edi, DWORD PTR _L$[esp+12]
	push	1
	push	edi
	call	_lua_tointeger

; 197  : 	const int y = lua_tointeger(L, 2);

	push	2
	push	edi
	mov	esi, eax
	call	_lua_tointeger
	add	esp, 16					; 00000010H
	mov	ebx, eax

; 198  : 
; 199  : 	CvPlot* pPlot = GC.getMap().plot(x, y);

	cmp	esi, -2147483647			; 80000001H
	je	$LN1@lGetPlot
	cmp	ebx, -2147483647			; 80000001H
	je	$LN1@lGetPlot
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN45@lGetPlot
	test	esi, esi
	jge	SHORT $LN18@lGetPlot
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN45@lGetPlot
$LN18@lGetPlot:
	cmp	esi, ecx
	jl	SHORT $LN45@lGetPlot
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
$LN45@lGetPlot:
	cmp	BYTE PTR [ebp+4057], 0
	mov	edi, DWORD PTR [ebp+4024]
	je	SHORT $LN46@lGetPlot
	test	ebx, ebx
	jge	SHORT $LN28@lGetPlot
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN30@lGetPlot
$LN28@lGetPlot:
	cmp	ebx, edi
	jl	SHORT $LN46@lGetPlot
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN30@lGetPlot
$LN46@lGetPlot:
	mov	edx, ebx
$LN30@lGetPlot:
	test	esi, esi
	jl	SHORT $LN1@lGetPlot
	cmp	esi, ecx
	jge	SHORT $LN1@lGetPlot
	test	edx, edx
	jl	SHORT $LN1@lGetPlot
	cmp	edx, edi
	jge	SHORT $LN1@lGetPlot
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]

; 200  : 	if(pPlot)

	test	ecx, ecx
	je	SHORT $LN1@lGetPlot

; 201  : 	{
; 202  : 		CvLuaPlot::Push(L, pPlot);

	mov	eax, DWORD PTR _L$[esp+12]
	push	ecx
	push	eax
	call	?Push@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAXPAUlua_State@@PAVCvPlot@@@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::Push
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp

; 203  : 		return 1;

	mov	eax, 1
	pop	ebx

; 206  : }

	ret	0
$LN1@lGetPlot:
	pop	edi
	pop	esi
	pop	ebp

; 204  : 	}
; 205  : 	return 0;

	xor	eax, eax
	pop	ebx

; 206  : }

	ret	0
?lGetPlot@CvLuaMap@@KAHPAUlua_State@@@Z ENDP		; CvLuaMap::lGetPlot
_TEXT	ENDS
PUBLIC	?lGetPlotXY@CvLuaMap@@KAHPAUlua_State@@@Z	; CvLuaMap::lGetPlotXY
; Function compile flags: /Ogtpy
;	COMDAT ?lGetPlotXY@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lGetPlotXY@CvLuaMap@@KAHPAUlua_State@@@Z PROC		; CvLuaMap::lGetPlotXY, COMDAT

; 225  : {

	push	ebx
	push	ebp
	push	esi

; 226  : 	int x, y, dx, dy;
; 227  : 	const int count = lua_gettop(L);

	mov	esi, DWORD PTR _L$[esp+8]
	push	edi
	push	esi
	call	_lua_gettop
	add	esp, 4

; 228  : 
; 229  : 	if(count == 2)
; 230  : 	{
; 231  : 		x = 0;
; 232  : 		y = 0;
; 233  : 		dx = lua_tointeger(L, 1);

	push	1
	push	esi
	cmp	eax, 2
	jne	SHORT $LN2@lGetPlotXY
	xor	edi, edi
	xor	ebx, ebx
	call	_lua_tointeger

; 234  : 		dy = lua_tointeger(L, 2);

	push	2
	push	esi
	mov	ebp, eax
	call	_lua_tointeger
	add	esp, 16					; 00000010H

; 235  : 	}
; 236  : 	else

	jmp	SHORT $LN1@lGetPlotXY
$LN2@lGetPlotXY:

; 237  : 	{
; 238  : 		x = lua_tointeger(L, 1);

	call	_lua_tointeger

; 239  : 		y = lua_tointeger(L, 2);

	push	2
	push	esi
	mov	edi, eax
	call	_lua_tointeger

; 240  : 		dx = lua_tointeger(L, 3);

	push	3
	push	esi
	mov	ebx, eax
	call	_lua_tointeger

; 241  : 		dy = lua_tointeger(L, 4);

	push	4
	push	esi
	mov	ebp, eax
	call	_lua_tointeger
	add	esp, 32					; 00000020H
$LN1@lGetPlotXY:

; 242  : 	}
; 243  : 
; 244  : 	CvPlot* pkPlot = plotXY(x, y, dx, dy);

	push	eax
	push	ebp
	push	ebx
	push	edi
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY

; 245  : 	CvLuaPlot::Push(L, pkPlot);

	push	eax
	push	esi
	call	?Push@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAXPAUlua_State@@PAVCvPlot@@@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::Push
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi
	pop	ebp

; 246  : 	return 1;

	mov	eax, 1
	pop	ebx

; 247  : }

	ret	0
?lGetPlotXY@CvLuaMap@@KAHPAUlua_State@@@Z ENDP		; CvLuaMap::lGetPlotXY
_TEXT	ENDS
PUBLIC	?lIsPlot@CvLuaMap@@KAHPAUlua_State@@@Z		; CvLuaMap::lIsPlot
; Function compile flags: /Ogtpy
;	COMDAT ?lIsPlot@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lIsPlot@CvLuaMap@@KAHPAUlua_State@@@Z PROC		; CvLuaMap::lIsPlot, COMDAT

; 313  : {

	push	esi
	push	edi

; 314  : 	int x = lua_tointeger(L, 1);

	mov	edi, DWORD PTR _L$[esp+4]
	push	1
	push	edi
	call	_lua_tointeger

; 315  : 	int y = lua_tointeger(L, 2);

	push	2
	push	edi
	mov	esi, eax
	call	_lua_tointeger
	add	esp, 16					; 00000010H

; 316  : 
; 317  : 	const bool bResult = GC.getMap().isPlot(x, y);

	test	esi, esi
	jl	SHORT $LN7@lIsPlot
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	esi, DWORD PTR [ecx+4020]
	jge	SHORT $LN7@lIsPlot
	test	eax, eax
	jl	SHORT $LN7@lIsPlot
	cmp	eax, DWORD PTR [ecx+4024]
	jge	SHORT $LN7@lIsPlot
	mov	eax, 1
	jmp	SHORT $LN8@lIsPlot
$LN7@lIsPlot:
	xor	eax, eax
$LN8@lIsPlot:
	xor	ecx, ecx
	test	eax, eax
	setne	cl

; 318  : 
; 319  : 	lua_pushboolean(L, bResult);

	push	ecx
	push	edi
	call	_lua_pushboolean
	add	esp, 8
	pop	edi

; 320  : 	return 1;

	mov	eax, 1
	pop	esi

; 321  : }

	ret	0
?lIsPlot@CvLuaMap@@KAHPAUlua_State@@@Z ENDP		; CvLuaMap::lIsPlot
_TEXT	ENDS
PUBLIC	?lPlotXYWithRangeCheck@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lPlotXYWithRangeCheck
; Function compile flags: /Ogtpy
;	COMDAT ?lPlotXYWithRangeCheck@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_iDeltaHexY$ = -4					; size = 4
_L$ = 8							; size = 4
?lPlotXYWithRangeCheck@CvLuaMap@@KAHPAUlua_State@@@Z PROC ; CvLuaMap::lPlotXYWithRangeCheck, COMDAT

; 385  : {

	push	ecx
	push	ebx
	push	ebp
	push	esi

; 386  : 	int iX = lua_tointeger(L, 1);

	mov	esi, DWORD PTR _L$[esp+12]
	push	edi
	push	1
	push	esi
	call	_lua_tointeger

; 387  : 	int iY = lua_tointeger(L, 2);

	push	2
	push	esi
	mov	edi, eax
	call	_lua_tointeger

; 388  : 	int iDeltaHexX = lua_tointeger(L, 3);

	push	3
	push	esi
	mov	ebx, eax
	call	_lua_tointeger

; 389  : 	int iDeltaHexY = lua_tointeger(L, 4);

	push	4
	push	esi
	mov	ebp, eax
	call	_lua_tointeger

; 390  : 	int iRange = lua_tointeger(L, 5);

	push	5
	push	esi
	mov	DWORD PTR _iDeltaHexY$[esp+60], eax
	call	_lua_tointeger

; 391  : 	CvPlot* pkPlot = plotXYWithRangeCheck(iX, iY, iDeltaHexX, iDeltaHexY, iRange);

	push	eax
	mov	eax, DWORD PTR _iDeltaHexY$[esp+64]
	push	eax
	push	ebp
	push	ebx
	push	edi
	call	?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z ; plotXYWithRangeCheck

; 392  : 	CvLuaPlot::Push(L, pkPlot);

	push	eax
	push	esi
	call	?Push@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAXPAUlua_State@@PAVCvPlot@@@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::Push
	add	esp, 68					; 00000044H
	pop	edi
	pop	esi
	pop	ebp

; 393  : 	return 1;

	mov	eax, 1
	pop	ebx

; 394  : }

	pop	ecx
	ret	0
?lPlotXYWithRangeCheck@CvLuaMap@@KAHPAUlua_State@@@Z ENDP ; CvLuaMap::lPlotXYWithRangeCheck
_TEXT	ENDS
PUBLIC	?lPlotDirection@CvLuaMap@@KAHPAUlua_State@@@Z	; CvLuaMap::lPlotDirection
; Function compile flags: /Ogtpy
;	COMDAT ?lPlotDirection@CvLuaMap@@KAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?lPlotDirection@CvLuaMap@@KAHPAUlua_State@@@Z PROC	; CvLuaMap::lPlotDirection, COMDAT

; 397  : {

	push	ebx
	push	esi

; 398  : 	int iX = lua_tointeger(L, 1);

	mov	esi, DWORD PTR _L$[esp+4]
	push	edi
	push	1
	push	esi
	call	_lua_tointeger

; 399  : 	int iY = lua_tointeger(L, 2);

	push	2
	push	esi
	mov	edi, eax
	call	_lua_tointeger

; 400  : 	DirectionTypes eDirection = (DirectionTypes)lua_tointeger(L, 3);

	push	3
	push	esi
	mov	ebx, eax
	call	_lua_tointeger

; 401  : 
; 402  : 	CvPlot* pkPlot = plotDirection(iX, iY, eDirection);

	push	eax
	push	ebx
	push	edi
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection

; 403  : 
; 404  : 	CvLuaPlot::Push(L, pkPlot);

	push	eax
	push	esi
	call	?Push@?$CvLuaScopedInstance@VCvLuaPlot@@VCvPlot@@@@SAXPAUlua_State@@PAVCvPlot@@@Z ; CvLuaScopedInstance<CvLuaPlot,CvPlot>::Push
	add	esp, 44					; 0000002cH
	pop	edi
	pop	esi

; 405  : 	return 1;

	mov	eax, 1
	pop	ebx

; 406  : }

	ret	0
?lPlotDirection@CvLuaMap@@KAHPAUlua_State@@@Z ENDP	; CvLuaMap::lPlotDirection
_TEXT	ENDS
PUBLIC	?RegisterMembers@CvLuaMap@@SAXPAUlua_State@@@Z	; CvLuaMap::RegisterMembers
; Function compile flags: /Ogtpy
;	COMDAT ?RegisterMembers@CvLuaMap@@SAXPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?RegisterMembers@CvLuaMap@@SAXPAUlua_State@@@Z PROC	; CvLuaMap::RegisterMembers, COMDAT

; 39   : {

	push	esi

; 40   : 	Method(Areas);

	mov	esi, DWORD PTR _L$[esp]
	push	0
	push	OFFSET ?lAreas@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lAreas
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG219456
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield

; 41   : 	Method(FindBiggestArea);

	push	0
	push	OFFSET ?lFindBiggestArea@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lFindBiggestArea
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG219457
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield

; 42   : 	Method(FindWater);

	push	0
	push	OFFSET ?lFindWater@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lFindWater
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG219458
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 43   : 	Method(GetClimate);

	push	0
	push	OFFSET ?lGetClimate@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lGetClimate
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG219459
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield

; 44   : 	Method(GetFractalFlags);

	push	0
	push	OFFSET ?lGetFractalFlags@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lGetFractalFlags
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG219460
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield

; 45   : 	Method(GetGridSize);

	push	0
	push	OFFSET ?lGetGridSize@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lGetGridSize
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG219461
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 46   : 	Method(GetNumPlots);

	push	0
	push	OFFSET ?lGetNumPlots@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lGetNumPlots
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG219462
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield

; 47   : 	Method(GetNumResources);

	push	0
	push	OFFSET ?lGetNumResources@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lGetNumResources
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG219463
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield

; 48   : 	Method(GetNumResourcesOnLand);

	push	0
	push	OFFSET ?lGetNumResourcesOnLand@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lGetNumResourcesOnLand
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG219464
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 49   : 	Method(GetPlot);

	push	0
	push	OFFSET ?lGetPlot@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lGetPlot
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG219465
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield

; 50   : 	Method(GetPlotByIndex);

	push	0
	push	OFFSET ?lGetPlotByIndex@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lGetPlotByIndex
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG219466
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield

; 51   : 	Method(GetPlotXY);

	push	0
	push	OFFSET ?lGetPlotXY@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lGetPlotXY
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG219467
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 52   : 	Method(GetArea);

	push	0
	push	OFFSET ?lGetArea@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lGetArea
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG219468
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield

; 53   : 	Method(GetIndexAfterLastArea);

	push	0
	push	OFFSET ?lGetIndexAfterLastArea@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lGetIndexAfterLastArea
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG219469
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield

; 54   : 	Method(GetLandPlots);

	push	0
	push	OFFSET ?lGetLandPlots@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lGetLandPlots
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG219470
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 55   : 	Method(GetNumAreas);

	push	0
	push	OFFSET ?lGetNumAreas@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lGetNumAreas
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG219471
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield

; 56   : 	Method(GetNumLandAreas);

	push	0
	push	OFFSET ?lGetNumLandAreas@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lGetNumLandAreas
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG219472
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield

; 57   : 	Method(GetRandomResourceQuantity);

	push	0
	push	OFFSET ?lGetRandomResourceQuantity@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lGetRandomResourceQuantity
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG219473
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 58   : 	Method(GetSeaLevel);

	push	0
	push	OFFSET ?lGetSeaLevel@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lGetSeaLevel
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG219474
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield

; 59   : 	Method(GetWorldSize);

	push	0
	push	OFFSET ?lGetWorldSize@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lGetWorldSize
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG219475
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield

; 60   : 	Method(IsPlot);

	push	0
	push	OFFSET ?lIsPlot@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lIsPlot
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG219476
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 61   : 	Method(IsWrapX);

	push	0
	push	OFFSET ?lIsWrapX@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lIsWrapX
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG219477
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield

; 62   : 	Method(IsWrapY);

	push	0
	push	OFFSET ?lIsWrapY@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lIsWrapY
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG219478
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield

; 63   : 	Method(MaxPlotDistance);

	push	0
	push	OFFSET ?lMaxPlotDistance@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lMaxPlotDistance
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG219479
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 64   : 	Method(Rand);

	push	0
	push	OFFSET ?lRand@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lRand
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG219480
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield

; 65   : 	Method(CalculateAreas);

	push	0
	push	OFFSET ?lCalculateAreas@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lCalculateAreas
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG219481
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield

; 66   : 	Method(RecalculateAreas);

	push	0
	push	OFFSET ?lRecalculateAreas@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lRecalculateAreas
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG219482
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 67   : 	Method(PlotDistance);

	push	0
	push	OFFSET ?lPlotDistance@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lPlotDistance
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG219483
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield

; 68   : 	Method(PlotXYWithRangeCheck);

	push	0
	push	OFFSET ?lPlotXYWithRangeCheck@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lPlotXYWithRangeCheck
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG219484
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield

; 69   : 	Method(PlotDirection);

	push	0
	push	OFFSET ?lPlotDirection@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lPlotDirection
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG219485
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 70   : 	Method(DefaultContinentStamper);

	push	0
	push	OFFSET ?lDefaultContinentStamper@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lDefaultContinentStamper
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG219486
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield

; 71   : 	Method(DoPlaceNaturalWonders);

	push	0
	push	OFFSET ?lDoPlaceNaturalWonders@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lDoPlaceNaturalWonders
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG219487
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield

; 72   : 	Method(GetCustomOption);

	push	0
	push	OFFSET ?lGetCustomOption@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lGetCustomOption
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG219488
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H

; 73   : 	Method(UpdateDeferredFog);

	push	0
	push	OFFSET ?lUpdateDeferredFog@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lUpdateDeferredFog
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG219489
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield

; 74   : 	Method(ChangeAIMapHint);

	push	0
	push	OFFSET ?lChangeAIMapHint@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lChangeAIMapHint
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG219490
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield

; 75   : 	Method(GetAIMapHint);

	push	0
	push	OFFSET ?lGetAIMapHint@CvLuaMap@@KAHPAUlua_State@@@Z ; CvLuaMap::lGetAIMapHint
	push	esi
	call	_lua_pushcclosure
	push	OFFSET $SG219491
	push	-2					; fffffffeH
	push	esi
	call	_lua_setfield
	add	esp, 72					; 00000048H
	pop	esi

; 76   : }

	ret	0
?RegisterMembers@CvLuaMap@@SAXPAUlua_State@@@Z ENDP	; CvLuaMap::RegisterMembers
_TEXT	ENDS
END
