; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Documents\GitHub\Lekmod\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvTacticalAnalysisMap.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?NO_QUEST_DATA@CvMinorCivQuest@@2HB		; CvMinorCivQuest::NO_QUEST_DATA
PUBLIC	?NO_TURN@CvMinorCivQuest@@2HB			; CvMinorCivQuest::NO_TURN
CONST	SEGMENT
$SG222824 DB	'Zone ID: %d, Area ID: %d, Value: %d, FRIENDLY Str: %d (%'
	DB	'd), Ranged: %d (%d), ENEMY Str: %d (%d), Ranged: %d (%d), Clo'
	DB	'sest Enemy: %d', 00H
$SG222826 DB	', Friendly', 00H
	ORG $+1
$SG222829 DB	', Enemy', 00H
$SG222832 DB	', Even', 00H
	ORG $+1
$SG222835 DB	', No Units Visible', 00H
	ORG $+1
$SG222837 DB	', Water', 00H
$SG222839 DB	', Land', 00H
	ORG $+1
$SG222841 DB	', Temporary Zone', 00H
	ORG $+3
$SG222846 DB	', ', 00H
	ORG $+1
$SG222848 DB	' (Temp)', 00H
CONST	ENDS
;	COMDAT ?NO_TURN@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_TURN@CvMinorCivQuest@@2HB DD 0ffffffffH		; CvMinorCivQuest::NO_TURN
CONST	ENDS
;	COMDAT ?NO_QUEST_DATA@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_QUEST_DATA@CvMinorCivQuest@@2HB DD 0ffffffffH	; CvMinorCivQuest::NO_QUEST_DATA
CONST	ENDS
PUBLIC	?wrapCoordDifference@@YAHHI_N@Z			; wrapCoordDifference
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?wrapCoordDifference@@YAHHI_N@Z
_TEXT	SEGMENT
_iDiff$ = 8						; size = 4
_uiRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?wrapCoordDifference@@YAHHI_N@Z PROC			; wrapCoordDifference, COMDAT

; 57   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iDiff$[esp-4]
	je	SHORT $LN5@wrapCoordD

; 58   : 	{
; 59   : 		if(iDiff > (int)(uiRange >> 1))		// Using an unsigned int so we can safely assume that value >> 1 == value / 2

	mov	edx, DWORD PTR _uiRange$[esp-4]
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN3@wrapCoordD

; 60   : 		{
; 61   : 			return (iDiff - (int)uiRange);

	sub	eax, edx

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
$LN3@wrapCoordD:

; 62   : 		}
; 63   : 		else if(iDiff < -(int)(uiRange >> 1))

	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN5@wrapCoordD

; 64   : 		{
; 65   : 			return (iDiff + (int)uiRange);

	add	eax, edx
$LN5@wrapCoordD:

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
?wrapCoordDifference@@YAHHI_N@Z ENDP			; wrapCoordDifference
_TEXT	ENDS
PUBLIC	?xToHexspaceX@@YAHHH@Z				; xToHexspaceX
; Function compile flags: /Ogtpy
;	COMDAT ?xToHexspaceX@@YAHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?xToHexspaceX@@YAHHH@Z PROC				; xToHexspaceX, COMDAT

; 86   : 	return iX - ((iY >= 0) ? (iY>>1) : ((iY - 1)/2));

	mov	ecx, DWORD PTR _iY$[esp-4]
	test	ecx, ecx
	jge	SHORT $LN5@xToHexspac
	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
	mov	ecx, eax
$LN5@xToHexspac:
	mov	eax, DWORD PTR _iX$[esp-4]
	sar	ecx, 1
	sub	eax, ecx

; 87   : }

	ret	0
?xToHexspaceX@@YAHHH@Z ENDP				; xToHexspaceX
_TEXT	ENDS
PUBLIC	?hexspaceXToX@@YAHHH@Z				; hexspaceXToX
; Function compile flags: /Ogtpy
;	COMDAT ?hexspaceXToX@@YAHHH@Z
_TEXT	SEGMENT
_iHexspaceX$ = 8					; size = 4
_iHexspaceY$ = 12					; size = 4
?hexspaceXToX@@YAHHH@Z PROC				; hexspaceXToX, COMDAT

; 91   : 	return iHexspaceX + ((iHexspaceY >= 0) ? (iHexspaceY>>1) : ((iHexspaceY - 1)/2));

	mov	eax, DWORD PTR _iHexspaceY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@hexspaceXT
	mov	ecx, DWORD PTR _iHexspaceX$[esp-4]
	sar	eax, 1
	add	eax, ecx

; 92   : }

	ret	0
$LN3@hexspaceXT:

; 91   : 	return iHexspaceX + ((iHexspaceY >= 0) ? (iHexspaceY>>1) : ((iHexspaceY - 1)/2));

	dec	eax
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _iHexspaceX$[esp-4]
	sar	eax, 1
	add	eax, edx

; 92   : }

	ret	0
?hexspaceXToX@@YAHHH@Z ENDP				; hexspaceXToX
_TEXT	ENDS
PUBLIC	??0CvTacticalDominanceZone@@QAE@XZ		; CvTacticalDominanceZone::CvTacticalDominanceZone
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtacticalanalysismap.cpp
;	COMDAT ??0CvTacticalDominanceZone@@QAE@XZ
_TEXT	SEGMENT
??0CvTacticalDominanceZone@@QAE@XZ PROC			; CvTacticalDominanceZone::CvTacticalDominanceZone, COMDAT
; _this$ = ecx

; 77   : {

	mov	eax, ecx

; 78   : 	m_iDominanceZoneID = -1;
; 79   : 	m_eTerritoryType = TACTICAL_TERRITORY_NONE;

	xor	ecx, ecx
	or	edx, -1
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 80   : 	m_eDominanceFlag = TACTICAL_DOMINANCE_NO_UNITS_VISIBLE;

	mov	DWORD PTR [eax+8], ecx

; 81   : 	m_eOwner = NO_PLAYER;

	mov	DWORD PTR [eax+12], edx

; 82   : 	m_iCityID = -1;

	mov	DWORD PTR [eax+16], edx

; 83   : 	m_iAreaID = 0;

	mov	DWORD PTR [eax+20], ecx

; 84   : 	m_iFriendlyStrength = 0;

	mov	DWORD PTR [eax+24], ecx

; 85   : 	m_iEnemyStrength = 0;

	mov	DWORD PTR [eax+28], ecx

; 86   : 	m_iFriendlyRangedStrength = 0;

	mov	DWORD PTR [eax+32], ecx

; 87   : 	m_iEnemyRangedStrength = 0;

	mov	DWORD PTR [eax+36], ecx

; 88   : 	m_iFriendlyUnitCount = 0;

	mov	DWORD PTR [eax+40], ecx

; 89   : 	m_iEnemyUnitCount = 0;

	mov	DWORD PTR [eax+44], ecx

; 90   : 	m_iFriendlyRangedUnitCount = 0;

	mov	DWORD PTR [eax+48], ecx

; 91   : 	m_iEnemyRangedUnitCount = 0;

	mov	DWORD PTR [eax+52], ecx

; 92   : 	m_iEnemyNavalUnitCount = 0;

	mov	DWORD PTR [eax+56], ecx

; 93   : 	m_iZoneValue = 0;

	mov	DWORD PTR [eax+60], ecx

; 94   : 	m_iRangeClosestEnemyUnit = MAX_INT;

	mov	DWORD PTR [eax+64], 2147483647		; 7fffffffH

; 95   : 	m_bIsWater = false;

	mov	BYTE PTR [eax+68], cl

; 96   : 	m_bIsNavalInvasion = false;

	mov	BYTE PTR [eax+69], cl

; 97   : 	m_pTempZoneCenter = NULL;

	mov	DWORD PTR [eax+72], ecx

; 98   : }

	ret	0
??0CvTacticalDominanceZone@@QAE@XZ ENDP			; CvTacticalDominanceZone::CvTacticalDominanceZone
_TEXT	ENDS
PUBLIC	?GetRangeClosestEnemyUnit@CvTacticalDominanceZone@@QBEHXZ ; CvTacticalDominanceZone::GetRangeClosestEnemyUnit
; Function compile flags: /Ogtpy
;	COMDAT ?GetRangeClosestEnemyUnit@CvTacticalDominanceZone@@QBEHXZ
_TEXT	SEGMENT
?GetRangeClosestEnemyUnit@CvTacticalDominanceZone@@QBEHXZ PROC ; CvTacticalDominanceZone::GetRangeClosestEnemyUnit, COMDAT
; _this$ = ecx

; 127  : 	return m_iRangeClosestEnemyUnit;

	mov	eax, DWORD PTR [ecx+64]

; 128  : }

	ret	0
?GetRangeClosestEnemyUnit@CvTacticalDominanceZone@@QBEHXZ ENDP ; CvTacticalDominanceZone::GetRangeClosestEnemyUnit
_TEXT	ENDS
PUBLIC	?SetRangeClosestEnemyUnit@CvTacticalDominanceZone@@QAEXH@Z ; CvTacticalDominanceZone::SetRangeClosestEnemyUnit
; Function compile flags: /Ogtpy
;	COMDAT ?SetRangeClosestEnemyUnit@CvTacticalDominanceZone@@QAEXH@Z
_TEXT	SEGMENT
_iRange$ = 8						; size = 4
?SetRangeClosestEnemyUnit@CvTacticalDominanceZone@@QAEXH@Z PROC ; CvTacticalDominanceZone::SetRangeClosestEnemyUnit, COMDAT
; _this$ = ecx

; 133  : 	m_iRangeClosestEnemyUnit = iRange;

	mov	eax, DWORD PTR _iRange$[esp-4]
	mov	DWORD PTR [ecx+64], eax

; 134  : }

	ret	4
?SetRangeClosestEnemyUnit@CvTacticalDominanceZone@@QAEXH@Z ENDP ; CvTacticalDominanceZone::SetRangeClosestEnemyUnit
_TEXT	ENDS
PUBLIC	?GetZoneType@CvTacticalDominanceZone@@QBE?AW4TacticalMoveZoneType@@XZ ; CvTacticalDominanceZone::GetZoneType
; Function compile flags: /Ogtpy
;	COMDAT ?GetZoneType@CvTacticalDominanceZone@@QBE?AW4TacticalMoveZoneType@@XZ
_TEXT	SEGMENT
?GetZoneType@CvTacticalDominanceZone@@QBE?AW4TacticalMoveZoneType@@XZ PROC ; CvTacticalDominanceZone::GetZoneType, COMDAT
; _this$ = ecx

; 139  : 	if(m_eTerritoryType == TACTICAL_TERRITORY_FRIENDLY)

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, 2
	jne	SHORT $LN12@GetZoneTyp

; 140  : 	{
; 141  : 		if(m_eDominanceFlag == TACTICAL_DOMINANCE_FRIENDLY)

	mov	ecx, DWORD PTR [ecx+8]

; 142  : 		{
; 143  : 			return AI_TACTICAL_MOVE_ZONE_FRIENDLY_WINNING;

	xor	eax, eax
	cmp	ecx, 1
	je	SHORT $LN1@GetZoneTyp

; 144  : 		}
; 145  : 		else if(m_eDominanceFlag == TACTICAL_DOMINANCE_EVEN)

	cmp	ecx, 3
	setne	al
	inc	eax

; 174  : 	}
; 175  : }

	ret	0
$LN12@GetZoneTyp:

; 146  : 		{
; 147  : 			return AI_TACTICAL_MOVE_ZONE_FRIENDLY_EVEN;
; 148  : 		}
; 149  : 		else
; 150  : 		{
; 151  : 			return AI_TACTICAL_MOVE_ZONE_FRIENDLY_LOSING;
; 152  : 		}
; 153  : 	}
; 154  : 
; 155  : 	else if(m_eTerritoryType == TACTICAL_TERRITORY_ENEMY)

	cmp	eax, 3
	jne	SHORT $LN6@GetZoneTyp

; 156  : 	{
; 157  : 		if(m_eDominanceFlag == TACTICAL_DOMINANCE_FRIENDLY)

	mov	ecx, DWORD PTR [ecx+8]
	cmp	ecx, 1
	jne	SHORT $LN5@GetZoneTyp

; 174  : 	}
; 175  : }

	ret	0
$LN5@GetZoneTyp:

; 158  : 		{
; 159  : 			return AI_TACTICAL_MOVE_ZONE_ENEMY_WINNING;
; 160  : 		}
; 161  : 		else if(m_eDominanceFlag == TACTICAL_DOMINANCE_EVEN)

	xor	eax, eax
	cmp	ecx, 3
	setne	al
	add	eax, 4

; 174  : 	}
; 175  : }

	ret	0
$LN6@GetZoneTyp:

; 162  : 		{
; 163  : 			return AI_TACTICAL_MOVE_ZONE_ENEMY_EVEN;
; 164  : 		}
; 165  : 		else
; 166  : 		{
; 167  : 			return AI_TACTICAL_MOVE_ZONE_ENEMY_LOSING;
; 168  : 		}
; 169  : 	}
; 170  : 
; 171  : 	else
; 172  : 	{
; 173  : 		return AI_TACTICAL_MOVE_ZONE_UNOWNED;

	mov	eax, 6
$LN1@GetZoneTyp:

; 174  : 	}
; 175  : }

	ret	0
?GetZoneType@CvTacticalDominanceZone@@QBE?AW4TacticalMoveZoneType@@XZ ENDP ; CvTacticalDominanceZone::GetZoneType
_TEXT	ENDS
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtpy
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	push	edi
	mov	edi, DWORD PTR ___n$[esp]
	sub	edi, 1
	js	SHORT $LN1@vector
	push	ebx
	mov	ebx, DWORD PTR ___f$[esp+4]
	push	ebp
	mov	ebp, DWORD PTR ___s$[esp+8]
	push	esi
	mov	esi, DWORD PTR ___t$[esp+12]
	npad	7
$LL2@vector:
	mov	ecx, esi
	call	ebx
	add	esi, ebp
	sub	edi, 1
	jns	SHORT $LL2@vector
	pop	esi
	pop	ebp
	pop	ebx
$LN1@vector:
	pop	edi
	ret	16					; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	esi
	lea	eax, DWORD PTR __Message$[esp]
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[esp-4]

; 60   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??A?$BaseVector@VCvTacticalDominanceZone@@$00@@QAEAAVCvTacticalDominanceZone@@I@Z ; BaseVector<CvTacticalDominanceZone,1>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@VCvTacticalDominanceZone@@$00@@QAEAAVCvTacticalDominanceZone@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@VCvTacticalDominanceZone@@$00@@QAEAAVCvTacticalDominanceZone@@I@Z PROC ; BaseVector<CvTacticalDominanceZone,1>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR _ui$[esp-4]
	imul	eax, 76					; 0000004cH
	add	eax, DWORD PTR [ecx]

; 131  : 	};

	ret	4
??A?$BaseVector@VCvTacticalDominanceZone@@$00@@QAEAAVCvTacticalDominanceZone@@I@Z ENDP ; BaseVector<CvTacticalDominanceZone,1>::operator[]
_TEXT	ENDS
PUBLIC	?begin@?$BaseVector@VCvTacticalDominanceZone@@$00@@QAEPAVCvTacticalDominanceZone@@XZ ; BaseVector<CvTacticalDominanceZone,1>::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$BaseVector@VCvTacticalDominanceZone@@$00@@QAEPAVCvTacticalDominanceZone@@XZ
_TEXT	SEGMENT
?begin@?$BaseVector@VCvTacticalDominanceZone@@$00@@QAEPAVCvTacticalDominanceZone@@XZ PROC ; BaseVector<CvTacticalDominanceZone,1>::begin, COMDAT
; _this$ = ecx

; 194  :         return m_pData; 

	mov	eax, DWORD PTR [ecx]

; 195  :     };

	ret	0
?begin@?$BaseVector@VCvTacticalDominanceZone@@$00@@QAEPAVCvTacticalDominanceZone@@XZ ENDP ; BaseVector<CvTacticalDominanceZone,1>::begin
_TEXT	ENDS
PUBLIC	?end@?$BaseVector@VCvTacticalDominanceZone@@$00@@QAEPAVCvTacticalDominanceZone@@XZ ; BaseVector<CvTacticalDominanceZone,1>::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$BaseVector@VCvTacticalDominanceZone@@$00@@QAEPAVCvTacticalDominanceZone@@XZ
_TEXT	SEGMENT
?end@?$BaseVector@VCvTacticalDominanceZone@@$00@@QAEPAVCvTacticalDominanceZone@@XZ PROC ; BaseVector<CvTacticalDominanceZone,1>::end, COMDAT
; _this$ = ecx

; 197  :         return m_pData+m_uiCurrSize; 

	mov	eax, DWORD PTR [ecx+4]
	imul	eax, 76					; 0000004cH
	add	eax, DWORD PTR [ecx]

; 198  :     };

	ret	0
?end@?$BaseVector@VCvTacticalDominanceZone@@$00@@QAEPAVCvTacticalDominanceZone@@XZ ENDP ; BaseVector<CvTacticalDominanceZone,1>::end
_TEXT	ENDS
PUBLIC	??A?$BaseVector@PAVCvUnit@@$00@@QAEAAPAVCvUnit@@I@Z ; BaseVector<CvUnit *,1>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@PAVCvUnit@@$00@@QAEAAPAVCvUnit@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@PAVCvUnit@@$00@@QAEAAPAVCvUnit@@I@Z PROC ; BaseVector<CvUnit *,1>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 131  : 	};

	ret	4
??A?$BaseVector@PAVCvUnit@@$00@@QAEAAPAVCvUnit@@I@Z ENDP ; BaseVector<CvUnit *,1>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@PAVCvUnit@@$00@@QBEIXZ	; BaseVector<CvUnit *,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@PAVCvUnit@@$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@PAVCvUnit@@$00@@QBEIXZ PROC		; BaseVector<CvUnit *,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@PAVCvUnit@@$00@@QBEIXZ ENDP		; BaseVector<CvUnit *,1>::size
_TEXT	ENDS
PUBLIC	?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ; DestructionNotification<FObjectHandle<CvUnit> >::addTarget
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
;	COMDAT ?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z PROC ; DestructionNotification<FObjectHandle<CvUnit> >::addTarget, COMDAT
; _this$ = ecx

; 52   : #ifdef TRACK_DESTRUCTION_NOTIFICATION
; 53   : 		m_targets.insert(&target);
; 54   : #endif
; 55   : 	}

	ret	4
?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ENDP ; DestructionNotification<FObjectHandle<CvUnit> >::addTarget
_TEXT	ENDS
PUBLIC	?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget
; Function compile flags: /Ogtpy
;	COMDAT ?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z PROC ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget, COMDAT
; _this$ = ecx

; 63   : #ifdef TRACK_DESTRUCTION_NOTIFICATION
; 64   : 		m_targets.erase(&target);
; 65   : #endif
; 66   : 	}

	ret	4
?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ENDP ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget
_TEXT	ENDS
PUBLIC	??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@ ; `string'
PUBLIC	?Alloc@?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@IAEPAVCvTacticalDominanceZone@@I@Z ; FStaticVector<CvTacticalDominanceZone,110,1,297,0>::Alloc
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@ DB 'c:\users\eno'
	DB	'rmousapplepie\documents\github\lekmod\lekmod_dll\fireplace\in'
	DB	'clude\fireworks\FFastVector.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?Alloc@?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@IAEPAVCvTacticalDominanceZone@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@IAEPAVCvTacticalDominanceZone@@I@Z PROC ; FStaticVector<CvTacticalDominanceZone,110,1,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 110				; 0000006eH
	jbe	SHORT $LN2@Alloc

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	mov	eax, edi
	imul	eax, 76					; 0000004cH
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 110			; 0000006eH
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@IAEPAVCvTacticalDominanceZone@@I@Z ENDP ; FStaticVector<CvTacticalDominanceZone,110,1,297,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@VCvTacticalDominanceZone@@$00@@QAE@XZ ; BaseVector<CvTacticalDominanceZone,1>::~BaseVector<CvTacticalDominanceZone,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@VCvTacticalDominanceZone@@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@VCvTacticalDominanceZone@@$00@@QAE@XZ PROC ; BaseVector<CvTacticalDominanceZone,1>::~BaseVector<CvTacticalDominanceZone,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@VCvTacticalDominanceZone@@$00@@QAE@XZ ENDP ; BaseVector<CvTacticalDominanceZone,1>::~BaseVector<CvTacticalDominanceZone,1>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@VCvTacticalDominanceZone@@$00@@IAE@XZ ; BaseVector<CvTacticalDominanceZone,1>::BaseVector<CvTacticalDominanceZone,1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@VCvTacticalDominanceZone@@$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@VCvTacticalDominanceZone@@$00@@IAE@XZ PROC ; BaseVector<CvTacticalDominanceZone,1>::BaseVector<CvTacticalDominanceZone,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@VCvTacticalDominanceZone@@$00@@IAE@XZ ENDP ; BaseVector<CvTacticalDominanceZone,1>::BaseVector<CvTacticalDominanceZone,1>
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@VCvTacticalDominanceZone@@$00@@IAEXPAVCvTacticalDominanceZone@@I@Z ; BaseVector<CvTacticalDominanceZone,1>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@VCvTacticalDominanceZone@@$00@@IAEXPAVCvTacticalDominanceZone@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@VCvTacticalDominanceZone@@$00@@IAEXPAVCvTacticalDominanceZone@@I@Z PROC ; BaseVector<CvTacticalDominanceZone,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@VCvTacticalDominanceZone@@$00@@IAEXPAVCvTacticalDominanceZone@@I@Z ENDP ; BaseVector<CvTacticalDominanceZone,1>::Destroy
_TEXT	ENDS
PUBLIC	?Alloc@?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@IAEPAPAVCvUnit@@I@Z ; FStaticVector<CvUnit *,250,1,297,0>::Alloc
; Function compile flags: /Ogtpy
;	COMDAT ?Alloc@?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@IAEPAPAVCvUnit@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@IAEPAPAVCvUnit@@I@Z PROC ; FStaticVector<CvUnit *,250,1,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 250				; 000000faH
	jbe	SHORT $LN2@Alloc@2

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc@2:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 250			; 000000faH
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@IAEPAPAVCvUnit@@I@Z ENDP ; FStaticVector<CvUnit *,250,1,297,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@PAVCvUnit@@$00@@QAE@XZ		; BaseVector<CvUnit *,1>::~BaseVector<CvUnit *,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@PAVCvUnit@@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@PAVCvUnit@@$00@@QAE@XZ PROC		; BaseVector<CvUnit *,1>::~BaseVector<CvUnit *,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@PAVCvUnit@@$00@@QAE@XZ ENDP		; BaseVector<CvUnit *,1>::~BaseVector<CvUnit *,1>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@PAVCvUnit@@$00@@IAE@XZ		; BaseVector<CvUnit *,1>::BaseVector<CvUnit *,1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@PAVCvUnit@@$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@PAVCvUnit@@$00@@IAE@XZ PROC		; BaseVector<CvUnit *,1>::BaseVector<CvUnit *,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@PAVCvUnit@@$00@@IAE@XZ ENDP		; BaseVector<CvUnit *,1>::BaseVector<CvUnit *,1>
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@PAVCvUnit@@$00@@IAEXPAPAVCvUnit@@I@Z ; BaseVector<CvUnit *,1>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@PAVCvUnit@@$00@@IAEXPAPAVCvUnit@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@PAVCvUnit@@$00@@IAEXPAPAVCvUnit@@I@Z PROC ; BaseVector<CvUnit *,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@PAVCvUnit@@$00@@IAEXPAPAVCvUnit@@I@Z ENDP ; BaseVector<CvUnit *,1>::Destroy
_TEXT	ENDS
PUBLIC	??$max@H@std@@YAABHABH0@Z			; std::max<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$max@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@H@std@@YAABHABH0@Z PROC				; std::max<int>, COMDAT

; 3384 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN4@max
	mov	eax, ecx
$LN4@max:

; 3385 : 	}

	ret	0
??$max@H@std@@YAABHABH0@Z ENDP				; std::max<int>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@VCvTacticalAnalysisCell@@@@YAXAAPAVCvTacticalAnalysisCell@@@Z ; SAFE_DELETE_ARRAY<CvTacticalAnalysisCell>
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE_ARRAY@VCvTacticalAnalysisCell@@@@YAXAAPAVCvTacticalAnalysisCell@@@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@VCvTacticalAnalysisCell@@@@YAXAAPAVCvTacticalAnalysisCell@@@Z PROC ; SAFE_DELETE_ARRAY<CvTacticalAnalysisCell>, COMDAT

; 311  : {

	push	esi

; 312  : 	delete[] pkInstanceArray;

	mov	esi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@VCvTacticalAnalysisCell@@@@YAXAAPAVCvTacticalAnalysisCell@@@Z ENDP ; SAFE_DELETE_ARRAY<CvTacticalAnalysisCell>
_TEXT	ENDS
PUBLIC	??$_Dist_type@PAVCvTacticalDominanceZone@@@std@@YAPAHPAVCvTacticalDominanceZone@@@Z ; std::_Dist_type<CvTacticalDominanceZone *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Dist_type@PAVCvTacticalDominanceZone@@@std@@YAPAHPAVCvTacticalDominanceZone@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@PAVCvTacticalDominanceZone@@@std@@YAPAHPAVCvTacticalDominanceZone@@@Z PROC ; std::_Dist_type<CvTacticalDominanceZone *>, COMDAT

; 1831 : 	return (0);

	xor	eax, eax

; 1832 : 	}

	ret	0
??$_Dist_type@PAVCvTacticalDominanceZone@@@std@@YAPAHPAVCvTacticalDominanceZone@@@Z ENDP ; std::_Dist_type<CvTacticalDominanceZone *>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAVCvTacticalDominanceZone@@@std@@YAPAVCvTacticalDominanceZone@@PAV1@@Z ; std::_Val_type<CvTacticalDominanceZone *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Val_type@PAVCvTacticalDominanceZone@@@std@@YAPAVCvTacticalDominanceZone@@PAV1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAVCvTacticalDominanceZone@@@std@@YAPAVCvTacticalDominanceZone@@PAV1@@Z PROC ; std::_Val_type<CvTacticalDominanceZone *>, COMDAT

; 1766 : 	return (0);

	xor	eax, eax

; 1767 : 	}

	ret	0
??$_Val_type@PAVCvTacticalDominanceZone@@@std@@YAPAVCvTacticalDominanceZone@@PAV1@@Z ENDP ; std::_Val_type<CvTacticalDominanceZone *>
_TEXT	ENDS
PUBLIC	??0?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAE@H@Z ; std::_Temp_iterator<CvTacticalDominanceZone>::_Temp_iterator<CvTacticalDominanceZone>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??0?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAE@H@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
??0?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAE@H@Z PROC ; std::_Temp_iterator<CvTacticalDominanceZone>::_Temp_iterator<CvTacticalDominanceZone>, COMDAT
; _this$ = ecx

; 526  : 	_Temp_iterator(_PDFT _Count = 0)

	mov	eax, ecx

; 527  : 		{	// construct from desired temporary buffer size
; 528  : 		_Buf._Begin = 0;

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 529  : 		_Buf._Current = 0;

	mov	DWORD PTR [eax+4], ecx

; 530  : 		_Buf._Hiwater = 0;

	mov	DWORD PTR [eax+8], ecx

; 531  : 		_Buf._Size = _Count;	// memorize size for lazy allocation

	mov	ecx, DWORD PTR __Count$[esp-4]
	mov	DWORD PTR [eax+12], ecx

; 532  : 		_Pbuf = &_Buf;

	mov	DWORD PTR [eax+16], eax

; 533  : 		}

	ret	4
??0?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAE@H@Z ENDP ; std::_Temp_iterator<CvTacticalDominanceZone>::_Temp_iterator<CvTacticalDominanceZone>
_TEXT	ENDS
PUBLIC	_sqrtf
EXTRN	_sqrt:PROC
EXTRN	__fltused:DWORD
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\math.h
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv71 = 8						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC						; COMDAT

; 423  :         {return ((float)sqrt((double)_X)); }

	fld	DWORD PTR __X$[esp-4]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	fstp	DWORD PTR tv71[esp+4]
	add	esp, 8
	fld	DWORD PTR tv71[esp-4]
	ret	0
_sqrtf	ENDP
_TEXT	ENDS
PUBLIC	??$_Destroy@VCvTacticalDominanceZone@@@std@@YAXPAVCvTacticalDominanceZone@@@Z ; std::_Destroy<CvTacticalDominanceZone>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy@VCvTacticalDominanceZone@@@std@@YAXPAVCvTacticalDominanceZone@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@VCvTacticalDominanceZone@@@std@@YAXPAVCvTacticalDominanceZone@@@Z PROC ; std::_Destroy<CvTacticalDominanceZone>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@VCvTacticalDominanceZone@@@std@@YAXPAVCvTacticalDominanceZone@@@Z ENDP ; std::_Destroy<CvTacticalDominanceZone>
_TEXT	ENDS
PUBLIC	??$return_temporary_buffer@VCvTacticalDominanceZone@@@std@@YAXPAVCvTacticalDominanceZone@@@Z ; std::return_temporary_buffer<CvTacticalDominanceZone>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$return_temporary_buffer@VCvTacticalDominanceZone@@@std@@YAXPAVCvTacticalDominanceZone@@@Z
_TEXT	SEGMENT
__Pbuf$ = 8						; size = 4
??$return_temporary_buffer@VCvTacticalDominanceZone@@@std@@YAXPAVCvTacticalDominanceZone@@@Z PROC ; std::return_temporary_buffer<CvTacticalDominanceZone>, COMDAT

; 39   : 	operator delete(_Pbuf);

	jmp	??3@YAXPAX@Z				; operator delete
??$return_temporary_buffer@VCvTacticalDominanceZone@@@std@@YAXPAVCvTacticalDominanceZone@@@Z ENDP ; std::return_temporary_buffer<CvTacticalDominanceZone>
_TEXT	ENDS
PUBLIC	??$_Iter_cat@PAVCvTacticalDominanceZone@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalDominanceZone@@@Z ; std::_Iter_cat<CvTacticalDominanceZone *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_cat@PAVCvTacticalDominanceZone@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalDominanceZone@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAVCvTacticalDominanceZone@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalDominanceZone@@@Z PROC ; std::_Iter_cat<CvTacticalDominanceZone *>, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@PAVCvTacticalDominanceZone@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalDominanceZone@@@Z ENDP ; std::_Iter_cat<CvTacticalDominanceZone *>
_TEXT	ENDS
PUBLIC	??$_Distance2@PAVCvTacticalDominanceZone@@H@std@@YAXPAVCvTacticalDominanceZone@@0AAHUrandom_access_iterator_tag@0@@Z ; std::_Distance2<CvTacticalDominanceZone *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Distance2@PAVCvTacticalDominanceZone@@H@std@@YAXPAVCvTacticalDominanceZone@@0AAHUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Distance2@PAVCvTacticalDominanceZone@@H@std@@YAXPAVCvTacticalDominanceZone@@0AAHUrandom_access_iterator_tag@0@@Z PROC ; std::_Distance2<CvTacticalDominanceZone *,int>, COMDAT

; 1867 : 
; 1868 :  #if _HAS_ITERATOR_DEBUGGING
; 1869 : 	if (_First != _Last)
; 1870 : 		{	// check for null pointers
; 1871 : 		_DEBUG_POINTER(_First);
; 1872 : 		_DEBUG_POINTER(_Last);
; 1873 : 		}
; 1874 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1875 : 
; 1876 : 	_Off += _Last - _First;

	mov	ecx, DWORD PTR __Last$[esp-4]
	sub	ecx, DWORD PTR __First$[esp-4]
	mov	eax, 1808407283				; 6bca1af3H
	imul	ecx
	mov	eax, DWORD PTR __Off$[esp-4]
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	DWORD PTR [eax], ecx

; 1877 : 	}

	ret	0
??$_Distance2@PAVCvTacticalDominanceZone@@H@std@@YAXPAVCvTacticalDominanceZone@@0AAHUrandom_access_iterator_tag@0@@Z ENDP ; std::_Distance2<CvTacticalDominanceZone *,int>
_TEXT	ENDS
PUBLIC	?sqrt@@YAMM@Z					; sqrt
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\math.h
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
tv73 = 8						; size = 4
$T224702 = 8						; size = 4
__X$ = 8						; size = 4
?sqrt@@YAMM@Z PROC					; sqrt, COMDAT

; 534  :         {return (sqrtf(_X)); }

	fld	DWORD PTR __X$[esp-4]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	fstp	DWORD PTR tv73[esp+4]
	add	esp, 8
	fld	DWORD PTR tv73[esp-4]
	fstp	DWORD PTR $T224702[esp-4]
	fld	DWORD PTR $T224702[esp-4]
	ret	0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
PUBLIC	?_Init@?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAEAAV12@XZ ; std::_Temp_iterator<CvTacticalDominanceZone>::_Init
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ?_Init@?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT
?_Init@?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAEAAV12@XZ PROC ; std::_Temp_iterator<CvTacticalDominanceZone>::_Init, COMDAT
; _this$ = ecx

; 591  : 		{	// set pointer at beginning of buffer

	mov	eax, ecx

; 592  : 		_Pbuf->_Current = _Pbuf->_Begin;

	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], edx

; 593  : 		return (*this);
; 594  : 		}

	ret	0
?_Init@?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAEAAV12@XZ ENDP ; std::_Temp_iterator<CvTacticalDominanceZone>::_Init
_TEXT	ENDS
PUBLIC	?_First@?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QBEPAVCvTacticalDominanceZone@@XZ ; std::_Temp_iterator<CvTacticalDominanceZone>::_First
; Function compile flags: /Ogtpy
;	COMDAT ?_First@?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QBEPAVCvTacticalDominanceZone@@XZ
_TEXT	SEGMENT
?_First@?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QBEPAVCvTacticalDominanceZone@@XZ PROC ; std::_Temp_iterator<CvTacticalDominanceZone>::_First, COMDAT
; _this$ = ecx

; 598  : 		return (_Pbuf->_Begin);

	mov	eax, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax]

; 599  : 		}

	ret	0
?_First@?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QBEPAVCvTacticalDominanceZone@@XZ ENDP ; std::_Temp_iterator<CvTacticalDominanceZone>::_First
_TEXT	ENDS
PUBLIC	?_Last@?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QBEPAVCvTacticalDominanceZone@@XZ ; std::_Temp_iterator<CvTacticalDominanceZone>::_Last
; Function compile flags: /Ogtpy
;	COMDAT ?_Last@?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QBEPAVCvTacticalDominanceZone@@XZ
_TEXT	SEGMENT
?_Last@?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QBEPAVCvTacticalDominanceZone@@XZ PROC ; std::_Temp_iterator<CvTacticalDominanceZone>::_Last, COMDAT
; _this$ = ecx

; 603  : 		return (_Pbuf->_Current);

	mov	eax, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax+4]

; 604  : 		}

	ret	0
?_Last@?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QBEPAVCvTacticalDominanceZone@@XZ ENDP ; std::_Temp_iterator<CvTacticalDominanceZone>::_Last
_TEXT	ENDS
PUBLIC	??0?$pair@PAVCvTacticalDominanceZone@@H@std@@QAE@ABQAVCvTacticalDominanceZone@@ABH@Z ; std::pair<CvTacticalDominanceZone *,int>::pair<CvTacticalDominanceZone *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@PAVCvTacticalDominanceZone@@H@std@@QAE@ABQAVCvTacticalDominanceZone@@ABH@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@PAVCvTacticalDominanceZone@@H@std@@QAE@ABQAVCvTacticalDominanceZone@@ABH@Z PROC ; std::pair<CvTacticalDominanceZone *,int>::pair<CvTacticalDominanceZone *,int>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@PAVCvTacticalDominanceZone@@H@std@@QAE@ABQAVCvTacticalDominanceZone@@ABH@Z ENDP ; std::pair<CvTacticalDominanceZone *,int>::pair<CvTacticalDominanceZone *,int>
_TEXT	ENDS
PUBLIC	??4?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAEAAV01@ABV01@@Z ; std::_Temp_iterator<CvTacticalDominanceZone>::operator=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??4?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Temp_iterator<CvTacticalDominanceZone>::operator=, COMDAT
; _this$ = ecx

; 556  : 		{	// assign _Right (share active buffer)

	mov	eax, ecx

; 557  : 		_Pbuf = _Right._Pbuf;

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 558  : 		return (*this);
; 559  : 		}

	ret	4
??4?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Temp_iterator<CvTacticalDominanceZone>::operator=
_TEXT	ENDS
PUBLIC	??$_Advance@PAVCvTacticalDominanceZone@@H@std@@YAXAAPAVCvTacticalDominanceZone@@HUrandom_access_iterator_tag@0@@Z ; std::_Advance<CvTacticalDominanceZone *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Advance@PAVCvTacticalDominanceZone@@H@std@@YAXAAPAVCvTacticalDominanceZone@@HUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Advance@PAVCvTacticalDominanceZone@@H@std@@YAXAAPAVCvTacticalDominanceZone@@HUrandom_access_iterator_tag@0@@Z PROC ; std::_Advance<CvTacticalDominanceZone *,int>, COMDAT

; 1822 : 	_Where += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	mov	eax, DWORD PTR __Where$[esp-4]
	imul	ecx, 76					; 0000004cH
	add	DWORD PTR [eax], ecx

; 1823 : 	}

	ret	0
??$_Advance@PAVCvTacticalDominanceZone@@H@std@@YAXAAPAVCvTacticalDominanceZone@@HUrandom_access_iterator_tag@0@@Z ENDP ; std::_Advance<CvTacticalDominanceZone *,int>
_TEXT	ENDS
PUBLIC	??$swap@VCvTacticalDominanceZone@@@std@@YAXAAVCvTacticalDominanceZone@@0@Z ; std::swap<CvTacticalDominanceZone>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$swap@VCvTacticalDominanceZone@@@std@@YAXAAVCvTacticalDominanceZone@@0@Z
_TEXT	SEGMENT
__Tmp$223918 = -76					; size = 76
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@VCvTacticalDominanceZone@@@std@@YAXAAVCvTacticalDominanceZone@@0@Z PROC ; std::swap<CvTacticalDominanceZone>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	edx, DWORD PTR __Right$[esp-4]
	sub	esp, 76					; 0000004cH
	cmp	eax, edx
	je	SHORT $LN1@swap
	push	esi
	push	edi

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	ecx, 19					; 00000013H
	mov	esi, eax
	lea	edi, DWORD PTR __Tmp$223918[esp+84]
	rep movsd

; 21   : 
; 22   : 		_Left = _Right;

	mov	ecx, 19					; 00000013H
	mov	esi, edx
	mov	edi, eax
	rep movsd

; 23   : 		_Right = _Tmp;

	mov	ecx, 19					; 00000013H
	lea	esi, DWORD PTR __Tmp$223918[esp+84]
	mov	edi, edx
	rep movsd
	pop	edi
	pop	esi
$LN1@swap:

; 24   : 		}
; 25   : 	}

	add	esp, 76					; 0000004cH
	ret	0
??$swap@VCvTacticalDominanceZone@@@std@@YAXAAVCvTacticalDominanceZone@@0@Z ENDP ; std::swap<CvTacticalDominanceZone>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvTacticalDominanceZone@@ABV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z ; std::_Iter_random<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvTacticalDominanceZone@@ABV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvTacticalDominanceZone@@ABV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z PROC ; std::_Iter_random<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone> >, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvTacticalDominanceZone@@ABV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z ENDP ; std::_Iter_random<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvTacticalDominanceZone@@AAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z ; std::_Ptr_cat<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvTacticalDominanceZone@@AAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvTacticalDominanceZone@@AAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z PROC ; std::_Ptr_cat<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone> >, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvTacticalDominanceZone@@AAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z ENDP ; std::_Ptr_cat<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone> >
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvTacticalDominanceZone@@PAV1@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalDominanceZone@@00@Z ; std::_Iter_random<CvTacticalDominanceZone *,CvTacticalDominanceZone *,CvTacticalDominanceZone *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAVCvTacticalDominanceZone@@PAV1@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalDominanceZone@@00@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Iter_random@PAVCvTacticalDominanceZone@@PAV1@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalDominanceZone@@00@Z PROC ; std::_Iter_random<CvTacticalDominanceZone *,CvTacticalDominanceZone *,CvTacticalDominanceZone *>, COMDAT

; 1007 : 	typename _Iter_random_helper3<
; 1008 : 		iterator_traits<_Iter1>::iterator_category, 
; 1009 : 		iterator_traits<_Iter2>::iterator_category,
; 1010 : 		iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat _Cat;
; 1011 : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1012 : 	}

	ret	0
??$_Iter_random@PAVCvTacticalDominanceZone@@PAV1@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalDominanceZone@@00@Z ENDP ; std::_Iter_random<CvTacticalDominanceZone *,CvTacticalDominanceZone *,CvTacticalDominanceZone *>
_TEXT	ENDS
PUBLIC	??D?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAEAAV01@XZ ; std::_Temp_iterator<CvTacticalDominanceZone>::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??D?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??D?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAEAAV01@XZ PROC ; std::_Temp_iterator<CvTacticalDominanceZone>::operator*, COMDAT
; _this$ = ecx

; 576  : 		{	// pretend to return designated value

	mov	eax, ecx

; 577  : 		return (*this);
; 578  : 		}

	ret	0
??D?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAEAAV01@XZ ENDP ; std::_Temp_iterator<CvTacticalDominanceZone>::operator*
_TEXT	ENDS
PUBLIC	??E?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAEAAV01@XZ ; std::_Temp_iterator<CvTacticalDominanceZone>::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAEAAV01@XZ PROC ; std::_Temp_iterator<CvTacticalDominanceZone>::operator++, COMDAT
; _this$ = ecx

; 581  : 		{	// pretend to preincrement

	mov	eax, ecx

; 582  : 		return (*this);
; 583  : 		}

	ret	0
??E?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAEAAV01@XZ ENDP ; std::_Temp_iterator<CvTacticalDominanceZone>::operator++
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvTacticalDominanceZone@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalDominanceZone@@0@Z ; std::_Iter_random<CvTacticalDominanceZone *,CvTacticalDominanceZone *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAVCvTacticalDominanceZone@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalDominanceZone@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAVCvTacticalDominanceZone@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalDominanceZone@@0@Z PROC ; std::_Iter_random<CvTacticalDominanceZone *,CvTacticalDominanceZone *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAVCvTacticalDominanceZone@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvTacticalDominanceZone@@0@Z ENDP ; std::_Iter_random<CvTacticalDominanceZone *,CvTacticalDominanceZone *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAVCvTacticalDominanceZone@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvTacticalDominanceZone@@0@Z ; std::_Ptr_cat<CvTacticalDominanceZone *,CvTacticalDominanceZone *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAVCvTacticalDominanceZone@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvTacticalDominanceZone@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCvTacticalDominanceZone@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvTacticalDominanceZone@@0@Z PROC ; std::_Ptr_cat<CvTacticalDominanceZone *,CvTacticalDominanceZone *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAVCvTacticalDominanceZone@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvTacticalDominanceZone@@0@Z ENDP ; std::_Ptr_cat<CvTacticalDominanceZone *,CvTacticalDominanceZone *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAVCvTacticalDominanceZone@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalDominanceZone@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvTacticalDominanceZone *,CvTacticalDominanceZone *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAVCvTacticalDominanceZone@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalDominanceZone@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAVCvTacticalDominanceZone@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalDominanceZone@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvTacticalDominanceZone *,CvTacticalDominanceZone *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR __First$[esp]
	cmp	ebx, edx
	je	SHORT $LN1@Copy_backw
	push	esi
	push	edi
$LL2@Copy_backw:

; 2676 : 		*--_Dest = *--_Last;

	sub	edx, 76					; 0000004cH
	sub	eax, 76					; 0000004cH
	mov	ecx, 19					; 00000013H
	mov	esi, edx
	mov	edi, eax
	rep movsd
	cmp	edx, ebx
	jne	SHORT $LL2@Copy_backw
	pop	edi
	pop	esi
$LN1@Copy_backw:
	pop	ebx

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAVCvTacticalDominanceZone@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalDominanceZone@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvTacticalDominanceZone *,CvTacticalDominanceZone *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAVCvTacticalDominanceZone@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalDominanceZone@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTacticalDominanceZone *,CvTacticalDominanceZone *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAVCvTacticalDominanceZone@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalDominanceZone@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAVCvTacticalDominanceZone@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalDominanceZone@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvTacticalDominanceZone *,CvTacticalDominanceZone *,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR __Last$[esp]
	cmp	edx, ebx
	je	SHORT $LN1@Copy_opt
	push	esi
	push	edi
$LL3@Copy_opt:

; 2472 : 		*_Dest = *_First;

	mov	esi, edx
	mov	edi, eax
	add	edx, 76					; 0000004cH
	mov	ecx, 19					; 00000013H
	add	eax, 76					; 0000004cH
	rep movsd
	cmp	edx, ebx
	jne	SHORT $LL3@Copy_opt
	pop	edi
	pop	esi
$LN1@Copy_opt:
	pop	ebx

; 2473 : 	return (_Dest);
; 2474 : 	}

	ret	0
??$_Copy_opt@PAVCvTacticalDominanceZone@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalDominanceZone@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvTacticalDominanceZone *,CvTacticalDominanceZone *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Construct@VCvTacticalDominanceZone@@V1@@std@@YAXPAVCvTacticalDominanceZone@@ABV1@@Z ; std::_Construct<CvTacticalDominanceZone,CvTacticalDominanceZone>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Construct@VCvTacticalDominanceZone@@V1@@std@@YAXPAVCvTacticalDominanceZone@@ABV1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@VCvTacticalDominanceZone@@V1@@std@@YAXPAVCvTacticalDominanceZone@@ABV1@@Z PROC ; std::_Construct<CvTacticalDominanceZone,CvTacticalDominanceZone>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	edi

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	edi, DWORD PTR __Ptr$[esp]
	test	edi, edi
	je	SHORT $LN3@Construct
	push	esi
	mov	esi, DWORD PTR __Val$[esp+4]
	mov	ecx, 19					; 00000013H
	rep movsd
	pop	esi
$LN3@Construct:
	pop	edi

; 53   : 	}

	ret	0
??$_Construct@VCvTacticalDominanceZone@@V1@@std@@YAXPAVCvTacticalDominanceZone@@ABV1@@Z ENDP ; std::_Construct<CvTacticalDominanceZone,CvTacticalDominanceZone>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvTacticalDominanceZone@@PAV1@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvTacticalDominanceZone@@0ABV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z ; std::_Iter_random<CvTacticalDominanceZone *,CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAVCvTacticalDominanceZone@@PAV1@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvTacticalDominanceZone@@0ABV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Iter_random@PAVCvTacticalDominanceZone@@PAV1@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvTacticalDominanceZone@@0ABV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z PROC ; std::_Iter_random<CvTacticalDominanceZone *,CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone> >, COMDAT

; 1007 : 	typename _Iter_random_helper3<
; 1008 : 		iterator_traits<_Iter1>::iterator_category, 
; 1009 : 		iterator_traits<_Iter2>::iterator_category,
; 1010 : 		iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat _Cat;
; 1011 : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1012 : 	}

	ret	0
??$_Iter_random@PAVCvTacticalDominanceZone@@PAV1@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvTacticalDominanceZone@@0ABV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z ENDP ; std::_Iter_random<CvTacticalDominanceZone *,CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone> >
_TEXT	ENDS
PUBLIC	??$_Rotate@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@00PAH0@Z ; std::_Rotate<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Rotate@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@00PAH0@Z
_TEXT	SEGMENT
tv257 = -88						; size = 4
tv172 = -84						; size = 4
__Next$224154 = -80					; size = 4
__Holeval$224155 = -76					; size = 76
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Rotate@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@00PAH0@Z PROC ; std::_Rotate<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>, COMDAT

; 1679 : 	{	// rotate [_First, _Last), random-access iterators

	sub	esp, 88					; 00000058H

; 1680 : 	_DEBUG_RANGE(_First, _Mid);
; 1681 : 	_DEBUG_RANGE(_Mid, _Last);
; 1682 : 	_Diff _Shift = _Mid - _First;

	mov	ecx, DWORD PTR __Mid$[esp+84]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+96]
	sub	ecx, edi
	mov	eax, 1808407283				; 6bca1af3H
	imul	ecx

; 1683 : 	_Diff _Count = _Last - _First;

	mov	ecx, DWORD PTR __Last$[esp+96]
	sar	edx, 5
	mov	ebp, edx
	sub	ecx, edi
	shr	ebp, 31					; 0000001fH
	add	ebp, edx
	mov	eax, 1808407283				; 6bca1af3H
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	eax, ecx
	mov	DWORD PTR __Count$[esp+96], eax

; 1684 : 
; 1685 : 	for (_Diff _Factor = _Shift; _Factor != 0; )

	mov	esi, ebp
	test	ebp, ebp
	je	SHORT $LN7@Rotate
$LL21@Rotate:

; 1686 : 		{	// find subcycle count as GCD of shift count and length
; 1687 : 		_Diff _Tmp = _Count % _Factor;

	cdq
	idiv	esi

; 1688 : 		_Count = _Factor, _Factor = _Tmp;

	mov	DWORD PTR __Count$[esp+96], esi
	mov	eax, DWORD PTR __Count$[esp+96]
	mov	esi, edx
	test	edx, edx
	jne	SHORT $LL21@Rotate
$LN7@Rotate:

; 1689 : 		}
; 1690 : 
; 1691 : 	if (_Count < _Last - _First)

	cmp	eax, ecx
	jge	$LN3@Rotate

; 1692 : 		for (; 0 < _Count; --_Count)

	test	eax, eax
	jle	$LN3@Rotate
	push	ebx
	mov	edx, eax
	mov	ebx, ebp
	imul	edx, 76					; 0000004cH
	imul	ebx, 76					; 0000004cH
	add	edx, edi
	mov	DWORD PTR tv172[esp+104], ebx
	mov	DWORD PTR tv257[esp+104], edx
	jmp	SHORT $LN5@Rotate
	npad	4
$LL22@Rotate:
	mov	ebx, DWORD PTR tv172[esp+104]
$LN5@Rotate:

; 1693 : 			{	// rotate each subcycle
; 1694 : 			_RanIt _Hole = _First + _Count;
; 1695 : 			_RanIt _Next = _Hole;
; 1696 : 			_Ty _Holeval = *_Hole;

	mov	ecx, 19					; 00000013H
	mov	esi, edx
	lea	edi, DWORD PTR __Holeval$224155[esp+104]
	rep movsd

; 1697 : 			_RanIt _Next1 = _Next + _Shift == _Last ? _First : _Next + _Shift;

	lea	ecx, DWORD PTR [edx+ebx]
	mov	ebx, DWORD PTR __First$[esp+100]
	mov	eax, edx
	cmp	ecx, DWORD PTR __Last$[esp+100]
	je	SHORT $LN12@Rotate
	mov	ebx, ecx
$LN12@Rotate:

; 1698 : 			while (_Next1 != _Hole)

	cmp	ebx, edx
	je	SHORT $LN1@Rotate
$LL2@Rotate:

; 1699 : 				{	// percolate elements back around subcycle
; 1700 : 				*_Next = *_Next1;

	mov	edi, eax
	mov	ecx, 19					; 00000013H
	mov	esi, ebx
	rep movsd

; 1701 : 				_Next = _Next1;
; 1702 : 				_Next1 = _Shift < _Last - _Next1 ? _Next1 + _Shift
; 1703 : 					: _First + (_Shift - (_Last - _Next1));

	mov	ecx, DWORD PTR __Last$[esp+100]
	sub	ecx, ebx
	mov	eax, 1808407283				; 6bca1af3H
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	ebp, eax
	mov	DWORD PTR __Next$224154[esp+104], ebx
	jge	SHORT $LN13@Rotate
	add	ebx, DWORD PTR tv172[esp+104]
	jmp	SHORT $LN14@Rotate
$LN13@Rotate:
	mov	ebx, ebp
	sub	ebx, eax
	imul	ebx, 76					; 0000004cH
	add	ebx, DWORD PTR __First$[esp+100]
$LN14@Rotate:
	mov	eax, DWORD PTR __Next$224154[esp+104]
	cmp	ebx, DWORD PTR tv257[esp+104]
	jne	SHORT $LL2@Rotate

; 1698 : 			while (_Next1 != _Hole)

	mov	edx, DWORD PTR tv257[esp+104]
$LN1@Rotate:

; 1704 : 				}
; 1705 : 			*_Next = _Holeval;

	mov	edi, eax
	mov	eax, DWORD PTR __Count$[esp+100]
	dec	eax
	sub	edx, 76					; 0000004cH
	mov	ecx, 19					; 00000013H
	lea	esi, DWORD PTR __Holeval$224155[esp+104]
	rep movsd
	mov	DWORD PTR __Count$[esp+100], eax
	mov	DWORD PTR tv257[esp+104], edx
	test	eax, eax
	jg	$LL22@Rotate
	pop	ebx
$LN3@Rotate:
	pop	edi
	pop	esi
	pop	ebp

; 1706 : 			}
; 1707 : 	}

	add	esp, 88					; 00000058H
	ret	0
??$_Rotate@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@00PAH0@Z ENDP ; std::_Rotate<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@XZ				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??0CvString@@QAE@XZ
_TEXT	SEGMENT
??0CvString@@QAE@XZ PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 23   : 	CvString() {}

	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, esi
	pop	esi
	ret	0
??0CvString@@QAE@XZ ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvString::operator=
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CvString::operator=, COMDAT
; _this$ = ecx

; 38   : 	CvString& operator=( const std::string& s) { assign(s.c_str());	return *this; }	

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _s$[esp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CvString::operator=
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	__imp___vsnprintf:PROC
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
_buf$ = -2048						; size = 2048
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	sub	esp, 2048				; 00000800H
	push	ebx
	push	ebp

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	mov	ebp, DWORD PTR _args$[esp+2052]
	push	esi
	push	edi
	lea	edi, DWORD PTR _buf$[esp+2064]
	mov	esi, 2047				; 000007ffH
	npad	6
$LL10@formatv:

; 194  : 	int len = 0;
; 195  : 	int attempts = 0;
; 196  : 	bool success = false;
; 197  : 	const int kMaxAttempts = 40;
; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;
; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	eax, DWORD PTR _fmt$[esp+2060]
	push	ebp
	push	eax
	push	esi
	push	edi
	mov	ebx, esi
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H

; 203  : 		attempts++;

	add	esi, 2048				; 00000800H

; 204  : 		success = (len>=0 && len<=maxlen);

	test	eax, eax
	jl	SHORT $LN13@formatv
	cmp	eax, ebx
	jle	SHORT $LN18@formatv
$LN13@formatv:

; 205  : 		if (!success)
; 206  : 		{
; 207  : 			if (pbuf!=buf)

	lea	ecx, DWORD PTR _buf$[esp+2064]
	xor	bl, bl
	cmp	edi, ecx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	lea	edx, DWORD PTR [esi+1]
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	cmp	esi, 83967				; 000147ffH
	mov	edi, eax
	jl	SHORT $LL10@formatv

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN21@formatv:
	mov	ecx, DWORD PTR _out$[esp+2064]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 223  : 
; 224  : 	if (pbuf!=buf)

	lea	eax, DWORD PTR _buf$[esp+2064]
	cmp	edi, eax
	je	SHORT $LN20@formatv

; 225  : 		delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN20@formatv:
	pop	edi
	pop	esi
	pop	ebp

; 226  : 
; 227  : 	return success;

	mov	al, bl
	pop	ebx

; 228  : }

	add	esp, 2048				; 00000800H
	ret	0
$LN18@formatv:

; 204  : 		success = (len>=0 && len<=maxlen);

	mov	bl, 1

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)
; 220  : 		out = pbuf;

	push	edi

; 221  : 	else

	jmp	SHORT $LN21@formatv
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
PUBLIC	?Format@CvString@@QAAXPBDZZ			; CvString::Format
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Format@CvString@@QAAXPBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0
__ehfuncinfo$?Format@CvString@@QAAXPBDZZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Format@CvString@@QAAXPBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?Format@CvString@@QAAXPBDZZ
_TEXT	SEGMENT
_result$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Format@CvString@@QAAXPBDZZ PROC			; CvString::Format, COMDAT

; 269  : {

	push	-1
	push	__ehhandler$?Format@CvString@@QAAXPBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH

; 270  : 	std::string result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 271  : 	va_list args;
; 272  : 	va_start(args,lpszFormat);
; 273  : 	formatv(result,lpszFormat,args);

	mov	ecx, DWORD PTR _lpszFormat$[esp+36]
	lea	eax, DWORD PTR _lpszFormat$[esp+40]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _result$[esp+48]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+60], 0
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 274  : 	va_end(args);
; 275  : 	*this = result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR _this$[esp+36]
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 276  : }

	lea	ecx, DWORD PTR _result$[esp+40]
	mov	DWORD PTR __$EHRec$[esp+48], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Format@CvString@@QAAXPBDZZ:
	mov	eax, OFFSET __ehfuncinfo$?Format@CvString@@QAAXPBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Format@CvString@@QAAXPBDZZ ENDP			; CvString::Format
PUBLIC	?getMap@CvGlobals@@QAEAAVCvMap@@XZ		; CvGlobals::getMap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMap@CvGlobals@@QAEAAVCvMap@@XZ
_TEXT	SEGMENT
?getMap@CvGlobals@@QAEAAVCvMap@@XZ PROC			; CvGlobals::getMap, COMDAT
; _this$ = ecx

; 175  : 		return *m_map;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+52]

; 176  : 	}

	ret	0
?getMap@CvGlobals@@QAEAAVCvMap@@XZ ENDP			; CvGlobals::getMap
_TEXT	ENDS
PUBLIC	?getGame@CvGlobals@@QAEAAVCvGame@@XZ		; CvGlobals::getGame
; Function compile flags: /Ogtpy
;	COMDAT ?getGame@CvGlobals@@QAEAAVCvGame@@XZ
_TEXT	SEGMENT
?getGame@CvGlobals@@QAEAAVCvGame@@XZ PROC		; CvGlobals::getGame, COMDAT
; _this$ = ecx

; 183  : 		return *m_game;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+48]

; 184  : 	}

	ret	0
?getGame@CvGlobals@@QAEAAVCvGame@@XZ ENDP		; CvGlobals::getGame
_TEXT	ENDS
PUBLIC	?getPlotDirectionX@CvGlobals@@QAEPAHXZ		; CvGlobals::getPlotDirectionX
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotDirectionX@CvGlobals@@QAEPAHXZ
_TEXT	SEGMENT
?getPlotDirectionX@CvGlobals@@QAEPAHXZ PROC		; CvGlobals::getPlotDirectionX, COMDAT
; _this$ = ecx

; 191  : 		return m_aiPlotDirectionX;

	lea	eax, DWORD PTR [ecx+112]

; 192  : 	}

	ret	0
?getPlotDirectionX@CvGlobals@@QAEPAHXZ ENDP		; CvGlobals::getPlotDirectionX
_TEXT	ENDS
PUBLIC	?getPlotDirectionY@CvGlobals@@QAEPAHXZ		; CvGlobals::getPlotDirectionY
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotDirectionY@CvGlobals@@QAEPAHXZ
_TEXT	SEGMENT
?getPlotDirectionY@CvGlobals@@QAEPAHXZ PROC		; CvGlobals::getPlotDirectionY, COMDAT
; _this$ = ecx

; 195  : 		return m_aiPlotDirectionY;

	lea	eax, DWORD PTR [ecx+136]

; 196  : 	}

	ret	0
?getPlotDirectionY@CvGlobals@@QAEPAHXZ ENDP		; CvGlobals::getPlotDirectionY
_TEXT	ENDS
PUBLIC	?getAI_TACTICAL_MAP_UNIT_STRENGTH_MULTIPLIER@CvGlobals@@QAEHXZ ; CvGlobals::getAI_TACTICAL_MAP_UNIT_STRENGTH_MULTIPLIER
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_TACTICAL_MAP_UNIT_STRENGTH_MULTIPLIER@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_TACTICAL_MAP_UNIT_STRENGTH_MULTIPLIER@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_TACTICAL_MAP_UNIT_STRENGTH_MULTIPLIER, COMDAT
; _this$ = ecx

; 1505 : 		return m_iAI_TACTICAL_MAP_UNIT_STRENGTH_MULTIPLIER;

	mov	eax, DWORD PTR [ecx+2440]

; 1506 : 	}

	ret	0
?getAI_TACTICAL_MAP_UNIT_STRENGTH_MULTIPLIER@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_TACTICAL_MAP_UNIT_STRENGTH_MULTIPLIER
_TEXT	ENDS
PUBLIC	?getAI_TACTICAL_MAP_DOMINANCE_PERCENTAGE@CvGlobals@@QAEHXZ ; CvGlobals::getAI_TACTICAL_MAP_DOMINANCE_PERCENTAGE
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_TACTICAL_MAP_DOMINANCE_PERCENTAGE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_TACTICAL_MAP_DOMINANCE_PERCENTAGE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_TACTICAL_MAP_DOMINANCE_PERCENTAGE, COMDAT
; _this$ = ecx

; 1509 : 		return m_iAI_TACTICAL_MAP_DOMINANCE_PERCENTAGE;

	mov	eax, DWORD PTR [ecx+2444]

; 1510 : 	}

	ret	0
?getAI_TACTICAL_MAP_DOMINANCE_PERCENTAGE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_TACTICAL_MAP_DOMINANCE_PERCENTAGE
_TEXT	ENDS
PUBLIC	?getAI_TACTICAL_RECRUIT_RANGE@CvGlobals@@QAEHXZ	; CvGlobals::getAI_TACTICAL_RECRUIT_RANGE
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_TACTICAL_RECRUIT_RANGE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_TACTICAL_RECRUIT_RANGE@CvGlobals@@QAEHXZ PROC	; CvGlobals::getAI_TACTICAL_RECRUIT_RANGE, COMDAT
; _this$ = ecx

; 1525 : 		return m_iAI_TACTICAL_RECRUIT_RANGE;

	mov	eax, DWORD PTR [ecx+2460]

; 1526 : 	}

	ret	0
?getAI_TACTICAL_RECRUIT_RANGE@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getAI_TACTICAL_RECRUIT_RANGE
_TEXT	ENDS
PUBLIC	?getMAX_CITY_HIT_POINTS@CvGlobals@@QAEHXZ	; CvGlobals::getMAX_CITY_HIT_POINTS
; Function compile flags: /Ogtpy
;	COMDAT ?getMAX_CITY_HIT_POINTS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getMAX_CITY_HIT_POINTS@CvGlobals@@QAEHXZ PROC		; CvGlobals::getMAX_CITY_HIT_POINTS, COMDAT
; _this$ = ecx

; 6501 : 		return m_iMAX_CITY_HIT_POINTS;

	mov	eax, DWORD PTR [ecx+7372]

; 6502 : 	}

	ret	0
?getMAX_CITY_HIT_POINTS@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getMAX_CITY_HIT_POINTS
_TEXT	ENDS
PUBLIC	?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z	; CvPlayerAI::getPlayer
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
;	COMDAT ?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z PROC	; CvPlayerAI::getPlayer, COMDAT

; 28   : 		CvAssertMsg(ePlayer != NO_PLAYER, "Player is not assigned a valid value");
; 29   : 		CvAssertMsg(ePlayer < MAX_PLAYERS, "Player is not assigned a valid value");
; 30   : 		return m_aPlayers[ePlayer];

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 31   : 	}

	ret	0
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z ENDP	; CvPlayerAI::getPlayer
_TEXT	ENDS
PUBLIC	?isCity@CvPlot@@QBE_NXZ				; CvPlot::isCity
EXTRN	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z:PROC	; CvPlayer::getCity
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?isCity@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isCity@CvPlot@@QBE_NXZ PROC				; CvPlot::isCity, COMDAT
; _this$ = ecx

; 245  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN1@isCity
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@isCity

; 246  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID)) != NULL;

	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	neg	eax
	sbb	eax, eax
	neg	eax

; 249  : 	}

	ret	0
$LN1@isCity:

; 247  : 
; 248  : 		return false;

	xor	al, al

; 249  : 	}

	ret	0
?isCity@CvPlot@@QBE_NXZ ENDP				; CvPlot::isCity
_TEXT	ENDS
PUBLIC	?getX@CvPlot@@QBEHXZ				; CvPlot::getX
; Function compile flags: /Ogtpy
;	COMDAT ?getX@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getX@CvPlot@@QBEHXZ PROC				; CvPlot::getX, COMDAT
; _this$ = ecx

; 307  : 		return m_iX;

	movsx	eax, WORD PTR [ecx]

; 308  : 	}

	ret	0
?getX@CvPlot@@QBEHXZ ENDP				; CvPlot::getX
_TEXT	ENDS
PUBLIC	?getY@CvPlot@@QBEHXZ				; CvPlot::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getY@CvPlot@@QBEHXZ PROC				; CvPlot::getY, COMDAT
; _this$ = ecx

; 312  : 		return m_iY;

	movsx	eax, WORD PTR [ecx+2]

; 313  : 	}

	ret	0
?getY@CvPlot@@QBEHXZ ENDP				; CvPlot::getY
_TEXT	ENDS
PUBLIC	?getArea@CvPlot@@QBEHXZ				; CvPlot::getArea
; Function compile flags: /Ogtpy
;	COMDAT ?getArea@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getArea@CvPlot@@QBEHXZ PROC				; CvPlot::getArea, COMDAT
; _this$ = ecx

; 324  : 		return m_iArea;

	mov	eax, DWORD PTR [ecx+356]

; 325  : 	}

	ret	0
?getArea@CvPlot@@QBEHXZ ENDP				; CvPlot::getArea
_TEXT	ENDS
PUBLIC	?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ	; CvPlot::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlot::getOwner, COMDAT
; _this$ = ecx

; 387  : 		return (PlayerTypes)m_eOwner;

	movsx	eax, BYTE PTR [ecx+4]

; 388  : 	}

	ret	0
?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlot::getOwner
_TEXT	ENDS
PUBLIC	?isWater@CvPlot@@QBE_NXZ			; CvPlot::isWater
; Function compile flags: /Ogtpy
;	COMDAT ?isWater@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isWater@CvPlot@@QBE_NXZ PROC				; CvPlot::isWater, COMDAT
; _this$ = ecx

; 409  : 		return (PlotTypes)m_ePlotType == PLOT_OCEAN;

	xor	eax, eax
	cmp	BYTE PTR [ecx+5], 3
	sete	al

; 410  : 	};

	ret	0
?isWater@CvPlot@@QBE_NXZ ENDP				; CvPlot::isWater
_TEXT	ENDS
PUBLIC	?isMountain@CvPlot@@QBE_NXZ			; CvPlot::isMountain
; Function compile flags: /Ogtpy
;	COMDAT ?isMountain@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isMountain@CvPlot@@QBE_NXZ PROC			; CvPlot::isMountain, COMDAT
; _this$ = ecx

; 422  : 		return (PlotTypes)m_ePlotType == PLOT_MOUNTAIN;

	xor	eax, eax
	cmp	BYTE PTR [ecx+5], al
	sete	al

; 423  : 	};

	ret	0
?isMountain@CvPlot@@QBE_NXZ ENDP			; CvPlot::isMountain
_TEXT	ENDS
PUBLIC	?isImpassable@CvPlot@@QBE_NXZ			; CvPlot::isImpassable
; Function compile flags: /Ogtpy
;	COMDAT ?isImpassable@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isImpassable@CvPlot@@QBE_NXZ PROC			; CvPlot::isImpassable, COMDAT
; _this$ = ecx

; 444  : 		return m_bIsImpassable;

	mov	al, BYTE PTR [ecx+462]
	shr	al, 7

; 445  : 	}

	ret	0
?isImpassable@CvPlot@@QBE_NXZ ENDP			; CvPlot::isImpassable
_TEXT	ENDS
PUBLIC	?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z	; CvPlot::getVisibilityCount
; Function compile flags: /Ogtpy
;	COMDAT ?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z PROC	; CvPlot::getVisibilityCount, COMDAT
; _this$ = ecx

; 588  : 		CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 589  : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 590  : 
; 591  : 		return m_aiVisibilityCount[eTeam];

	mov	eax, DWORD PTR [ecx+156]
	mov	ecx, DWORD PTR _eTeam$[esp-4]
	movsx	eax, WORD PTR [eax+ecx*2]

; 592  : 	}

	ret	4
?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z ENDP	; CvPlot::getVisibilityCount
_TEXT	ENDS
PUBLIC	?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z		; CvPlot::PlotBoolField::GetBit
; Function compile flags: /Ogtpy
;	COMDAT ?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z
_TEXT	SEGMENT
_uiEntry$ = 8						; size = 4
?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z PROC		; CvPlot::PlotBoolField::GetBit, COMDAT
; _this$ = ecx

; 767  : 		{

	mov	edx, ecx

; 768  : 			const uint uiOffset = uiEntry/eSize;

	mov	ecx, DWORD PTR _uiEntry$[esp-4]
	push	esi
	mov	eax, ecx
	shr	eax, 5

; 769  : 			return m_dwBits[uiOffset] & 1<<(uiEntry-(eSize*uiOffset));

	mov	esi, eax
	shl	esi, 5
	sub	ecx, esi
	mov	esi, 1
	shl	esi, cl
	test	esi, DWORD PTR [edx+eax*4]
	pop	esi
	setne	al

; 770  : 		}

	ret	4
?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z ENDP		; CvPlot::PlotBoolField::GetBit
_TEXT	ENDS
PUBLIC	?coordRange@@YAHHH_N@Z				; coordRange
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?coordRange@@YAHHH_N@Z
_TEXT	SEGMENT
_iCoord$ = 8						; size = 4
_iRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?coordRange@@YAHHH_N@Z PROC				; coordRange, COMDAT

; 88   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iCoord$[esp-4]
	je	SHORT $LN5@coordRange

; 89   : 	{
; 90   : 		if(iCoord < 0)
; 91   : 		{
; 92   : 			return (iRange + (iCoord % iRange));

	mov	ecx, DWORD PTR _iRange$[esp-4]
	test	eax, eax
	jge	SHORT $LN3@coordRange
	cdq
	idiv	ecx
	mov	eax, edx
	add	eax, ecx

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
$LN3@coordRange:

; 93   : 		}
; 94   : 		else if(iCoord >= iRange)

	cmp	eax, ecx
	jl	SHORT $LN5@coordRange

; 95   : 		{
; 96   : 			return (iCoord % iRange);

	cdq
	idiv	ecx
	mov	eax, edx
$LN5@coordRange:

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
?coordRange@@YAHHH_N@Z ENDP				; coordRange
_TEXT	ENDS
PUBLIC	?numPlots@CvMap@@QBEHXZ				; CvMap::numPlots
; Function compile flags: /Ogtpy
;	COMDAT ?numPlots@CvMap@@QBEHXZ
_TEXT	SEGMENT
?numPlots@CvMap@@QBEHXZ PROC				; CvMap::numPlots, COMDAT
; _this$ = ecx

; 170  : 		return m_iGridSize;

	mov	eax, DWORD PTR [ecx+4028]

; 171  : 	}

	ret	0
?numPlots@CvMap@@QBEHXZ ENDP				; CvMap::numPlots
_TEXT	ENDS
PUBLIC	?getGridWidth@CvMap@@QBEHXZ			; CvMap::getGridWidth
; Function compile flags: /Ogtpy
;	COMDAT ?getGridWidth@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridWidth@CvMap@@QBEHXZ PROC			; CvMap::getGridWidth, COMDAT
; _this$ = ecx

; 198  : 		return m_iGridWidth;

	mov	eax, DWORD PTR [ecx+4020]

; 199  : 	}

	ret	0
?getGridWidth@CvMap@@QBEHXZ ENDP			; CvMap::getGridWidth
_TEXT	ENDS
PUBLIC	?getGridHeight@CvMap@@QBEHXZ			; CvMap::getGridHeight
; Function compile flags: /Ogtpy
;	COMDAT ?getGridHeight@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridHeight@CvMap@@QBEHXZ PROC			; CvMap::getGridHeight, COMDAT
; _this$ = ecx

; 206  : 		return m_iGridHeight;

	mov	eax, DWORD PTR [ecx+4024]

; 207  : 	}

	ret	0
?getGridHeight@CvMap@@QBEHXZ ENDP			; CvMap::getGridHeight
_TEXT	ENDS
PUBLIC	?isWrapX@CvMap@@QBE_NXZ				; CvMap::isWrapX
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapX@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapX@CvMap@@QBE_NXZ PROC				; CvMap::isWrapX, COMDAT
; _this$ = ecx

; 228  : 		return m_bWrapX;

	mov	al, BYTE PTR [ecx+4056]

; 229  : 	}

	ret	0
?isWrapX@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapX
_TEXT	ENDS
PUBLIC	?isWrapY@CvMap@@QBE_NXZ				; CvMap::isWrapY
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapY@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapY@CvMap@@QBE_NXZ PROC				; CvMap::isWrapY, COMDAT
; _this$ = ecx

; 233  : 		return m_bWrapY;

	mov	al, BYTE PTR [ecx+4057]

; 234  : 	}

	ret	0
?isWrapY@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapY
_TEXT	ENDS
PUBLIC	?plotByIndex@CvMap@@QBEPAVCvPlot@@H@Z		; CvMap::plotByIndex
; Function compile flags: /Ogtpy
;	COMDAT ?plotByIndex@CvMap@@QBEPAVCvPlot@@H@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?plotByIndex@CvMap@@QBEPAVCvPlot@@H@Z PROC		; CvMap::plotByIndex, COMDAT
; _this$ = ecx

; 263  : 		return (((iIndex >= 0) && (iIndex < (numPlots()))) ? &(m_pMapPlots[iIndex]) : NULL);

	mov	eax, DWORD PTR _iIndex$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@plotByInde
	cmp	eax, DWORD PTR [ecx+4028]
	jge	SHORT $LN3@plotByInde
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]

; 264  : 	}

	ret	4
$LN3@plotByInde:

; 263  : 		return (((iIndex >= 0) && (iIndex < (numPlots()))) ? &(m_pMapPlots[iIndex]) : NULL);

	xor	eax, eax

; 264  : 	}

	ret	4
?plotByIndex@CvMap@@QBEPAVCvPlot@@H@Z ENDP		; CvMap::plotByIndex
_TEXT	ENDS
PUBLIC	?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z	; CvMap::plotByIndexUnchecked
; Function compile flags: /Ogtpy
;	COMDAT ?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z PROC	; CvMap::plotByIndexUnchecked, COMDAT
; _this$ = ecx

; 268  : 		return &m_pMapPlots[iIndex];

	mov	eax, DWORD PTR _iIndex$[esp-4]
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]

; 269  : 	}

	ret	4
?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z ENDP	; CvMap::plotByIndexUnchecked
_TEXT	ENDS
PUBLIC	?GetBit@CvTacticalAnalysisCell@@QBE_NI@Z	; CvTacticalAnalysisCell::GetBit
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtacticalanalysismap.h
;	COMDAT ?GetBit@CvTacticalAnalysisCell@@QBE_NI@Z
_TEXT	SEGMENT
_uiFlag$ = 8						; size = 4
?GetBit@CvTacticalAnalysisCell@@QBE_NI@Z PROC		; CvTacticalAnalysisCell::GetBit, COMDAT
; _this$ = ecx

; 83   : 	FBITFLAGS(uint);

	mov	eax, DWORD PTR [ecx]
	and	eax, DWORD PTR _uiFlag$[esp-4]
	neg	eax
	sbb	eax, eax
	neg	eax
	ret	4
?GetBit@CvTacticalAnalysisCell@@QBE_NI@Z ENDP		; CvTacticalAnalysisCell::GetBit
_TEXT	ENDS
PUBLIC	?SetBit@CvTacticalAnalysisCell@@QAEXI_N@Z	; CvTacticalAnalysisCell::SetBit
; Function compile flags: /Ogtpy
;	COMDAT ?SetBit@CvTacticalAnalysisCell@@QAEXI_N@Z
_TEXT	SEGMENT
_uiFlag$ = 8						; size = 4
_bOn$ = 12						; size = 1
?SetBit@CvTacticalAnalysisCell@@QAEXI_N@Z PROC		; CvTacticalAnalysisCell::SetBit, COMDAT
; _this$ = ecx

; 83   : 	FBITFLAGS(uint);

	cmp	BYTE PTR _bOn$[esp-4], 0
	je	SHORT $LN2@SetBit
	mov	eax, DWORD PTR _uiFlag$[esp-4]
	or	DWORD PTR [ecx], eax
	ret	8
$LN2@SetBit:
	mov	edx, DWORD PTR _uiFlag$[esp-4]
	not	edx
	and	DWORD PTR [ecx], edx
	ret	8
?SetBit@CvTacticalAnalysisCell@@QAEXI_N@Z ENDP		; CvTacticalAnalysisCell::SetBit
_TEXT	ENDS
PUBLIC	?ClearFlags@CvTacticalAnalysisCell@@QAEXXZ	; CvTacticalAnalysisCell::ClearFlags
; Function compile flags: /Ogtpy
;	COMDAT ?ClearFlags@CvTacticalAnalysisCell@@QAEXXZ
_TEXT	SEGMENT
?ClearFlags@CvTacticalAnalysisCell@@QAEXXZ PROC		; CvTacticalAnalysisCell::ClearFlags, COMDAT
; _this$ = ecx

; 83   : 	FBITFLAGS(uint);

	mov	DWORD PTR [ecx], 0
	ret	0
?ClearFlags@CvTacticalAnalysisCell@@QAEXXZ ENDP		; CvTacticalAnalysisCell::ClearFlags
_TEXT	ENDS
PUBLIC	?IsRevealed@CvTacticalAnalysisCell@@QAE_NXZ	; CvTacticalAnalysisCell::IsRevealed
; Function compile flags: /Ogtpy
;	COMDAT ?IsRevealed@CvTacticalAnalysisCell@@QAE_NXZ
_TEXT	SEGMENT
?IsRevealed@CvTacticalAnalysisCell@@QAE_NXZ PROC	; CvTacticalAnalysisCell::IsRevealed, COMDAT
; _this$ = ecx

; 92   : 		return GetBit(TACTICAL_FLAG_REVEALED);

	mov	eax, DWORD PTR [ecx]
	and	eax, 1

; 93   : 	};

	ret	0
?IsRevealed@CvTacticalAnalysisCell@@QAE_NXZ ENDP	; CvTacticalAnalysisCell::IsRevealed
_TEXT	ENDS
PUBLIC	?SetRevealed@CvTacticalAnalysisCell@@QAEX_N@Z	; CvTacticalAnalysisCell::SetRevealed
; Function compile flags: /Ogtpy
;	COMDAT ?SetRevealed@CvTacticalAnalysisCell@@QAEX_N@Z
_TEXT	SEGMENT
_bNewValue$ = 8						; size = 1
?SetRevealed@CvTacticalAnalysisCell@@QAEX_N@Z PROC	; CvTacticalAnalysisCell::SetRevealed, COMDAT
; _this$ = ecx

; 96   : 		SetBit(TACTICAL_FLAG_REVEALED, bNewValue);

	cmp	BYTE PTR _bNewValue$[esp-4], 0
	je	SHORT $LN4@SetReveale
	or	DWORD PTR [ecx], 1

; 97   : 	};

	ret	4

; 96   : 		SetBit(TACTICAL_FLAG_REVEALED, bNewValue);

$LN4@SetReveale:
	and	DWORD PTR [ecx], -2			; fffffffeH

; 97   : 	};

	ret	4
?SetRevealed@CvTacticalAnalysisCell@@QAEX_N@Z ENDP	; CvTacticalAnalysisCell::SetRevealed
_TEXT	ENDS
PUBLIC	?SetVisible@CvTacticalAnalysisCell@@QAEX_N@Z	; CvTacticalAnalysisCell::SetVisible
; Function compile flags: /Ogtpy
;	COMDAT ?SetVisible@CvTacticalAnalysisCell@@QAEX_N@Z
_TEXT	SEGMENT
_bNewValue$ = 8						; size = 1
?SetVisible@CvTacticalAnalysisCell@@QAEX_N@Z PROC	; CvTacticalAnalysisCell::SetVisible, COMDAT
; _this$ = ecx

; 104  : 		SetBit(TACTICAL_FLAG_VISIBLE, bNewValue);

	cmp	BYTE PTR _bNewValue$[esp-4], 0
	je	SHORT $LN4@SetVisible
	or	DWORD PTR [ecx], 2

; 105  : 	};

	ret	4

; 104  : 		SetBit(TACTICAL_FLAG_VISIBLE, bNewValue);

$LN4@SetVisible:
	and	DWORD PTR [ecx], -3			; fffffffdH

; 105  : 	};

	ret	4
?SetVisible@CvTacticalAnalysisCell@@QAEX_N@Z ENDP	; CvTacticalAnalysisCell::SetVisible
_TEXT	ENDS
PUBLIC	?IsImpassableTerrain@CvTacticalAnalysisCell@@QAE_NXZ ; CvTacticalAnalysisCell::IsImpassableTerrain
; Function compile flags: /Ogtpy
;	COMDAT ?IsImpassableTerrain@CvTacticalAnalysisCell@@QAE_NXZ
_TEXT	SEGMENT
?IsImpassableTerrain@CvTacticalAnalysisCell@@QAE_NXZ PROC ; CvTacticalAnalysisCell::IsImpassableTerrain, COMDAT
; _this$ = ecx

; 108  : 		return GetBit(TACTICAL_FLAG_IMPASSABLE_TERRAIN);

	mov	eax, DWORD PTR [ecx]
	shr	eax, 2
	and	eax, 1

; 109  : 	};

	ret	0
?IsImpassableTerrain@CvTacticalAnalysisCell@@QAE_NXZ ENDP ; CvTacticalAnalysisCell::IsImpassableTerrain
_TEXT	ENDS
PUBLIC	?SetImpassableTerrain@CvTacticalAnalysisCell@@QAEX_N@Z ; CvTacticalAnalysisCell::SetImpassableTerrain
; Function compile flags: /Ogtpy
;	COMDAT ?SetImpassableTerrain@CvTacticalAnalysisCell@@QAEX_N@Z
_TEXT	SEGMENT
_bNewValue$ = 8						; size = 1
?SetImpassableTerrain@CvTacticalAnalysisCell@@QAEX_N@Z PROC ; CvTacticalAnalysisCell::SetImpassableTerrain, COMDAT
; _this$ = ecx

; 112  : 		SetBit(TACTICAL_FLAG_IMPASSABLE_TERRAIN, bNewValue);

	cmp	BYTE PTR _bNewValue$[esp-4], 0
	je	SHORT $LN4@SetImpassa
	or	DWORD PTR [ecx], 4

; 113  : 	};

	ret	4

; 112  : 		SetBit(TACTICAL_FLAG_IMPASSABLE_TERRAIN, bNewValue);

$LN4@SetImpassa:
	and	DWORD PTR [ecx], -5			; fffffffbH

; 113  : 	};

	ret	4
?SetImpassableTerrain@CvTacticalAnalysisCell@@QAEX_N@Z ENDP ; CvTacticalAnalysisCell::SetImpassableTerrain
_TEXT	ENDS
PUBLIC	?IsImpassableTerritory@CvTacticalAnalysisCell@@QAE_NXZ ; CvTacticalAnalysisCell::IsImpassableTerritory
; Function compile flags: /Ogtpy
;	COMDAT ?IsImpassableTerritory@CvTacticalAnalysisCell@@QAE_NXZ
_TEXT	SEGMENT
?IsImpassableTerritory@CvTacticalAnalysisCell@@QAE_NXZ PROC ; CvTacticalAnalysisCell::IsImpassableTerritory, COMDAT
; _this$ = ecx

; 116  : 		return GetBit(TACTICAL_FLAG_IMPASSABLE_TERRITORY);

	mov	eax, DWORD PTR [ecx]
	shr	eax, 3
	and	eax, 1

; 117  : 	};

	ret	0
?IsImpassableTerritory@CvTacticalAnalysisCell@@QAE_NXZ ENDP ; CvTacticalAnalysisCell::IsImpassableTerritory
_TEXT	ENDS
PUBLIC	?SetImpassableTerritory@CvTacticalAnalysisCell@@QAEX_N@Z ; CvTacticalAnalysisCell::SetImpassableTerritory
; Function compile flags: /Ogtpy
;	COMDAT ?SetImpassableTerritory@CvTacticalAnalysisCell@@QAEX_N@Z
_TEXT	SEGMENT
_bNewValue$ = 8						; size = 1
?SetImpassableTerritory@CvTacticalAnalysisCell@@QAEX_N@Z PROC ; CvTacticalAnalysisCell::SetImpassableTerritory, COMDAT
; _this$ = ecx

; 120  : 		SetBit(TACTICAL_FLAG_IMPASSABLE_TERRITORY, bNewValue);

	cmp	BYTE PTR _bNewValue$[esp-4], 0
	je	SHORT $LN4@SetImpassa@2
	or	DWORD PTR [ecx], 8

; 121  : 	};

	ret	4

; 120  : 		SetBit(TACTICAL_FLAG_IMPASSABLE_TERRITORY, bNewValue);

$LN4@SetImpassa@2:
	and	DWORD PTR [ecx], -9			; fffffff7H

; 121  : 	};

	ret	4
?SetImpassableTerritory@CvTacticalAnalysisCell@@QAEX_N@Z ENDP ; CvTacticalAnalysisCell::SetImpassableTerritory
_TEXT	ENDS
PUBLIC	?SetNotVisibleToEnemy@CvTacticalAnalysisCell@@QAEX_N@Z ; CvTacticalAnalysisCell::SetNotVisibleToEnemy
; Function compile flags: /Ogtpy
;	COMDAT ?SetNotVisibleToEnemy@CvTacticalAnalysisCell@@QAEX_N@Z
_TEXT	SEGMENT
_bNewValue$ = 8						; size = 1
?SetNotVisibleToEnemy@CvTacticalAnalysisCell@@QAEX_N@Z PROC ; CvTacticalAnalysisCell::SetNotVisibleToEnemy, COMDAT
; _this$ = ecx

; 128  : 		SetBit(TACTICAL_FLAG_NOT_VISIBLE_TO_ENEMY, bNewValue);

	cmp	BYTE PTR _bNewValue$[esp-4], 0
	je	SHORT $LN4@SetNotVisi
	or	DWORD PTR [ecx], 16			; 00000010H

; 129  : 	};

	ret	4

; 128  : 		SetBit(TACTICAL_FLAG_NOT_VISIBLE_TO_ENEMY, bNewValue);

$LN4@SetNotVisi:
	and	DWORD PTR [ecx], -17			; ffffffefH

; 129  : 	};

	ret	4
?SetNotVisibleToEnemy@CvTacticalAnalysisCell@@QAEX_N@Z ENDP ; CvTacticalAnalysisCell::SetNotVisibleToEnemy
_TEXT	ENDS
PUBLIC	?IsSubjectToAttack@CvTacticalAnalysisCell@@QAE_NXZ ; CvTacticalAnalysisCell::IsSubjectToAttack
; Function compile flags: /Ogtpy
;	COMDAT ?IsSubjectToAttack@CvTacticalAnalysisCell@@QAE_NXZ
_TEXT	SEGMENT
?IsSubjectToAttack@CvTacticalAnalysisCell@@QAE_NXZ PROC	; CvTacticalAnalysisCell::IsSubjectToAttack, COMDAT
; _this$ = ecx

; 132  : 		return GetBit(TACTICAL_FLAG_SUBJECT_TO_ENEMY_ATTACK);

	mov	eax, DWORD PTR [ecx]
	shr	eax, 5
	and	eax, 1

; 133  : 	};

	ret	0
?IsSubjectToAttack@CvTacticalAnalysisCell@@QAE_NXZ ENDP	; CvTacticalAnalysisCell::IsSubjectToAttack
_TEXT	ENDS
PUBLIC	?SetSubjectToAttack@CvTacticalAnalysisCell@@QAEX_N@Z ; CvTacticalAnalysisCell::SetSubjectToAttack
; Function compile flags: /Ogtpy
;	COMDAT ?SetSubjectToAttack@CvTacticalAnalysisCell@@QAEX_N@Z
_TEXT	SEGMENT
_bNewValue$ = 8						; size = 1
?SetSubjectToAttack@CvTacticalAnalysisCell@@QAEX_N@Z PROC ; CvTacticalAnalysisCell::SetSubjectToAttack, COMDAT
; _this$ = ecx

; 136  : 		SetBit(TACTICAL_FLAG_SUBJECT_TO_ENEMY_ATTACK, bNewValue);

	cmp	BYTE PTR _bNewValue$[esp-4], 0
	je	SHORT $LN4@SetSubject
	or	DWORD PTR [ecx], 32			; 00000020H

; 137  : 	};

	ret	4

; 136  : 		SetBit(TACTICAL_FLAG_SUBJECT_TO_ENEMY_ATTACK, bNewValue);

$LN4@SetSubject:
	and	DWORD PTR [ecx], -33			; ffffffdfH

; 137  : 	};

	ret	4
?SetSubjectToAttack@CvTacticalAnalysisCell@@QAEX_N@Z ENDP ; CvTacticalAnalysisCell::SetSubjectToAttack
_TEXT	ENDS
PUBLIC	?SetEnemyCanMovePast@CvTacticalAnalysisCell@@QAEX_N@Z ; CvTacticalAnalysisCell::SetEnemyCanMovePast
; Function compile flags: /Ogtpy
;	COMDAT ?SetEnemyCanMovePast@CvTacticalAnalysisCell@@QAEX_N@Z
_TEXT	SEGMENT
_bNewValue$ = 8						; size = 1
?SetEnemyCanMovePast@CvTacticalAnalysisCell@@QAEX_N@Z PROC ; CvTacticalAnalysisCell::SetEnemyCanMovePast, COMDAT
; _this$ = ecx

; 144  : 		SetBit(TACTICAL_FLAG_ENEMY_CAN_REACH_WITH_MOVES, bNewValue);

	cmp	BYTE PTR _bNewValue$[esp-4], 0
	je	SHORT $LN4@SetEnemyCa
	or	DWORD PTR [ecx], 64			; 00000040H

; 145  : 	};

	ret	4

; 144  : 		SetBit(TACTICAL_FLAG_ENEMY_CAN_REACH_WITH_MOVES, bNewValue);

$LN4@SetEnemyCa:
	and	DWORD PTR [ecx], -65			; ffffffbfH

; 145  : 	};

	ret	4
?SetEnemyCanMovePast@CvTacticalAnalysisCell@@QAEX_N@Z ENDP ; CvTacticalAnalysisCell::SetEnemyCanMovePast
_TEXT	ENDS
PUBLIC	?IsFriendlyTurnEndTile@CvTacticalAnalysisCell@@QAE_NXZ ; CvTacticalAnalysisCell::IsFriendlyTurnEndTile
; Function compile flags: /Ogtpy
;	COMDAT ?IsFriendlyTurnEndTile@CvTacticalAnalysisCell@@QAE_NXZ
_TEXT	SEGMENT
?IsFriendlyTurnEndTile@CvTacticalAnalysisCell@@QAE_NXZ PROC ; CvTacticalAnalysisCell::IsFriendlyTurnEndTile, COMDAT
; _this$ = ecx

; 148  : 		return GetBit(TACTICAL_FLAG_FRIENDLY_TURN_END_TILE);

	mov	eax, DWORD PTR [ecx]
	shr	eax, 7
	and	eax, 1

; 149  : 	};

	ret	0
?IsFriendlyTurnEndTile@CvTacticalAnalysisCell@@QAE_NXZ ENDP ; CvTacticalAnalysisCell::IsFriendlyTurnEndTile
_TEXT	ENDS
PUBLIC	?IsFriendlyCity@CvTacticalAnalysisCell@@QAE_NXZ	; CvTacticalAnalysisCell::IsFriendlyCity
; Function compile flags: /Ogtpy
;	COMDAT ?IsFriendlyCity@CvTacticalAnalysisCell@@QAE_NXZ
_TEXT	SEGMENT
?IsFriendlyCity@CvTacticalAnalysisCell@@QAE_NXZ PROC	; CvTacticalAnalysisCell::IsFriendlyCity, COMDAT
; _this$ = ecx

; 156  : 		return GetBit(TACTICAL_FLAG_FRIENDLY_CITY);

	mov	eax, DWORD PTR [ecx]
	shr	eax, 8
	and	eax, 1

; 157  : 	};

	ret	0
?IsFriendlyCity@CvTacticalAnalysisCell@@QAE_NXZ ENDP	; CvTacticalAnalysisCell::IsFriendlyCity
_TEXT	ENDS
PUBLIC	?SetFriendlyCity@CvTacticalAnalysisCell@@QAEX_N@Z ; CvTacticalAnalysisCell::SetFriendlyCity
; Function compile flags: /Ogtpy
;	COMDAT ?SetFriendlyCity@CvTacticalAnalysisCell@@QAEX_N@Z
_TEXT	SEGMENT
_bNewValue$ = 8						; size = 1
?SetFriendlyCity@CvTacticalAnalysisCell@@QAEX_N@Z PROC	; CvTacticalAnalysisCell::SetFriendlyCity, COMDAT
; _this$ = ecx

; 160  : 		SetBit(TACTICAL_FLAG_FRIENDLY_CITY, bNewValue);

	cmp	BYTE PTR _bNewValue$[esp-4], 0
	je	SHORT $LN4@SetFriendl
	or	DWORD PTR [ecx], 256			; 00000100H

; 161  : 	};

	ret	4

; 160  : 		SetBit(TACTICAL_FLAG_FRIENDLY_CITY, bNewValue);

$LN4@SetFriendl:
	and	DWORD PTR [ecx], -257			; fffffeffH

; 161  : 	};

	ret	4
?SetFriendlyCity@CvTacticalAnalysisCell@@QAEX_N@Z ENDP	; CvTacticalAnalysisCell::SetFriendlyCity
_TEXT	ENDS
PUBLIC	?IsEnemyCity@CvTacticalAnalysisCell@@QAE_NXZ	; CvTacticalAnalysisCell::IsEnemyCity
; Function compile flags: /Ogtpy
;	COMDAT ?IsEnemyCity@CvTacticalAnalysisCell@@QAE_NXZ
_TEXT	SEGMENT
?IsEnemyCity@CvTacticalAnalysisCell@@QAE_NXZ PROC	; CvTacticalAnalysisCell::IsEnemyCity, COMDAT
; _this$ = ecx

; 164  : 		return GetBit(TACTICAL_FLAG_ENEMY_CITY);

	mov	eax, DWORD PTR [ecx]
	shr	eax, 9
	and	eax, 1

; 165  : 	};

	ret	0
?IsEnemyCity@CvTacticalAnalysisCell@@QAE_NXZ ENDP	; CvTacticalAnalysisCell::IsEnemyCity
_TEXT	ENDS
PUBLIC	?SetEnemyCity@CvTacticalAnalysisCell@@QAEX_N@Z	; CvTacticalAnalysisCell::SetEnemyCity
; Function compile flags: /Ogtpy
;	COMDAT ?SetEnemyCity@CvTacticalAnalysisCell@@QAEX_N@Z
_TEXT	SEGMENT
_bNewValue$ = 8						; size = 1
?SetEnemyCity@CvTacticalAnalysisCell@@QAEX_N@Z PROC	; CvTacticalAnalysisCell::SetEnemyCity, COMDAT
; _this$ = ecx

; 168  : 		SetBit(TACTICAL_FLAG_ENEMY_CITY, bNewValue);

	cmp	BYTE PTR _bNewValue$[esp-4], 0
	je	SHORT $LN4@SetEnemyCi
	or	DWORD PTR [ecx], 512			; 00000200H

; 169  : 	};

	ret	4

; 168  : 		SetBit(TACTICAL_FLAG_ENEMY_CITY, bNewValue);

$LN4@SetEnemyCi:
	and	DWORD PTR [ecx], -513			; fffffdffH

; 169  : 	};

	ret	4
?SetEnemyCity@CvTacticalAnalysisCell@@QAEX_N@Z ENDP	; CvTacticalAnalysisCell::SetEnemyCity
_TEXT	ENDS
PUBLIC	?IsNeutralCity@CvTacticalAnalysisCell@@QAE_NXZ	; CvTacticalAnalysisCell::IsNeutralCity
; Function compile flags: /Ogtpy
;	COMDAT ?IsNeutralCity@CvTacticalAnalysisCell@@QAE_NXZ
_TEXT	SEGMENT
?IsNeutralCity@CvTacticalAnalysisCell@@QAE_NXZ PROC	; CvTacticalAnalysisCell::IsNeutralCity, COMDAT
; _this$ = ecx

; 172  : 		return GetBit(TACTICAL_FLAG_NEUTRAL_CITY);

	mov	eax, DWORD PTR [ecx]
	shr	eax, 10					; 0000000aH
	and	eax, 1

; 173  : 	};

	ret	0
?IsNeutralCity@CvTacticalAnalysisCell@@QAE_NXZ ENDP	; CvTacticalAnalysisCell::IsNeutralCity
_TEXT	ENDS
PUBLIC	?SetNeutralCity@CvTacticalAnalysisCell@@QAEX_N@Z ; CvTacticalAnalysisCell::SetNeutralCity
; Function compile flags: /Ogtpy
;	COMDAT ?SetNeutralCity@CvTacticalAnalysisCell@@QAEX_N@Z
_TEXT	SEGMENT
_bNewValue$ = 8						; size = 1
?SetNeutralCity@CvTacticalAnalysisCell@@QAEX_N@Z PROC	; CvTacticalAnalysisCell::SetNeutralCity, COMDAT
; _this$ = ecx

; 176  : 		SetBit(TACTICAL_FLAG_NEUTRAL_CITY, bNewValue);

	cmp	BYTE PTR _bNewValue$[esp-4], 0
	je	SHORT $LN4@SetNeutral
	or	DWORD PTR [ecx], 1024			; 00000400H

; 177  : 	};

	ret	4

; 176  : 		SetBit(TACTICAL_FLAG_NEUTRAL_CITY, bNewValue);

$LN4@SetNeutral:
	and	DWORD PTR [ecx], -1025			; fffffbffH

; 177  : 	};

	ret	4
?SetNeutralCity@CvTacticalAnalysisCell@@QAEX_N@Z ENDP	; CvTacticalAnalysisCell::SetNeutralCity
_TEXT	ENDS
PUBLIC	?IsWater@CvTacticalAnalysisCell@@QAE_NXZ	; CvTacticalAnalysisCell::IsWater
; Function compile flags: /Ogtpy
;	COMDAT ?IsWater@CvTacticalAnalysisCell@@QAE_NXZ
_TEXT	SEGMENT
?IsWater@CvTacticalAnalysisCell@@QAE_NXZ PROC		; CvTacticalAnalysisCell::IsWater, COMDAT
; _this$ = ecx

; 184  : 		return GetBit(TACTICAL_FLAG_WATER);

	mov	eax, DWORD PTR [ecx]
	shr	eax, 11					; 0000000bH
	and	eax, 1

; 185  : 	};

	ret	0
?IsWater@CvTacticalAnalysisCell@@QAE_NXZ ENDP		; CvTacticalAnalysisCell::IsWater
_TEXT	ENDS
PUBLIC	?SetWater@CvTacticalAnalysisCell@@QAEX_N@Z	; CvTacticalAnalysisCell::SetWater
; Function compile flags: /Ogtpy
;	COMDAT ?SetWater@CvTacticalAnalysisCell@@QAEX_N@Z
_TEXT	SEGMENT
_bNewValue$ = 8						; size = 1
?SetWater@CvTacticalAnalysisCell@@QAEX_N@Z PROC		; CvTacticalAnalysisCell::SetWater, COMDAT
; _this$ = ecx

; 188  : 		SetBit(TACTICAL_FLAG_WATER, bNewValue);

	cmp	BYTE PTR _bNewValue$[esp-4], 0
	je	SHORT $LN4@SetWater
	or	DWORD PTR [ecx], 2048			; 00000800H

; 189  : 	};

	ret	4

; 188  : 		SetBit(TACTICAL_FLAG_WATER, bNewValue);

$LN4@SetWater:
	and	DWORD PTR [ecx], -2049			; fffff7ffH

; 189  : 	};

	ret	4
?SetWater@CvTacticalAnalysisCell@@QAEX_N@Z ENDP		; CvTacticalAnalysisCell::SetWater
_TEXT	ENDS
PUBLIC	?SetOcean@CvTacticalAnalysisCell@@QAEX_N@Z	; CvTacticalAnalysisCell::SetOcean
; Function compile flags: /Ogtpy
;	COMDAT ?SetOcean@CvTacticalAnalysisCell@@QAEX_N@Z
_TEXT	SEGMENT
_bNewValue$ = 8						; size = 1
?SetOcean@CvTacticalAnalysisCell@@QAEX_N@Z PROC		; CvTacticalAnalysisCell::SetOcean, COMDAT
; _this$ = ecx

; 196  : 		SetBit(TACTICAL_FLAG_OCEAN, bNewValue);

	cmp	BYTE PTR _bNewValue$[esp-4], 0
	je	SHORT $LN4@SetOcean
	or	DWORD PTR [ecx], 4096			; 00001000H

; 197  : 	};

	ret	4

; 196  : 		SetBit(TACTICAL_FLAG_OCEAN, bNewValue);

$LN4@SetOcean:
	and	DWORD PTR [ecx], -4097			; ffffefffH

; 197  : 	};

	ret	4
?SetOcean@CvTacticalAnalysisCell@@QAEX_N@Z ENDP		; CvTacticalAnalysisCell::SetOcean
_TEXT	ENDS
PUBLIC	?SetOwnTerritory@CvTacticalAnalysisCell@@QAEX_N@Z ; CvTacticalAnalysisCell::SetOwnTerritory
; Function compile flags: /Ogtpy
;	COMDAT ?SetOwnTerritory@CvTacticalAnalysisCell@@QAEX_N@Z
_TEXT	SEGMENT
_bNewValue$ = 8						; size = 1
?SetOwnTerritory@CvTacticalAnalysisCell@@QAEX_N@Z PROC	; CvTacticalAnalysisCell::SetOwnTerritory, COMDAT
; _this$ = ecx

; 204  : 		SetBit(TACTICAL_FLAG_OWN_TERRITORY, bNewValue);

	cmp	BYTE PTR _bNewValue$[esp-4], 0
	je	SHORT $LN4@SetOwnTerr
	or	DWORD PTR [ecx], 8192			; 00002000H

; 205  : 	};

	ret	4

; 204  : 		SetBit(TACTICAL_FLAG_OWN_TERRITORY, bNewValue);

$LN4@SetOwnTerr:
	and	DWORD PTR [ecx], -8193			; ffffdfffH

; 205  : 	};

	ret	4
?SetOwnTerritory@CvTacticalAnalysisCell@@QAEX_N@Z ENDP	; CvTacticalAnalysisCell::SetOwnTerritory
_TEXT	ENDS
PUBLIC	?SetFriendlyTerritory@CvTacticalAnalysisCell@@QAEX_N@Z ; CvTacticalAnalysisCell::SetFriendlyTerritory
; Function compile flags: /Ogtpy
;	COMDAT ?SetFriendlyTerritory@CvTacticalAnalysisCell@@QAEX_N@Z
_TEXT	SEGMENT
_bNewValue$ = 8						; size = 1
?SetFriendlyTerritory@CvTacticalAnalysisCell@@QAEX_N@Z PROC ; CvTacticalAnalysisCell::SetFriendlyTerritory, COMDAT
; _this$ = ecx

; 212  : 		SetBit(TACTICAL_FLAG_FRIENDLY_TERRITORY, bNewValue);

	cmp	BYTE PTR _bNewValue$[esp-4], 0
	je	SHORT $LN4@SetFriendl@2
	or	DWORD PTR [ecx], 16384			; 00004000H

; 213  : 	};

	ret	4

; 212  : 		SetBit(TACTICAL_FLAG_FRIENDLY_TERRITORY, bNewValue);

$LN4@SetFriendl@2:
	and	DWORD PTR [ecx], -16385			; ffffbfffH

; 213  : 	};

	ret	4
?SetFriendlyTerritory@CvTacticalAnalysisCell@@QAEX_N@Z ENDP ; CvTacticalAnalysisCell::SetFriendlyTerritory
_TEXT	ENDS
PUBLIC	?SetEnemyTerritory@CvTacticalAnalysisCell@@QAEX_N@Z ; CvTacticalAnalysisCell::SetEnemyTerritory
; Function compile flags: /Ogtpy
;	COMDAT ?SetEnemyTerritory@CvTacticalAnalysisCell@@QAEX_N@Z
_TEXT	SEGMENT
_bNewValue$ = 8						; size = 1
?SetEnemyTerritory@CvTacticalAnalysisCell@@QAEX_N@Z PROC ; CvTacticalAnalysisCell::SetEnemyTerritory, COMDAT
; _this$ = ecx

; 220  : 		SetBit(TACTICAL_FLAG_ENEMY_TERRITORY, bNewValue);

	cmp	BYTE PTR _bNewValue$[esp-4], 0
	je	SHORT $LN4@SetEnemyTe
	or	DWORD PTR [ecx], 32768			; 00008000H

; 221  : 	};

	ret	4

; 220  : 		SetBit(TACTICAL_FLAG_ENEMY_TERRITORY, bNewValue);

$LN4@SetEnemyTe:
	and	DWORD PTR [ecx], -32769			; ffff7fffH

; 221  : 	};

	ret	4
?SetEnemyTerritory@CvTacticalAnalysisCell@@QAEX_N@Z ENDP ; CvTacticalAnalysisCell::SetEnemyTerritory
_TEXT	ENDS
PUBLIC	?SetUnclaimedTerritory@CvTacticalAnalysisCell@@QAEX_N@Z ; CvTacticalAnalysisCell::SetUnclaimedTerritory
; Function compile flags: /Ogtpy
;	COMDAT ?SetUnclaimedTerritory@CvTacticalAnalysisCell@@QAEX_N@Z
_TEXT	SEGMENT
_bNewValue$ = 8						; size = 1
?SetUnclaimedTerritory@CvTacticalAnalysisCell@@QAEX_N@Z PROC ; CvTacticalAnalysisCell::SetUnclaimedTerritory, COMDAT
; _this$ = ecx

; 228  : 		SetBit(TACTICAL_FLAG_UNCLAIMED_TERRITORY, bNewValue);

	cmp	BYTE PTR _bNewValue$[esp-4], 0
	je	SHORT $LN4@SetUnclaim
	or	DWORD PTR [ecx], 65536			; 00010000H

; 229  : 	};

	ret	4

; 228  : 		SetBit(TACTICAL_FLAG_UNCLAIMED_TERRITORY, bNewValue);

$LN4@SetUnclaim:
	and	DWORD PTR [ecx], -65537			; fffeffffH

; 229  : 	};

	ret	4
?SetUnclaimedTerritory@CvTacticalAnalysisCell@@QAEX_N@Z ENDP ; CvTacticalAnalysisCell::SetUnclaimedTerritory
_TEXT	ENDS
PUBLIC	?SetWithinRangeOfTarget@CvTacticalAnalysisCell@@QAEX_N@Z ; CvTacticalAnalysisCell::SetWithinRangeOfTarget
; Function compile flags: /Ogtpy
;	COMDAT ?SetWithinRangeOfTarget@CvTacticalAnalysisCell@@QAEX_N@Z
_TEXT	SEGMENT
_bNewValue$ = 8						; size = 1
?SetWithinRangeOfTarget@CvTacticalAnalysisCell@@QAEX_N@Z PROC ; CvTacticalAnalysisCell::SetWithinRangeOfTarget, COMDAT
; _this$ = ecx

; 237  : 		SetBit(TACTICAL_FLAG_WITHIN_RANGE_OF_TARGET, bNewValue);

	cmp	BYTE PTR _bNewValue$[esp-4], 0
	je	SHORT $LN4@SetWithinR
	or	DWORD PTR [ecx], 131072			; 00020000H

; 238  : 	};

	ret	4

; 237  : 		SetBit(TACTICAL_FLAG_WITHIN_RANGE_OF_TARGET, bNewValue);

$LN4@SetWithinR:
	and	DWORD PTR [ecx], -131073		; fffdffffH

; 238  : 	};

	ret	4
?SetWithinRangeOfTarget@CvTacticalAnalysisCell@@QAEX_N@Z ENDP ; CvTacticalAnalysisCell::SetWithinRangeOfTarget
_TEXT	ENDS
PUBLIC	?SetHelpsProvidesFlankBonus@CvTacticalAnalysisCell@@QAEX_N@Z ; CvTacticalAnalysisCell::SetHelpsProvidesFlankBonus
; Function compile flags: /Ogtpy
;	COMDAT ?SetHelpsProvidesFlankBonus@CvTacticalAnalysisCell@@QAEX_N@Z
_TEXT	SEGMENT
_bNewValue$ = 8						; size = 1
?SetHelpsProvidesFlankBonus@CvTacticalAnalysisCell@@QAEX_N@Z PROC ; CvTacticalAnalysisCell::SetHelpsProvidesFlankBonus, COMDAT
; _this$ = ecx

; 245  : 		SetBit(TACTICAL_FLAG_CAN_USE_TO_FLANK, bNewValue);

	cmp	BYTE PTR _bNewValue$[esp-4], 0
	je	SHORT $LN4@SetHelpsPr
	or	DWORD PTR [ecx], 262144			; 00040000H

; 246  : 	};

	ret	4

; 245  : 		SetBit(TACTICAL_FLAG_CAN_USE_TO_FLANK, bNewValue);

$LN4@SetHelpsPr:
	and	DWORD PTR [ecx], -262145		; fffbffffH

; 246  : 	};

	ret	4
?SetHelpsProvidesFlankBonus@CvTacticalAnalysisCell@@QAEX_N@Z ENDP ; CvTacticalAnalysisCell::SetHelpsProvidesFlankBonus
_TEXT	ENDS
PUBLIC	?SetSafeForDeployment@CvTacticalAnalysisCell@@QAEX_N@Z ; CvTacticalAnalysisCell::SetSafeForDeployment
; Function compile flags: /Ogtpy
;	COMDAT ?SetSafeForDeployment@CvTacticalAnalysisCell@@QAEX_N@Z
_TEXT	SEGMENT
_bNewValue$ = 8						; size = 1
?SetSafeForDeployment@CvTacticalAnalysisCell@@QAEX_N@Z PROC ; CvTacticalAnalysisCell::SetSafeForDeployment, COMDAT
; _this$ = ecx

; 253  : 		SetBit(TACTICAL_FLAG_SAFE_DEPLOYMENT, bNewValue);

	cmp	BYTE PTR _bNewValue$[esp-4], 0
	je	SHORT $LN4@SetSafeFor
	or	DWORD PTR [ecx], 524288			; 00080000H

; 254  : 	};

	ret	4

; 253  : 		SetBit(TACTICAL_FLAG_SAFE_DEPLOYMENT, bNewValue);

$LN4@SetSafeFor:
	and	DWORD PTR [ecx], -524289		; fff7ffffH

; 254  : 	};

	ret	4
?SetSafeForDeployment@CvTacticalAnalysisCell@@QAEX_N@Z ENDP ; CvTacticalAnalysisCell::SetSafeForDeployment
_TEXT	ENDS
PUBLIC	?GetEnemyMilitaryUnit@CvTacticalAnalysisCell@@QAEPAVCvUnit@@XZ ; CvTacticalAnalysisCell::GetEnemyMilitaryUnit
; Function compile flags: /Ogtpy
;	COMDAT ?GetEnemyMilitaryUnit@CvTacticalAnalysisCell@@QAEPAVCvUnit@@XZ
_TEXT	SEGMENT
?GetEnemyMilitaryUnit@CvTacticalAnalysisCell@@QAEPAVCvUnit@@XZ PROC ; CvTacticalAnalysisCell::GetEnemyMilitaryUnit, COMDAT
; _this$ = ecx

; 258  : 		return m_pEnemyMilitary;

	mov	eax, DWORD PTR [ecx+4]

; 259  : 	};

	ret	0
?GetEnemyMilitaryUnit@CvTacticalAnalysisCell@@QAEPAVCvUnit@@XZ ENDP ; CvTacticalAnalysisCell::GetEnemyMilitaryUnit
_TEXT	ENDS
PUBLIC	?SetEnemyMilitaryUnit@CvTacticalAnalysisCell@@QAEXPAVCvUnit@@@Z ; CvTacticalAnalysisCell::SetEnemyMilitaryUnit
; Function compile flags: /Ogtpy
;	COMDAT ?SetEnemyMilitaryUnit@CvTacticalAnalysisCell@@QAEXPAVCvUnit@@@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
?SetEnemyMilitaryUnit@CvTacticalAnalysisCell@@QAEXPAVCvUnit@@@Z PROC ; CvTacticalAnalysisCell::SetEnemyMilitaryUnit, COMDAT
; _this$ = ecx

; 262  : 		m_pEnemyMilitary = pUnit;

	mov	eax, DWORD PTR _pUnit$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 263  : 	};

	ret	4
?SetEnemyMilitaryUnit@CvTacticalAnalysisCell@@QAEXPAVCvUnit@@@Z ENDP ; CvTacticalAnalysisCell::SetEnemyMilitaryUnit
_TEXT	ENDS
PUBLIC	?GetNeutralMilitaryUnit@CvTacticalAnalysisCell@@QAEPAVCvUnit@@XZ ; CvTacticalAnalysisCell::GetNeutralMilitaryUnit
; Function compile flags: /Ogtpy
;	COMDAT ?GetNeutralMilitaryUnit@CvTacticalAnalysisCell@@QAEPAVCvUnit@@XZ
_TEXT	SEGMENT
?GetNeutralMilitaryUnit@CvTacticalAnalysisCell@@QAEPAVCvUnit@@XZ PROC ; CvTacticalAnalysisCell::GetNeutralMilitaryUnit, COMDAT
; _this$ = ecx

; 266  : 		return m_pNeutralMilitary;

	mov	eax, DWORD PTR [ecx+12]

; 267  : 	};

	ret	0
?GetNeutralMilitaryUnit@CvTacticalAnalysisCell@@QAEPAVCvUnit@@XZ ENDP ; CvTacticalAnalysisCell::GetNeutralMilitaryUnit
_TEXT	ENDS
PUBLIC	?SetNeutralMilitaryUnit@CvTacticalAnalysisCell@@QAEXPAVCvUnit@@@Z ; CvTacticalAnalysisCell::SetNeutralMilitaryUnit
; Function compile flags: /Ogtpy
;	COMDAT ?SetNeutralMilitaryUnit@CvTacticalAnalysisCell@@QAEXPAVCvUnit@@@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
?SetNeutralMilitaryUnit@CvTacticalAnalysisCell@@QAEXPAVCvUnit@@@Z PROC ; CvTacticalAnalysisCell::SetNeutralMilitaryUnit, COMDAT
; _this$ = ecx

; 270  : 		m_pNeutralMilitary = pUnit;

	mov	eax, DWORD PTR _pUnit$[esp-4]
	mov	DWORD PTR [ecx+12], eax

; 271  : 	};

	ret	4
?SetNeutralMilitaryUnit@CvTacticalAnalysisCell@@QAEXPAVCvUnit@@@Z ENDP ; CvTacticalAnalysisCell::SetNeutralMilitaryUnit
_TEXT	ENDS
PUBLIC	?GetFriendlyMilitaryUnit@CvTacticalAnalysisCell@@QAEPAVCvUnit@@XZ ; CvTacticalAnalysisCell::GetFriendlyMilitaryUnit
; Function compile flags: /Ogtpy
;	COMDAT ?GetFriendlyMilitaryUnit@CvTacticalAnalysisCell@@QAEPAVCvUnit@@XZ
_TEXT	SEGMENT
?GetFriendlyMilitaryUnit@CvTacticalAnalysisCell@@QAEPAVCvUnit@@XZ PROC ; CvTacticalAnalysisCell::GetFriendlyMilitaryUnit, COMDAT
; _this$ = ecx

; 274  : 		return m_pFriendlyMilitary;

	mov	eax, DWORD PTR [ecx+20]

; 275  : 	};

	ret	0
?GetFriendlyMilitaryUnit@CvTacticalAnalysisCell@@QAEPAVCvUnit@@XZ ENDP ; CvTacticalAnalysisCell::GetFriendlyMilitaryUnit
_TEXT	ENDS
PUBLIC	?SetFriendlyMilitaryUnit@CvTacticalAnalysisCell@@QAEXPAVCvUnit@@@Z ; CvTacticalAnalysisCell::SetFriendlyMilitaryUnit
; Function compile flags: /Ogtpy
;	COMDAT ?SetFriendlyMilitaryUnit@CvTacticalAnalysisCell@@QAEXPAVCvUnit@@@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
?SetFriendlyMilitaryUnit@CvTacticalAnalysisCell@@QAEXPAVCvUnit@@@Z PROC ; CvTacticalAnalysisCell::SetFriendlyMilitaryUnit, COMDAT
; _this$ = ecx

; 278  : 		m_pFriendlyMilitary = pUnit;

	mov	eax, DWORD PTR _pUnit$[esp-4]
	mov	DWORD PTR [ecx+20], eax

; 279  : 	};

	ret	4
?SetFriendlyMilitaryUnit@CvTacticalAnalysisCell@@QAEXPAVCvUnit@@@Z ENDP ; CvTacticalAnalysisCell::SetFriendlyMilitaryUnit
_TEXT	ENDS
PUBLIC	?SetEnemyCivilianUnit@CvTacticalAnalysisCell@@QAEXPAVCvUnit@@@Z ; CvTacticalAnalysisCell::SetEnemyCivilianUnit
; Function compile flags: /Ogtpy
;	COMDAT ?SetEnemyCivilianUnit@CvTacticalAnalysisCell@@QAEXPAVCvUnit@@@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
?SetEnemyCivilianUnit@CvTacticalAnalysisCell@@QAEXPAVCvUnit@@@Z PROC ; CvTacticalAnalysisCell::SetEnemyCivilianUnit, COMDAT
; _this$ = ecx

; 286  : 		m_pEnemyCivilian = pUnit;

	mov	eax, DWORD PTR _pUnit$[esp-4]
	mov	DWORD PTR [ecx+8], eax

; 287  : 	};

	ret	4
?SetEnemyCivilianUnit@CvTacticalAnalysisCell@@QAEXPAVCvUnit@@@Z ENDP ; CvTacticalAnalysisCell::SetEnemyCivilianUnit
_TEXT	ENDS
PUBLIC	?GetNeutralCivilianUnit@CvTacticalAnalysisCell@@QAEPAVCvUnit@@XZ ; CvTacticalAnalysisCell::GetNeutralCivilianUnit
; Function compile flags: /Ogtpy
;	COMDAT ?GetNeutralCivilianUnit@CvTacticalAnalysisCell@@QAEPAVCvUnit@@XZ
_TEXT	SEGMENT
?GetNeutralCivilianUnit@CvTacticalAnalysisCell@@QAEPAVCvUnit@@XZ PROC ; CvTacticalAnalysisCell::GetNeutralCivilianUnit, COMDAT
; _this$ = ecx

; 290  : 		return m_pNeutralCivilian;

	mov	eax, DWORD PTR [ecx+16]

; 291  : 	};

	ret	0
?GetNeutralCivilianUnit@CvTacticalAnalysisCell@@QAEPAVCvUnit@@XZ ENDP ; CvTacticalAnalysisCell::GetNeutralCivilianUnit
_TEXT	ENDS
PUBLIC	?SetNeutralCivilianUnit@CvTacticalAnalysisCell@@QAEXPAVCvUnit@@@Z ; CvTacticalAnalysisCell::SetNeutralCivilianUnit
; Function compile flags: /Ogtpy
;	COMDAT ?SetNeutralCivilianUnit@CvTacticalAnalysisCell@@QAEXPAVCvUnit@@@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
?SetNeutralCivilianUnit@CvTacticalAnalysisCell@@QAEXPAVCvUnit@@@Z PROC ; CvTacticalAnalysisCell::SetNeutralCivilianUnit, COMDAT
; _this$ = ecx

; 294  : 		m_pNeutralCivilian = pUnit;

	mov	eax, DWORD PTR _pUnit$[esp-4]
	mov	DWORD PTR [ecx+16], eax

; 295  : 	};

	ret	4
?SetNeutralCivilianUnit@CvTacticalAnalysisCell@@QAEXPAVCvUnit@@@Z ENDP ; CvTacticalAnalysisCell::SetNeutralCivilianUnit
_TEXT	ENDS
PUBLIC	?SetFriendlyCivilianUnit@CvTacticalAnalysisCell@@QAEXPAVCvUnit@@@Z ; CvTacticalAnalysisCell::SetFriendlyCivilianUnit
; Function compile flags: /Ogtpy
;	COMDAT ?SetFriendlyCivilianUnit@CvTacticalAnalysisCell@@QAEXPAVCvUnit@@@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
?SetFriendlyCivilianUnit@CvTacticalAnalysisCell@@QAEXPAVCvUnit@@@Z PROC ; CvTacticalAnalysisCell::SetFriendlyCivilianUnit, COMDAT
; _this$ = ecx

; 302  : 		m_pFriendlyCivilian = pUnit;

	mov	eax, DWORD PTR _pUnit$[esp-4]
	mov	DWORD PTR [ecx+24], eax

; 303  : 	};

	ret	4
?SetFriendlyCivilianUnit@CvTacticalAnalysisCell@@QAEXPAVCvUnit@@@Z ENDP ; CvTacticalAnalysisCell::SetFriendlyCivilianUnit
_TEXT	ENDS
PUBLIC	?SetDefenseModifier@CvTacticalAnalysisCell@@QAEXH@Z ; CvTacticalAnalysisCell::SetDefenseModifier
; Function compile flags: /Ogtpy
;	COMDAT ?SetDefenseModifier@CvTacticalAnalysisCell@@QAEXH@Z
_TEXT	SEGMENT
_iModifier$ = 8						; size = 4
?SetDefenseModifier@CvTacticalAnalysisCell@@QAEXH@Z PROC ; CvTacticalAnalysisCell::SetDefenseModifier, COMDAT
; _this$ = ecx

; 311  : 		m_iDefenseModifier = iModifier;

	mov	eax, DWORD PTR _iModifier$[esp-4]
	mov	DWORD PTR [ecx+28], eax

; 312  : 	};

	ret	4
?SetDefenseModifier@CvTacticalAnalysisCell@@QAEXH@Z ENDP ; CvTacticalAnalysisCell::SetDefenseModifier
_TEXT	ENDS
PUBLIC	?SetDeploymentScore@CvTacticalAnalysisCell@@QAEXH@Z ; CvTacticalAnalysisCell::SetDeploymentScore
; Function compile flags: /Ogtpy
;	COMDAT ?SetDeploymentScore@CvTacticalAnalysisCell@@QAEXH@Z
_TEXT	SEGMENT
_iScore$ = 8						; size = 4
?SetDeploymentScore@CvTacticalAnalysisCell@@QAEXH@Z PROC ; CvTacticalAnalysisCell::SetDeploymentScore, COMDAT
; _this$ = ecx

; 319  : 		m_iDeploymentScore = iScore;

	mov	eax, DWORD PTR _iScore$[esp-4]
	mov	DWORD PTR [ecx+32], eax

; 320  : 	};

	ret	4
?SetDeploymentScore@CvTacticalAnalysisCell@@QAEXH@Z ENDP ; CvTacticalAnalysisCell::SetDeploymentScore
_TEXT	ENDS
PUBLIC	?GetDominanceZone@CvTacticalAnalysisCell@@QBEHXZ ; CvTacticalAnalysisCell::GetDominanceZone
; Function compile flags: /Ogtpy
;	COMDAT ?GetDominanceZone@CvTacticalAnalysisCell@@QBEHXZ
_TEXT	SEGMENT
?GetDominanceZone@CvTacticalAnalysisCell@@QBEHXZ PROC	; CvTacticalAnalysisCell::GetDominanceZone, COMDAT
; _this$ = ecx

; 323  : 		return m_iDominanceZoneID;

	mov	eax, DWORD PTR [ecx+40]

; 324  : 	};

	ret	0
?GetDominanceZone@CvTacticalAnalysisCell@@QBEHXZ ENDP	; CvTacticalAnalysisCell::GetDominanceZone
_TEXT	ENDS
PUBLIC	?SetDominanceZone@CvTacticalAnalysisCell@@QAEXH@Z ; CvTacticalAnalysisCell::SetDominanceZone
; Function compile flags: /Ogtpy
;	COMDAT ?SetDominanceZone@CvTacticalAnalysisCell@@QAEXH@Z
_TEXT	SEGMENT
_iZone$ = 8						; size = 4
?SetDominanceZone@CvTacticalAnalysisCell@@QAEXH@Z PROC	; CvTacticalAnalysisCell::SetDominanceZone, COMDAT
; _this$ = ecx

; 327  : 		m_iDominanceZoneID = iZone;

	mov	eax, DWORD PTR _iZone$[esp-4]
	mov	DWORD PTR [ecx+40], eax

; 328  : 	};

	ret	4
?SetDominanceZone@CvTacticalAnalysisCell@@QAEXH@Z ENDP	; CvTacticalAnalysisCell::SetDominanceZone
_TEXT	ENDS
PUBLIC	??MCvTacticalDominanceZone@@QBE_NABV0@@Z	; CvTacticalDominanceZone::operator<
; Function compile flags: /Ogtpy
;	COMDAT ??MCvTacticalDominanceZone@@QBE_NABV0@@Z
_TEXT	SEGMENT
_zone$ = 8						; size = 4
??MCvTacticalDominanceZone@@QBE_NABV0@@Z PROC		; CvTacticalDominanceZone::operator<, COMDAT
; _this$ = ecx

; 390  : 		return (m_iZoneValue > zone.m_iZoneValue);

	mov	eax, DWORD PTR [ecx+60]
	mov	edx, DWORD PTR _zone$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+60]
	setg	cl
	mov	al, cl

; 391  : 	}

	ret	4
??MCvTacticalDominanceZone@@QBE_NABV0@@Z ENDP		; CvTacticalDominanceZone::operator<
_TEXT	ENDS
PUBLIC	?GetDominanceZoneID@CvTacticalDominanceZone@@QBEHXZ ; CvTacticalDominanceZone::GetDominanceZoneID
; Function compile flags: /Ogtpy
;	COMDAT ?GetDominanceZoneID@CvTacticalDominanceZone@@QBEHXZ
_TEXT	SEGMENT
?GetDominanceZoneID@CvTacticalDominanceZone@@QBEHXZ PROC ; CvTacticalDominanceZone::GetDominanceZoneID, COMDAT
; _this$ = ecx

; 396  : 		return m_iDominanceZoneID;

	mov	eax, DWORD PTR [ecx]

; 397  : 	};

	ret	0
?GetDominanceZoneID@CvTacticalDominanceZone@@QBEHXZ ENDP ; CvTacticalDominanceZone::GetDominanceZoneID
_TEXT	ENDS
PUBLIC	?SetDominanceZoneID@CvTacticalDominanceZone@@QAEXH@Z ; CvTacticalDominanceZone::SetDominanceZoneID
; Function compile flags: /Ogtpy
;	COMDAT ?SetDominanceZoneID@CvTacticalDominanceZone@@QAEXH@Z
_TEXT	SEGMENT
_iID$ = 8						; size = 4
?SetDominanceZoneID@CvTacticalDominanceZone@@QAEXH@Z PROC ; CvTacticalDominanceZone::SetDominanceZoneID, COMDAT
; _this$ = ecx

; 400  : 		m_iDominanceZoneID = iID;

	mov	eax, DWORD PTR _iID$[esp-4]
	mov	DWORD PTR [ecx], eax

; 401  : 	};

	ret	4
?SetDominanceZoneID@CvTacticalDominanceZone@@QAEXH@Z ENDP ; CvTacticalDominanceZone::SetDominanceZoneID
_TEXT	ENDS
PUBLIC	?GetTerritoryType@CvTacticalDominanceZone@@QBE?AW4eDominanceTerritoryTypes@@XZ ; CvTacticalDominanceZone::GetTerritoryType
; Function compile flags: /Ogtpy
;	COMDAT ?GetTerritoryType@CvTacticalDominanceZone@@QBE?AW4eDominanceTerritoryTypes@@XZ
_TEXT	SEGMENT
?GetTerritoryType@CvTacticalDominanceZone@@QBE?AW4eDominanceTerritoryTypes@@XZ PROC ; CvTacticalDominanceZone::GetTerritoryType, COMDAT
; _this$ = ecx

; 404  : 		return m_eTerritoryType;

	mov	eax, DWORD PTR [ecx+4]

; 405  : 	};

	ret	0
?GetTerritoryType@CvTacticalDominanceZone@@QBE?AW4eDominanceTerritoryTypes@@XZ ENDP ; CvTacticalDominanceZone::GetTerritoryType
_TEXT	ENDS
PUBLIC	?SetTerritoryType@CvTacticalDominanceZone@@QAEXW4eDominanceTerritoryTypes@@@Z ; CvTacticalDominanceZone::SetTerritoryType
; Function compile flags: /Ogtpy
;	COMDAT ?SetTerritoryType@CvTacticalDominanceZone@@QAEXW4eDominanceTerritoryTypes@@@Z
_TEXT	SEGMENT
_eTerritoryType$ = 8					; size = 4
?SetTerritoryType@CvTacticalDominanceZone@@QAEXW4eDominanceTerritoryTypes@@@Z PROC ; CvTacticalDominanceZone::SetTerritoryType, COMDAT
; _this$ = ecx

; 408  : 		m_eTerritoryType = eTerritoryType;

	mov	eax, DWORD PTR _eTerritoryType$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 409  : 	};

	ret	4
?SetTerritoryType@CvTacticalDominanceZone@@QAEXW4eDominanceTerritoryTypes@@@Z ENDP ; CvTacticalDominanceZone::SetTerritoryType
_TEXT	ENDS
PUBLIC	?GetDominanceFlag@CvTacticalDominanceZone@@QBE?AW4eTacticalDominanceFlags@@XZ ; CvTacticalDominanceZone::GetDominanceFlag
; Function compile flags: /Ogtpy
;	COMDAT ?GetDominanceFlag@CvTacticalDominanceZone@@QBE?AW4eTacticalDominanceFlags@@XZ
_TEXT	SEGMENT
?GetDominanceFlag@CvTacticalDominanceZone@@QBE?AW4eTacticalDominanceFlags@@XZ PROC ; CvTacticalDominanceZone::GetDominanceFlag, COMDAT
; _this$ = ecx

; 412  : 		return m_eDominanceFlag;

	mov	eax, DWORD PTR [ecx+8]

; 413  : 	};

	ret	0
?GetDominanceFlag@CvTacticalDominanceZone@@QBE?AW4eTacticalDominanceFlags@@XZ ENDP ; CvTacticalDominanceZone::GetDominanceFlag
_TEXT	ENDS
PUBLIC	?SetDominanceFlag@CvTacticalDominanceZone@@QAEXW4eTacticalDominanceFlags@@@Z ; CvTacticalDominanceZone::SetDominanceFlag
; Function compile flags: /Ogtpy
;	COMDAT ?SetDominanceFlag@CvTacticalDominanceZone@@QAEXW4eTacticalDominanceFlags@@@Z
_TEXT	SEGMENT
_eDominanceFlag$ = 8					; size = 4
?SetDominanceFlag@CvTacticalDominanceZone@@QAEXW4eTacticalDominanceFlags@@@Z PROC ; CvTacticalDominanceZone::SetDominanceFlag, COMDAT
; _this$ = ecx

; 416  : 		m_eDominanceFlag = eDominanceFlag;

	mov	eax, DWORD PTR _eDominanceFlag$[esp-4]
	mov	DWORD PTR [ecx+8], eax

; 417  : 	};

	ret	4
?SetDominanceFlag@CvTacticalDominanceZone@@QAEXW4eTacticalDominanceFlags@@@Z ENDP ; CvTacticalDominanceZone::SetDominanceFlag
_TEXT	ENDS
PUBLIC	?GetOwner@CvTacticalDominanceZone@@QBE?AW4PlayerTypes@@XZ ; CvTacticalDominanceZone::GetOwner
; Function compile flags: /Ogtpy
;	COMDAT ?GetOwner@CvTacticalDominanceZone@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetOwner@CvTacticalDominanceZone@@QBE?AW4PlayerTypes@@XZ PROC ; CvTacticalDominanceZone::GetOwner, COMDAT
; _this$ = ecx

; 420  : 		return m_eOwner;

	mov	eax, DWORD PTR [ecx+12]

; 421  : 	};

	ret	0
?GetOwner@CvTacticalDominanceZone@@QBE?AW4PlayerTypes@@XZ ENDP ; CvTacticalDominanceZone::GetOwner
_TEXT	ENDS
PUBLIC	?SetOwner@CvTacticalDominanceZone@@QAEXW4PlayerTypes@@@Z ; CvTacticalDominanceZone::SetOwner
; Function compile flags: /Ogtpy
;	COMDAT ?SetOwner@CvTacticalDominanceZone@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_eOwner$ = 8						; size = 4
?SetOwner@CvTacticalDominanceZone@@QAEXW4PlayerTypes@@@Z PROC ; CvTacticalDominanceZone::SetOwner, COMDAT
; _this$ = ecx

; 424  : 		m_eOwner = eOwner;

	mov	eax, DWORD PTR _eOwner$[esp-4]
	mov	DWORD PTR [ecx+12], eax

; 425  : 	};

	ret	4
?SetOwner@CvTacticalDominanceZone@@QAEXW4PlayerTypes@@@Z ENDP ; CvTacticalDominanceZone::SetOwner
_TEXT	ENDS
PUBLIC	?GetAreaID@CvTacticalDominanceZone@@QBEHXZ	; CvTacticalDominanceZone::GetAreaID
; Function compile flags: /Ogtpy
;	COMDAT ?GetAreaID@CvTacticalDominanceZone@@QBEHXZ
_TEXT	SEGMENT
?GetAreaID@CvTacticalDominanceZone@@QBEHXZ PROC		; CvTacticalDominanceZone::GetAreaID, COMDAT
; _this$ = ecx

; 432  : 		return m_iAreaID;

	mov	eax, DWORD PTR [ecx+20]

; 433  : 	};

	ret	0
?GetAreaID@CvTacticalDominanceZone@@QBEHXZ ENDP		; CvTacticalDominanceZone::GetAreaID
_TEXT	ENDS
PUBLIC	?SetAreaID@CvTacticalDominanceZone@@QAEXH@Z	; CvTacticalDominanceZone::SetAreaID
; Function compile flags: /Ogtpy
;	COMDAT ?SetAreaID@CvTacticalDominanceZone@@QAEXH@Z
_TEXT	SEGMENT
_iID$ = 8						; size = 4
?SetAreaID@CvTacticalDominanceZone@@QAEXH@Z PROC	; CvTacticalDominanceZone::SetAreaID, COMDAT
; _this$ = ecx

; 436  : 		m_iAreaID = iID;

	mov	eax, DWORD PTR _iID$[esp-4]
	mov	DWORD PTR [ecx+20], eax

; 437  : 	};

	ret	4
?SetAreaID@CvTacticalDominanceZone@@QAEXH@Z ENDP	; CvTacticalDominanceZone::SetAreaID
_TEXT	ENDS
PUBLIC	?GetFriendlyStrength@CvTacticalDominanceZone@@QBEHXZ ; CvTacticalDominanceZone::GetFriendlyStrength
; Function compile flags: /Ogtpy
;	COMDAT ?GetFriendlyStrength@CvTacticalDominanceZone@@QBEHXZ
_TEXT	SEGMENT
?GetFriendlyStrength@CvTacticalDominanceZone@@QBEHXZ PROC ; CvTacticalDominanceZone::GetFriendlyStrength, COMDAT
; _this$ = ecx

; 440  : 		return m_iFriendlyStrength;

	mov	eax, DWORD PTR [ecx+24]

; 441  : 	};

	ret	0
?GetFriendlyStrength@CvTacticalDominanceZone@@QBEHXZ ENDP ; CvTacticalDominanceZone::GetFriendlyStrength
_TEXT	ENDS
PUBLIC	?AddFriendlyStrength@CvTacticalDominanceZone@@QAEXH@Z ; CvTacticalDominanceZone::AddFriendlyStrength
; Function compile flags: /Ogtpy
;	COMDAT ?AddFriendlyStrength@CvTacticalDominanceZone@@QAEXH@Z
_TEXT	SEGMENT
_iStrength$ = 8						; size = 4
?AddFriendlyStrength@CvTacticalDominanceZone@@QAEXH@Z PROC ; CvTacticalDominanceZone::AddFriendlyStrength, COMDAT
; _this$ = ecx

; 444  : 		m_iFriendlyStrength += iStrength;

	mov	eax, DWORD PTR _iStrength$[esp-4]
	add	DWORD PTR [ecx+24], eax

; 445  : 	};

	ret	4
?AddFriendlyStrength@CvTacticalDominanceZone@@QAEXH@Z ENDP ; CvTacticalDominanceZone::AddFriendlyStrength
_TEXT	ENDS
PUBLIC	?GetEnemyStrength@CvTacticalDominanceZone@@QBEHXZ ; CvTacticalDominanceZone::GetEnemyStrength
; Function compile flags: /Ogtpy
;	COMDAT ?GetEnemyStrength@CvTacticalDominanceZone@@QBEHXZ
_TEXT	SEGMENT
?GetEnemyStrength@CvTacticalDominanceZone@@QBEHXZ PROC	; CvTacticalDominanceZone::GetEnemyStrength, COMDAT
; _this$ = ecx

; 448  : 		return m_iEnemyStrength;

	mov	eax, DWORD PTR [ecx+28]

; 449  : 	};

	ret	0
?GetEnemyStrength@CvTacticalDominanceZone@@QBEHXZ ENDP	; CvTacticalDominanceZone::GetEnemyStrength
_TEXT	ENDS
PUBLIC	?AddEnemyStrength@CvTacticalDominanceZone@@QAEXH@Z ; CvTacticalDominanceZone::AddEnemyStrength
; Function compile flags: /Ogtpy
;	COMDAT ?AddEnemyStrength@CvTacticalDominanceZone@@QAEXH@Z
_TEXT	SEGMENT
_iStrength$ = 8						; size = 4
?AddEnemyStrength@CvTacticalDominanceZone@@QAEXH@Z PROC	; CvTacticalDominanceZone::AddEnemyStrength, COMDAT
; _this$ = ecx

; 452  : 		m_iEnemyStrength += iStrength;

	mov	eax, DWORD PTR _iStrength$[esp-4]
	add	DWORD PTR [ecx+28], eax

; 453  : 	};

	ret	4
?AddEnemyStrength@CvTacticalDominanceZone@@QAEXH@Z ENDP	; CvTacticalDominanceZone::AddEnemyStrength
_TEXT	ENDS
PUBLIC	?GetFriendlyRangedStrength@CvTacticalDominanceZone@@QBEHXZ ; CvTacticalDominanceZone::GetFriendlyRangedStrength
; Function compile flags: /Ogtpy
;	COMDAT ?GetFriendlyRangedStrength@CvTacticalDominanceZone@@QBEHXZ
_TEXT	SEGMENT
?GetFriendlyRangedStrength@CvTacticalDominanceZone@@QBEHXZ PROC ; CvTacticalDominanceZone::GetFriendlyRangedStrength, COMDAT
; _this$ = ecx

; 456  : 		return m_iFriendlyRangedStrength;

	mov	eax, DWORD PTR [ecx+32]

; 457  : 	};

	ret	0
?GetFriendlyRangedStrength@CvTacticalDominanceZone@@QBEHXZ ENDP ; CvTacticalDominanceZone::GetFriendlyRangedStrength
_TEXT	ENDS
PUBLIC	?AddFriendlyRangedStrength@CvTacticalDominanceZone@@QAEXH@Z ; CvTacticalDominanceZone::AddFriendlyRangedStrength
; Function compile flags: /Ogtpy
;	COMDAT ?AddFriendlyRangedStrength@CvTacticalDominanceZone@@QAEXH@Z
_TEXT	SEGMENT
_iRangedStrength$ = 8					; size = 4
?AddFriendlyRangedStrength@CvTacticalDominanceZone@@QAEXH@Z PROC ; CvTacticalDominanceZone::AddFriendlyRangedStrength, COMDAT
; _this$ = ecx

; 460  : 		m_iFriendlyRangedStrength += iRangedStrength;

	mov	eax, DWORD PTR _iRangedStrength$[esp-4]
	add	DWORD PTR [ecx+32], eax

; 461  : 	};

	ret	4
?AddFriendlyRangedStrength@CvTacticalDominanceZone@@QAEXH@Z ENDP ; CvTacticalDominanceZone::AddFriendlyRangedStrength
_TEXT	ENDS
PUBLIC	?GetEnemyRangedStrength@CvTacticalDominanceZone@@QBEHXZ ; CvTacticalDominanceZone::GetEnemyRangedStrength
; Function compile flags: /Ogtpy
;	COMDAT ?GetEnemyRangedStrength@CvTacticalDominanceZone@@QBEHXZ
_TEXT	SEGMENT
?GetEnemyRangedStrength@CvTacticalDominanceZone@@QBEHXZ PROC ; CvTacticalDominanceZone::GetEnemyRangedStrength, COMDAT
; _this$ = ecx

; 464  : 		return m_iEnemyRangedStrength;

	mov	eax, DWORD PTR [ecx+36]

; 465  : 	};

	ret	0
?GetEnemyRangedStrength@CvTacticalDominanceZone@@QBEHXZ ENDP ; CvTacticalDominanceZone::GetEnemyRangedStrength
_TEXT	ENDS
PUBLIC	?AddEnemyRangedStrength@CvTacticalDominanceZone@@QAEXH@Z ; CvTacticalDominanceZone::AddEnemyRangedStrength
; Function compile flags: /Ogtpy
;	COMDAT ?AddEnemyRangedStrength@CvTacticalDominanceZone@@QAEXH@Z
_TEXT	SEGMENT
_iRangedStrength$ = 8					; size = 4
?AddEnemyRangedStrength@CvTacticalDominanceZone@@QAEXH@Z PROC ; CvTacticalDominanceZone::AddEnemyRangedStrength, COMDAT
; _this$ = ecx

; 468  : 		m_iEnemyRangedStrength += iRangedStrength;

	mov	eax, DWORD PTR _iRangedStrength$[esp-4]
	add	DWORD PTR [ecx+36], eax

; 469  : 	};

	ret	4
?AddEnemyRangedStrength@CvTacticalDominanceZone@@QAEXH@Z ENDP ; CvTacticalDominanceZone::AddEnemyRangedStrength
_TEXT	ENDS
PUBLIC	?GetFriendlyUnitCount@CvTacticalDominanceZone@@QBEHXZ ; CvTacticalDominanceZone::GetFriendlyUnitCount
; Function compile flags: /Ogtpy
;	COMDAT ?GetFriendlyUnitCount@CvTacticalDominanceZone@@QBEHXZ
_TEXT	SEGMENT
?GetFriendlyUnitCount@CvTacticalDominanceZone@@QBEHXZ PROC ; CvTacticalDominanceZone::GetFriendlyUnitCount, COMDAT
; _this$ = ecx

; 472  : 		return m_iFriendlyUnitCount;

	mov	eax, DWORD PTR [ecx+40]

; 473  : 	};

	ret	0
?GetFriendlyUnitCount@CvTacticalDominanceZone@@QBEHXZ ENDP ; CvTacticalDominanceZone::GetFriendlyUnitCount
_TEXT	ENDS
PUBLIC	?AddFriendlyUnitCount@CvTacticalDominanceZone@@QAEXH@Z ; CvTacticalDominanceZone::AddFriendlyUnitCount
; Function compile flags: /Ogtpy
;	COMDAT ?AddFriendlyUnitCount@CvTacticalDominanceZone@@QAEXH@Z
_TEXT	SEGMENT
_iUnitCount$ = 8					; size = 4
?AddFriendlyUnitCount@CvTacticalDominanceZone@@QAEXH@Z PROC ; CvTacticalDominanceZone::AddFriendlyUnitCount, COMDAT
; _this$ = ecx

; 476  : 		m_iFriendlyUnitCount += iUnitCount;

	mov	eax, DWORD PTR _iUnitCount$[esp-4]
	add	DWORD PTR [ecx+40], eax

; 477  : 	};

	ret	4
?AddFriendlyUnitCount@CvTacticalDominanceZone@@QAEXH@Z ENDP ; CvTacticalDominanceZone::AddFriendlyUnitCount
_TEXT	ENDS
PUBLIC	?GetEnemyUnitCount@CvTacticalDominanceZone@@QBEHXZ ; CvTacticalDominanceZone::GetEnemyUnitCount
; Function compile flags: /Ogtpy
;	COMDAT ?GetEnemyUnitCount@CvTacticalDominanceZone@@QBEHXZ
_TEXT	SEGMENT
?GetEnemyUnitCount@CvTacticalDominanceZone@@QBEHXZ PROC	; CvTacticalDominanceZone::GetEnemyUnitCount, COMDAT
; _this$ = ecx

; 480  : 		return m_iEnemyUnitCount;

	mov	eax, DWORD PTR [ecx+44]

; 481  : 	};

	ret	0
?GetEnemyUnitCount@CvTacticalDominanceZone@@QBEHXZ ENDP	; CvTacticalDominanceZone::GetEnemyUnitCount
_TEXT	ENDS
PUBLIC	?AddEnemyUnitCount@CvTacticalDominanceZone@@QAEXH@Z ; CvTacticalDominanceZone::AddEnemyUnitCount
; Function compile flags: /Ogtpy
;	COMDAT ?AddEnemyUnitCount@CvTacticalDominanceZone@@QAEXH@Z
_TEXT	SEGMENT
_iUnitCount$ = 8					; size = 4
?AddEnemyUnitCount@CvTacticalDominanceZone@@QAEXH@Z PROC ; CvTacticalDominanceZone::AddEnemyUnitCount, COMDAT
; _this$ = ecx

; 484  : 		m_iEnemyUnitCount += iUnitCount;

	mov	eax, DWORD PTR _iUnitCount$[esp-4]
	add	DWORD PTR [ecx+44], eax

; 485  : 	};

	ret	4
?AddEnemyUnitCount@CvTacticalDominanceZone@@QAEXH@Z ENDP ; CvTacticalDominanceZone::AddEnemyUnitCount
_TEXT	ENDS
PUBLIC	?GetFriendlyRangedUnitCount@CvTacticalDominanceZone@@QBEHXZ ; CvTacticalDominanceZone::GetFriendlyRangedUnitCount
; Function compile flags: /Ogtpy
;	COMDAT ?GetFriendlyRangedUnitCount@CvTacticalDominanceZone@@QBEHXZ
_TEXT	SEGMENT
?GetFriendlyRangedUnitCount@CvTacticalDominanceZone@@QBEHXZ PROC ; CvTacticalDominanceZone::GetFriendlyRangedUnitCount, COMDAT
; _this$ = ecx

; 488  : 		return m_iFriendlyRangedUnitCount;

	mov	eax, DWORD PTR [ecx+48]

; 489  : 	};

	ret	0
?GetFriendlyRangedUnitCount@CvTacticalDominanceZone@@QBEHXZ ENDP ; CvTacticalDominanceZone::GetFriendlyRangedUnitCount
_TEXT	ENDS
PUBLIC	?AddFriendlyRangedUnitCount@CvTacticalDominanceZone@@QAEXH@Z ; CvTacticalDominanceZone::AddFriendlyRangedUnitCount
; Function compile flags: /Ogtpy
;	COMDAT ?AddFriendlyRangedUnitCount@CvTacticalDominanceZone@@QAEXH@Z
_TEXT	SEGMENT
_iUnitCount$ = 8					; size = 4
?AddFriendlyRangedUnitCount@CvTacticalDominanceZone@@QAEXH@Z PROC ; CvTacticalDominanceZone::AddFriendlyRangedUnitCount, COMDAT
; _this$ = ecx

; 492  : 		m_iFriendlyRangedUnitCount += iUnitCount;

	mov	eax, DWORD PTR _iUnitCount$[esp-4]
	add	DWORD PTR [ecx+48], eax

; 493  : 	};

	ret	4
?AddFriendlyRangedUnitCount@CvTacticalDominanceZone@@QAEXH@Z ENDP ; CvTacticalDominanceZone::AddFriendlyRangedUnitCount
_TEXT	ENDS
PUBLIC	?GetEnemyRangedUnitCount@CvTacticalDominanceZone@@QBEHXZ ; CvTacticalDominanceZone::GetEnemyRangedUnitCount
; Function compile flags: /Ogtpy
;	COMDAT ?GetEnemyRangedUnitCount@CvTacticalDominanceZone@@QBEHXZ
_TEXT	SEGMENT
?GetEnemyRangedUnitCount@CvTacticalDominanceZone@@QBEHXZ PROC ; CvTacticalDominanceZone::GetEnemyRangedUnitCount, COMDAT
; _this$ = ecx

; 496  : 		return m_iEnemyRangedUnitCount;

	mov	eax, DWORD PTR [ecx+52]

; 497  : 	};

	ret	0
?GetEnemyRangedUnitCount@CvTacticalDominanceZone@@QBEHXZ ENDP ; CvTacticalDominanceZone::GetEnemyRangedUnitCount
_TEXT	ENDS
PUBLIC	?AddEnemyRangedUnitCount@CvTacticalDominanceZone@@QAEXH@Z ; CvTacticalDominanceZone::AddEnemyRangedUnitCount
; Function compile flags: /Ogtpy
;	COMDAT ?AddEnemyRangedUnitCount@CvTacticalDominanceZone@@QAEXH@Z
_TEXT	SEGMENT
_iUnitCount$ = 8					; size = 4
?AddEnemyRangedUnitCount@CvTacticalDominanceZone@@QAEXH@Z PROC ; CvTacticalDominanceZone::AddEnemyRangedUnitCount, COMDAT
; _this$ = ecx

; 500  : 		m_iEnemyRangedUnitCount += iUnitCount;

	mov	eax, DWORD PTR _iUnitCount$[esp-4]
	add	DWORD PTR [ecx+52], eax

; 501  : 	};

	ret	4
?AddEnemyRangedUnitCount@CvTacticalDominanceZone@@QAEXH@Z ENDP ; CvTacticalDominanceZone::AddEnemyRangedUnitCount
_TEXT	ENDS
PUBLIC	?AddEnemyNavalUnitCount@CvTacticalDominanceZone@@QAEXH@Z ; CvTacticalDominanceZone::AddEnemyNavalUnitCount
; Function compile flags: /Ogtpy
;	COMDAT ?AddEnemyNavalUnitCount@CvTacticalDominanceZone@@QAEXH@Z
_TEXT	SEGMENT
_iUnitCount$ = 8					; size = 4
?AddEnemyNavalUnitCount@CvTacticalDominanceZone@@QAEXH@Z PROC ; CvTacticalDominanceZone::AddEnemyNavalUnitCount, COMDAT
; _this$ = ecx

; 508  : 		m_iEnemyNavalUnitCount += iUnitCount;

	mov	eax, DWORD PTR _iUnitCount$[esp-4]
	add	DWORD PTR [ecx+56], eax

; 509  : 	};

	ret	4
?AddEnemyNavalUnitCount@CvTacticalDominanceZone@@QAEXH@Z ENDP ; CvTacticalDominanceZone::AddEnemyNavalUnitCount
_TEXT	ENDS
PUBLIC	?GetDominanceZoneValue@CvTacticalDominanceZone@@QBEHXZ ; CvTacticalDominanceZone::GetDominanceZoneValue
; Function compile flags: /Ogtpy
;	COMDAT ?GetDominanceZoneValue@CvTacticalDominanceZone@@QBEHXZ
_TEXT	SEGMENT
?GetDominanceZoneValue@CvTacticalDominanceZone@@QBEHXZ PROC ; CvTacticalDominanceZone::GetDominanceZoneValue, COMDAT
; _this$ = ecx

; 512  : 		return m_iZoneValue;

	mov	eax, DWORD PTR [ecx+60]

; 513  : 	};

	ret	0
?GetDominanceZoneValue@CvTacticalDominanceZone@@QBEHXZ ENDP ; CvTacticalDominanceZone::GetDominanceZoneValue
_TEXT	ENDS
PUBLIC	?SetDominanceZoneValue@CvTacticalDominanceZone@@QAEXH@Z ; CvTacticalDominanceZone::SetDominanceZoneValue
; Function compile flags: /Ogtpy
;	COMDAT ?SetDominanceZoneValue@CvTacticalDominanceZone@@QAEXH@Z
_TEXT	SEGMENT
_iValue$ = 8						; size = 4
?SetDominanceZoneValue@CvTacticalDominanceZone@@QAEXH@Z PROC ; CvTacticalDominanceZone::SetDominanceZoneValue, COMDAT
; _this$ = ecx

; 516  : 		m_iZoneValue = iValue;

	mov	eax, DWORD PTR _iValue$[esp-4]
	mov	DWORD PTR [ecx+60], eax

; 517  : 	};

	ret	4
?SetDominanceZoneValue@CvTacticalDominanceZone@@QAEXH@Z ENDP ; CvTacticalDominanceZone::SetDominanceZoneValue
_TEXT	ENDS
PUBLIC	?IsWater@CvTacticalDominanceZone@@QBE_NXZ	; CvTacticalDominanceZone::IsWater
; Function compile flags: /Ogtpy
;	COMDAT ?IsWater@CvTacticalDominanceZone@@QBE_NXZ
_TEXT	SEGMENT
?IsWater@CvTacticalDominanceZone@@QBE_NXZ PROC		; CvTacticalDominanceZone::IsWater, COMDAT
; _this$ = ecx

; 520  : 		return m_bIsWater;

	mov	al, BYTE PTR [ecx+68]

; 521  : 	};

	ret	0
?IsWater@CvTacticalDominanceZone@@QBE_NXZ ENDP		; CvTacticalDominanceZone::IsWater
_TEXT	ENDS
PUBLIC	?SetWater@CvTacticalDominanceZone@@QAEX_N@Z	; CvTacticalDominanceZone::SetWater
; Function compile flags: /Ogtpy
;	COMDAT ?SetWater@CvTacticalDominanceZone@@QAEX_N@Z
_TEXT	SEGMENT
_bWater$ = 8						; size = 1
?SetWater@CvTacticalDominanceZone@@QAEX_N@Z PROC	; CvTacticalDominanceZone::SetWater, COMDAT
; _this$ = ecx

; 524  : 		m_bIsWater = bWater;

	mov	al, BYTE PTR _bWater$[esp-4]
	mov	BYTE PTR [ecx+68], al

; 525  : 	};

	ret	4
?SetWater@CvTacticalDominanceZone@@QAEX_N@Z ENDP	; CvTacticalDominanceZone::SetWater
_TEXT	ENDS
PUBLIC	?SetNavalInvasion@CvTacticalDominanceZone@@QAEX_N@Z ; CvTacticalDominanceZone::SetNavalInvasion
; Function compile flags: /Ogtpy
;	COMDAT ?SetNavalInvasion@CvTacticalDominanceZone@@QAEX_N@Z
_TEXT	SEGMENT
_bIsNavalInvasion$ = 8					; size = 1
?SetNavalInvasion@CvTacticalDominanceZone@@QAEX_N@Z PROC ; CvTacticalDominanceZone::SetNavalInvasion, COMDAT
; _this$ = ecx

; 532  : 		m_bIsNavalInvasion = bIsNavalInvasion;

	mov	al, BYTE PTR _bIsNavalInvasion$[esp-4]
	mov	BYTE PTR [ecx+69], al

; 533  : 	};

	ret	4
?SetNavalInvasion@CvTacticalDominanceZone@@QAEX_N@Z ENDP ; CvTacticalDominanceZone::SetNavalInvasion
_TEXT	ENDS
PUBLIC	?GetTempZoneCenter@CvTacticalDominanceZone@@QBEPAVCvPlot@@XZ ; CvTacticalDominanceZone::GetTempZoneCenter
; Function compile flags: /Ogtpy
;	COMDAT ?GetTempZoneCenter@CvTacticalDominanceZone@@QBEPAVCvPlot@@XZ
_TEXT	SEGMENT
?GetTempZoneCenter@CvTacticalDominanceZone@@QBEPAVCvPlot@@XZ PROC ; CvTacticalDominanceZone::GetTempZoneCenter, COMDAT
; _this$ = ecx

; 536  : 		return m_pTempZoneCenter;

	mov	eax, DWORD PTR [ecx+72]

; 537  : 	};

	ret	0
?GetTempZoneCenter@CvTacticalDominanceZone@@QBEPAVCvPlot@@XZ ENDP ; CvTacticalDominanceZone::GetTempZoneCenter
_TEXT	ENDS
PUBLIC	?SetTempZoneCenter@CvTacticalDominanceZone@@QAEXPAVCvPlot@@@Z ; CvTacticalDominanceZone::SetTempZoneCenter
; Function compile flags: /Ogtpy
;	COMDAT ?SetTempZoneCenter@CvTacticalDominanceZone@@QAEXPAVCvPlot@@@Z
_TEXT	SEGMENT
_pPlot$ = 8						; size = 4
?SetTempZoneCenter@CvTacticalDominanceZone@@QAEXPAVCvPlot@@@Z PROC ; CvTacticalDominanceZone::SetTempZoneCenter, COMDAT
; _this$ = ecx

; 540  : 		m_pTempZoneCenter = pPlot;

	mov	eax, DWORD PTR _pPlot$[esp-4]
	mov	DWORD PTR [ecx+72], eax

; 541  : 	};

	ret	4
?SetTempZoneCenter@CvTacticalDominanceZone@@QAEXPAVCvPlot@@@Z ENDP ; CvTacticalDominanceZone::SetTempZoneCenter
_TEXT	ENDS
PUBLIC	??0CvTacticalAnalysisEnemy@@QAE@XZ		; CvTacticalAnalysisEnemy::CvTacticalAnalysisEnemy
; Function compile flags: /Ogtpy
;	COMDAT ??0CvTacticalAnalysisEnemy@@QAE@XZ
_TEXT	SEGMENT
??0CvTacticalAnalysisEnemy@@QAE@XZ PROC			; CvTacticalAnalysisEnemy::CvTacticalAnalysisEnemy, COMDAT
; _this$ = ecx

; 581  : 	CvTacticalAnalysisEnemy(void)

	mov	eax, ecx

; 582  : 	{
; 583  : 		m_pUnit = NULL;

	mov	DWORD PTR [eax], 0

; 584  : 	}

	ret	0
??0CvTacticalAnalysisEnemy@@QAE@XZ ENDP			; CvTacticalAnalysisEnemy::CvTacticalAnalysisEnemy
_TEXT	ENDS
PUBLIC	?GetCell@CvTacticalAnalysisMap@@QAEPAVCvTacticalAnalysisCell@@H@Z ; CvTacticalAnalysisMap::GetCell
; Function compile flags: /Ogtpy
;	COMDAT ?GetCell@CvTacticalAnalysisMap@@QAEPAVCvTacticalAnalysisCell@@H@Z
_TEXT	SEGMENT
_iPlotIndex$ = 8					; size = 4
?GetCell@CvTacticalAnalysisMap@@QAEPAVCvTacticalAnalysisCell@@H@Z PROC ; CvTacticalAnalysisMap::GetCell, COMDAT
; _this$ = ecx

; 630  : 		return &m_pPlots[iPlotIndex];

	mov	eax, DWORD PTR _iPlotIndex$[esp-4]
	imul	eax, 44					; 0000002cH
	add	eax, DWORD PTR [ecx+12]

; 631  : 	};

	ret	4
?GetCell@CvTacticalAnalysisMap@@QAEPAVCvTacticalAnalysisCell@@H@Z ENDP ; CvTacticalAnalysisMap::GetCell
_TEXT	ENDS
PUBLIC	?GetBestFriendlyRange@CvTacticalAnalysisMap@@QBEHXZ ; CvTacticalAnalysisMap::GetBestFriendlyRange
; Function compile flags: /Ogtpy
;	COMDAT ?GetBestFriendlyRange@CvTacticalAnalysisMap@@QBEHXZ
_TEXT	SEGMENT
?GetBestFriendlyRange@CvTacticalAnalysisMap@@QBEHXZ PROC ; CvTacticalAnalysisMap::GetBestFriendlyRange, COMDAT
; _this$ = ecx

; 641  : 		return m_iBestFriendlyRange;

	mov	eax, DWORD PTR [ecx+28]

; 642  : 	};

	ret	0
?GetBestFriendlyRange@CvTacticalAnalysisMap@@QBEHXZ ENDP ; CvTacticalAnalysisMap::GetBestFriendlyRange
_TEXT	ENDS
PUBLIC	?SetBestFriendlyRange@CvTacticalAnalysisMap@@QAEXH@Z ; CvTacticalAnalysisMap::SetBestFriendlyRange
; Function compile flags: /Ogtpy
;	COMDAT ?SetBestFriendlyRange@CvTacticalAnalysisMap@@QAEXH@Z
_TEXT	SEGMENT
_iNewRange$ = 8						; size = 4
?SetBestFriendlyRange@CvTacticalAnalysisMap@@QAEXH@Z PROC ; CvTacticalAnalysisMap::SetBestFriendlyRange, COMDAT
; _this$ = ecx

; 645  : 		m_iBestFriendlyRange = iNewRange;

	mov	eax, DWORD PTR _iNewRange$[esp-4]
	mov	DWORD PTR [ecx+28], eax

; 646  : 	};

	ret	4
?SetBestFriendlyRange@CvTacticalAnalysisMap@@QAEXH@Z ENDP ; CvTacticalAnalysisMap::SetBestFriendlyRange
_TEXT	ENDS
PUBLIC	?SetIgnoreLOS@CvTacticalAnalysisMap@@QAEX_N@Z	; CvTacticalAnalysisMap::SetIgnoreLOS
; Function compile flags: /Ogtpy
;	COMDAT ?SetIgnoreLOS@CvTacticalAnalysisMap@@QAEX_N@Z
_TEXT	SEGMENT
_bNewValue$ = 8						; size = 1
?SetIgnoreLOS@CvTacticalAnalysisMap@@QAEX_N@Z PROC	; CvTacticalAnalysisMap::SetIgnoreLOS, COMDAT
; _this$ = ecx

; 653  : 		m_bIgnoreLOS = bNewValue;

	mov	al, BYTE PTR _bNewValue$[esp-4]
	mov	BYTE PTR [ecx+32], al

; 654  : 	};

	ret	4
?SetIgnoreLOS@CvTacticalAnalysisMap@@QAEX_N@Z ENDP	; CvTacticalAnalysisMap::SetIgnoreLOS
_TEXT	ENDS
PUBLIC	?GetX@CvTemporaryZone@@QBEHXZ			; CvTemporaryZone::GetX
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.h
;	COMDAT ?GetX@CvTemporaryZone@@QBEHXZ
_TEXT	SEGMENT
?GetX@CvTemporaryZone@@QBEHXZ PROC			; CvTemporaryZone::GetX, COMDAT
; _this$ = ecx

; 577  : 		return m_iX;

	mov	eax, DWORD PTR [ecx]

; 578  : 	};

	ret	0
?GetX@CvTemporaryZone@@QBEHXZ ENDP			; CvTemporaryZone::GetX
_TEXT	ENDS
PUBLIC	?GetY@CvTemporaryZone@@QBEHXZ			; CvTemporaryZone::GetY
; Function compile flags: /Ogtpy
;	COMDAT ?GetY@CvTemporaryZone@@QBEHXZ
_TEXT	SEGMENT
?GetY@CvTemporaryZone@@QBEHXZ PROC			; CvTemporaryZone::GetY, COMDAT
; _this$ = ecx

; 585  : 		return m_iY;

	mov	eax, DWORD PTR [ecx+4]

; 586  : 	};

	ret	0
?GetY@CvTemporaryZone@@QBEHXZ ENDP			; CvTemporaryZone::GetY
_TEXT	ENDS
PUBLIC	?GetTargetType@CvTemporaryZone@@QBE?AW4AITacticalTargetType@@XZ ; CvTemporaryZone::GetTargetType
; Function compile flags: /Ogtpy
;	COMDAT ?GetTargetType@CvTemporaryZone@@QBE?AW4AITacticalTargetType@@XZ
_TEXT	SEGMENT
?GetTargetType@CvTemporaryZone@@QBE?AW4AITacticalTargetType@@XZ PROC ; CvTemporaryZone::GetTargetType, COMDAT
; _this$ = ecx

; 593  : 		return m_eTargetType;

	mov	eax, DWORD PTR [ecx+8]

; 594  : 	};

	ret	0
?GetTargetType@CvTemporaryZone@@QBE?AW4AITacticalTargetType@@XZ ENDP ; CvTemporaryZone::GetTargetType
_TEXT	ENDS
PUBLIC	?IsNavalInvasion@CvTemporaryZone@@QBE_NXZ	; CvTemporaryZone::IsNavalInvasion
; Function compile flags: /Ogtpy
;	COMDAT ?IsNavalInvasion@CvTemporaryZone@@QBE_NXZ
_TEXT	SEGMENT
?IsNavalInvasion@CvTemporaryZone@@QBE_NXZ PROC		; CvTemporaryZone::IsNavalInvasion, COMDAT
; _this$ = ecx

; 609  : 		return m_bIsNavalInvasion;

	mov	al, BYTE PTR [ecx+16]

; 610  : 	};

	ret	0
?IsNavalInvasion@CvTemporaryZone@@QBE_NXZ ENDP		; CvTemporaryZone::IsNavalInvasion
_TEXT	ENDS
PUBLIC	?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z		; CvTeam::getTeam
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.h
;	COMDAT ?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z PROC		; CvTeam::getTeam, COMDAT

; 29   : 		CvAssertMsg(eTeam != NO_TEAM, "eTeam is not assigned a valid value");
; 30   : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is not assigned a valid value");
; 31   : 		return m_aTeams[eTeam];

	mov	eax, DWORD PTR _eTeam$[esp-4]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 32   : 	}

	ret	0
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z ENDP		; CvTeam::getTeam
_TEXT	ENDS
PUBLIC	??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z PROC ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ENDP ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@VCvTacticalDominanceZone@@$00@@QBEIXZ ; BaseVector<CvTacticalDominanceZone,1>::size
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?size@?$BaseVector@VCvTacticalDominanceZone@@$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@VCvTacticalDominanceZone@@$00@@QBEIXZ PROC ; BaseVector<CvTacticalDominanceZone,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@VCvTacticalDominanceZone@@$00@@QBEIXZ ENDP ; BaseVector<CvTacticalDominanceZone,1>::size
_TEXT	ENDS
PUBLIC	?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvUnit>::get
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvUnit>::get, COMDAT
; _this$ = ecx

; 177  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 178  : }

	ret	0
?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvUnit>::get
_TEXT	ENDS
PUBLIC	?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ	; FAutoVariable<int,CvUnit>::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ
_TEXT	SEGMENT
?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ PROC		; FAutoVariable<int,CvUnit>::get, COMDAT
; _this$ = ecx

; 177  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 178  : }

	ret	0
?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvUnit>::get
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ		; FAutoVariable<int,CvUnit>::operator int const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ
_TEXT	SEGMENT
??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ PROC		; FAutoVariable<int,CvUnit>::operator int const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvUnit>::operator int const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@_NVCvUnit@@@@QBEAB_NXZ	; FAutoVariable<bool,CvUnit>::operator bool const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@_NVCvUnit@@@@QBEAB_NXZ
_TEXT	SEGMENT
??B?$FAutoVariable@_NVCvUnit@@@@QBEAB_NXZ PROC		; FAutoVariable<bool,CvUnit>::operator bool const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@_NVCvUnit@@@@QBEAB_NXZ ENDP		; FAutoVariable<bool,CvUnit>::operator bool const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ		; FAutoVariable<int,CvCity>::operator int const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ
_TEXT	SEGMENT
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ PROC		; FAutoVariable<int,CvCity>::operator int const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvCity>::operator int const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ	; FAutoVariable<bool,CvPlayer>::operator bool const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ
_TEXT	SEGMENT
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ PROC	; FAutoVariable<bool,CvPlayer>::operator bool const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ ENDP	; FAutoVariable<bool,CvPlayer>::operator bool const &
_TEXT	ENDS
PUBLIC	?dxWrap@@YAHH@Z					; dxWrap
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?dxWrap@@YAHH@Z
_TEXT	SEGMENT
_iDX$ = 8						; size = 4
?dxWrap@@YAHH@Z PROC					; dxWrap, COMDAT

; 74   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

	mov	edx, DWORD PTR [eax+4020]
	cmp	BYTE PTR [eax+4056], 0
	mov	eax, DWORD PTR _iDX$[esp-4]
	je	SHORT $LN13@dxWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dxWrap
	sub	eax, edx

; 76   : }

	ret	0

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

$LN11@dxWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dxWrap
	add	eax, edx
$LN13@dxWrap:

; 76   : }

	ret	0
?dxWrap@@YAHH@Z ENDP					; dxWrap
_TEXT	ENDS
PUBLIC	?dyWrap@@YAHH@Z					; dyWrap
; Function compile flags: /Ogtpy
;	COMDAT ?dyWrap@@YAHH@Z
_TEXT	SEGMENT
_iDY$ = 8						; size = 4
?dyWrap@@YAHH@Z PROC					; dyWrap, COMDAT

; 80   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

	mov	edx, DWORD PTR [eax+4024]
	cmp	BYTE PTR [eax+4057], 0
	mov	eax, DWORD PTR _iDY$[esp-4]
	je	SHORT $LN13@dyWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dyWrap
	sub	eax, edx

; 82   : }

	ret	0

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

$LN11@dyWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dyWrap
	add	eax, edx
$LN13@dyWrap:

; 82   : }

	ret	0
?dyWrap@@YAHH@Z ENDP					; dyWrap
_TEXT	ENDS
PUBLIC	?plotDistance@@YAHHHHH@Z			; plotDistance
; Function compile flags: /Ogtpy
;	COMDAT ?plotDistance@@YAHHHHH@Z
_TEXT	SEGMENT
_iDY$ = -12						; size = 4
tv320 = -8						; size = 4
tv357 = -4						; size = 4
_iX1$ = 8						; size = 4
_iDX$ = 12						; size = 4
_iY1$ = 12						; size = 4
$T225441 = 16						; size = 4
_iX2$ = 16						; size = 4
_iY2$ = 20						; size = 4
?plotDistance@@YAHHHHH@Z PROC				; plotDistance, COMDAT

; 144  : {

	sub	esp, 12					; 0000000cH

; 145  : 	int iDX;
; 146  : 	int iWrappedDX = dxWrap(iX2 - iX1);

	mov	ecx, DWORD PTR _iX2$[esp+8]
	sub	ecx, DWORD PTR _iX1$[esp+8]
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [edi+4056], 0
	mov	edx, DWORD PTR [edi+4020]
	mov	DWORD PTR tv320[esp+28], ecx
	je	SHORT $LN18@plotDistan
	mov	eax, edx
	shr	eax, 1
	cmp	ecx, eax
	jle	SHORT $LN20@plotDistan
	sub	ecx, edx
	jmp	SHORT $LN18@plotDistan
$LN20@plotDistan:
	neg	eax
	cmp	ecx, eax
	jge	SHORT $LN18@plotDistan
	add	ecx, edx
$LN18@plotDistan:

; 147  : 	int iWrappedDY = dyWrap(iY2 - iY1);

	mov	ebp, DWORD PTR _iY2$[esp+24]
	sub	ebp, DWORD PTR _iY1$[esp+24]
	cmp	BYTE PTR [edi+4057], 0
	mov	eax, DWORD PTR [edi+4024]
	je	SHORT $LN32@plotDistan
	mov	edx, eax
	shr	edx, 1
	cmp	ebp, edx
	jle	SHORT $LN34@plotDistan
	mov	ebx, ebp
	sub	ebx, eax
	mov	DWORD PTR $T225441[esp+24], ebx
	jmp	SHORT $LN36@plotDistan
$LN34@plotDistan:
	neg	edx
	cmp	ebp, edx
	jge	SHORT $LN32@plotDistan
	lea	ebx, DWORD PTR [eax+ebp]
	mov	DWORD PTR $T225441[esp+24], ebx
	jmp	SHORT $LN36@plotDistan
$LN32@plotDistan:
	mov	ebx, ebp
	mov	DWORD PTR $T225441[esp+24], ebp
$LN36@plotDistan:

; 148  : 	int iDY = abs(iWrappedDY);

	mov	eax, ebx
	cdq
	mov	esi, eax
	xor	esi, edx
	sub	esi, edx

; 149  : 
; 150  : #ifdef GAMECOREUTILS_FIX_PLOT_DISTANCE
; 151  : 	const CvMap& kMap = GC.getMap();
; 152  : 	// equidistant column joint fix (on X-wrapped maps):
; 153  : 	if ((kMap.isWrapX()) && (abs(iWrappedDX * 2) == kMap.getGridWidth()) && (iDY % 2 != 0) && ((iY1 % 2 == 0) == (iWrappedDX > (kMap.getGridWidth() >> 2))))

	cmp	BYTE PTR [edi+4056], 0
	mov	DWORD PTR _iDY$[esp+28], esi
	je	$LN77@plotDistan
	lea	eax, DWORD PTR [ecx+ecx]
	cdq
	mov	ebx, eax
	mov	eax, DWORD PTR [edi+4020]
	xor	ebx, edx
	sub	ebx, edx
	cmp	ebx, eax
	jne	SHORT $LN73@plotDistan
	mov	edx, esi
	and	edx, -2147483647			; 80000001H
	jns	SHORT $LN79@plotDistan
	dec	edx
	or	edx, -2					; fffffffeH
	inc	edx
$LN79@plotDistan:
	je	SHORT $LN73@plotDistan
	sar	eax, 2
	xor	edx, edx
	cmp	ecx, eax
	mov	eax, DWORD PTR _iY1$[esp+24]
	setg	dl
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN80@plotDistan
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN80@plotDistan:

; 154  : 	{
; 155  : 		iWrappedDX *= -1;  // change polarity

	mov	ebx, DWORD PTR $T225441[esp+24]
	neg	eax
	sbb	eax, eax
	inc	eax
	cmp	eax, edx
	jne	SHORT $LN5@plotDistan
	neg	ecx
	jmp	SHORT $LN5@plotDistan
$LN73@plotDistan:
	mov	ebx, DWORD PTR $T225441[esp+24]
$LN5@plotDistan:

; 156  : 	}
; 157  : 	if ((kMap.isWrapX()) && (abs(iWrappedDX * 2) == kMap.getGridWidth()) && (abs(iWrappedDY) < abs(iY2 - iY1)) && (iDY % 2 == 0) && (iX2 - iX1 < 0))

	cmp	BYTE PTR [edi+4056], 0
	je	$LN77@plotDistan
	lea	eax, DWORD PTR [ecx+ecx]
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	eax, DWORD PTR [edi+4020]
	jne	SHORT $LN75@plotDistan
	mov	eax, ebp
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	esi, eax
	jge	SHORT $LN75@plotDistan
	mov	edx, DWORD PTR _iDY$[esp+28]
	and	edx, -2147483647			; 80000001H
	jns	SHORT $LN81@plotDistan
	dec	edx
	or	edx, -2					; fffffffeH
	inc	edx
$LN81@plotDistan:
	jne	SHORT $LN75@plotDistan
	cmp	DWORD PTR tv320[esp+28], 0
	jge	SHORT $LN75@plotDistan

; 158  : 	{
; 159  : 		iWrappedDX *= -1;  // change polarity

	neg	ecx
$LN75@plotDistan:

; 160  : 	}
; 161  : 	// special case when map is toroidal AND map height is odd
; 162  : 	// TODO works but ugly
; 163  : 	if ((kMap.isWrapX()) && (kMap.getGridHeight() % 2 != 0) && (iY1 % 2 == kMap.getGridWidth() % 2) && (iY2 % 2 == 0) &&
; 164  : 		(abs(iWrappedDY) < abs(iY2 - iY1)) && (abs(iX2 - iX1) == kMap.getGridWidth() / 2 + ((kMap.getGridWidth() % 2 == 1) && (iX2 - iX1 > 0)) ? 1 : 0))

	cmp	BYTE PTR [edi+4056], 0
	je	$LN77@plotDistan
	mov	eax, DWORD PTR [edi+4024]
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN82@plotDistan
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN82@plotDistan:
	je	$LN77@plotDistan
	mov	edi, DWORD PTR [edi+4020]
	mov	DWORD PTR tv357[esp+28], edi
	and	edi, -2147483647			; 80000001H
	jns	SHORT $LN83@plotDistan
	dec	edi
	or	edi, -2					; fffffffeH
	inc	edi
$LN83@plotDistan:
	mov	edx, DWORD PTR _iY1$[esp+24]
	and	edx, -2147483647			; 80000001H
	jns	SHORT $LN84@plotDistan
	dec	edx
	or	edx, -2					; fffffffeH
	inc	edx
$LN84@plotDistan:
	cmp	edx, edi
	jne	SHORT $LN77@plotDistan
	mov	eax, DWORD PTR _iY2$[esp+24]
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN85@plotDistan
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN85@plotDistan:
	jne	SHORT $LN77@plotDistan
	mov	eax, ebp
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	esi, eax
	jge	SHORT $LN77@plotDistan
	cmp	edi, 1
	jne	SHORT $LN76@plotDistan
	cmp	DWORD PTR tv320[esp+28], 0
	jle	SHORT $LN76@plotDistan
	mov	esi, edi
	jmp	SHORT $LN9@plotDistan
$LN76@plotDistan:
	xor	esi, esi
$LN9@plotDistan:
	mov	eax, DWORD PTR tv320[esp+28]
	cdq
	mov	edi, eax
	mov	eax, DWORD PTR tv357[esp+28]
	xor	edi, edx
	sub	edi, edx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, esi
	cmp	edi, eax
	jne	SHORT $LN77@plotDistan

; 165  : 	{
; 166  : 		iWrappedDX -= (iWrappedDX > 0) - (iWrappedDX < 0);  // decrease regardless of polarity

	xor	edx, edx
	test	ecx, ecx
	setl	dl
	xor	eax, eax
	test	ecx, ecx
	setg	al
	sub	edx, eax
	add	ecx, edx
$LN77@plotDistan:

; 167  : 	}
; 168  : #endif
; 169  : 
; 170  : 	// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 171  : 	int iHX1 = xToHexspaceX(iX1, iY1);

	mov	eax, DWORD PTR _iY1$[esp+24]
	test	eax, eax
	jge	SHORT $LN88@plotDistan
	dec	eax
	cdq
	sub	eax, edx
$LN88@plotDistan:
	mov	edi, DWORD PTR _iX1$[esp+24]

; 172  : 	int iHX2 = xToHexspaceX(iX1 + iWrappedDX, iY1 + iWrappedDY);

	mov	edx, DWORD PTR _iY1$[esp+24]
	sar	eax, 1
	mov	esi, edi
	sub	esi, eax
	lea	eax, DWORD PTR [ebx+edx]
	test	eax, eax
	jge	SHORT $LN89@plotDistan
	dec	eax
	cdq
	sub	eax, edx
$LN89@plotDistan:
	sar	eax, 1
	sub	ecx, eax
	add	ecx, edi

; 173  : 
; 174  : #ifdef GAMECOREUTILS_FIX_PLOT_DISTANCE
; 175  : 	// obvious bug
; 176  : 	iDX = abs(iHX2 - iHX1);

	sub	ecx, esi
	mov	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx

; 177  : #else
; 178  : 	iDX = abs(dxWrap(iHX2 - iHX1));
; 179  : #endif
; 180  : 
; 181  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 182  : 	if (((iHX2 - iHX1) ^ (iWrappedDY)) >= 0)  // the signs match
; 183  : #else
; 184  : 	if((iHX2 - iHX1 >= 0) == (iWrappedDY >= 0))  // the signs match

	xor	edx, edx
	test	ecx, ecx
	setge	dl
	xor	ecx, ecx
	test	ebx, ebx
	setge	cl
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR _iDX$[esp+12], eax
	pop	ebx
	cmp	edx, ecx
	jne	SHORT $LN2@plotDistan

; 185  : #endif
; 186  : 	{
; 187  : 		return iDX + iDY;

	mov	edx, DWORD PTR _iDY$[esp+12]
	add	eax, edx

; 195  : #endif
; 196  : 	}
; 197  : }

	add	esp, 12					; 0000000cH
	ret	0
$LN2@plotDistan:

; 188  : 	}
; 189  : 	else
; 190  : 	{
; 191  : #ifdef NQM_FAST_COMP
; 192  : 		return (MAX(iDX, iDY));
; 193  : #else
; 194  : 		return (std::max(iDX, iDY));

	cmp	eax, DWORD PTR _iDY$[esp+12]
	lea	eax, DWORD PTR _iDY$[esp+12]
	jl	SHORT $LN71@plotDistan
	lea	eax, DWORD PTR _iDX$[esp+8]
$LN71@plotDistan:
	mov	eax, DWORD PTR [eax]

; 195  : #endif
; 196  : 	}
; 197  : }

	add	esp, 12					; 0000000cH
	ret	0
?plotDistance@@YAHHHHH@Z ENDP				; plotDistance
_TEXT	ENDS
PUBLIC	?Clear@CvTacticalAnalysisCell@@QAEXXZ		; CvTacticalAnalysisCell::Clear
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtacticalanalysismap.cpp
;	COMDAT ?Clear@CvTacticalAnalysisCell@@QAEXXZ
_TEXT	SEGMENT
?Clear@CvTacticalAnalysisCell@@QAEXXZ PROC		; CvTacticalAnalysisCell::Clear, COMDAT
; _this$ = ecx

; 39   : 	ClearFlags();

	xor	eax, eax
	mov	DWORD PTR [ecx], eax

; 40   : 	m_pEnemyMilitary = NULL;

	mov	DWORD PTR [ecx+4], eax

; 41   : 	m_pEnemyCivilian = NULL;

	mov	DWORD PTR [ecx+8], eax

; 42   : 	m_pNeutralMilitary = NULL;

	mov	DWORD PTR [ecx+12], eax

; 43   : 	m_pNeutralCivilian = NULL;

	mov	DWORD PTR [ecx+16], eax

; 44   : 	m_pFriendlyMilitary = NULL;

	mov	DWORD PTR [ecx+20], eax

; 45   : 	m_pFriendlyCivilian = NULL;

	mov	DWORD PTR [ecx+24], eax

; 46   : 	m_iDefenseModifier = 0;

	mov	DWORD PTR [ecx+28], eax

; 47   : 	m_iDeploymentScore = 0;

	mov	DWORD PTR [ecx+32], eax

; 48   : 	m_eTargetType = AI_TACTICAL_TARGET_NONE;

	mov	DWORD PTR [ecx+36], eax

; 49   : 	m_iDominanceZoneID = -1;

	mov	DWORD PTR [ecx+40], -1

; 50   : }

	ret	0
?Clear@CvTacticalAnalysisCell@@QAEXXZ ENDP		; CvTacticalAnalysisCell::Clear
_TEXT	ENDS
PUBLIC	?CanUseForOperationGathering@CvTacticalAnalysisCell@@QAE_NXZ ; CvTacticalAnalysisCell::CanUseForOperationGathering
; Function compile flags: /Ogtpy
;	COMDAT ?CanUseForOperationGathering@CvTacticalAnalysisCell@@QAE_NXZ
_TEXT	SEGMENT
?CanUseForOperationGathering@CvTacticalAnalysisCell@@QAE_NXZ PROC ; CvTacticalAnalysisCell::CanUseForOperationGathering, COMDAT
; _this$ = ecx

; 54   : 	if(IsImpassableTerrain() || IsImpassableTerritory() || GetEnemyMilitaryUnit() || GetNeutralMilitaryUnit() || GetNeutralCivilianUnit() || IsFriendlyTurnEndTile() || IsEnemyCity() || IsNeutralCity())

	mov	eax, DWORD PTR [ecx]
	mov	edx, eax
	shr	edx, 2
	test	dl, 1
	jne	SHORT $LN1@CanUseForO
	mov	edx, eax
	shr	edx, 3
	test	dl, 1
	jne	SHORT $LN1@CanUseForO
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN1@CanUseForO
	cmp	DWORD PTR [ecx+12], 0
	jne	SHORT $LN1@CanUseForO
	cmp	DWORD PTR [ecx+16], 0
	jne	SHORT $LN1@CanUseForO
	mov	ecx, eax
	shr	ecx, 7
	test	cl, 1
	jne	SHORT $LN1@CanUseForO
	mov	edx, eax
	shr	edx, 9
	test	dl, 1
	jne	SHORT $LN1@CanUseForO
	shr	eax, 10					; 0000000aH
	test	al, 1
	jne	SHORT $LN1@CanUseForO

; 57   : 	}
; 58   : 
; 59   : 	return true;

	mov	al, 1

; 60   : }

	ret	0
$LN1@CanUseForO:

; 55   : 	{
; 56   : 		return false;

	xor	al, al

; 60   : }

	ret	0
?CanUseForOperationGathering@CvTacticalAnalysisCell@@QAE_NXZ ENDP ; CvTacticalAnalysisCell::CanUseForOperationGathering
_TEXT	ENDS
PUBLIC	?CanUseForOperationGatheringCheckWater@CvTacticalAnalysisCell@@QAE_N_N@Z ; CvTacticalAnalysisCell::CanUseForOperationGatheringCheckWater
; Function compile flags: /Ogtpy
;	COMDAT ?CanUseForOperationGatheringCheckWater@CvTacticalAnalysisCell@@QAE_N_N@Z
_TEXT	SEGMENT
_bWater$ = 8						; size = 1
?CanUseForOperationGatheringCheckWater@CvTacticalAnalysisCell@@QAE_N_N@Z PROC ; CvTacticalAnalysisCell::CanUseForOperationGatheringCheckWater, COMDAT
; _this$ = ecx

; 64   : 	if(bWater != IsWater() || IsImpassableTerrain() || IsImpassableTerritory() || GetEnemyMilitaryUnit() || GetNeutralMilitaryUnit() || GetNeutralCivilianUnit() || IsFriendlyTurnEndTile() || IsEnemyCity() || IsNeutralCity())

	mov	eax, DWORD PTR [ecx]
	mov	edx, eax
	shr	edx, 11					; 0000000bH
	and	dl, 1
	cmp	BYTE PTR _bWater$[esp-4], dl
	jne	SHORT $LN1@CanUseForO@2
	mov	edx, eax
	shr	edx, 2
	test	dl, 1
	jne	SHORT $LN1@CanUseForO@2
	mov	edx, eax
	shr	edx, 3
	test	dl, 1
	jne	SHORT $LN1@CanUseForO@2
	cmp	DWORD PTR [ecx+4], 0
	jne	SHORT $LN1@CanUseForO@2
	cmp	DWORD PTR [ecx+12], 0
	jne	SHORT $LN1@CanUseForO@2
	cmp	DWORD PTR [ecx+16], 0
	jne	SHORT $LN1@CanUseForO@2
	mov	ecx, eax
	shr	ecx, 7
	test	cl, 1
	jne	SHORT $LN1@CanUseForO@2
	mov	edx, eax
	shr	edx, 9
	test	dl, 1
	jne	SHORT $LN1@CanUseForO@2
	shr	eax, 10					; 0000000aH
	test	al, 1
	jne	SHORT $LN1@CanUseForO@2

; 67   : 	}
; 68   : 
; 69   : 	return true;

	mov	al, 1

; 70   : }

	ret	4
$LN1@CanUseForO@2:

; 65   : 	{
; 66   : 		return false;

	xor	al, al

; 70   : }

	ret	4
?CanUseForOperationGatheringCheckWater@CvTacticalAnalysisCell@@QAE_N_N@Z ENDP ; CvTacticalAnalysisCell::CanUseForOperationGatheringCheckWater
_TEXT	ENDS
PUBLIC	?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ ; CvTacticalDominanceZone::GetClosestCity
; Function compile flags: /Ogtpy
;	COMDAT ?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ
_TEXT	SEGMENT
?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ PROC ; CvTacticalDominanceZone::GetClosestCity, COMDAT
; _this$ = ecx

; 103  : 	if(m_eOwner != NO_PLAYER)

	mov	eax, DWORD PTR [ecx+12]
	cmp	eax, -1
	je	SHORT $LN1@GetClosest

; 104  : 	{
; 105  : 		return GET_PLAYER(m_eOwner).getCity(m_iCityID);

	mov	ecx, DWORD PTR [ecx+16]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 109  : }

	ret	0
$LN1@GetClosest:

; 106  : 	}
; 107  : 
; 108  : 	return NULL;

	xor	eax, eax

; 109  : }

	ret	0
?GetClosestCity@CvTacticalDominanceZone@@QBEPAVCvCity@@XZ ENDP ; CvTacticalDominanceZone::GetClosestCity
_TEXT	ENDS
PUBLIC	?ClearDynamicFlags@CvTacticalAnalysisMap@@QAEXXZ ; CvTacticalAnalysisMap::ClearDynamicFlags
; Function compile flags: /Ogtpy
;	COMDAT ?ClearDynamicFlags@CvTacticalAnalysisMap@@QAEXXZ
_TEXT	SEGMENT
?ClearDynamicFlags@CvTacticalAnalysisMap@@QAEXXZ PROC	; CvTacticalAnalysisMap::ClearDynamicFlags, COMDAT
; _this$ = ecx

; 398  : #ifdef AUI_WARNING_FIXES
; 399  : 	for (uint iI = 0; iI < GC.getMap().numPlots(); iI++)
; 400  : #else
; 401  : 	for(int iI = 0; iI < GC.getMap().numPlots(); iI++)

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	esi
	xor	esi, esi
	cmp	DWORD PTR [eax+4028], esi
	jle	SHORT $LN1@ClearDynam
	xor	edx, edx
$LL3@ClearDynam:

; 402  : #endif
; 403  : 	{
; 404  : 		// Erase this cell
; 405  : 		m_pPlots[iI].SetWithinRangeOfTarget(false);

	mov	eax, DWORD PTR [ecx+12]
	and	DWORD PTR [eax+edx], -131073		; fffdffffH
	add	eax, edx

; 406  : 		m_pPlots[iI].SetHelpsProvidesFlankBonus(false);

	mov	eax, DWORD PTR [ecx+12]
	and	DWORD PTR [eax+edx], -262145		; fffbffffH
	add	eax, edx

; 407  : 		m_pPlots[iI].SetSafeForDeployment(false);

	mov	eax, DWORD PTR [ecx+12]
	and	DWORD PTR [eax+edx], -524289		; fff7ffffH
	add	eax, edx

; 408  : 		m_pPlots[iI].SetDeploymentScore(0);

	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+edx+32], 0
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	inc	esi
	add	edx, 44					; 0000002cH
	cmp	esi, DWORD PTR [eax+4028]
	jl	SHORT $LL3@ClearDynam
$LN1@ClearDynam:
	pop	esi

; 409  : 	}
; 410  : }

	ret	0
?ClearDynamicFlags@CvTacticalAnalysisMap@@QAEXXZ ENDP	; CvTacticalAnalysisMap::ClearDynamicFlags
_TEXT	ENDS
PUBLIC	?LogZones@CvTacticalAnalysisMap@@IAEXXZ		; CvTacticalAnalysisMap::LogZones
EXTRN	?IsTemporaryZoneCity@CvTacticalAI@@QAE_NPAVCvCity@@@Z:PROC ; CvTacticalAI::IsTemporaryZoneCity
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z:PROC
EXTRN	?getName@CvCity@@QBE?BVCvString@@XZ:PROC	; CvCity::getName
EXTRN	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z:PROC ; CvTacticalAI::LogTacticalMessage
EXTRN	?GetTacticalAI@CvPlayer@@QBEPAVCvTacticalAI@@XZ:PROC ; CvPlayer::GetTacticalAI
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	?getAILogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getAILogging
EXTRN	?getLogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getLogging
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?LogZones@CvTacticalAnalysisMap@@IAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogZones@CvTacticalAnalysisMap@@IAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogZones@CvTacticalAnalysisMap@@IAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogZones@CvTacticalAnalysisMap@@IAEXXZ$2
__ehfuncinfo$?LogZones@CvTacticalAnalysisMap@@IAEXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?LogZones@CvTacticalAnalysisMap@@IAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtacticalanalysismap.cpp
xdata$x	ENDS
;	COMDAT ?LogZones@CvTacticalAnalysisMap@@IAEXXZ
_TEXT	SEGMENT
_this$ = -132						; size = 4
_iI$222820 = -128					; size = 4
tv514 = -124						; size = 4
$T225772 = -120						; size = 4
$T225776 = -116						; size = 4
$T225780 = -112						; size = 4
$T225784 = -108						; size = 4
$T225788 = -104						; size = 4
$T225792 = -100						; size = 4
_szLogMsg$222818 = -96					; size = 28
$T225734 = -68						; size = 28
$T225733 = -40						; size = 28
__$EHRec$ = -12						; size = 12
?LogZones@CvTacticalAnalysisMap@@IAEXXZ PROC		; CvTacticalAnalysisMap::LogZones, COMDAT
; _this$ = ecx

; 1070 : {

	push	-1
	push	__ehhandler$?LogZones@CvTacticalAnalysisMap@@IAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 120				; 00000078H
	push	esi
	mov	esi, ecx

; 1071 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _this$[esp+136], esi
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN17@LogZones
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN17@LogZones

; 1072 : 	{
; 1073 : 		CvString szLogMsg;

	lea	ecx, DWORD PTR _szLogMsg$222818[esp+136]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1074 : 		CvTacticalDominanceZone* pZone;
; 1075 : 
; 1076 : 		for(unsigned int iI = 0; iI < m_DominanceZones.size(); iI++)

	mov	eax, DWORD PTR [esi+116]
	xor	ecx, ecx
	mov	DWORD PTR __$EHRec$[esp+144], ecx
	mov	DWORD PTR _iI$222820[esp+136], ecx
	cmp	eax, ecx
	jbe	$LN14@LogZones
	push	ebx
	push	ebp
	mov	DWORD PTR tv514[esp+144], ecx
	push	edi
	npad	4
$LL16@LogZones:

; 1077 : 		{
; 1078 : 			pZone = &m_DominanceZones[iI];

	mov	esi, DWORD PTR [esi+112]

; 1079 : 
; 1080 : 			szLogMsg.Format("Zone ID: %d, Area ID: %d, Value: %d, FRIENDLY Str: %d (%d), Ranged: %d (%d), ENEMY Str: %d (%d), Ranged: %d (%d), Closest Enemy: %d",
; 1081 : 			                pZone->GetDominanceZoneID(), pZone->GetAreaID(), pZone->GetDominanceZoneValue(),
; 1082 : 			                pZone->GetFriendlyStrength(), pZone->GetFriendlyUnitCount(), pZone->GetFriendlyRangedStrength(), pZone->GetFriendlyRangedUnitCount(),
; 1083 : 			                pZone->GetEnemyStrength(), pZone->GetEnemyUnitCount(), pZone->GetEnemyRangedStrength(), pZone->GetEnemyRangedUnitCount(), pZone->GetRangeClosestEnemyUnit());

	mov	eax, DWORD PTR [esi+ecx+64]
	mov	ebx, DWORD PTR [esi+ecx+48]
	mov	edx, DWORD PTR [esi+ecx+36]
	mov	edi, DWORD PTR [esi+ecx+44]
	mov	ebp, DWORD PTR [esi+ecx+28]
	add	esi, ecx
	mov	ecx, DWORD PTR [esi+52]
	push	eax
	push	ecx
	push	edx
	mov	DWORD PTR $T225772[esp+160], ebx
	mov	ebx, DWORD PTR [esi+32]
	mov	eax, DWORD PTR $T225772[esp+160]
	push	edi
	mov	DWORD PTR $T225776[esp+164], ebx
	mov	ebx, DWORD PTR [esi+40]
	mov	ecx, DWORD PTR $T225776[esp+164]
	push	ebp
	push	eax
	mov	DWORD PTR $T225780[esp+172], ebx
	mov	ebx, DWORD PTR [esi+24]
	mov	edx, DWORD PTR $T225780[esp+172]
	push	ecx
	mov	DWORD PTR $T225784[esp+176], ebx
	mov	ebx, DWORD PTR [esi+60]
	mov	eax, DWORD PTR $T225784[esp+176]
	push	edx
	push	eax
	mov	DWORD PTR $T225788[esp+184], ebx
	mov	ebx, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR $T225788[esp+184]
	push	ecx
	mov	DWORD PTR $T225792[esp+188], ebx
	mov	edx, DWORD PTR $T225792[esp+188]
	mov	ebx, DWORD PTR [esi]
	push	edx
	push	ebx
	lea	eax, DWORD PTR _szLogMsg$222818[esp+196]
	push	OFFSET $SG222824
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 1084 : 			if(pZone->GetDominanceFlag() == TACTICAL_DOMINANCE_FRIENDLY)

	mov	eax, DWORD PTR [esi+8]
	mov	ebx, 1
	add	esp, 56					; 00000038H
	cmp	eax, ebx
	jne	SHORT $LN13@LogZones

; 1085 : 			{
; 1086 : 				szLogMsg += ", Friendly";

	push	OFFSET $SG222826
	jmp	SHORT $LN91@LogZones
$LN13@LogZones:

; 1087 : 			}
; 1088 : 			else if(pZone->GetDominanceFlag() == TACTICAL_DOMINANCE_ENEMY)

	cmp	eax, 2
	jne	SHORT $LN11@LogZones

; 1089 : 			{
; 1090 : 				szLogMsg += ", Enemy";

	push	OFFSET $SG222829
	jmp	SHORT $LN91@LogZones
$LN11@LogZones:

; 1091 : 			}
; 1092 : 			else if(pZone->GetDominanceFlag() == TACTICAL_DOMINANCE_EVEN)

	cmp	eax, 3
	jne	SHORT $LN9@LogZones

; 1093 : 			{
; 1094 : 				szLogMsg += ", Even";

	push	OFFSET $SG222832
	jmp	SHORT $LN91@LogZones
$LN9@LogZones:

; 1095 : 			}
; 1096 : 			else if(pZone->GetDominanceFlag() == TACTICAL_DOMINANCE_NO_UNITS_VISIBLE)

	test	eax, eax
	jne	SHORT $LN7@LogZones

; 1097 : 			{
; 1098 : 				szLogMsg += ", No Units Visible";

	push	OFFSET $SG222835
$LN91@LogZones:
	lea	ecx, DWORD PTR _szLogMsg$222818[esp+152]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN7@LogZones:

; 1099 : 			}
; 1100 : 
; 1101 : 			if(pZone->IsWater())

	cmp	BYTE PTR [esi+68], 0

; 1102 : 			{
; 1103 : 				szLogMsg += ", Water";

	lea	ecx, DWORD PTR _szLogMsg$222818[esp+148]
	je	SHORT $LN6@LogZones
	push	OFFSET $SG222837

; 1104 : 			}
; 1105 : 			else

	jmp	SHORT $LN92@LogZones
$LN6@LogZones:

; 1106 : 			{
; 1107 : 				szLogMsg += ", Land";

	push	OFFSET $SG222839
$LN92@LogZones:
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1108 : 			}
; 1109 : 
; 1110 : 			if(pZone->GetTerritoryType() == TACTICAL_TERRITORY_TEMP_ZONE)

	cmp	DWORD PTR [esi+4], 5
	jne	SHORT $LN4@LogZones

; 1111 : 			{
; 1112 : 				szLogMsg += ", Temporary Zone";

	push	OFFSET $SG222841
	lea	ecx, DWORD PTR _szLogMsg$222818[esp+152]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN89@LogZones:

; 1118 : 				{
; 1119 : 					szLogMsg += " (Temp)";

	mov	esi, DWORD PTR _this$[esp+148]
$LN1@LogZones:

; 1120 : 				}
; 1121 : 			}
; 1122 : 
; 1123 : 			m_pPlayer->GetTacticalAI()->LogTacticalMessage(szLogMsg, true /*bSkipLogDominanceZone*/);

	mov	ecx, DWORD PTR [esi+20]
	push	ebx
	lea	edx, DWORD PTR _szLogMsg$222818[esp+152]
	push	edx
	call	?GetTacticalAI@CvPlayer@@QBEPAVCvTacticalAI@@XZ ; CvPlayer::GetTacticalAI
	mov	ecx, eax
	call	?LogTacticalMessage@CvTacticalAI@@QAEXAAVCvString@@_N@Z ; CvTacticalAI::LogTacticalMessage
	mov	eax, DWORD PTR _iI$222820[esp+148]
	mov	ecx, DWORD PTR tv514[esp+148]
	add	eax, ebx
	add	ecx, 76					; 0000004cH
	mov	DWORD PTR _iI$222820[esp+148], eax
	mov	DWORD PTR tv514[esp+148], ecx
	cmp	eax, DWORD PTR [esi+116]
	jb	$LL16@LogZones
	pop	edi
	pop	ebp
	pop	ebx
$LN14@LogZones:

; 1124 : 		}
; 1125 : 	}

	lea	ecx, DWORD PTR _szLogMsg$222818[esp+136]
	mov	DWORD PTR __$EHRec$[esp+144], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN17@LogZones:

; 1126 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+136]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 132				; 00000084H
	ret	0
$LN4@LogZones:

; 1113 : 			}
; 1114 : 			else if(pZone->GetClosestCity())

	mov	eax, DWORD PTR [esi+12]
	cmp	eax, -1
	je	SHORT $LN89@LogZones
	mov	ecx, DWORD PTR [esi+16]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	je	$LN89@LogZones

; 1115 : 			{
; 1116 : 				szLogMsg += ", " + pZone->GetClosestCity()->getName();

	mov	eax, DWORD PTR [esi+12]
	cmp	eax, -1
	je	SHORT $LN71@LogZones
	mov	edx, DWORD PTR [esi+16]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	jmp	SHORT $LN72@LogZones
$LN71@LogZones:
	xor	eax, eax
$LN72@LogZones:
	lea	ecx, DWORD PTR $T225733[esp+148]
	push	ecx
	mov	ecx, eax
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	push	eax
	lea	edx, DWORD PTR $T225734[esp+152]
	push	OFFSET $SG222846
	push	edx
	mov	BYTE PTR __$EHRec$[esp+168], bl
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _szLogMsg$222818[esp+152]
	mov	BYTE PTR __$EHRec$[esp+160], 2
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T225734[esp+148]
	mov	BYTE PTR __$EHRec$[esp+156], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T225733[esp+148]
	mov	BYTE PTR __$EHRec$[esp+156], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1117 : 				if (m_pPlayer->GetTacticalAI()->IsTemporaryZoneCity(pZone->GetClosestCity()))

	mov	eax, DWORD PTR [esi+12]
	cmp	eax, -1
	je	SHORT $LN79@LogZones
	mov	ecx, DWORD PTR [esi+16]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	jmp	SHORT $LN80@LogZones
$LN79@LogZones:
	xor	eax, eax
$LN80@LogZones:
	mov	esi, DWORD PTR _this$[esp+148]
	mov	ecx, DWORD PTR [esi+20]
	push	eax
	call	?GetTacticalAI@CvPlayer@@QBEPAVCvTacticalAI@@XZ ; CvPlayer::GetTacticalAI
	mov	ecx, eax
	call	?IsTemporaryZoneCity@CvTacticalAI@@QAE_NPAVCvCity@@@Z ; CvTacticalAI::IsTemporaryZoneCity
	test	al, al
	je	$LN1@LogZones

; 1118 : 				{
; 1119 : 					szLogMsg += " (Temp)";

	push	OFFSET $SG222848
	lea	ecx, DWORD PTR _szLogMsg$222818[esp+152]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
	jmp	$LN1@LogZones
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogZones@CvTacticalAnalysisMap@@IAEXXZ$0:
	lea	ecx, DWORD PTR _szLogMsg$222818[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogZones@CvTacticalAnalysisMap@@IAEXXZ$1:
	lea	ecx, DWORD PTR $T225733[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogZones@CvTacticalAnalysisMap@@IAEXXZ$2:
	lea	ecx, DWORD PTR $T225734[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogZones@CvTacticalAnalysisMap@@IAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?LogZones@CvTacticalAnalysisMap@@IAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogZones@CvTacticalAnalysisMap@@IAEXXZ ENDP		; CvTacticalAnalysisMap::LogZones
PUBLIC	?FindExistingZone@CvTacticalAnalysisMap@@IAEPAVCvTacticalDominanceZone@@PAVCvPlot@@@Z ; CvTacticalAnalysisMap::FindExistingZone
; Function compile flags: /Ogtpy
;	COMDAT ?FindExistingZone@CvTacticalAnalysisMap@@IAEPAVCvTacticalDominanceZone@@PAVCvPlot@@@Z
_TEXT	SEGMENT
_iI$222854 = -4						; size = 4
_pPlot$ = 8						; size = 4
?FindExistingZone@CvTacticalAnalysisMap@@IAEPAVCvTacticalDominanceZone@@PAVCvPlot@@@Z PROC ; CvTacticalAnalysisMap::FindExistingZone, COMDAT
; _this$ = ecx

; 1130 : {

	push	ecx
	push	ebx
	push	ebp
	push	esi

; 1131 : 	CvTacticalDominanceZone* pZone;
; 1132 : 
; 1133 : 	for(unsigned int iI = 0; iI < m_DominanceZones.size(); iI++)

	xor	ebp, ebp
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _iI$222854[esp+20], ebp
	cmp	DWORD PTR [esi+116], ebp
	jbe	$LN8@FindExisti
$LL10@FindExisti:

; 1134 : 	{
; 1135 : 		pZone = &m_DominanceZones[iI];

	mov	edi, DWORD PTR [esi+112]

; 1136 : 
; 1137 : 		// If this is a temporary zone, matches if unowned and close enough
; 1138 : 		if((pZone->GetTerritoryType() == TACTICAL_TERRITORY_TEMP_ZONE) &&
; 1139 : 		        (m_TempZone.GetTerritoryType() == TACTICAL_TERRITORY_NO_OWNER || m_TempZone.GetTerritoryType() == TACTICAL_TERRITORY_NEUTRAL) &&
; 1140 : 		        (plotDistance(pPlot->getX(), pPlot->getY(), pZone->GetTempZoneCenter()->getX(), pZone->GetTempZoneCenter()->getY()) <= m_iTacticalRange))

	mov	ebx, DWORD PTR [edi+ebp+4]
	add	edi, ebp
	cmp	ebx, 5
	jne	SHORT $LN74@FindExisti
	mov	eax, DWORD PTR [esi+40]
	cmp	eax, 1
	je	SHORT $LN6@FindExisti
	cmp	eax, 4
	jne	SHORT $LN74@FindExisti
$LN6@FindExisti:
	mov	eax, DWORD PTR [edi+72]
	movsx	ecx, WORD PTR [eax+2]
	movsx	edx, WORD PTR [eax]
	mov	eax, DWORD PTR _pPlot$[esp+16]
	push	ecx
	movsx	ecx, WORD PTR [eax+2]
	push	edx
	movsx	edx, WORD PTR [eax]
	push	ecx
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, DWORD PTR [esi+8]
	jle	$LN70@FindExisti
$LN74@FindExisti:

; 1143 : 		}
; 1144 : 
; 1145 : 		// If not friendly or enemy, just 1 zone per area
; 1146 : 		if((pZone->GetTerritoryType() == TACTICAL_TERRITORY_NO_OWNER || pZone->GetTerritoryType() == TACTICAL_TERRITORY_NEUTRAL) &&
; 1147 : 		        (m_TempZone.GetTerritoryType() == TACTICAL_TERRITORY_NO_OWNER || m_TempZone.GetTerritoryType() == TACTICAL_TERRITORY_NEUTRAL))

	cmp	ebx, 1
	je	SHORT $LN76@FindExisti
	cmp	ebx, 4
	jne	SHORT $LN2@FindExisti
$LN76@FindExisti:
	mov	eax, DWORD PTR [esi+40]
	cmp	eax, 1
	je	SHORT $LN3@FindExisti
	cmp	eax, 4
	jne	SHORT $LN2@FindExisti
$LN3@FindExisti:

; 1148 : 		{
; 1149 : 			if(pZone->GetAreaID() == m_TempZone.GetAreaID())

	mov	eax, DWORD PTR [edi+20]
	cmp	eax, DWORD PTR [esi+56]
	je	SHORT $LN70@FindExisti
$LN2@FindExisti:

; 1150 : 			{
; 1151 : 				return pZone;
; 1152 : 			}
; 1153 : 		}
; 1154 : 
; 1155 : 		// Otherwise everything needs to match
; 1156 : 		if(pZone->GetTerritoryType() == m_TempZone.GetTerritoryType() &&
; 1157 : 		        pZone->GetOwner() == m_TempZone.GetOwner() &&
; 1158 : 		        pZone->GetAreaID() == m_TempZone.GetAreaID() &&
; 1159 : 		        pZone->GetClosestCity() == m_TempZone.GetClosestCity())

	cmp	ebx, DWORD PTR [esi+40]
	jne	SHORT $LN9@FindExisti
	mov	eax, DWORD PTR [edi+12]
	cmp	eax, DWORD PTR [esi+48]
	jne	SHORT $LN9@FindExisti
	mov	ecx, DWORD PTR [edi+20]
	cmp	ecx, DWORD PTR [esi+56]
	jne	SHORT $LN9@FindExisti
	cmp	eax, -1
	je	SHORT $LN59@FindExisti
	mov	edx, DWORD PTR [edi+16]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	ebx, eax
	jmp	SHORT $LN60@FindExisti
$LN59@FindExisti:
	xor	ebx, ebx
$LN60@FindExisti:
	mov	eax, DWORD PTR [esi+48]
	cmp	eax, -1
	je	SHORT $LN64@FindExisti
	mov	ecx, DWORD PTR [esi+52]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	jmp	SHORT $LN65@FindExisti
$LN64@FindExisti:
	xor	eax, eax
$LN65@FindExisti:
	cmp	ebx, eax
	je	SHORT $LN70@FindExisti
$LN9@FindExisti:

; 1131 : 	CvTacticalDominanceZone* pZone;
; 1132 : 
; 1133 : 	for(unsigned int iI = 0; iI < m_DominanceZones.size(); iI++)

	mov	eax, DWORD PTR _iI$222854[esp+20]
	inc	eax
	add	ebp, 76					; 0000004cH
	mov	DWORD PTR _iI$222854[esp+20], eax
	cmp	eax, DWORD PTR [esi+116]
	jb	$LL10@FindExisti
$LN8@FindExisti:
	pop	edi
	pop	esi
	pop	ebp

; 1160 : 		{
; 1161 : 			return pZone;
; 1162 : 		}
; 1163 : 	}
; 1164 : 
; 1165 : 	return NULL;

	xor	eax, eax
	pop	ebx

; 1166 : }

	pop	ecx
	ret	4
$LN70@FindExisti:

; 1141 : 		{
; 1142 : 			return pZone;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1166 : }

	pop	ecx
	ret	4
?FindExistingZone@CvTacticalAnalysisMap@@IAEPAVCvTacticalDominanceZone@@PAVCvPlot@@@Z ENDP ; CvTacticalAnalysisMap::FindExistingZone
_TEXT	ENDS
PUBLIC	?GetZone@CvTacticalAnalysisMap@@QAEPAVCvTacticalDominanceZone@@H@Z ; CvTacticalAnalysisMap::GetZone
; Function compile flags: /Ogtpy
;	COMDAT ?GetZone@CvTacticalAnalysisMap@@QAEPAVCvTacticalDominanceZone@@H@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?GetZone@CvTacticalAnalysisMap@@QAEPAVCvTacticalDominanceZone@@H@Z PROC ; CvTacticalAnalysisMap::GetZone, COMDAT
; _this$ = ecx

; 1171 : 	if(iIndex < 0 || iIndex >= (int)m_DominanceZones.size())

	mov	eax, DWORD PTR _iIndex$[esp-4]
	test	eax, eax
	jl	SHORT $LN1@GetZone
	cmp	eax, DWORD PTR [ecx+116]
	jge	SHORT $LN1@GetZone

; 1173 : 	return &m_DominanceZones[iIndex];

	imul	eax, 76					; 0000004cH
	add	eax, DWORD PTR [ecx+112]

; 1174 : }

	ret	4
$LN1@GetZone:

; 1172 : 		return 0;

	xor	eax, eax

; 1174 : }

	ret	4
?GetZone@CvTacticalAnalysisMap@@QAEPAVCvTacticalDominanceZone@@H@Z ENDP ; CvTacticalAnalysisMap::GetZone
_TEXT	ENDS
PUBLIC	?ComputeDominance@CvTacticalAnalysisMap@@IAE?AW4eTacticalDominanceFlags@@PAVCvTacticalDominanceZone@@@Z ; CvTacticalAnalysisMap::ComputeDominance
; Function compile flags: /Ogtpy
;	COMDAT ?ComputeDominance@CvTacticalAnalysisMap@@IAE?AW4eTacticalDominanceFlags@@PAVCvTacticalDominanceZone@@@Z
_TEXT	SEGMENT
_pZone$ = 8						; size = 4
?ComputeDominance@CvTacticalAnalysisMap@@IAE?AW4eTacticalDominanceFlags@@PAVCvTacticalDominanceZone@@@Z PROC ; CvTacticalAnalysisMap::ComputeDominance, COMDAT
; _this$ = ecx

; 1216 : {

	push	esi

; 1217 : 	// Look at ratio of friendly to enemy strength
; 1218 : 	if(pZone->GetTerritoryType() != TACTICAL_TERRITORY_ENEMY && pZone->GetEnemyUnitCount() <= 0)

	mov	esi, DWORD PTR _pZone$[esp]
	cmp	DWORD PTR [esi+4], 3
	je	SHORT $LN8@ComputeDom
	cmp	DWORD PTR [esi+44], 0
	jg	SHORT $LN8@ComputeDom

; 1219 : 	{
; 1220 : 		pZone->SetDominanceFlag(TACTICAL_DOMINANCE_NO_UNITS_VISIBLE);

	mov	DWORD PTR [esi+8], 0

; 1244 : 			}
; 1245 : 		}
; 1246 : 	}
; 1247 : 
; 1248 : 	return pZone->GetDominanceFlag();

	mov	eax, DWORD PTR [esi+8]
	pop	esi

; 1249 : }

	ret	4
$LN8@ComputeDom:
	push	edi

; 1221 : 	}
; 1222 : 
; 1223 : 	else
; 1224 : 	{
; 1225 : 		// Otherwise compute it by strength
; 1226 : 		if(pZone->GetEnemyStrength() <= 0)

	mov	edi, DWORD PTR [esi+28]
	test	edi, edi
	jg	SHORT $LN6@ComputeDom
$LN35@ComputeDom:

; 1227 : 		{
; 1228 : 			pZone->SetDominanceFlag(TACTICAL_DOMINANCE_FRIENDLY);

	mov	DWORD PTR [esi+8], 1

; 1244 : 			}
; 1245 : 		}
; 1246 : 	}
; 1247 : 
; 1248 : 	return pZone->GetDominanceFlag();

	mov	eax, DWORD PTR [esi+8]
	pop	edi
	pop	esi

; 1249 : }

	ret	4
$LN6@ComputeDom:

; 1229 : 		}
; 1230 : 		else
; 1231 : 		{
; 1232 : 			int iRatio = (pZone->GetFriendlyStrength()  * 100) / pZone->GetEnemyStrength();

	mov	eax, DWORD PTR [esi+24]
	imul	eax, 100				; 00000064H
	cdq
	idiv	edi

; 1233 : 			if(iRatio > 100 + m_iDominancePercentage)

	mov	ecx, DWORD PTR [ecx]
	lea	edx, DWORD PTR [ecx+100]
	cmp	eax, edx

; 1234 : 			{
; 1235 : 				pZone->SetDominanceFlag(TACTICAL_DOMINANCE_FRIENDLY);

	jg	SHORT $LN35@ComputeDom

; 1236 : 			}
; 1237 : 			else if(iRatio < 100 - m_iDominancePercentage)

	mov	edx, 100				; 00000064H
	sub	edx, ecx
	cmp	eax, edx
	jge	SHORT $LN2@ComputeDom

; 1238 : 			{
; 1239 : 				pZone->SetDominanceFlag(TACTICAL_DOMINANCE_ENEMY);

	mov	DWORD PTR [esi+8], 2

; 1244 : 			}
; 1245 : 		}
; 1246 : 	}
; 1247 : 
; 1248 : 	return pZone->GetDominanceFlag();

	mov	eax, DWORD PTR [esi+8]
	pop	edi
	pop	esi

; 1249 : }

	ret	4
$LN2@ComputeDom:

; 1240 : 			}
; 1241 : 			else
; 1242 : 			{
; 1243 : 				pZone->SetDominanceFlag(TACTICAL_DOMINANCE_EVEN);

	mov	DWORD PTR [esi+8], 3

; 1244 : 			}
; 1245 : 		}
; 1246 : 	}
; 1247 : 
; 1248 : 	return pZone->GetDominanceFlag();

	mov	eax, DWORD PTR [esi+8]
	pop	edi
	pop	esi

; 1249 : }

	ret	4
?ComputeDominance@CvTacticalAnalysisMap@@IAE?AW4eTacticalDominanceFlags@@PAVCvTacticalDominanceZone@@@Z ENDP ; CvTacticalAnalysisMap::ComputeDominance
_TEXT	ENDS
PUBLIC	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
EXTRN	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ:PROC ; CvUnit::getDestructionNotification
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
;	COMDAT ??1?$FObjectHandle@VCvUnit@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ PROC		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 147  : 		if(m_target) 

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@FObjectHan

; 148  : 		{
; 149  : 			m_target->getDestructionNotification().removeTarget(*this);

	jmp	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN4@FObjectHan:

; 150  : 		}
; 151  : 	}

	ret	0
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ ENDP		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z	; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z PROC	; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 156  : 	{

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _target$[esp]
	mov	DWORD PTR [esi], ecx
	mov	BYTE PTR [esi+4], 0

; 157  : 		OBJECT_HANDLE_STACK;
; 158  : 		if(m_target)

	test	ecx, ecx
	je	SHORT $LN6@FObjectHan@2

; 159  : 		{
; 160  : 			m_target->getDestructionNotification().addTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN6@FObjectHan@2:

; 161  : 		}
; 162  : 	}

	mov	eax, esi
	pop	esi
	ret	4
??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z ENDP	; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvTacticalDominanceZone,110,1,297,0>::FStaticVector<CvTacticalDominanceZone,110,1,297,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvTacticalDominanceZone,110,1,297,0>::FStaticVector<CvTacticalDominanceZone,110,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 110			; 0000006eH
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvTacticalDominanceZone,110,1,297,0>::FStaticVector<CvTacticalDominanceZone,110,1,297,0>
_TEXT	ENDS
PUBLIC	?clear@?$BaseVector@VCvTacticalDominanceZone@@$00@@QAEXXZ ; BaseVector<CvTacticalDominanceZone,1>::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$BaseVector@VCvTacticalDominanceZone@@$00@@QAEXXZ
_TEXT	SEGMENT
?clear@?$BaseVector@VCvTacticalDominanceZone@@$00@@QAEXXZ PROC ; BaseVector<CvTacticalDominanceZone,1>::clear, COMDAT
; _this$ = ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);
; 122  : 		m_uiCurrSize = 0;

	mov	DWORD PTR [ecx+4], 0

; 123  : 	};

	ret	0
?clear@?$BaseVector@VCvTacticalDominanceZone@@$00@@QAEXXZ ENDP ; BaseVector<CvTacticalDominanceZone,1>::clear
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvUnit *,250,1,297,0>::FStaticVector<CvUnit *,250,1,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvUnit *,250,1,297,0>::FStaticVector<CvUnit *,250,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 250			; 000000faH
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvUnit *,250,1,297,0>::FStaticVector<CvUnit *,250,1,297,0>
_TEXT	ENDS
PUBLIC	?clear@?$BaseVector@PAVCvUnit@@$00@@QAEXXZ	; BaseVector<CvUnit *,1>::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$BaseVector@PAVCvUnit@@$00@@QAEXXZ
_TEXT	SEGMENT
?clear@?$BaseVector@PAVCvUnit@@$00@@QAEXXZ PROC		; BaseVector<CvUnit *,1>::clear, COMDAT
; _this$ = ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);
; 122  : 		m_uiCurrSize = 0;

	mov	DWORD PTR [ecx+4], 0

; 123  : 	};

	ret	0
?clear@?$BaseVector@PAVCvUnit@@$00@@QAEXXZ ENDP		; BaseVector<CvUnit *,1>::clear
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@IAEXPAVCvTacticalDominanceZone@@I@Z ; FStaticVector<CvTacticalDominanceZone,110,1,297,0>::Free
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@IAEXPAVCvTacticalDominanceZone@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@IAEXPAVCvTacticalDominanceZone@@I@Z PROC ; FStaticVector<CvTacticalDominanceZone,110,1,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@IAEXPAVCvTacticalDominanceZone@@I@Z ENDP ; FStaticVector<CvTacticalDominanceZone,110,1,297,0>::Free
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@IAEXPAPAVCvUnit@@I@Z ; FStaticVector<CvUnit *,250,1,297,0>::Free
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@IAEXPAPAVCvUnit@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@IAEXPAPAVCvUnit@@I@Z PROC ; FStaticVector<CvUnit *,250,1,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free@2

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free@2:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@IAEXPAPAVCvUnit@@I@Z ENDP ; FStaticVector<CvUnit *,250,1,297,0>::Free
_TEXT	ENDS
PUBLIC	??1?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAE@XZ ; std::_Temp_iterator<CvTacticalDominanceZone>::~_Temp_iterator<CvTacticalDominanceZone>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??1?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAE@XZ PROC ; std::_Temp_iterator<CvTacticalDominanceZone>::~_Temp_iterator<CvTacticalDominanceZone>, COMDAT
; _this$ = ecx

; 546  : 		if (_Buf._Begin != 0)

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN9@Temp_itera

; 547  : 			{	// destroy any constructed elements in buffer
; 548  : 			for (_Pty _Next = _Buf._Begin;
; 549  : 				_Next != _Buf._Hiwater; ++_Next)
; 550  : 				_Destroy(&*_Next);
; 551  : 			std::return_temporary_buffer(_Buf._Begin);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
$LN9@Temp_itera:

; 552  : 			}
; 553  : 		}

	ret	0
??1?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAE@XZ ENDP ; std::_Temp_iterator<CvTacticalDominanceZone>::~_Temp_iterator<CvTacticalDominanceZone>
_TEXT	ENDS
PUBLIC	??$_Distance@PAVCvTacticalDominanceZone@@H@std@@YAXPAVCvTacticalDominanceZone@@0AAH@Z ; std::_Distance<CvTacticalDominanceZone *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Distance@PAVCvTacticalDominanceZone@@H@std@@YAXPAVCvTacticalDominanceZone@@0AAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
??$_Distance@PAVCvTacticalDominanceZone@@H@std@@YAXPAVCvTacticalDominanceZone@@0AAH@Z PROC ; std::_Distance<CvTacticalDominanceZone *,int>, COMDAT

; 1893 : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

	mov	ecx, DWORD PTR __Last$[esp-4]
	sub	ecx, DWORD PTR __First$[esp-4]
	mov	eax, 1808407283				; 6bca1af3H
	imul	ecx
	mov	eax, DWORD PTR __Off$[esp-4]
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	DWORD PTR [eax], ecx

; 1894 : 	}

	ret	0
??$_Distance@PAVCvTacticalDominanceZone@@H@std@@YAXPAVCvTacticalDominanceZone@@0AAH@Z ENDP ; std::_Distance<CvTacticalDominanceZone *,int>
_TEXT	ENDS
PUBLIC	??$advance@PAVCvTacticalDominanceZone@@H@std@@YAXAAPAVCvTacticalDominanceZone@@H@Z ; std::advance<CvTacticalDominanceZone *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$advance@PAVCvTacticalDominanceZone@@H@std@@YAXAAPAVCvTacticalDominanceZone@@H@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
??$advance@PAVCvTacticalDominanceZone@@H@std@@YAXAAPAVCvTacticalDominanceZone@@H@Z PROC ; std::advance<CvTacticalDominanceZone *,int>, COMDAT

; 1774 : 	_Advance(_Where, _Off, _Iter_cat(_Where));

	mov	ecx, DWORD PTR __Off$[esp-4]
	mov	eax, DWORD PTR __Where$[esp-4]
	imul	ecx, 76					; 0000004cH
	add	DWORD PTR [eax], ecx

; 1775 : 	}

	ret	0
??$advance@PAVCvTacticalDominanceZone@@H@std@@YAXAAPAVCvTacticalDominanceZone@@H@Z ENDP ; std::advance<CvTacticalDominanceZone *,int>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$get_temporary_buffer@VCvTacticalDominanceZone@@@std@@YA?AU?$pair@PAVCvTacticalDominanceZone@@H@0@H@Z ; std::get_temporary_buffer<CvTacticalDominanceZone>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	??2@YAPAXIABUnothrow_t@std@@@Z:PROC		; operator new
EXTRN	?nothrow@std@@3Unothrow_t@1@B:BYTE		; std::nothrow
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$get_temporary_buffer@VCvTacticalDominanceZone@@@std@@YA?AU?$pair@PAVCvTacticalDominanceZone@@H@0@H@Z
_TEXT	SEGMENT
$T226175 = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
$T226180 = 12						; size = 4
__Count$ = 12						; size = 4
??$get_temporary_buffer@VCvTacticalDominanceZone@@@std@@YA?AU?$pair@PAVCvTacticalDominanceZone@@H@0@H@Z PROC ; std::get_temporary_buffer<CvTacticalDominanceZone>, COMDAT

; 19   : 	{	// get raw temporary buffer of up to _Count elements

	sub	esp, 12					; 0000000cH
	push	esi

; 20   : 	_Ty _FARQ *_Pbuf;
; 21   : 
; 22   : 	if (_Count <= 0)

	mov	esi, DWORD PTR __Count$[esp+12]
	test	esi, esi
	jg	SHORT $LN7@get_tempor

; 23   : 		_Count = 0;

	xor	esi, esi
$LN5@get_tempor:

; 26   : 
; 27   : 	for (_Pbuf = 0; 0 < _Count; _Count /= 2)

	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN15@get_tempor
$LL4@get_tempor:

; 28   : 		if ((_Pbuf = (_Ty _FARQ *)operator new(
; 29   : 			(_SIZT)_Count * sizeof (_Ty), nothrow)) != 0)

	mov	edx, esi
	imul	edx, 76					; 0000004cH
	push	OFFSET ?nothrow@std@@3Unothrow_t@1@B	; std::nothrow
	push	edx
	call	??2@YAPAXIABUnothrow_t@std@@@Z		; operator new
	mov	ecx, eax
	add	esp, 8
	test	ecx, ecx
	jne	SHORT $LN15@get_tempor
	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	test	esi, esi
	jg	SHORT $LL4@get_tempor
$LN15@get_tempor:

; 30   : 			break;
; 31   : 
; 32   : 	return (pair<_Ty _FARQ *, _PDFT>(_Pbuf, _Count));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 33   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN7@get_tempor:

; 24   : 	else if (((size_t)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	esi
	cmp	eax, 76					; 0000004cH
	jae	SHORT $LN5@get_tempor

; 25   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T226180[esp+12]
	push	eax
	lea	ecx, DWORD PTR $T226175[esp+20]
	mov	DWORD PTR $T226180[esp+16], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T226175[esp+20]
	push	ecx
	mov	DWORD PTR $T226175[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN18@get_tempor:
$LN17@get_tempor:
	int	3
??$get_temporary_buffer@VCvTacticalDominanceZone@@@std@@YA?AU?$pair@PAVCvTacticalDominanceZone@@H@0@H@Z ENDP ; std::get_temporary_buffer<CvTacticalDominanceZone>
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??0?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAE@ABV01@@Z ; std::_Temp_iterator<CvTacticalDominanceZone>::_Temp_iterator<CvTacticalDominanceZone>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAE@ABV01@@Z PROC ; std::_Temp_iterator<CvTacticalDominanceZone>::_Temp_iterator<CvTacticalDominanceZone>, COMDAT
; _this$ = ecx

; 535  : 	_Temp_iterator(const _Temp_iterator<_Ty>& _Right)

	mov	eax, ecx

; 536  : 		{	// construct from _Right (share active buffer)
; 537  : 		_Buf._Begin = 0;	// clear stored buffer, for safe destruction

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 538  : 		_Buf._Current = 0;

	mov	DWORD PTR [eax+4], ecx

; 539  : 		_Buf._Hiwater = 0;

	mov	DWORD PTR [eax+8], ecx

; 540  : 		_Buf._Size = 0;

	mov	DWORD PTR [eax+12], ecx

; 541  : 		*this = _Right;

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 542  : 		}

	ret	4
??0?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAE@ABV01@@Z ENDP ; std::_Temp_iterator<CvTacticalDominanceZone>::_Temp_iterator<CvTacticalDominanceZone>
_TEXT	ENDS
PUBLIC	??$iter_swap@PAVCvTacticalDominanceZone@@PAV1@@std@@YAXPAVCvTacticalDominanceZone@@0@Z ; std::iter_swap<CvTacticalDominanceZone *,CvTacticalDominanceZone *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$iter_swap@PAVCvTacticalDominanceZone@@PAV1@@std@@YAXPAVCvTacticalDominanceZone@@0@Z
_TEXT	SEGMENT
__Tmp$226205 = -76					; size = 76
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@PAVCvTacticalDominanceZone@@PAV1@@std@@YAXPAVCvTacticalDominanceZone@@0@Z PROC ; std::iter_swap<CvTacticalDominanceZone *,CvTacticalDominanceZone *>, COMDAT

; 594  : 	swap(*_Left, *_Right);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	edx, DWORD PTR __Right$[esp-4]
	sub	esp, 76					; 0000004cH
	cmp	eax, edx
	je	SHORT $LN3@iter_swap
	push	esi
	push	edi
	mov	ecx, 19					; 00000013H
	mov	esi, eax
	lea	edi, DWORD PTR __Tmp$226205[esp+84]
	rep movsd
	mov	ecx, 19					; 00000013H
	mov	esi, edx
	mov	edi, eax
	rep movsd
	mov	ecx, 19					; 00000013H
	lea	esi, DWORD PTR __Tmp$226205[esp+84]
	mov	edi, edx
	rep movsd
	pop	edi
	pop	esi
$LN3@iter_swap:

; 595  : 	}

	add	esp, 76					; 0000004cH
	ret	0
??$iter_swap@PAVCvTacticalDominanceZone@@PAV1@@std@@YAXPAVCvTacticalDominanceZone@@0@Z ENDP ; std::iter_swap<CvTacticalDominanceZone *,CvTacticalDominanceZone *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy_backward@PAVCvTacticalDominanceZone@@PAV1@@stdext@@YAPAVCvTacticalDominanceZone@@PAV1@00@Z ; stdext::unchecked_copy_backward<CvTacticalDominanceZone *,CvTacticalDominanceZone *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy_backward@PAVCvTacticalDominanceZone@@PAV1@@stdext@@YAPAVCvTacticalDominanceZone@@PAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy_backward@PAVCvTacticalDominanceZone@@PAV1@@stdext@@YAPAVCvTacticalDominanceZone@@PAV1@00@Z PROC ; stdext::unchecked_copy_backward<CvTacticalDominanceZone *,CvTacticalDominanceZone *>, COMDAT

; 3637 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3638 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR __First$[esp]
	cmp	ebx, edx
	je	SHORT $LN7@unchecked_
	push	esi
	push	edi
$LL8@unchecked_:
	sub	edx, 76					; 0000004cH
	sub	eax, 76					; 0000004cH
	mov	ecx, 19					; 00000013H
	mov	esi, edx
	mov	edi, eax
	rep movsd
	cmp	edx, ebx
	jne	SHORT $LL8@unchecked_
	pop	edi
	pop	esi
$LN7@unchecked_:
	pop	ebx

; 3639 : 	}

	ret	0
??$unchecked_copy_backward@PAVCvTacticalDominanceZone@@PAV1@@stdext@@YAPAVCvTacticalDominanceZone@@PAV1@00@Z ENDP ; stdext::unchecked_copy_backward<CvTacticalDominanceZone *,CvTacticalDominanceZone *>
_TEXT	ENDS
PUBLIC	??$_Merge_backward@PAVCvTacticalDominanceZone@@PAV1@PAV1@@std@@YAPAVCvTacticalDominanceZone@@PAV1@0000U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<CvTacticalDominanceZone *,CvTacticalDominanceZone *,CvTacticalDominanceZone *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Merge_backward@PAVCvTacticalDominanceZone@@PAV1@PAV1@@std@@YAPAVCvTacticalDominanceZone@@PAV1@0000U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Merge_backward@PAVCvTacticalDominanceZone@@PAV1@PAV1@@std@@YAPAVCvTacticalDominanceZone@@PAV1@0000U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge_backward<CvTacticalDominanceZone *,CvTacticalDominanceZone *,CvTacticalDominanceZone *>, COMDAT

; 2711 : 	for (; ; )
; 2712 : 		if (_First1 == _Last1)

	mov	edx, DWORD PTR __Last1$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR __Last2$[esp]
	push	ebp
	mov	ebp, DWORD PTR __First1$[esp+4]
	push	esi
	push	edi
	cmp	ebp, edx
	je	SHORT $LN37@Merge_back
$LL8@Merge_back:

; 2714 : 		else if (_First2 == _Last2)

	cmp	DWORD PTR __First2$[esp+12], ebx
	je	SHORT $LN38@Merge_back

; 2716 : 		else if (_DEBUG_LT(*--_Last2, *--_Last1))

	mov	ecx, DWORD PTR [ebx-16]
	sub	ebx, 76					; 0000004cH
	sub	edx, 76					; 0000004cH

; 2717 : 			*--_Dest = *_Last1, ++_Last2;

	sub	eax, 76					; 0000004cH
	cmp	ecx, DWORD PTR [edx+60]
	mov	edi, eax
	mov	ecx, 19					; 00000013H
	jle	SHORT $LN2@Merge_back
	mov	esi, edx
	add	ebx, 76					; 0000004cH

; 2718 : 		else

	jmp	SHORT $LN42@Merge_back
$LN2@Merge_back:

; 2719 : 			*--_Dest = *_Last2, ++_Last1;

	mov	esi, ebx
	add	edx, 76					; 0000004cH
$LN42@Merge_back:
	rep movsd
	cmp	ebp, edx
	jne	SHORT $LL8@Merge_back
$LN37@Merge_back:

; 2713 : 			return (_STDEXT unchecked_copy_backward(_First2, _Last2, _Dest));

	mov	ebp, DWORD PTR __First2$[esp+12]
	mov	edx, ebx
	cmp	ebp, ebx
	je	SHORT $LN7@Merge_back
$LL18@Merge_back:
	sub	edx, 76					; 0000004cH
	sub	eax, 76					; 0000004cH
	mov	ecx, 19					; 00000013H
	mov	esi, edx
	mov	edi, eax
	rep movsd
	cmp	edx, ebp
	jne	SHORT $LL18@Merge_back
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2720 : 	}

	ret	0
$LN38@Merge_back:

; 2715 : 			return (_STDEXT unchecked_copy_backward(_First1, _Last1, _Dest));

	cmp	ebp, edx
	je	SHORT $LN7@Merge_back
$LL28@Merge_back:
	sub	edx, 76					; 0000004cH
	sub	eax, 76					; 0000004cH
	mov	ecx, 19					; 00000013H
	mov	esi, edx
	mov	edi, eax
	rep movsd
	cmp	edx, ebp
	jne	SHORT $LL28@Merge_back
$LN7@Merge_back:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2720 : 	}

	ret	0
??$_Merge_backward@PAVCvTacticalDominanceZone@@PAV1@PAV1@@std@@YAPAVCvTacticalDominanceZone@@PAV1@0000U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge_backward<CvTacticalDominanceZone *,CvTacticalDominanceZone *,CvTacticalDominanceZone *>
_TEXT	ENDS
PUBLIC	??$_Lower_bound@PAVCvTacticalDominanceZone@@V1@H@std@@YAPAVCvTacticalDominanceZone@@PAV1@0ABV1@PAH@Z ; std::_Lower_bound<CvTacticalDominanceZone *,CvTacticalDominanceZone,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Lower_bound@PAVCvTacticalDominanceZone@@V1@H@std@@YAPAVCvTacticalDominanceZone@@PAV1@0ABV1@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Lower_bound@PAVCvTacticalDominanceZone@@V1@H@std@@YAPAVCvTacticalDominanceZone@@PAV1@0ABV1@PAH@Z PROC ; std::_Lower_bound<CvTacticalDominanceZone *,CvTacticalDominanceZone,int>, COMDAT

; 2253 : 	_DEBUG_ORDER_SINGLE(_First, _Last, true);
; 2254 : 	_Diff _Count = 0;
; 2255 : 	_Distance(_First, _Last, _Count);

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+4]
	sub	ecx, edi
	mov	eax, 1808407283				; 6bca1af3H
	imul	ecx
	sar	edx, 5
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx

; 2256 : 
; 2257 : 	for (; 0 < _Count; )

	test	esi, esi
	jle	SHORT $LN22@Lower_boun
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ebx
	mov	ebx, DWORD PTR [eax+60]
	npad	7
$LL4@Lower_boun:

; 2258 : 		{	// divide and conquer, find half that contains answer
; 2259 : 		_Diff _Count2 = _Count / 2;

	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1

; 2260 : 		_FwdIt _Mid = _First;
; 2261 : 		std::advance(_Mid, _Count2);

	mov	ecx, eax
	imul	ecx, 76					; 0000004cH
	add	ecx, edi

; 2262 : 		_DEBUG_ORDER_SINGLE(_Mid, _Last, false);
; 2263 : 
; 2264 : 		if (_DEBUG_LT(*_Mid, _Val))

	cmp	DWORD PTR [ecx+60], ebx
	jle	SHORT $LN2@Lower_boun

; 2265 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	lea	edi, DWORD PTR [ecx+76]
	or	ecx, -1
	sub	ecx, eax
	add	esi, ecx

; 2266 : 		else

	jmp	SHORT $LN1@Lower_boun
$LN2@Lower_boun:

; 2267 : 			_Count = _Count2;

	mov	esi, eax
$LN1@Lower_boun:

; 2256 : 
; 2257 : 	for (; 0 < _Count; )

	test	esi, esi
	jg	SHORT $LL4@Lower_boun
	pop	ebx
$LN22@Lower_boun:

; 2268 : 		}
; 2269 : 	return (_First);

	mov	eax, edi
	pop	edi
	pop	esi

; 2270 : 	}

	ret	0
??$_Lower_bound@PAVCvTacticalDominanceZone@@V1@H@std@@YAPAVCvTacticalDominanceZone@@PAV1@0ABV1@PAH@Z ENDP ; std::_Lower_bound<CvTacticalDominanceZone *,CvTacticalDominanceZone,int>
_TEXT	ENDS
PUBLIC	??$_Upper_bound@PAVCvTacticalDominanceZone@@V1@H@std@@YAPAVCvTacticalDominanceZone@@PAV1@0ABV1@PAH@Z ; std::_Upper_bound<CvTacticalDominanceZone *,CvTacticalDominanceZone,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Upper_bound@PAVCvTacticalDominanceZone@@V1@H@std@@YAPAVCvTacticalDominanceZone@@PAV1@0ABV1@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Upper_bound@PAVCvTacticalDominanceZone@@V1@H@std@@YAPAVCvTacticalDominanceZone@@PAV1@0ABV1@PAH@Z PROC ; std::_Upper_bound<CvTacticalDominanceZone *,CvTacticalDominanceZone,int>, COMDAT

; 2325 : 	_DEBUG_ORDER_SINGLE(_First, _Last, true);
; 2326 : 	_Diff _Count = 0;
; 2327 : 	_Distance(_First, _Last, _Count);

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+4]
	sub	ecx, edi
	mov	eax, 1808407283				; 6bca1af3H
	imul	ecx
	sar	edx, 5
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx

; 2328 : 	for (; 0 < _Count; )

	test	esi, esi
	jle	SHORT $LN22@Upper_boun
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ebx
	mov	ebx, DWORD PTR [eax+60]
	npad	7
$LL4@Upper_boun:

; 2329 : 		{	// divide and conquer, find half that contains answer
; 2330 : 		_Diff _Count2 = _Count / 2;

	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1

; 2331 : 		_FwdIt _Mid = _First;
; 2332 : 		std::advance(_Mid, _Count2);

	mov	ecx, eax
	imul	ecx, 76					; 0000004cH
	add	ecx, edi

; 2333 : 		_DEBUG_ORDER_SINGLE(_Mid, _Last, false);
; 2334 : 
; 2335 : 		if (!_DEBUG_LT(_Val, *_Mid))

	cmp	ebx, DWORD PTR [ecx+60]
	jg	SHORT $LN2@Upper_boun

; 2336 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	lea	edi, DWORD PTR [ecx+76]
	or	ecx, -1
	sub	ecx, eax
	add	esi, ecx

; 2337 : 		else

	jmp	SHORT $LN1@Upper_boun
$LN2@Upper_boun:

; 2338 : 			_Count = _Count2;

	mov	esi, eax
$LN1@Upper_boun:

; 2328 : 	for (; 0 < _Count; )

	test	esi, esi
	jg	SHORT $LL4@Upper_boun
	pop	ebx
$LN22@Upper_boun:

; 2339 : 		}
; 2340 : 	return (_First);

	mov	eax, edi
	pop	edi
	pop	esi

; 2341 : 	}

	ret	0
??$_Upper_bound@PAVCvTacticalDominanceZone@@V1@H@std@@YAPAVCvTacticalDominanceZone@@PAV1@0ABV1@PAH@Z ENDP ; std::_Upper_bound<CvTacticalDominanceZone *,CvTacticalDominanceZone,int>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAVCvTacticalDominanceZone@@PAV1@@stdext@@YAPAVCvTacticalDominanceZone@@PAV1@00@Z ; stdext::unchecked_copy<CvTacticalDominanceZone *,CvTacticalDominanceZone *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAVCvTacticalDominanceZone@@PAV1@@stdext@@YAPAVCvTacticalDominanceZone@@PAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAVCvTacticalDominanceZone@@PAV1@@stdext@@YAPAVCvTacticalDominanceZone@@PAV1@00@Z PROC ; stdext::unchecked_copy<CvTacticalDominanceZone *,CvTacticalDominanceZone *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR __Last$[esp]
	cmp	edx, ebx
	je	SHORT $LN7@unchecked_@2
	push	esi
	push	edi
$LL9@unchecked_@2:
	mov	esi, edx
	mov	edi, eax
	add	edx, 76					; 0000004cH
	mov	ecx, 19					; 00000013H
	add	eax, 76					; 0000004cH
	rep movsd
	cmp	edx, ebx
	jne	SHORT $LL9@unchecked_@2
	pop	edi
	pop	esi
$LN7@unchecked_@2:
	pop	ebx

; 3607 : 	}

	ret	0
??$unchecked_copy@PAVCvTacticalDominanceZone@@PAV1@@stdext@@YAPAVCvTacticalDominanceZone@@PAV1@00@Z ENDP ; stdext::unchecked_copy<CvTacticalDominanceZone *,CvTacticalDominanceZone *>
_TEXT	ENDS
PUBLIC	??4?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAEAAV01@ABVCvTacticalDominanceZone@@@Z ; std::_Temp_iterator<CvTacticalDominanceZone>::operator=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??4?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAEAAV01@ABVCvTacticalDominanceZone@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??4?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAEAAV01@ABVCvTacticalDominanceZone@@@Z PROC ; std::_Temp_iterator<CvTacticalDominanceZone>::operator=, COMDAT
; _this$ = ecx

; 562  : 		{	// assign or construct value into active buffer, and increment

	mov	eax, ecx

; 563  : 		if (_Pbuf->_Current < _Pbuf->_Hiwater)

	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	push	esi
	push	edi
	cmp	edx, DWORD PTR [ecx+8]
	jae	SHORT $LN2@operator

; 564  : 			*_Pbuf->_Current++ = _Val;	// below high water mark, assign

	mov	esi, DWORD PTR __Val$[esp+4]
	mov	edx, ecx
	mov	edi, DWORD PTR [edx+4]
	mov	ecx, 19					; 00000013H
	rep movsd
	mov	ecx, DWORD PTR [eax+16]
	add	DWORD PTR [ecx+4], 76			; 0000004cH
	pop	edi
	pop	esi

; 571  : 			}
; 572  : 		return (*this);
; 573  : 		}

	ret	4
$LN2@operator:

; 565  : 		else
; 566  : 			{	// above high water mark, construct
; 567  : 			_SCL_SECURE_VALIDATE((_Pbuf->_Current - _Pbuf->_Begin) < _Pbuf->_Size);
; 568  : 			_Pty _Ptr = &*_Pbuf->_Current;
; 569  : 			_Construct(_Ptr, _Val);

	mov	edi, DWORD PTR [ecx+4]
	test	edi, edi
	je	SHORT $LN7@operator
	mov	esi, DWORD PTR __Val$[esp+4]
	mov	ecx, 19					; 00000013H
	rep movsd
$LN7@operator:

; 570  : 			_Pbuf->_Hiwater = ++_Pbuf->_Current;

	mov	ecx, DWORD PTR [eax+16]
	add	DWORD PTR [ecx+4], 76			; 0000004cH
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	pop	edi
	mov	DWORD PTR [ecx+8], edx
	pop	esi

; 571  : 			}
; 572  : 		return (*this);
; 573  : 		}

	ret	4
??4?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAEAAV01@ABVCvTacticalDominanceZone@@@Z ENDP ; std::_Temp_iterator<CvTacticalDominanceZone>::operator=
_TEXT	ENDS
PUBLIC	??$_Rotate@PAVCvTacticalDominanceZone@@@std@@YAXPAVCvTacticalDominanceZone@@00Urandom_access_iterator_tag@0@@Z ; std::_Rotate<CvTacticalDominanceZone *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Rotate@PAVCvTacticalDominanceZone@@@std@@YAXPAVCvTacticalDominanceZone@@00Urandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Rotate@PAVCvTacticalDominanceZone@@@std@@YAXPAVCvTacticalDominanceZone@@00Urandom_access_iterator_tag@0@@Z PROC ; std::_Rotate<CvTacticalDominanceZone *>, COMDAT

; 1713 : 	_Rotate(_First, _Mid, _Last, _Dist_type(_First), _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __Mid$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	0
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Rotate@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@00PAH0@Z ; std::_Rotate<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>
	add	esp, 20					; 00000014H

; 1714 : 	}

	ret	0
??$_Rotate@PAVCvTacticalDominanceZone@@@std@@YAXPAVCvTacticalDominanceZone@@00Urandom_access_iterator_tag@0@@Z ENDP ; std::_Rotate<CvTacticalDominanceZone *>
_TEXT	ENDS
PUBLIC	?isEmbarked@CvUnit@@QBE_NXZ			; CvUnit::isEmbarked
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunit.h
;	COMDAT ?isEmbarked@CvUnit@@QBE_NXZ
_TEXT	SEGMENT
?isEmbarked@CvUnit@@QBE_NXZ PROC			; CvUnit::isEmbarked, COMDAT
; _this$ = ecx

; 257  : 		return m_bEmbarked;

	mov	al, BYTE PTR [ecx+1652]

; 258  : 	}

	ret	0
?isEmbarked@CvUnit@@QBE_NXZ ENDP			; CvUnit::isEmbarked
_TEXT	ENDS
PUBLIC	?getX@CvUnit@@QBEHXZ				; CvUnit::getX
; Function compile flags: /Ogtpy
;	COMDAT ?getX@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?getX@CvUnit@@QBEHXZ PROC				; CvUnit::getX, COMDAT
; _this$ = ecx

; 673  : 		return m_iX.get();

	mov	eax, DWORD PTR [ecx+76]

; 674  : 	}

	ret	0
?getX@CvUnit@@QBEHXZ ENDP				; CvUnit::getX
_TEXT	ENDS
PUBLIC	?getY@CvUnit@@QBEHXZ				; CvUnit::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?getY@CvUnit@@QBEHXZ PROC				; CvUnit::getY, COMDAT
; _this$ = ecx

; 678  : 		return m_iY.get();

	mov	eax, DWORD PTR [ecx+88]

; 679  : 	}

	ret	0
?getY@CvUnit@@QBEHXZ ENDP				; CvUnit::getY
_TEXT	ENDS
PUBLIC	?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ	; CvUnit::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ PROC		; CvUnit::getOwner, COMDAT
; _this$ = ecx

; 1046 : 		return m_eOwner.get();

	mov	eax, DWORD PTR [ecx+40]

; 1047 : 	}

	ret	0
?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ ENDP		; CvUnit::getOwner
_TEXT	ENDS
PUBLIC	?IsCombatUnit@CvUnit@@QBE_NXZ			; CvUnit::IsCombatUnit
; Function compile flags: /Ogtpy
;	COMDAT ?IsCombatUnit@CvUnit@@QBE_NXZ
_TEXT	SEGMENT
?IsCombatUnit@CvUnit@@QBE_NXZ PROC			; CvUnit::IsCombatUnit, COMDAT
; _this$ = ecx

; 1243 : 		return (m_iBaseCombat > 0);

	xor	eax, eax
	cmp	DWORD PTR [ecx+1044], eax
	setg	al

; 1244 : 	}

	ret	0
?IsCombatUnit@CvUnit@@QBE_NXZ ENDP			; CvUnit::IsCombatUnit
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT
; _p$ = eax

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 302  : }

	ret	0
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1

; 302  : }

	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
PUBLIC	?GetID@CvCity@@QBEHXZ				; CvCity::GetID
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcity.h
;	COMDAT ?GetID@CvCity@@QBEHXZ
_TEXT	SEGMENT
?GetID@CvCity@@QBEHXZ PROC				; CvCity::GetID, COMDAT
; _this$ = ecx

; 331  : 		return m_iID;

	mov	eax, DWORD PTR [ecx+120]

; 332  : 	}

	ret	0
?GetID@CvCity@@QBEHXZ ENDP				; CvCity::GetID
_TEXT	ENDS
PUBLIC	?getX@CvCity@@QBEHXZ				; CvCity::getX
; Function compile flags: /Ogtpy
;	COMDAT ?getX@CvCity@@QBEHXZ
_TEXT	SEGMENT
?getX@CvCity@@QBEHXZ PROC				; CvCity::getX, COMDAT
; _this$ = ecx

; 340  : 		return m_iX;

	mov	eax, DWORD PTR [ecx+96]

; 341  : 	}

	ret	0
?getX@CvCity@@QBEHXZ ENDP				; CvCity::getX
_TEXT	ENDS
PUBLIC	?getY@CvCity@@QBEHXZ				; CvCity::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvCity@@QBEHXZ
_TEXT	SEGMENT
?getY@CvCity@@QBEHXZ PROC				; CvCity::getY, COMDAT
; _this$ = ecx

; 345  : 		return m_iY;

	mov	eax, DWORD PTR [ecx+108]

; 346  : 	}

	ret	0
?getY@CvCity@@QBEHXZ ENDP				; CvCity::getY
_TEXT	ENDS
PUBLIC	?isAlive@CvPlayer@@QBE_NXZ			; CvPlayer::isAlive
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayer.h
;	COMDAT ?isAlive@CvPlayer@@QBE_NXZ
_TEXT	SEGMENT
?isAlive@CvPlayer@@QBE_NXZ PROC				; CvPlayer::isAlive, COMDAT
; _this$ = ecx

; 1096 : 		return m_bAlive;

	mov	al, BYTE PTR [ecx+2256]

; 1097 : 	}

	ret	0
?isAlive@CvPlayer@@QBE_NXZ ENDP				; CvPlayer::isAlive
_TEXT	ENDS
PUBLIC	?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ		; CvPlayer::GetID
; Function compile flags: /Ogtpy
;	COMDAT ?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlayer::GetID, COMDAT
; _this$ = ecx

; 1172 : 		return m_eID;

	mov	eax, DWORD PTR [ecx+44]

; 1173 : 	}

	ret	0
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlayer::GetID
_TEXT	ENDS
PUBLIC	?getTeam@CvPlayer@@SA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPlayer::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@CvPlayer@@SA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayerID$ = 8						; size = 4
?getTeam@CvPlayer@@SA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPlayer::getTeam, COMDAT

; 1177 : 		return CvPreGame::teamType(ePlayerID);

	mov	eax, DWORD PTR _ePlayerID$[esp-4]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN3@getTeam
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1178 : 	}

	ret	0

; 1177 : 		return CvPreGame::teamType(ePlayerID);

$LN3@getTeam:
	or	eax, -1

; 1178 : 	}

	ret	0
?getTeam@CvPlayer@@SA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPlayer::getTeam
_TEXT	ENDS
PUBLIC	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ		; CvPlayer::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ PROC		; CvPlayer::getTeam, COMDAT
; _this$ = ecx

; 1182 : 		return CvPreGame::teamType(m_eID);

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN5@getTeam@2
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1183 : 	}

	ret	0

; 1182 : 		return CvPreGame::teamType(m_eID);

$LN5@getTeam@2:
	or	eax, -1

; 1183 : 	}

	ret	0
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ ENDP		; CvPlayer::getTeam
_TEXT	ENDS
PUBLIC	?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z		; CvPlot::isVisible
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z PROC		; CvPlot::isVisible, COMDAT
; _this$ = ecx

; 210  : 		if(eTeam == NO_TEAM)

	mov	eax, DWORD PTR _eTeam$[esp-4]
	cmp	eax, -1
	jne	SHORT $LN1@isVisible

; 211  : 			return false;

	xor	al, al

; 214  : 	}

	ret	4
$LN1@isVisible:

; 212  : 
; 213  : 		return ((getVisibilityCount(eTeam) > 0));

	mov	ecx, DWORD PTR [ecx+156]
	xor	edx, edx
	cmp	WORD PTR [ecx+eax*2], dx
	setg	dl
	mov	al, dl

; 214  : 	}

	ret	4
?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z ENDP		; CvPlot::isVisible
_TEXT	ENDS
PUBLIC	?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ		; CvPlot::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ PROC		; CvPlot::getTeam, COMDAT
; _this$ = ecx

; 232  : 		PlayerTypes playerID = getOwner();

	movsx	eax, BYTE PTR [ecx+4]

; 233  : 		if(playerID != NO_PLAYER)

	cmp	eax, -1
	je	SHORT $LN2@getTeam@3

; 234  : 		{
; 235  : 			return CvPlayer::getTeam(playerID);

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN2@getTeam@3
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 240  : 		}
; 241  : 	}

	ret	0
$LN2@getTeam@3:

; 236  : 		}
; 237  : 		else
; 238  : 		{
; 239  : 			return NO_TEAM;

	or	eax, -1

; 240  : 		}
; 241  : 	}

	ret	0
?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ ENDP		; CvPlot::getTeam
_TEXT	ENDS
PUBLIC	?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z	; CvPlot::isRevealed
; Function compile flags: /Ogtpy
;	COMDAT ?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z PROC		; CvPlot::isRevealed, COMDAT
; _this$ = ecx

; 620  : 	{

	mov	edx, ecx

; 621  : 		CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 622  : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 623  : 		return m_bfRevealed.GetBit(eTeam);

	mov	ecx, DWORD PTR _eTeam$[esp-4]
	push	esi
	mov	eax, ecx
	shr	eax, 5
	mov	esi, eax
	shl	esi, 5
	sub	ecx, esi
	mov	esi, 1
	shl	esi, cl
	test	esi, DWORD PTR [edx+eax*4+8]
	pop	esi
	setne	al

; 624  : 	}

	ret	4
?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z ENDP		; CvPlot::isRevealed
_TEXT	ENDS
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	mov	eax, DWORD PTR _iX$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4020]
	jge	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _iY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4024]
	jge	SHORT $LN3@isPlot
	mov	eax, 1

; 161  : #endif
; 162  : 	}

	ret	8
$LN3@isPlot:

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	xor	eax, eax

; 161  : #endif
; 162  : 	}

	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
PUBLIC	?plotNum@CvMap@@QBEHHH@Z			; CvMap::plotNum
; Function compile flags: /Ogtpy
;	COMDAT ?plotNum@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plotNum@CvMap@@QBEHHH@Z PROC				; CvMap::plotNum, COMDAT
; _this$ = ecx

; 183  : 		return ((iY * getGridWidth()) + iX);

	mov	eax, DWORD PTR [ecx+4020]
	imul	eax, DWORD PTR _iY$[esp-4]
	add	eax, DWORD PTR _iX$[esp-4]

; 184  : #endif
; 185  : 	}

	ret	8
?plotNum@CvMap@@QBEHHH@Z ENDP				; CvMap::plotNum
_TEXT	ENDS
PUBLIC	?plot@CvMap@@QBEPAVCvPlot@@HH@Z			; CvMap::plot
; Function compile flags: /Ogtpy
;	COMDAT ?plot@CvMap@@QBEPAVCvPlot@@HH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plot@CvMap@@QBEPAVCvPlot@@HH@Z PROC			; CvMap::plot, COMDAT
; _this$ = ecx

; 273  : 		if((iX == INVALID_PLOT_COORD) || (iY == INVALID_PLOT_COORD))

	mov	eax, DWORD PTR _iX$[esp-4]
	push	ebp
	cmp	eax, -2147483647			; 80000001H
	je	$LN1@plot
	mov	ebp, DWORD PTR _iY$[esp]
	cmp	ebp, -2147483647			; 80000001H
	je	$LN1@plot

; 276  : 		}
; 277  : 		int iMapX = coordRange(iX, getGridWidth(), isWrapX());

	cmp	BYTE PTR [ecx+4056], 0
	push	ebx
	push	esi
	mov	esi, DWORD PTR [ecx+4020]
	push	edi
	je	SHORT $LN11@plot
	test	eax, eax
	jge	SHORT $LN13@plot
	cdq
	idiv	esi
	mov	edi, edx
	add	edi, esi
	jmp	SHORT $LN15@plot
$LN13@plot:
	cmp	eax, esi
	jl	SHORT $LN11@plot
	cdq
	idiv	esi
	mov	edi, edx
	jmp	SHORT $LN15@plot
$LN11@plot:
	mov	edi, eax
$LN15@plot:

; 278  : 		int iMapY = coordRange(iY, getGridHeight(), isWrapY());

	cmp	BYTE PTR [ecx+4057], 0
	mov	ebx, DWORD PTR [ecx+4024]
	je	SHORT $LN40@plot
	test	ebp, ebp
	jge	SHORT $LN23@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN25@plot
$LN23@plot:
	cmp	ebp, ebx
	jl	SHORT $LN40@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	jmp	SHORT $LN25@plot
$LN40@plot:
	mov	edx, ebp
$LN25@plot:

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	test	edi, edi
	jl	SHORT $LN5@plot
	cmp	edi, esi
	jge	SHORT $LN5@plot
	test	edx, edx
	jl	SHORT $LN5@plot
	cmp	edx, ebx
	jge	SHORT $LN5@plot
	imul	esi, edx
	add	esi, edi
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [ecx+4068]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	pop	ebp

; 280  : 	}

	ret	8
$LN5@plot:
	pop	edi
	pop	esi
	pop	ebx

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
$LN1@plot:

; 274  : 		{
; 275  : 			return NULL;

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
?plot@CvMap@@QBEPAVCvPlot@@HH@Z ENDP			; CvMap::plot
_TEXT	ENDS
PUBLIC	?GetNumZones@CvTacticalAnalysisMap@@QBEHXZ	; CvTacticalAnalysisMap::GetNumZones
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtacticalanalysismap.h
;	COMDAT ?GetNumZones@CvTacticalAnalysisMap@@QBEHXZ
_TEXT	SEGMENT
?GetNumZones@CvTacticalAnalysisMap@@QBEHXZ PROC		; CvTacticalAnalysisMap::GetNumZones, COMDAT
; _this$ = ecx

; 624  : 		return m_DominanceZones.size();

	mov	eax, DWORD PTR [ecx+116]

; 625  : 	};

	ret	0
?GetNumZones@CvTacticalAnalysisMap@@QBEHXZ ENDP		; CvTacticalAnalysisMap::GetNumZones
_TEXT	ENDS
PUBLIC	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_eDirection$ = 16					; size = 4
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z PROC ; plotDirection, COMDAT

; 219  : 	if(eDirection == NO_DIRECTION)

	mov	ecx, DWORD PTR _eDirection$[esp-4]
	push	ebx
	push	ebp
	push	esi
	push	edi
	cmp	ecx, -1
	jne	$LN2@plotDirect

; 220  : 	{
; 221  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR _iX$[esp+12]
	cmp	eax, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebx, DWORD PTR _iY$[esp+12]
	cmp	ebx, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN99@plotDirect
	test	eax, eax
	jge	SHORT $LN19@plotDirect
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN21@plotDirect
$LN19@plotDirect:
	cmp	eax, ecx
	jl	SHORT $LN99@plotDirect
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN21@plotDirect
$LN99@plotDirect:
	mov	esi, eax
$LN21@plotDirect:
	cmp	BYTE PTR [ebp+4057], 0
	mov	edi, DWORD PTR [ebp+4024]
	je	SHORT $LN101@plotDirect
	test	ebx, ebx
	jge	SHORT $LN29@plotDirect
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN31@plotDirect
$LN29@plotDirect:
	cmp	ebx, edi
	jl	SHORT $LN101@plotDirect
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN31@plotDirect
$LN101@plotDirect:
	mov	edx, ebx
$LN31@plotDirect:
	test	esi, esi
	jl	$LN59@plotDirect
	cmp	esi, ecx
	jge	$LN59@plotDirect
	test	edx, edx
	jl	$LN59@plotDirect
	cmp	edx, edi
	jge	$LN59@plotDirect
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ecx
	pop	ebx

; 234  : 	}
; 235  : }

	ret	0
$LN2@plotDirect:

; 222  : 	}
; 223  : 	else
; 224  : 	{
; 225  : 		// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 226  : 		iX = xToHexspaceX(iX , iY);

	mov	esi, DWORD PTR _iY$[esp+12]
	test	esi, esi
	jl	SHORT $LN47@plotDirect
	mov	eax, esi
	jmp	SHORT $LN103@plotDirect
$LN47@plotDirect:
	lea	eax, DWORD PTR [esi-1]
	cdq
	sub	eax, edx
$LN103@plotDirect:

; 227  : 		iX += GC.getPlotDirectionX()[eDirection];

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A[ecx*4+112]
	mov	edi, DWORD PTR _iX$[esp+12]
	sar	eax, 1
	sub	edx, eax
	add	edi, edx

; 228  : 		iY += GC.getPlotDirectionY()[eDirection];

	add	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A[ecx*4+136]

; 229  : 
; 230  : 		// convert from hex-space coordinates to the storage array
; 231  : 		iX = hexspaceXToX(iX, iY);

	js	SHORT $LN55@plotDirect
	mov	eax, esi
	jmp	SHORT $LN104@plotDirect
$LN55@plotDirect:
	lea	eax, DWORD PTR [esi-1]
	cdq
	sub	eax, edx
$LN104@plotDirect:
	sar	eax, 1
	add	edi, eax

; 232  : 
; 233  : 		return GC.getMap().plot(iX, iY);

	cmp	edi, -2147483647			; 80000001H
	je	$LN59@plotDirect
	cmp	esi, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN69@plotDirect
	test	edi, edi
	jge	SHORT $LN71@plotDirect
	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, edx
	add	edi, ecx
	jmp	SHORT $LN69@plotDirect
$LN71@plotDirect:
	cmp	edi, ecx
	jl	SHORT $LN69@plotDirect
	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, edx
$LN69@plotDirect:
	cmp	BYTE PTR [ebp+4057], 0
	mov	ebx, DWORD PTR [ebp+4024]
	je	SHORT $LN100@plotDirect
	test	esi, esi
	jge	SHORT $LN81@plotDirect
	mov	eax, esi
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN83@plotDirect
$LN81@plotDirect:
	cmp	esi, ebx
	jl	SHORT $LN100@plotDirect
	mov	eax, esi
	cdq
	idiv	ebx
	jmp	SHORT $LN83@plotDirect
$LN100@plotDirect:
	mov	edx, esi
$LN83@plotDirect:
	test	edi, edi
	jl	SHORT $LN59@plotDirect
	cmp	edi, ecx
	jge	SHORT $LN59@plotDirect
	test	edx, edx
	jl	SHORT $LN59@plotDirect
	cmp	edx, ebx
	jge	SHORT $LN59@plotDirect
	imul	ecx, edx
	add	ecx, edi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ecx
	pop	ebx

; 234  : 	}
; 235  : }

	ret	0

; 232  : 
; 233  : 		return GC.getMap().plot(iX, iY);

$LN59@plotDirect:
	pop	edi
	pop	esi
	pop	ebp
	xor	eax, eax
	pop	ebx

; 234  : 	}
; 235  : }

	ret	0
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ENDP ; plotDirection
_TEXT	ENDS
PUBLIC	?plotXY@@YAPAVCvPlot@@HHHH@Z			; plotXY
; Function compile flags: /Ogtpy
;	COMDAT ?plotXY@@YAPAVCvPlot@@HHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
?plotXY@@YAPAVCvPlot@@HHHH@Z PROC			; plotXY, COMDAT

; 239  : 	// convert the start coord to hex-space coordinates
; 240  : 	int iStartHexX = xToHexspaceX(iX, iY);

	mov	ecx, DWORD PTR _iY$[esp-4]
	test	ecx, ecx
	jl	SHORT $LN5@plotXY
	mov	eax, ecx
	jmp	SHORT $LN55@plotXY
$LN5@plotXY:
	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
$LN55@plotXY:
	push	esi

; 241  : 
; 242  : 	int iPlotHexX = iStartHexX + iDX;

	mov	esi, DWORD PTR _iX$[esp]
	sar	eax, 1
	sub	esi, eax

; 243  : 	int iPlotY = iY + iDY; // Y is the same in both coordinate systems

	mov	eax, DWORD PTR _iDY$[esp]
	add	esi, DWORD PTR _iDX$[esp]
	push	edi
	lea	edi, DWORD PTR [ecx+eax]

; 244  : 
; 245  : 	// convert from hex-space coordinates to the storage array
; 246  : 	iPlotHexX = hexspaceXToX(iPlotHexX, iPlotY);

	test	edi, edi
	jl	SHORT $LN9@plotXY
	mov	eax, edi
	jmp	SHORT $LN56@plotXY
$LN9@plotXY:
	lea	eax, DWORD PTR [edi-1]
	cdq
	sub	eax, edx
$LN56@plotXY:
	sar	eax, 1
	add	esi, eax

; 247  : 
; 248  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

	cmp	esi, -2147483647			; 80000001H
	je	$LN13@plotXY
	cmp	edi, -2147483647			; 80000001H
	je	$LN13@plotXY
	push	ebp
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN23@plotXY
	test	esi, esi
	jge	SHORT $LN25@plotXY
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN23@plotXY
$LN25@plotXY:
	cmp	esi, ecx
	jl	SHORT $LN23@plotXY
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
$LN23@plotXY:
	cmp	BYTE PTR [ebp+4057], 0
	push	ebx
	mov	ebx, DWORD PTR [ebp+4024]
	je	SHORT $LN52@plotXY
	test	edi, edi
	jge	SHORT $LN35@plotXY
	mov	eax, edi
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN37@plotXY
$LN35@plotXY:
	cmp	edi, ebx
	jl	SHORT $LN52@plotXY
	mov	eax, edi
	cdq
	idiv	ebx
	jmp	SHORT $LN37@plotXY
$LN52@plotXY:
	mov	edx, edi
$LN37@plotXY:
	test	esi, esi
	jl	SHORT $LN17@plotXY
	cmp	esi, ecx
	jge	SHORT $LN17@plotXY
	test	edx, edx
	jl	SHORT $LN17@plotXY
	cmp	edx, ebx
	jge	SHORT $LN17@plotXY
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	ebx
	pop	ebp
	pop	edi
	mov	eax, ecx
	pop	esi

; 249  : }

	ret	0

; 247  : 
; 248  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

$LN17@plotXY:
	pop	ebx
	pop	ebp
	pop	edi
	xor	eax, eax
	pop	esi

; 249  : }

	ret	0

; 247  : 
; 248  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

$LN13@plotXY:
	pop	edi
	xor	eax, eax
	pop	esi

; 249  : }

	ret	0
?plotXY@@YAPAVCvPlot@@HHHH@Z ENDP			; plotXY
_TEXT	ENDS
PUBLIC	??0CvTacticalAnalysisCell@@QAE@XZ		; CvTacticalAnalysisCell::CvTacticalAnalysisCell
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtacticalanalysismap.cpp
;	COMDAT ??0CvTacticalAnalysisCell@@QAE@XZ
_TEXT	SEGMENT
??0CvTacticalAnalysisCell@@QAE@XZ PROC			; CvTacticalAnalysisCell::CvTacticalAnalysisCell, COMDAT
; _this$ = ecx

; 32   : {

	mov	eax, ecx

; 33   : 	Clear();

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+28], ecx
	mov	DWORD PTR [eax+32], ecx
	mov	DWORD PTR [eax+36], ecx
	mov	DWORD PTR [eax+40], -1

; 34   : }

	ret	0
??0CvTacticalAnalysisCell@@QAE@XZ ENDP			; CvTacticalAnalysisCell::CvTacticalAnalysisCell
_TEXT	ENDS
PUBLIC	?SetClosestCity@CvTacticalDominanceZone@@QAEXPAVCvCity@@@Z ; CvTacticalDominanceZone::SetClosestCity
; Function compile flags: /Ogtpy
;	COMDAT ?SetClosestCity@CvTacticalDominanceZone@@QAEXPAVCvCity@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
?SetClosestCity@CvTacticalDominanceZone@@QAEXPAVCvCity@@@Z PROC ; CvTacticalDominanceZone::SetClosestCity, COMDAT
; _this$ = ecx

; 114  : 	if(pCity != NULL)

	mov	eax, DWORD PTR _pCity$[esp-4]
	test	eax, eax
	je	SHORT $LN2@SetClosest

; 115  : 	{
; 116  : 		m_iCityID = pCity->GetID();

	mov	eax, DWORD PTR [eax+120]
	mov	DWORD PTR [ecx+16], eax

; 121  : 	}
; 122  : }

	ret	4
$LN2@SetClosest:

; 117  : 	}
; 118  : 	else
; 119  : 	{
; 120  : 		m_iCityID = -1;

	mov	DWORD PTR [ecx+16], -1

; 121  : 	}
; 122  : }

	ret	4
?SetClosestCity@CvTacticalDominanceZone@@QAEXPAVCvCity@@@Z ENDP ; CvTacticalDominanceZone::SetClosestCity
_TEXT	ENDS
PUBLIC	?Init@CvTacticalAnalysisMap@@QAEXH@Z		; CvTacticalAnalysisMap::Init
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
xdata$x	SEGMENT
__unwindtable$?Init@CvTacticalAnalysisMap@@QAEXH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Init@CvTacticalAnalysisMap@@QAEXH@Z$0
__ehfuncinfo$?Init@CvTacticalAnalysisMap@@QAEXH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Init@CvTacticalAnalysisMap@@QAEXH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtacticalanalysismap.cpp
xdata$x	ENDS
;	COMDAT ?Init@CvTacticalAnalysisMap@@QAEXH@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
$T227093 = 8						; size = 4
_iNumPlots$ = 8						; size = 4
?Init@CvTacticalAnalysisMap@@QAEXH@Z PROC		; CvTacticalAnalysisMap::Init, COMDAT
; _this$ = ecx

; 204  : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?Init@CvTacticalAnalysisMap@@QAEXH@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 205  : 	// Time building of these maps
; 206  : 	AI_PERF("AI-perf-tact.csv", "CvTacticalAnalysisMap::Init()" );
; 207  : 
; 208  : 	if(m_pPlots)

	cmp	DWORD PTR [edi+12], 0
	je	SHORT $LN7@Init

; 209  : 	{
; 210  : 		SAFE_DELETE_ARRAY(m_pPlots);

	mov	eax, DWORD PTR [edi+12]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	mov	DWORD PTR [edi+12], 0
$LN7@Init:

; 211  : 	}
; 212  : 	m_pPlots = FNEW(CvTacticalAnalysisCell[iNumPlots], c_eCiv5GameplayDLL, 0);

	mov	ebp, DWORD PTR _iNumPlots$[esp+20]
	xor	ecx, ecx
	mov	eax, ebp
	mov	edx, 44					; 0000002cH
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T227093[esp+20], esi
	mov	DWORD PTR __$EHRec$[esp+32], 0
	test	esi, esi
	je	SHORT $LN4@Init
	push	OFFSET ??0CvTacticalAnalysisCell@@QAE@XZ ; CvTacticalAnalysisCell::CvTacticalAnalysisCell
	push	ebp
	push	44					; 0000002cH
	push	esi
	call	??_H@YGXPAXIHP6EPAX0@Z@Z
	jmp	SHORT $LN5@Init
$LN4@Init:
	xor	esi, esi
$LN5@Init:

; 213  : 	m_iNumPlots = iNumPlots;
; 214  : 
; 215  : 	m_iDominancePercentage = GC.getAI_TACTICAL_MAP_DOMINANCE_PERCENTAGE();
; 216  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR [edi+12], esi
	mov	DWORD PTR [edi+16], ebp
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2444
	mov	DWORD PTR [edi], eax
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebp
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Init@CvTacticalAnalysisMap@@QAEXH@Z$0:
	mov	eax, DWORD PTR $T227093[ebp-4]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
__ehhandler$?Init@CvTacticalAnalysisMap@@QAEXH@Z:
	mov	eax, OFFSET __ehfuncinfo$?Init@CvTacticalAnalysisMap@@QAEXH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Init@CvTacticalAnalysisMap@@QAEXH@Z ENDP		; CvTacticalAnalysisMap::Init
PUBLIC	?MarkCellsNearEnemy@CvTacticalAnalysisMap@@IAEXXZ ; CvTacticalAnalysisMap::MarkCellsNearEnemy
EXTRN	?GetNearbyEnemyDamage@CvImprovementEntry@@QBEHXZ:PROC ; CvImprovementEntry::GetNearbyEnemyDamage
EXTRN	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z:PROC ; CvGlobals::getImprovementInfo
EXTRN	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ:PROC ; CvPlot::getImprovementType
EXTRN	?atWar@@YA_NW4TeamTypes@@0@Z:PROC		; atWar
EXTRN	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z:PROC ; TurnsToReachTarget
EXTRN	?baseMoves@CvUnit@@QBEHW4DomainTypes@@@Z:PROC	; CvUnit::baseMoves
EXTRN	?getArea@CvUnit@@QBEHXZ:PROC			; CvUnit::getArea
EXTRN	?isVisibleToEnemyTeam@CvPlot@@QBE_NW4TeamTypes@@@Z:PROC ; CvPlot::isVisibleToEnemyTeam
; Function compile flags: /Ogtpy
;	COMDAT ?MarkCellsNearEnemy@CvTacticalAnalysisMap@@IAEXXZ
_TEXT	SEGMENT
_bMarkedIt$222522 = -21					; size = 1
tv716 = -20						; size = 4
_iUnitIndex$222528 = -16				; size = 4
tv718 = -12						; size = 4
_iI$222518 = -8						; size = 4
$T227116 = -4						; size = 4
?MarkCellsNearEnemy@CvTacticalAnalysisMap@@IAEXXZ PROC	; CvTacticalAnalysisMap::MarkCellsNearEnemy, COMDAT
; _this$ = ecx

; 312  : {

	sub	esp, 24					; 00000018H

; 313  : 	int iDistance;
; 314  : 
; 315  : 	// Look at every cell on the map
; 316  : #ifdef AUI_WARNING_FIXES
; 317  : 	for (uint iI = 0; iI < GC.getMap().numPlots(); iI++)
; 318  : #else
; 319  : 	for(int iI = 0; iI < GC.getMap().numPlots(); iI++)

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	ebx
	push	ebp
	xor	ebp, ebp
	cmp	DWORD PTR [eax+4028], ebp
	push	esi
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _iI$222518[esp+40], ebp
	jle	$LN21@MarkCellsN
	xor	esi, esi
	mov	DWORD PTR tv716[esp+40], esi
	mov	DWORD PTR tv718[esp+40], ebp
	jmp	SHORT $LN23@MarkCellsN
	npad	4
$LL156@MarkCellsN:
	xor	ebp, ebp
$LN23@MarkCellsN:

; 320  : #endif
; 321  : 	{
; 322  : 		bool bMarkedIt = false;   // Set true once we've found one that enemy can move past (worst case)
; 323  : 
; 324  : 		CvPlot* pPlot = GC.getMap().plotByIndexUnchecked(iI);

	mov	ebx, DWORD PTR [eax+4068]

; 325  : 		if(m_pPlots[iI].IsRevealed() && !m_pPlots[iI].IsImpassableTerrain() && !m_pPlots[iI].IsImpassableTerritory())

	mov	eax, DWORD PTR [edi+12]
	add	ebx, DWORD PTR tv718[esp+40]
	add	eax, esi
	test	BYTE PTR [eax], 1
	mov	BYTE PTR _bMarkedIt$222522[esp+40], 0
	je	$LN22@MarkCellsN
	mov	eax, DWORD PTR [eax]
	mov	ecx, eax
	shr	ecx, 2
	test	cl, 1
	jne	$LN22@MarkCellsN
	mov	edx, eax
	shr	edx, 3
	test	dl, 1
	jne	$LN22@MarkCellsN

; 326  : 		{
; 327  : 			// Friendly cities always safe
; 328  : 			if(!m_pPlots[iI].IsFriendlyCity())

	shr	eax, 8
	test	al, 1
	jne	$LN22@MarkCellsN

; 329  : 			{
; 330  : 				if(!pPlot->isVisibleToEnemyTeam(m_pPlayer->getTeam()))

	mov	eax, DWORD PTR [edi+20]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN55@MarkCellsN
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN56@MarkCellsN
$LN55@MarkCellsN:
	or	eax, -1
$LN56@MarkCellsN:
	push	eax
	mov	ecx, ebx
	call	?isVisibleToEnemyTeam@CvPlot@@QBE_NW4TeamTypes@@@Z ; CvPlot::isVisibleToEnemyTeam
	test	al, al
	jne	SHORT $LN18@MarkCellsN

; 331  : 				{
; 332  : 					m_pPlots[iI].SetNotVisibleToEnemy(true);

	mov	eax, DWORD PTR [edi+12]
	add	eax, esi
	or	DWORD PTR [eax], 16			; 00000010H

; 333  : 				}
; 334  : 				else

	jmp	$LN22@MarkCellsN
$LN18@MarkCellsN:

; 335  : 				{
; 336  : 					for(unsigned int iUnitIndex = 0;  iUnitIndex < m_EnemyUnits.size() && !bMarkedIt; iUnitIndex++)

	mov	DWORD PTR _iUnitIndex$222528[esp+40], ebp
	cmp	DWORD PTR [edi+8492], ebp
	jbe	$LN14@MarkCellsN
$LN16@MarkCellsN:
	cmp	BYTE PTR _bMarkedIt$222522[esp+40], 0
	jne	$LN14@MarkCellsN

; 337  : 					{
; 338  : 						CvUnit* pUnit = m_EnemyUnits[iUnitIndex];

	mov	eax, DWORD PTR [edi+8488]
	mov	ecx, DWORD PTR _iUnitIndex$222528[esp+40]
	mov	esi, DWORD PTR [eax+ecx*4]

; 339  : 						if(pUnit->getArea() == pPlot->getArea())

	mov	ebp, DWORD PTR [ebx+356]
	mov	ecx, esi
	call	?getArea@CvUnit@@QBEHXZ			; CvUnit::getArea
	cmp	eax, ebp
	jne	$LN15@MarkCellsN

; 340  : 						{
; 341  : 							// Distance check before hitting pathfinder
; 342  : 							iDistance = plotDistance(pUnit->getX(), pUnit->getY(), pPlot->getX(), pPlot->getY());

	movsx	edx, WORD PTR [ebx+2]
	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	edx
	movsx	edx, WORD PTR [ebx]
	push	edx
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	mov	ebp, eax
	add	esp, 16					; 00000010H

; 343  : 							if(iDistance == 0)

	test	ebp, ebp
	jne	SHORT $LN12@MarkCellsN

; 344  : 							{
; 345  : 								m_pPlots[iI].SetSubjectToAttack(true);

	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR tv716[esp+40]
	or	DWORD PTR [eax+ecx], 32			; 00000020H
	add	eax, ecx

; 346  : 								m_pPlots[iI].SetEnemyCanMovePast(true);

	mov	eax, DWORD PTR [edi+12]
	add	eax, ecx

; 347  : 								bMarkedIt = true;

	jmp	SHORT $LN157@MarkCellsN
$LN12@MarkCellsN:

; 348  : 							}
; 349  : 
; 350  : 							// TEMPORARY OPTIMIZATION: Assumes can't use roads or RR
; 351  : 							else if(iDistance <= pUnit->baseMoves())

	push	-1
	mov	ecx, esi
	call	?baseMoves@CvUnit@@QBEHW4DomainTypes@@@Z ; CvUnit::baseMoves
	cmp	ebp, eax
	jg	SHORT $LN15@MarkCellsN

; 352  : 							{
; 353  : 								int iTurnsToReach;
; 354  : 								iTurnsToReach = TurnsToReachTarget(pUnit, pPlot, true /*bReusePaths*/, true /*bIgnoreUnits*/);	// Its ok to reuse paths because when ignoring units, we don't use the tactical analysis map (which we are building)

	push	0
	push	1
	push	1
	push	ebx
	sub	esp, 8
	mov	ecx, esp
	mov	DWORD PTR $T227116[esp+64], esp
	push	esi
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H

; 355  : 								if(iTurnsToReach <= 1)

	cmp	eax, 1
	jg	SHORT $LN98@MarkCellsN

; 356  : 								{
; 357  : 									m_pPlots[iI].SetSubjectToAttack(true);

	mov	ecx, DWORD PTR [edi+12]
	add	ecx, DWORD PTR tv716[esp+40]
	or	DWORD PTR [ecx], 32			; 00000020H
$LN98@MarkCellsN:

; 358  : 								}
; 359  : 								if(iTurnsToReach == 0)

	test	eax, eax
	jne	SHORT $LN15@MarkCellsN

; 360  : 								{
; 361  : 									m_pPlots[iI].SetEnemyCanMovePast(true);

	mov	eax, DWORD PTR [edi+12]
	add	eax, DWORD PTR tv716[esp+40]
$LN157@MarkCellsN:
	or	DWORD PTR [eax], 64			; 00000040H

; 362  : 									bMarkedIt = true;

	mov	BYTE PTR _bMarkedIt$222522[esp+40], 1
$LN15@MarkCellsN:
	mov	eax, DWORD PTR _iUnitIndex$222528[esp+40]
	inc	eax
	mov	DWORD PTR _iUnitIndex$222528[esp+40], eax
	cmp	eax, DWORD PTR [edi+8492]
	jb	$LN16@MarkCellsN
$LN14@MarkCellsN:

; 363  : 								}
; 364  : 							}
; 365  : 						}
; 366  : 					}
; 367  : 
; 368  : 					// Check adjacent plots for enemy citadels
; 369  : 					if(!m_pPlots[iI].IsSubjectToAttack())

	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR tv716[esp+40]
	mov	edx, DWORD PTR [ecx+eax]
	shr	edx, 5
	test	dl, 1
	jne	$LN22@MarkCellsN

; 370  : 					{
; 371  : 						CvPlot* pAdjacentPlot;
; 372  : 						for(int jJ = 0; jJ < NUM_DIRECTION_TYPES; jJ++)

	xor	ebp, ebp
$LL6@MarkCellsN:

; 373  : 						{
; 374  : 							pAdjacentPlot = plotDirection(pPlot->getX(), pPlot->getY(), ((DirectionTypes)jJ));

	movsx	eax, WORD PTR [ebx+2]
	movsx	ecx, WORD PTR [ebx]
	push	ebp
	push	eax
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 375  : 							if(pAdjacentPlot != NULL && pAdjacentPlot->getOwner() != NO_PLAYER)

	test	esi, esi
	je	SHORT $LN5@MarkCellsN
	mov	al, BYTE PTR [esi+4]
	cmp	al, -1
	je	SHORT $LN5@MarkCellsN

; 376  : 							{
; 377  : 								if(atWar(m_pPlayer->getTeam(), GET_PLAYER(pAdjacentPlot->getOwner()).getTeam()))

	movsx	edx, al
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	edx, 63236				; 0000f704H
	mov	eax, DWORD PTR [edx+eax+44]
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN126@MarkCellsN
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN127@MarkCellsN
$LN126@MarkCellsN:
	or	eax, -1
$LN127@MarkCellsN:
	mov	ecx, DWORD PTR [edi+20]
	mov	ecx, DWORD PTR [ecx+44]
	cmp	ecx, 63					; 0000003fH
	ja	SHORT $LN135@MarkCellsN
	mov	edx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN136@MarkCellsN
$LN135@MarkCellsN:
	or	ecx, -1
$LN136@MarkCellsN:
	push	eax
	push	ecx
	call	?atWar@@YA_NW4TeamTypes@@0@Z		; atWar
	add	esp, 8
	test	al, al
	je	SHORT $LN5@MarkCellsN

; 378  : 								{
; 379  : 									ImprovementTypes eImprovement = pAdjacentPlot->getImprovementType();

	mov	ecx, esi
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType

; 380  : 									if(eImprovement != NO_IMPROVEMENT && GC.getImprovementInfo(eImprovement)->GetNearbyEnemyDamage() > 0)

	cmp	eax, -1
	je	SHORT $LN5@MarkCellsN
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?GetNearbyEnemyDamage@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetNearbyEnemyDamage
	test	eax, eax
	jg	SHORT $LN149@MarkCellsN
$LN5@MarkCellsN:

; 370  : 					{
; 371  : 						CvPlot* pAdjacentPlot;
; 372  : 						for(int jJ = 0; jJ < NUM_DIRECTION_TYPES; jJ++)

	inc	ebp
	cmp	ebp, 6
	jl	$LL6@MarkCellsN

; 380  : 									if(eImprovement != NO_IMPROVEMENT && GC.getImprovementInfo(eImprovement)->GetNearbyEnemyDamage() > 0)

	jmp	SHORT $LN22@MarkCellsN
$LN149@MarkCellsN:

; 381  : 									{
; 382  : 										m_pPlots[iI].SetSubjectToAttack(true);

	mov	eax, DWORD PTR [edi+12]
	add	eax, DWORD PTR tv716[esp+40]
	or	DWORD PTR [eax], 32			; 00000020H
$LN22@MarkCellsN:
	mov	ecx, DWORD PTR _iI$222518[esp+40]
	mov	esi, DWORD PTR tv716[esp+40]
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	DWORD PTR tv718[esp+40], 484		; 000001e4H
	inc	ecx
	add	esi, 44					; 0000002cH
	cmp	ecx, DWORD PTR [eax+4028]
	mov	DWORD PTR _iI$222518[esp+40], ecx
	mov	DWORD PTR tv716[esp+40], esi
	jl	$LL156@MarkCellsN
$LN21@MarkCellsN:

; 383  : 										break;
; 384  : 									}
; 385  : 								}
; 386  : 							}
; 387  : 						}
; 388  : 					}
; 389  : 				}
; 390  : 			}
; 391  : 		}
; 392  : 	}
; 393  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
?MarkCellsNearEnemy@CvTacticalAnalysisMap@@IAEXXZ ENDP	; CvTacticalAnalysisMap::MarkCellsNearEnemy
_TEXT	ENDS
PUBLIC	?SetTargetBombardCells@CvTacticalAnalysisMap@@QAEXPAVCvPlot@@H_N@Z ; CvTacticalAnalysisMap::SetTargetBombardCells
EXTRN	?canSeePlot@CvPlot@@QBE_NPBV1@W4TeamTypes@@HW4DirectionTypes@@@Z:PROC ; CvPlot::canSeePlot
; Function compile flags: /Ogtpy
;	COMDAT ?SetTargetBombardCells@CvTacticalAnalysisMap@@QAEXPAVCvPlot@@H_N@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
_iDX$ = -12						; size = 4
_iDY$ = -8						; size = 4
tv288 = -4						; size = 4
_pTarget$ = 8						; size = 4
_iRange$ = 12						; size = 4
_bIgnoreLOS$ = 16					; size = 1
?SetTargetBombardCells@CvTacticalAnalysisMap@@QAEXPAVCvPlot@@H_N@Z PROC ; CvTacticalAnalysisMap::SetTargetBombardCells, COMDAT
; _this$ = ecx

; 414  : {

	sub	esp, 16					; 00000010H

; 415  : 	int iDX, iDY;
; 416  : 	CvPlot* pLoopPlot;
; 417  : 	int iPlotIndex;
; 418  : #ifdef AUI_HEXSPACE_DX_LOOPS
; 419  : 	int iMaxDX;
; 420  : 	for (iDY = -iRange; iDY <= iRange; iDY++)
; 421  : 	{
; 422  : 		iMaxDX = iRange - MAX(0, iDY);
; 423  : 		for (iDX = -iRange - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 424  : #else
; 425  : 	int iPlotDistance;
; 426  : 
; 427  : 	for(iDX = -(iRange); iDX <= iRange; iDX++)

	mov	eax, DWORD PTR _iRange$[esp+12]
	mov	DWORD PTR _this$[esp+16], ecx
	mov	ecx, eax
	neg	ecx
	mov	edx, ecx
	cmp	edx, eax
	mov	DWORD PTR tv288[esp+16], ecx
	mov	DWORD PTR _iDX$[esp+16], ecx
	jg	$LN10@SetTargetB
	push	ebx
	push	ebp
	push	esi
	push	edi
$LL12@SetTargetB:

; 428  : 	{
; 429  : 		for(iDY = -(iRange); iDY <= iRange; iDY++)

	cmp	ecx, eax
	mov	DWORD PTR _iDY$[esp+32], ecx
	jg	$LN11@SetTargetB
$LL9@SetTargetB:

; 430  : #endif
; 431  : 		{
; 432  : #ifdef AUI_HEXSPACE_DX_LOOPS
; 433  : 			if (iDX == 0 && iDY == 0)
; 434  : 				continue;
; 435  : #endif
; 436  : 			pLoopPlot = plotXY(pTarget->getX(), pTarget->getY(), iDX, iDY);

	mov	eax, DWORD PTR _pTarget$[esp+28]
	movsx	esi, WORD PTR [eax+2]
	movsx	ebp, WORD PTR [eax]
	push	ecx
	push	edx
	push	esi
	push	ebp
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	mov	edi, eax
	add	esp, 16					; 00000010H

; 437  : 			if(pLoopPlot != NULL)

	test	edi, edi
	je	$LN8@SetTargetB

; 438  : 			{
; 439  : #ifndef AUI_HEXSPACE_DX_LOOPS
; 440  : #ifdef AUI_FIX_HEX_DISTANCE_INSTEAD_OF_PLOT_DISTANCE
; 441  : 				iPlotDistance = hexDistance(iDX, iDY);
; 442  : #else
; 443  : 				iPlotDistance = plotDistance(pLoopPlot->getX(), pLoopPlot->getY(), pTarget->getX(), pTarget->getY());

	movsx	ebx, WORD PTR [edi+2]
	movsx	eax, WORD PTR [edi]
	push	esi
	push	ebp
	push	ebx
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H

; 444  : #endif
; 445  : 				if(iPlotDistance > 0 && iPlotDistance <= iRange)

	test	eax, eax
	jle	$LN8@SetTargetB
	cmp	eax, DWORD PTR _iRange$[esp+28]
	jg	$LN8@SetTargetB

; 446  : #endif
; 447  : 				{
; 448  : 					iPlotIndex = GC.getMap().plotNum(pLoopPlot->getX(), pLoopPlot->getY());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	esi, DWORD PTR [eax+4020]
	movsx	eax, WORD PTR [edi]
	imul	esi, ebx

; 449  : 					if(m_pPlots[iPlotIndex].IsRevealed() && !m_pPlots[iPlotIndex].IsImpassableTerrain() && !m_pPlots[iPlotIndex].IsImpassableTerritory())

	mov	ecx, DWORD PTR _this$[esp+32]
	mov	edx, DWORD PTR [ecx+12]
	add	esi, eax
	imul	esi, 44					; 0000002cH
	test	BYTE PTR [edx+esi], 1
	lea	eax, DWORD PTR [edx+esi]
	je	SHORT $LN8@SetTargetB
	mov	eax, DWORD PTR [eax]
	mov	ecx, eax
	shr	ecx, 2
	test	cl, 1
	jne	SHORT $LN8@SetTargetB
	mov	edx, eax
	shr	edx, 3
	test	dl, 1
	jne	SHORT $LN8@SetTargetB

; 450  : 					{
; 451  : 						if(!m_pPlots[iPlotIndex].IsEnemyCity() && !m_pPlots[iPlotIndex].IsNeutralCity())

	mov	ecx, eax
	shr	ecx, 9
	test	cl, 1
	jne	SHORT $LN8@SetTargetB
	shr	eax, 10					; 0000000aH
	test	al, 1
	jne	SHORT $LN8@SetTargetB

; 452  : 						{
; 453  : 							if(bIgnoreLOS || pLoopPlot->canSeePlot(pTarget, m_pPlayer->getTeam(), iRange, NO_DIRECTION))

	cmp	BYTE PTR _bIgnoreLOS$[esp+28], 0
	jne	SHORT $LN68@SetTargetB
	mov	edx, DWORD PTR _iRange$[esp+28]
	mov	eax, DWORD PTR _this$[esp+32]
	mov	ecx, DWORD PTR [eax+20]
	push	-1
	push	edx
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	mov	ecx, DWORD PTR _pTarget$[esp+36]
	push	eax
	push	ecx
	mov	ecx, edi
	call	?canSeePlot@CvPlot@@QBE_NPBV1@W4TeamTypes@@HW4DirectionTypes@@@Z ; CvPlot::canSeePlot
	test	al, al
	je	SHORT $LN8@SetTargetB
$LN68@SetTargetB:

; 454  : 							{
; 455  : 								m_pPlots[iPlotIndex].SetWithinRangeOfTarget(true);

	mov	edx, DWORD PTR _this$[esp+32]
	mov	eax, DWORD PTR [edx+12]
	add	eax, esi
	or	DWORD PTR [eax], 131072			; 00020000H
$LN8@SetTargetB:
	mov	ecx, DWORD PTR _iDY$[esp+32]
	mov	eax, DWORD PTR _iRange$[esp+28]
	mov	edx, DWORD PTR _iDX$[esp+32]
	inc	ecx
	cmp	ecx, eax
	mov	DWORD PTR _iDY$[esp+32], ecx
	jle	$LL9@SetTargetB

; 428  : 	{
; 429  : 		for(iDY = -(iRange); iDY <= iRange; iDY++)

	mov	ecx, DWORD PTR tv288[esp+32]
$LN11@SetTargetB:

; 415  : 	int iDX, iDY;
; 416  : 	CvPlot* pLoopPlot;
; 417  : 	int iPlotIndex;
; 418  : #ifdef AUI_HEXSPACE_DX_LOOPS
; 419  : 	int iMaxDX;
; 420  : 	for (iDY = -iRange; iDY <= iRange; iDY++)
; 421  : 	{
; 422  : 		iMaxDX = iRange - MAX(0, iDY);
; 423  : 		for (iDX = -iRange - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 424  : #else
; 425  : 	int iPlotDistance;
; 426  : 
; 427  : 	for(iDX = -(iRange); iDX <= iRange; iDX++)

	inc	edx
	cmp	edx, eax
	mov	DWORD PTR _iDX$[esp+32], edx
	jle	$LL12@SetTargetB
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
$LN10@SetTargetB:

; 456  : 							}
; 457  : 						}
; 458  : 					}
; 459  : 				}
; 460  : 			}
; 461  : 		}
; 462  : 	}
; 463  : }

	add	esp, 16					; 00000010H
	ret	12					; 0000000cH
?SetTargetBombardCells@CvTacticalAnalysisMap@@QAEXPAVCvPlot@@H_N@Z ENDP ; CvTacticalAnalysisMap::SetTargetBombardCells
_TEXT	ENDS
PUBLIC	?SetTargetFlankBonusCells@CvTacticalAnalysisMap@@QAEXPAVCvPlot@@@Z ; CvTacticalAnalysisMap::SetTargetFlankBonusCells
; Function compile flags: /Ogtpy
;	COMDAT ?SetTargetFlankBonusCells@CvTacticalAnalysisMap@@QAEXPAVCvPlot@@@Z
_TEXT	SEGMENT
_pTarget$ = 8						; size = 4
?SetTargetFlankBonusCells@CvTacticalAnalysisMap@@QAEXPAVCvPlot@@@Z PROC ; CvTacticalAnalysisMap::SetTargetFlankBonusCells, COMDAT
; _this$ = ecx

; 467  : {

	push	ebp
	push	edi

; 468  : 	CvPlot* pLoopPlot;
; 469  : 	int iPlotIndex;
; 470  : 
; 471  : 	// No flank attacks on units at sea (where all combat is bombards)
; 472  : 	if(pTarget->isWater())

	mov	edi, DWORD PTR _pTarget$[esp+4]
	cmp	BYTE PTR [edi+5], 3
	mov	ebp, ecx
	je	$LN5@SetTargetF
	push	esi

; 473  : 	{
; 474  : 		return;
; 475  : 	}
; 476  : 
; 477  : 	for(int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	xor	esi, esi
$LL7@SetTargetF:

; 478  : 	{
; 479  : 		pLoopPlot = plotDirection(pTarget->getX(), pTarget->getY(), ((DirectionTypes)iI));

	movsx	eax, WORD PTR [edi+2]
	movsx	ecx, WORD PTR [edi]
	push	esi
	push	eax
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 480  : 		if(pLoopPlot != NULL)

	test	eax, eax
	je	SHORT $LN6@SetTargetF

; 481  : 		{
; 482  : 			iPlotIndex = GC.getMap().plotNum(pLoopPlot->getX(), pLoopPlot->getY());

	movsx	ecx, WORD PTR [eax+2]
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	imul	ecx, DWORD PTR [edx+4020]
	movsx	eax, WORD PTR [eax]

; 483  : 			if(m_pPlots[iPlotIndex].IsRevealed() && !m_pPlots[iPlotIndex].IsImpassableTerrain() && !m_pPlots[iPlotIndex].IsImpassableTerritory())

	mov	edx, DWORD PTR [ebp+12]
	add	ecx, eax
	imul	ecx, 44					; 0000002cH
	test	BYTE PTR [ecx+edx], 1
	lea	eax, DWORD PTR [ecx+edx]
	je	SHORT $LN6@SetTargetF
	mov	ecx, DWORD PTR [eax]
	mov	edx, ecx
	shr	edx, 2
	test	dl, 1
	jne	SHORT $LN6@SetTargetF
	mov	edx, ecx
	shr	edx, 3
	test	dl, 1
	jne	SHORT $LN6@SetTargetF

; 484  : 			{
; 485  : 				if(!m_pPlots[iPlotIndex].IsFriendlyCity() && !m_pPlots[iPlotIndex].IsEnemyCity() && !m_pPlots[iPlotIndex].IsNeutralCity())

	mov	edx, ecx
	shr	edx, 8
	test	dl, 1
	jne	SHORT $LN6@SetTargetF
	mov	edx, ecx
	shr	edx, 9
	test	dl, 1
	jne	SHORT $LN6@SetTargetF
	mov	edx, ecx
	shr	edx, 10					; 0000000aH
	test	dl, 1
	jne	SHORT $LN6@SetTargetF

; 486  : 				{
; 487  : 					if(!m_pPlots[iPlotIndex].IsFriendlyTurnEndTile() && m_pPlots[iPlotIndex].GetEnemyMilitaryUnit() == NULL)

	shr	ecx, 7
	test	cl, 1
	jne	SHORT $LN6@SetTargetF
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN6@SetTargetF

; 488  : 					{
; 489  : 						m_pPlots[iPlotIndex].SetHelpsProvidesFlankBonus(true);

	or	DWORD PTR [eax], 262144			; 00040000H
$LN6@SetTargetF:

; 473  : 	{
; 474  : 		return;
; 475  : 	}
; 476  : 
; 477  : 	for(int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	inc	esi
	cmp	esi, 6
	jl	$LL7@SetTargetF
	pop	esi
$LN5@SetTargetF:
	pop	edi
	pop	ebp

; 490  : 					}
; 491  : 				}
; 492  : 			}
; 493  : 		}
; 494  : 	}
; 495  : }

	ret	4
?SetTargetFlankBonusCells@CvTacticalAnalysisMap@@QAEXPAVCvPlot@@@Z ENDP ; CvTacticalAnalysisMap::SetTargetFlankBonusCells
_TEXT	ENDS
PUBLIC	?PopulateCell@CvTacticalAnalysisMap@@IAE_NHPAVCvPlot@@@Z ; CvTacticalAnalysisMap::PopulateCell
EXTRN	?isEnemy@CvUnit@@QBE_NW4TeamTypes@@PBVCvPlot@@@Z:PROC ; CvUnit::isEnemy
EXTRN	?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z:PROC	; CvPlot::getUnitByIndex
EXTRN	?getNumUnits@CvPlot@@QBEHXZ:PROC		; CvPlot::getNumUnits
EXTRN	?defenseModifier@CvPlot@@QBEHW4TeamTypes@@_N1@Z:PROC ; CvPlot::defenseModifier
EXTRN	?isFriendlyTerritory@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC ; CvTeam::isFriendlyTerritory
EXTRN	?IsAllowsOpenBordersToTeam@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC ; CvTeam::IsAllowsOpenBordersToTeam
EXTRN	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC	; CvTeam::isAtWar
EXTRN	?isOwned@CvPlot@@QBE_NXZ:PROC			; CvPlot::isOwned
EXTRN	?isShallowWater@CvPlot@@QBE_NXZ:PROC		; CvPlot::isShallowWater
; Function compile flags: /Ogtpy
;	COMDAT ?PopulateCell@CvTacticalAnalysisMap@@IAE_NHPAVCvPlot@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bImpassableTerritory$ = 8				; size = 1
_iIndex$ = 8						; size = 4
_pPlot$ = 12						; size = 4
?PopulateCell@CvTacticalAnalysisMap@@IAE_NHPAVCvPlot@@@Z PROC ; CvTacticalAnalysisMap::PopulateCell, COMDAT
; _this$ = ecx

; 537  : {

	push	ecx
	push	ebx
	push	ebp
	push	esi

; 538  : 	CvUnit* pLoopUnit;
; 539  : #ifdef AUI_WARNING_FIXES
; 540  : 	uint iUnitLoop;
; 541  : #else
; 542  : 	int iUnitLoop;
; 543  : #endif
; 544  : 	CvTacticalAnalysisCell& cell = m_pPlots[iIndex];

	mov	esi, DWORD PTR _iIndex$[esp+12]
	imul	esi, 44					; 0000002cH

; 545  : 
; 546  : 	cell.Clear();

	xor	ebp, ebp
	push	edi
	mov	edi, ecx
	add	esi, DWORD PTR [edi+12]
	mov	DWORD PTR _this$[esp+20], edi
	mov	DWORD PTR [esi], ebp
	mov	DWORD PTR [esi+4], ebp
	mov	DWORD PTR [esi+8], ebp
	mov	DWORD PTR [esi+12], ebp
	mov	DWORD PTR [esi+16], ebp
	mov	DWORD PTR [esi+20], ebp
	mov	DWORD PTR [esi+24], ebp
	mov	DWORD PTR [esi+28], ebp
	mov	DWORD PTR [esi+32], ebp
	mov	DWORD PTR [esi+36], ebp
	mov	DWORD PTR [esi+40], -1

; 547  : 
; 548  : 	cell.SetRevealed(pPlot->isRevealed(m_pPlayer->getTeam()));

	mov	eax, DWORD PTR [edi+20]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN44@PopulateCe
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN45@PopulateCe
$LN44@PopulateCe:
	or	ecx, -1
$LN45@PopulateCe:
	mov	ebx, DWORD PTR _pPlot$[esp+16]
	mov	eax, ecx
	shr	eax, 5
	mov	edx, eax
	shl	edx, 5
	sub	ecx, edx
	mov	edx, 1
	shl	edx, cl
	and	edx, DWORD PTR [ebx+eax*4+8]
	neg	edx
	sbb	edx, edx
	neg	edx
	mov	DWORD PTR [esi], edx

; 549  : 	cell.SetVisible(pPlot->isVisible(m_pPlayer->getTeam()));

	mov	eax, DWORD PTR [edi+20]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN76@PopulateCe
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	cmp	eax, -1
	je	SHORT $LN76@PopulateCe
	mov	ecx, DWORD PTR [ebx+156]
	cmp	WORD PTR [ecx+eax*2], bp
	setg	al
	test	al, al
	je	SHORT $LN76@PopulateCe
	or	DWORD PTR [esi], 2
	jmp	SHORT $LN75@PopulateCe
$LN76@PopulateCe:
	and	DWORD PTR [esi], -3			; fffffffdH
$LN75@PopulateCe:

; 550  : 	cell.SetImpassableTerrain(pPlot->isImpassable() || pPlot->isMountain());

	test	BYTE PTR [ebx+462], 128			; 00000080H
	jne	SHORT $LN32@PopulateCe
	cmp	BYTE PTR [ebx+5], 0
	jne	SHORT $LN86@PopulateCe
$LN32@PopulateCe:
	or	DWORD PTR [esi], 4
	jmp	SHORT $LN85@PopulateCe
$LN86@PopulateCe:
	and	DWORD PTR [esi], -5			; fffffffbH
$LN85@PopulateCe:

; 551  : 	cell.SetWater(pPlot->isWater());

	mov	al, 3
	cmp	BYTE PTR [ebx+5], al
	jne	SHORT $LN94@PopulateCe
	or	DWORD PTR [esi], 2048			; 00000800H
	jmp	SHORT $LN93@PopulateCe
$LN94@PopulateCe:
	and	DWORD PTR [esi], -2049			; fffff7ffH
$LN93@PopulateCe:

; 552  : 	cell.SetOcean(pPlot->isWater() && !pPlot->isShallowWater());

	cmp	BYTE PTR [ebx+5], al
	jne	SHORT $LN102@PopulateCe
	mov	ecx, ebx
	call	?isShallowWater@CvPlot@@QBE_NXZ		; CvPlot::isShallowWater
	test	al, al
	jne	SHORT $LN102@PopulateCe
	or	DWORD PTR [esi], 4096			; 00001000H
	jmp	SHORT $LN101@PopulateCe
$LN102@PopulateCe:
	and	DWORD PTR [esi], -4097			; ffffefffH
$LN101@PopulateCe:

; 553  : 
; 554  : 	bool bImpassableTerritory = false;
; 555  : 	if(pPlot->isOwned())

	mov	ecx, ebx
	mov	BYTE PTR _bImpassableTerritory$[esp+16], 0
	call	?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	test	al, al
	je	$LN29@PopulateCe

; 556  : 	{
; 557  : 		TeamTypes eMyTeam = m_pPlayer->getTeam();

	mov	edx, DWORD PTR [edi+20]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN109@PopulateCe
	mov	edx, DWORD PTR [ecx+4]
	mov	edi, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN110@PopulateCe
$LN109@PopulateCe:
	or	edi, -1
$LN110@PopulateCe:

; 558  : 		TeamTypes ePlotTeam = pPlot->getTeam();

	movsx	eax, BYTE PTR [ebx+4]
	cmp	eax, -1
	je	SHORT $LN115@PopulateCe
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN122@PopulateCe
	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ebp, eax
	jmp	SHORT $LN114@PopulateCe
$LN122@PopulateCe:
	or	eax, -1
	mov	ebp, eax
	jmp	SHORT $LN114@PopulateCe
$LN115@PopulateCe:
	or	ebp, -1
$LN114@PopulateCe:

; 559  : 
; 560  : 		if(eMyTeam != ePlotTeam && !GET_TEAM(eMyTeam).isAtWar(ePlotTeam) && !GET_TEAM(ePlotTeam).IsAllowsOpenBordersToTeam(eMyTeam))

	cmp	edi, ebp
	je	SHORT $LN28@PopulateCe
	mov	ecx, edi
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ebp
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	jne	SHORT $LN28@PopulateCe
	mov	ecx, ebp
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	edi
	call	?IsAllowsOpenBordersToTeam@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::IsAllowsOpenBordersToTeam
	test	al, al
	jne	SHORT $LN28@PopulateCe

; 561  : 		{
; 562  : 			bImpassableTerritory = true;

	mov	BYTE PTR _bImpassableTerritory$[esp+16], 1
	jmp	SHORT $LN263@PopulateCe
$LN28@PopulateCe:

; 563  : 		}
; 564  : 		else if(pPlot->isCity())

	mov	eax, DWORD PTR [ebx+104]
	test	eax, eax
	jl	SHORT $LN263@PopulateCe
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN263@PopulateCe
	mov	edx, DWORD PTR [ebx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	setne	al
	test	al, al
	je	SHORT $LN263@PopulateCe

; 565  : 		{
; 566  : 			if(pPlot->getOwner() == m_pPlayer->GetID())

	mov	eax, DWORD PTR _this$[esp+20]
	movsx	edx, BYTE PTR [ebx+4]
	mov	ecx, DWORD PTR [eax+20]
	cmp	edx, DWORD PTR [ecx+44]
	jne	SHORT $LN25@PopulateCe

; 567  : 			{
; 568  : 				cell.SetFriendlyCity(true);

	or	DWORD PTR [esi], 256			; 00000100H
	jmp	SHORT $LN263@PopulateCe
$LN25@PopulateCe:

; 569  : 			}
; 570  : 			else if(GET_TEAM(eMyTeam).isAtWar(ePlotTeam))

	mov	ecx, edi
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ebp
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	je	SHORT $LN23@PopulateCe

; 571  : 			{
; 572  : 				cell.SetEnemyCity(true);

	or	DWORD PTR [esi], 512			; 00000200H

; 573  : 			}
; 574  : 			else

	jmp	SHORT $LN263@PopulateCe
$LN23@PopulateCe:

; 575  : 			{
; 576  : 				cell.SetNeutralCity(true);

	or	DWORD PTR [esi], 1024			; 00000400H
$LN263@PopulateCe:

; 577  : 			}
; 578  : 		}
; 579  : 
; 580  : 		if(m_pPlayer->GetID() == pPlot->getOwner())

	mov	eax, DWORD PTR _this$[esp+20]
	movsx	edx, BYTE PTR [ebx+4]
	mov	ecx, DWORD PTR [eax+20]
	cmp	DWORD PTR [ecx+44], edx
	jne	SHORT $LN170@PopulateCe

; 581  : 		{
; 582  : 			cell.SetOwnTerritory(true);

	or	DWORD PTR [esi], 8192			; 00002000H
$LN170@PopulateCe:

; 583  : 		}
; 584  : 
; 585  : 		if(GET_TEAM(eMyTeam).isFriendlyTerritory(ePlotTeam))

	imul	edi, 2984				; 00000ba8H
	add	edi, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ebp
	mov	ecx, edi
	call	?isFriendlyTerritory@CvTeam@@QBE_NW4TeamTypes@@@Z ; CvTeam::isFriendlyTerritory
	test	al, al
	je	SHORT $LN178@PopulateCe

; 586  : 		{
; 587  : 			cell.SetFriendlyTerritory(true);

	or	DWORD PTR [esi], 16384			; 00004000H
$LN178@PopulateCe:

; 588  : 		}
; 589  : 
; 590  : 		if(GET_TEAM(ePlotTeam).isAtWar(ePlotTeam))

	mov	ecx, ebp
	imul	ecx, 2984				; 00000ba8H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ebp
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	je	SHORT $LN192@PopulateCe

; 591  : 		{
; 592  : 			cell.SetEnemyTerritory(true);

	or	DWORD PTR [esi], 32768			; 00008000H

; 593  : 		}
; 594  : 	}
; 595  : 	else
; 596  : 	{
; 597  : 		cell.SetUnclaimedTerritory(true);

$LN192@PopulateCe:

; 598  : 	}
; 599  : 
; 600  : 	cell.SetImpassableTerritory(bImpassableTerritory);

	cmp	BYTE PTR _bImpassableTerritory$[esp+16], 0
	je	SHORT $LN264@PopulateCe
	or	DWORD PTR [esi], 8
	xor	ebp, ebp
	jmp	SHORT $LN198@PopulateCe
$LN29@PopulateCe:

; 593  : 		}
; 594  : 	}
; 595  : 	else
; 596  : 	{
; 597  : 		cell.SetUnclaimedTerritory(true);

	or	DWORD PTR [esi], 65536			; 00010000H

; 598  : 	}
; 599  : 
; 600  : 	cell.SetImpassableTerritory(bImpassableTerritory);

	jmp	SHORT $LN199@PopulateCe
$LN264@PopulateCe:
	xor	ebp, ebp
$LN199@PopulateCe:
	and	DWORD PTR [esi], -9			; fffffff7H
$LN198@PopulateCe:

; 601  : 	cell.SetDefenseModifier(pPlot->defenseModifier(NO_TEAM, true));

	push	ebp
	push	1
	push	-1
	mov	ecx, ebx
	call	?defenseModifier@CvPlot@@QBEHW4TeamTypes@@_N1@Z ; CvPlot::defenseModifier

; 602  : 
; 603  : 	if(pPlot->getNumUnits() > 0)

	mov	ecx, ebx
	mov	DWORD PTR [esi+28], eax
	call	?getNumUnits@CvPlot@@QBEHXZ		; CvPlot::getNumUnits
	test	eax, eax
	jle	$LN14@PopulateCe

; 604  : 	{
; 605  : 		for(iUnitLoop = 0; iUnitLoop < pPlot->getNumUnits(); iUnitLoop++)

	mov	ecx, ebx
	call	?getNumUnits@CvPlot@@QBEHXZ		; CvPlot::getNumUnits
	test	eax, eax
	jle	$LN14@PopulateCe
	npad	6
$LL16@PopulateCe:

; 606  : 		{
; 607  : 			pLoopUnit = pPlot->getUnitByIndex(iUnitLoop);

	push	ebp
	mov	ecx, ebx
	call	?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z ; CvPlot::getUnitByIndex
	mov	edi, eax

; 608  : 			if(!pLoopUnit) continue;

	test	edi, edi
	je	SHORT $LN15@PopulateCe

; 609  : 			if(pLoopUnit->getOwner() == m_pPlayer->GetID())

	mov	eax, DWORD PTR _this$[esp+20]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR [ecx+44]
	cmp	DWORD PTR [edi+40], eax
	jne	SHORT $LN12@PopulateCe

; 610  : 			{
; 611  : 				if(pLoopUnit->IsCombatUnit())

	cmp	DWORD PTR [edi+1044], 0
	jle	SHORT $LN11@PopulateCe

; 612  : 				{
; 613  : 					// CvAssertMsg(!cell.GetFriendlyMilitaryUnit(), "Two friendly military units in a hex, please show Ed and send save.");
; 614  : 					cell.SetFriendlyMilitaryUnit(pLoopUnit);

	mov	DWORD PTR [esi+20], edi

; 615  : 				}
; 616  : 				else

	jmp	SHORT $LN15@PopulateCe
$LN11@PopulateCe:

; 617  : 				{
; 618  : 					// CvAssertMsg(!cell.GetFriendlyCivilianUnit(), "Two friendly civilian units in a hex, please show Ed and send save.");
; 619  : 					cell.SetFriendlyCivilianUnit(pLoopUnit);

	mov	DWORD PTR [esi+24], edi

; 620  : 				}

	jmp	SHORT $LN15@PopulateCe
$LN12@PopulateCe:

; 621  : 			}
; 622  : 			else if(pLoopUnit->isEnemy(m_pPlayer->getTeam()))

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN224@PopulateCe
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN225@PopulateCe
$LN224@PopulateCe:
	or	eax, -1
$LN225@PopulateCe:
	push	0
	push	eax
	mov	ecx, edi
	call	?isEnemy@CvUnit@@QBE_NW4TeamTypes@@PBVCvPlot@@@Z ; CvUnit::isEnemy
	test	al, al
	je	SHORT $LN8@PopulateCe

; 623  : 			{
; 624  : 				if(pLoopUnit->IsCombatUnit())

	cmp	DWORD PTR [edi+1044], 0
	jle	SHORT $LN7@PopulateCe

; 625  : 				{
; 626  : 					// CvAssertMsg(!cell.GetEnemyMilitaryUnit(), "Two enemy military units in a hex, please show Ed and send save.");
; 627  : 					cell.SetEnemyMilitaryUnit(pLoopUnit);

	mov	DWORD PTR [esi+4], edi

; 628  : 				}
; 629  : 				else

	jmp	SHORT $LN15@PopulateCe
$LN7@PopulateCe:

; 630  : 				{
; 631  : 					// CvAssertMsg(!cell.GetEnemyCivilianUnit(), "Two enemy civilian units in a hex, please show Ed and send save.");
; 632  : 					cell.SetEnemyCivilianUnit(pLoopUnit);

	mov	DWORD PTR [esi+8], edi

; 633  : 				}
; 634  : 			}
; 635  : 			else

	jmp	SHORT $LN15@PopulateCe
$LN8@PopulateCe:

; 636  : 			{
; 637  : 				if(pLoopUnit->IsCombatUnit())

	cmp	DWORD PTR [edi+1044], 0
	jle	SHORT $LN4@PopulateCe

; 638  : 				{
; 639  : 					// CvAssertMsg(!cell.GetNeutralMilitaryUnit(), "Two neutral military units in a hex, please show Ed and send save.");
; 640  : 					cell.SetNeutralMilitaryUnit(pLoopUnit);

	mov	DWORD PTR [esi+12], edi

; 641  : 				}
; 642  : 				else

	jmp	SHORT $LN15@PopulateCe
$LN4@PopulateCe:

; 643  : 				{
; 644  : 					// CvAssertMsg(!cell.GetNeutralCivilianUnit(), "Two neutral civilian units in a hex, please show Ed and send save.");
; 645  : 					cell.SetNeutralCivilianUnit(pLoopUnit);

	mov	DWORD PTR [esi+16], edi
$LN15@PopulateCe:

; 604  : 	{
; 605  : 		for(iUnitLoop = 0; iUnitLoop < pPlot->getNumUnits(); iUnitLoop++)

	mov	ecx, ebx
	inc	ebp
	call	?getNumUnits@CvPlot@@QBEHXZ		; CvPlot::getNumUnits
	cmp	ebp, eax
	jl	$LL16@PopulateCe
$LN14@PopulateCe:

; 646  : 				}
; 647  : 			}
; 648  : 		}
; 649  : 	}
; 650  : 
; 651  : 	// Figure out whether or not to add this to a dominance zone
; 652  : 	bool bAdd = true;
; 653  : 	if(cell.IsImpassableTerrain() || cell.IsImpassableTerritory() || !cell.IsRevealed())

	mov	ecx, DWORD PTR [esi]
	mov	edx, ecx
	mov	al, 1
	shr	edx, 2
	test	dl, al
	jne	SHORT $LN1@PopulateCe
	shr	ecx, 3
	test	cl, al
	jne	SHORT $LN1@PopulateCe
	test	BYTE PTR [esi], al
	jne	SHORT $LN2@PopulateCe
$LN1@PopulateCe:

; 654  : 	{
; 655  : 		bAdd = false;

	xor	al, al
$LN2@PopulateCe:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 656  : 	}
; 657  : 	return bAdd;
; 658  : }

	pop	ecx
	ret	8
?PopulateCell@CvTacticalAnalysisMap@@IAE_NHPAVCvPlot@@@Z ENDP ; CvTacticalAnalysisMap::PopulateCell
_TEXT	ENDS
PUBLIC	?CalculateMilitaryStrengths@CvTacticalAnalysisMap@@IAEXXZ ; CvTacticalAnalysisMap::CalculateMilitaryStrengths
EXTRN	?isAdjacentVisible@CvPlot@@QBE_NW4TeamTypes@@_N@Z:PROC ; CvPlot::isAdjacentVisible
EXTRN	?plot@CvUnit@@QBEPAVCvPlot@@XZ:PROC		; CvUnit::plot
EXTRN	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::nextUnit
EXTRN	?isRanged@CvUnit@@QBE_NXZ:PROC			; CvUnit::isRanged
EXTRN	?IsRangeAttackIgnoreLOS@CvUnit@@QBE_NXZ:PROC	; CvUnit::IsRangeAttackIgnoreLOS
EXTRN	?GetRange@CvUnit@@QBEHXZ:PROC			; CvUnit::GetRange
EXTRN	?GetMaxRangedCombatStrength@CvUnit@@QBEHPBV1@PBVCvCity@@_N2@Z:PROC ; CvUnit::GetMaxRangedCombatStrength
EXTRN	?GetBaseCombatStrength@CvUnit@@QBEH_N@Z:PROC	; CvUnit::GetBaseCombatStrength
EXTRN	?GetBaseCombatStrengthConsideringDamage@CvUnit@@QBEHXZ:PROC ; CvUnit::GetBaseCombatStrengthConsideringDamage
EXTRN	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ:PROC ; CvUnit::getDomainType
EXTRN	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::firstUnit
EXTRN	?getStrengthValue@CvCity@@QBEH_N@Z:PROC		; CvCity::getStrengthValue
EXTRN	?getDamage@CvCity@@QBEHXZ:PROC			; CvCity::getDamage
EXTRN	?GetMaxHitPoints@CvCity@@QBEHXZ:PROC		; CvCity::GetMaxHitPoints
; Function compile flags: /Ogtpy
;	COMDAT ?CalculateMilitaryStrengths@CvTacticalAnalysisMap@@IAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T228101 = -40						; size = 4
_iLoop$ = -36						; size = 4
tv859 = -32						; size = 4
_iMultiplier$ = -28					; size = 4
tv846 = -24						; size = 4
_iI$222709 = -20					; size = 4
_pClosestCity$ = -16					; size = 4
_iDistance$ = -12					; size = 4
_kPlayer$222737 = -8					; size = 4
tv822 = -4						; size = 4
?CalculateMilitaryStrengths@CvTacticalAnalysisMap@@IAEXXZ PROC ; CvTacticalAnalysisMap::CalculateMilitaryStrengths, COMDAT
; _this$ = ecx

; 787  : {

	sub	esp, 44					; 0000002cH
	push	edi
	mov	edi, ecx

; 788  : 	// Loop through the dominance zones
; 789  : 	CvTacticalDominanceZone* pZone;
; 790  : 	CvCity* pClosestCity = NULL;
; 791  : 	int iDistance;
; 792  : 	int iMultiplier;
; 793  : 	int iLoop;
; 794  : 	CvUnit* pLoopUnit;
; 795  : 	TeamTypes eTeam;
; 796  : 
; 797  : 	eTeam = m_pPlayer->getTeam();

	mov	eax, DWORD PTR [edi+20]
	mov	eax, DWORD PTR [eax+44]
	mov	DWORD PTR _this$[esp+48], edi
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN49@CalculateM
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T228101[esp+48], eax
	jmp	SHORT $LN50@CalculateM
$LN49@CalculateM:
	mov	DWORD PTR $T228101[esp+48], -1
$LN50@CalculateM:

; 798  : 
; 799  : 	for(unsigned int iI = 0; iI < m_DominanceZones.size(); iI++)

	xor	eax, eax
	mov	DWORD PTR _iI$222709[esp+48], eax
	cmp	DWORD PTR [edi+116], eax
	jbe	$LN40@CalculateM
	push	ebx
	push	ebp
	mov	DWORD PTR tv859[esp+56], eax
	push	esi
$LL203@CalculateM:

; 800  : 	{
; 801  : 		pZone = &m_DominanceZones[iI];

	mov	esi, DWORD PTR [edi+112]
	add	esi, DWORD PTR tv859[esp+60]

; 802  : 
; 803  : 		if(pZone->GetTerritoryType() != TACTICAL_TERRITORY_NO_OWNER)

	cmp	DWORD PTR [esi+4], 1
	je	$LN41@CalculateM

; 804  : 		{
; 805  : 			pClosestCity = pZone->GetClosestCity();

	mov	eax, DWORD PTR [esi+12]
	cmp	eax, -1
	je	$LN41@CalculateM
	mov	ecx, DWORD PTR [esi+16]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	ebp, eax
	mov	DWORD PTR _pClosestCity$[esp+60], ebp

; 806  : 			if(pClosestCity)

	test	ebp, ebp
	je	$LN41@CalculateM

; 807  : 			{
; 808  : 				// Start with strength of the city itself
; 809  : 				int iCityHitPoints = pClosestCity->GetMaxHitPoints() - pClosestCity->getDamage();

	mov	ecx, ebp
	call	?GetMaxHitPoints@CvCity@@QBEHXZ		; CvCity::GetMaxHitPoints
	mov	ecx, ebp
	mov	edi, eax
	call	?getDamage@CvCity@@QBEHXZ		; CvCity::getDamage

; 810  : 				int iStrength = m_iTacticalRange * pClosestCity->getStrengthValue() * iCityHitPoints / GC.getMAX_CITY_HIT_POINTS();

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7372
	push	0
	mov	ecx, ebp
	sub	edi, eax
	call	?getStrengthValue@CvCity@@QBEH_N@Z	; CvCity::getStrengthValue
	mov	edx, DWORD PTR _this$[esp+60]
	imul	eax, DWORD PTR [edx+8]
	imul	eax, edi
	cdq
	idiv	ebx

; 811  : 				if(pZone->GetTerritoryType() == TACTICAL_TERRITORY_FRIENDLY)

	cmp	DWORD PTR [esi+4], 2

; 812  : 				{
; 813  : 					pZone->AddFriendlyStrength(iStrength);
; 814  : 					pZone->AddFriendlyRangedStrength(pClosestCity->getStrengthValue());

	push	0
	mov	ecx, ebp
	jne	SHORT $LN37@CalculateM
	add	DWORD PTR [esi+24], eax
	call	?getStrengthValue@CvCity@@QBEH_N@Z	; CvCity::getStrengthValue
	add	DWORD PTR [esi+32], eax

; 815  : 				}
; 816  : 				else

	jmp	SHORT $LN75@CalculateM
$LN37@CalculateM:

; 817  : 				{
; 818  : 					pZone->AddEnemyStrength(iStrength);

	add	DWORD PTR [esi+28], eax

; 819  : 					pZone->AddEnemyRangedStrength(pClosestCity->getStrengthValue());

	call	?getStrengthValue@CvCity@@QBEH_N@Z	; CvCity::getStrengthValue
	add	DWORD PTR [esi+36], eax
$LN75@CalculateM:

; 820  : 				}
; 821  : 
; 822  : 				// Loop through all of OUR units first
; 823  : 				for(pLoopUnit = m_pPlayer->firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iLoop))

	mov	ebx, DWORD PTR _this$[esp+60]
	mov	ecx, DWORD PTR [ebx+20]
	push	0
	lea	eax, DWORD PTR _iLoop$[esp+64]
	push	eax
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	edi, eax
	test	edi, edi
	je	$LN33@CalculateM
	npad	11
$LL199@CalculateM:

; 824  : 				{
; 825  : 					if(pLoopUnit->IsCombatUnit())

	cmp	DWORD PTR [edi+1044], 0
	jle	$LN34@CalculateM

; 826  : 					{
; 827  : 						if(pLoopUnit->getDomainType() == DOMAIN_AIR ||
; 828  : 						        (pLoopUnit->getDomainType() == DOMAIN_LAND && !pZone->IsWater()) ||
; 829  : 						        (pLoopUnit->getDomainType() == DOMAIN_SEA && pZone->IsWater()))

	mov	ecx, edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 1
	je	SHORT $LN30@CalculateM
	mov	ecx, edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	SHORT $LN29@CalculateM
	cmp	BYTE PTR [esi+68], 0
	je	SHORT $LN30@CalculateM
$LN29@CalculateM:
	mov	ecx, edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	jne	$LN34@CalculateM
	cmp	BYTE PTR [esi+68], al
	je	$LN34@CalculateM
$LN30@CalculateM:

; 830  : 						{
; 831  : 							iDistance = plotDistance(pLoopUnit->getX(), pLoopUnit->getY(), pClosestCity->getX(), pClosestCity->getY());

	mov	ecx, DWORD PTR [ebp+108]
	mov	edx, DWORD PTR [ebp+96]
	mov	eax, DWORD PTR [edi+88]
	push	ecx
	mov	ecx, DWORD PTR [edi+76]
	push	edx
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance

; 832  : 							if (iDistance <= m_iTacticalRange)

	mov	ecx, DWORD PTR [ebx+8]
	add	esp, 16					; 00000010H
	cmp	eax, ecx
	jg	$LN34@CalculateM

; 833  : 							{
; 834  : 								iMultiplier = (m_iTacticalRange + 4 - iDistance);  // "4" so unit strength isn't totally dominated by proximity to city

	sub	ecx, eax
	add	ecx, 4
	mov	ebx, ecx

; 835  : 								if(iMultiplier > 0)

	test	ebx, ebx
	jle	$LN34@CalculateM

; 836  : 								{
; 837  : 									int iUnitStrength = pLoopUnit->GetBaseCombatStrengthConsideringDamage();

	mov	ecx, edi
	call	?GetBaseCombatStrengthConsideringDamage@CvUnit@@QBEHXZ ; CvUnit::GetBaseCombatStrengthConsideringDamage

; 838  : 									if(iUnitStrength == 0 && pLoopUnit->isEmbarked() && !pZone->IsWater())

	test	eax, eax
	jne	SHORT $LN26@CalculateM
	cmp	BYTE PTR [edi+1652], al
	je	SHORT $LN26@CalculateM
	cmp	BYTE PTR [esi+68], al
	jne	SHORT $LN26@CalculateM

; 839  : 									{
; 840  : 										iUnitStrength = pLoopUnit->GetBaseCombatStrength(true);

	push	1
	mov	ecx, edi
	call	?GetBaseCombatStrength@CvUnit@@QBEH_N@Z	; CvUnit::GetBaseCombatStrength
$LN26@CalculateM:

; 841  : 									}
; 842  : 									pZone->AddFriendlyStrength(iUnitStrength * iMultiplier * m_iUnitStrengthMultiplier);

	mov	edx, DWORD PTR _this$[esp+60]
	mov	ecx, DWORD PTR [edx+4]
	imul	ecx, eax
	imul	ecx, ebx
	add	DWORD PTR [esi+24], ecx

; 843  : 									pZone->AddFriendlyRangedStrength(pLoopUnit->GetMaxRangedCombatStrength(NULL, /*pCity*/ NULL, true, true));

	push	1
	push	1
	push	0
	push	0
	mov	ecx, edi
	call	?GetMaxRangedCombatStrength@CvUnit@@QBEHPBV1@PBVCvCity@@_N2@Z ; CvUnit::GetMaxRangedCombatStrength

; 844  : 									if(pLoopUnit->GetRange() > GetBestFriendlyRange())

	mov	edx, DWORD PTR _this$[esp+60]
	add	DWORD PTR [esi+32], eax
	mov	ebx, DWORD PTR [edx+28]
	mov	ecx, edi
	call	?GetRange@CvUnit@@QBEHXZ		; CvUnit::GetRange
	cmp	eax, ebx
	jle	SHORT $LN197@CalculateM

; 845  : 									{
; 846  : 										SetBestFriendlyRange(pLoopUnit->GetRange());

	mov	ecx, edi
	call	?GetRange@CvUnit@@QBEHXZ		; CvUnit::GetRange
	mov	ecx, DWORD PTR _this$[esp+60]
	mov	DWORD PTR [ecx+28], eax
$LN197@CalculateM:

; 847  : 									}
; 848  : 									if(pLoopUnit->IsRangeAttackIgnoreLOS())

	mov	ecx, edi
	call	?IsRangeAttackIgnoreLOS@CvUnit@@QBE_NXZ	; CvUnit::IsRangeAttackIgnoreLOS
	test	al, al
	je	SHORT $LN115@CalculateM

; 849  : 									{
; 850  : 										SetIgnoreLOS(true);

	mov	edx, DWORD PTR _this$[esp+60]
	mov	BYTE PTR [edx+32], 1
$LN115@CalculateM:

; 851  : 									}
; 852  : 									pZone->AddFriendlyUnitCount(1);

	inc	DWORD PTR [esi+40]

; 853  : 									if(pLoopUnit->isRanged())

	mov	ecx, edi
	call	?isRanged@CvUnit@@QBE_NXZ		; CvUnit::isRanged
	test	al, al
	je	SHORT $LN34@CalculateM

; 854  : 									{
; 855  : 										pZone->AddFriendlyRangedUnitCount(1);

	inc	DWORD PTR [esi+48]
$LN34@CalculateM:

; 820  : 				}
; 821  : 
; 822  : 				// Loop through all of OUR units first
; 823  : 				for(pLoopUnit = m_pPlayer->firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = m_pPlayer->nextUnit(&iLoop))

	mov	ebx, DWORD PTR _this$[esp+60]
	mov	ecx, DWORD PTR [ebx+20]
	push	0
	lea	eax, DWORD PTR _iLoop$[esp+64]
	push	eax
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	edi, eax
	test	edi, edi
	jne	$LL199@CalculateM
$LN33@CalculateM:
	mov	ebx, DWORD PTR $T228101[esp+60]
	imul	ebx, 2984				; 00000ba8H

; 856  : 									}
; 857  : 								}
; 858  : 							}
; 859  : 						}
; 860  : 					}
; 861  : 				}
; 862  : 
; 863  : 				// Repeat for all visible enemy units (or adjacent to visible)
; 864  : 				for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)

	xor	ebp, ebp
	mov	DWORD PTR tv822[esp+60], ebx
	mov	DWORD PTR tv846[esp+60], ebp
	npad	3
$LL22@CalculateM:

; 865  : 				{
; 866  : 					CvPlayer& kPlayer = GET_PLAYER((PlayerTypes) iPlayerLoop);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 867  : 					if(GET_TEAM(eTeam).isAtWar(kPlayer.getTeam()))

	mov	eax, DWORD PTR [ecx+ebp+44]
	lea	edi, DWORD PTR [ecx+ebp]
	mov	DWORD PTR _kPlayer$222737[esp+60], edi
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN127@CalculateM
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN128@CalculateM
$LN127@CalculateM:
	or	eax, -1
$LN128@CalculateM:
	mov	edx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	lea	ecx, DWORD PTR [ebx+edx]
	push	eax
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	je	$LN21@CalculateM

; 868  : 					{
; 869  : 						for(pLoopUnit = kPlayer.firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = kPlayer.nextUnit(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$[esp+64]
	push	eax
	mov	ecx, edi
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	edi, eax
	test	edi, edi
	je	$LN21@CalculateM
	npad	10
$LL201@CalculateM:

; 870  : 						{
; 871  : 							if(pLoopUnit->IsCombatUnit())

	cmp	DWORD PTR [edi+1044], 0
	jle	$LN17@CalculateM

; 872  : 							{
; 873  : 								if(pLoopUnit->getDomainType() == DOMAIN_AIR ||
; 874  : 								        (pLoopUnit->getDomainType() == DOMAIN_LAND && !pZone->IsWater()) ||
; 875  : 								        (pLoopUnit->getDomainType() == DOMAIN_SEA && pZone->IsWater()))

	mov	ecx, edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 1
	je	SHORT $LN13@CalculateM
	mov	ecx, edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	SHORT $LN12@CalculateM
	cmp	BYTE PTR [esi+68], 0
	je	SHORT $LN13@CalculateM
$LN12@CalculateM:
	mov	ecx, edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	jne	$LN17@CalculateM
	cmp	BYTE PTR [esi+68], al
	je	$LN17@CalculateM
$LN13@CalculateM:

; 876  : 								{
; 877  : 									CvPlot* pPlot;
; 878  : 									pPlot = pLoopUnit->plot();

	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ebp, eax

; 879  : 									if(pPlot)

	test	ebp, ebp
	je	$LN17@CalculateM

; 880  : 									{
; 881  : 										bool bVisible = true;
; 882  : 										iDistance = plotDistance(pLoopUnit->getX(), pLoopUnit->getY(), pClosestCity->getX(), pClosestCity->getY());

	mov	eax, DWORD PTR _pClosestCity$[esp+60]
	mov	ecx, DWORD PTR [eax+108]
	mov	edx, DWORD PTR [eax+96]
	mov	eax, DWORD PTR [edi+88]
	push	ecx
	mov	ecx, DWORD PTR [edi+76]
	push	edx
	push	eax
	push	ecx
	mov	bl, 1
	call	?plotDistance@@YAHHHHH@Z		; plotDistance

; 883  : 										if (iDistance <= m_iTacticalRange)

	mov	edx, DWORD PTR _this$[esp+76]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+8]
	add	esp, 16					; 00000010H
	cmp	ecx, eax
	mov	DWORD PTR _iDistance$[esp+60], ecx
	jg	$LN17@CalculateM

; 884  : 										{
; 885  : 											iMultiplier = (m_iTacticalRange + 4 - iDistance);  // "4" so unit strength isn't totally dominated by proximity to city

	sub	eax, ecx

; 886  : 											if(!pPlot->isVisible(eTeam) && !pPlot->isAdjacentVisible(eTeam, false))

	mov	ecx, DWORD PTR $T228101[esp+60]
	add	eax, 4
	mov	DWORD PTR _iMultiplier$[esp+60], eax
	cmp	ecx, -1
	je	SHORT $LN192@CalculateM
	mov	eax, DWORD PTR [ebp+156]
	cmp	WORD PTR [eax+ecx*2], 0
	setg	al
	test	al, al
	jne	SHORT $LN193@CalculateM
$LN192@CalculateM:
	push	0
	push	ecx
	mov	ecx, ebp
	call	?isAdjacentVisible@CvPlot@@QBE_NW4TeamTypes@@_N@Z ; CvPlot::isAdjacentVisible
	test	al, al
	jne	SHORT $LN193@CalculateM

; 887  : 											{
; 888  : 												bVisible = false;

	xor	bl, bl
$LN193@CalculateM:

; 889  : 											}
; 890  : 											if(iMultiplier > 0)

	cmp	DWORD PTR _iMultiplier$[esp+60], 0
	jle	$LN17@CalculateM

; 891  : 											{
; 892  : 												int iUnitStrength = pLoopUnit->GetBaseCombatStrengthConsideringDamage();

	mov	ecx, edi
	call	?GetBaseCombatStrengthConsideringDamage@CvUnit@@QBEHXZ ; CvUnit::GetBaseCombatStrengthConsideringDamage

; 893  : 												if(iUnitStrength == 0 && pLoopUnit->isEmbarked() && !pZone->IsWater())

	test	eax, eax
	jne	SHORT $LN194@CalculateM
	cmp	BYTE PTR [edi+1652], al
	je	SHORT $LN194@CalculateM
	cmp	BYTE PTR [esi+68], al
	jne	SHORT $LN194@CalculateM

; 894  : 												{
; 895  : 													iUnitStrength = pLoopUnit->GetBaseCombatStrength(true);

	push	1
	mov	ecx, edi
	call	?GetBaseCombatStrength@CvUnit@@QBEH_N@Z	; CvUnit::GetBaseCombatStrength
$LN194@CalculateM:

; 896  : 												}
; 897  : 
; 898  : 												if(!bVisible)

	test	bl, bl
	jne	SHORT $LN6@CalculateM

; 899  : 												{
; 900  : 													iUnitStrength /= 2;

	cdq
	sub	eax, edx
	sar	eax, 1
$LN6@CalculateM:

; 901  : 												}
; 902  : 
; 903  : 												pZone->AddEnemyStrength(iUnitStrength * iMultiplier * m_iUnitStrengthMultiplier);

	mov	ecx, DWORD PTR _this$[esp+60]
	mov	edx, DWORD PTR [ecx+4]
	imul	edx, eax
	imul	edx, DWORD PTR _iMultiplier$[esp+60]
	add	DWORD PTR [esi+28], edx

; 904  : 
; 905  : 												int iRangedStrength = pLoopUnit->GetMaxRangedCombatStrength(NULL, /*pCity*/ NULL, true, true);

	push	1
	push	1
	push	0
	push	0
	mov	ecx, edi
	call	?GetMaxRangedCombatStrength@CvUnit@@QBEHPBV1@PBVCvCity@@_N2@Z ; CvUnit::GetMaxRangedCombatStrength

; 906  : 												if(!bVisible)

	test	bl, bl
	jne	SHORT $LN5@CalculateM

; 907  : 												{
; 908  : 													iRangedStrength /= 2;

	cdq
	sub	eax, edx
	sar	eax, 1
$LN5@CalculateM:

; 909  : 												}
; 910  : 
; 911  : 												pZone->AddEnemyRangedStrength(iRangedStrength);

	add	DWORD PTR [esi+36], eax

; 912  : 
; 913  : 												if(bVisible)

	test	bl, bl
	je	SHORT $LN17@CalculateM

; 914  : 												{
; 915  : 													pZone->AddEnemyUnitCount(1);
; 916  : 													if(iDistance < pZone->GetRangeClosestEnemyUnit())

	mov	eax, DWORD PTR _iDistance$[esp+60]
	mov	ebx, 1
	add	DWORD PTR [esi+44], ebx
	cmp	eax, DWORD PTR [esi+64]
	jge	SHORT $LN177@CalculateM

; 917  : 													{
; 918  : 														pZone->SetRangeClosestEnemyUnit(iDistance);

	mov	DWORD PTR [esi+64], eax
$LN177@CalculateM:

; 919  : 													}
; 920  : 													if(pLoopUnit->isRanged())

	mov	ecx, edi
	call	?isRanged@CvUnit@@QBE_NXZ		; CvUnit::isRanged
	test	al, al
	je	SHORT $LN179@CalculateM

; 921  : 													{
; 922  : 														pZone->AddEnemyRangedUnitCount(1);

	add	DWORD PTR [esi+52], ebx
$LN179@CalculateM:

; 923  : 													}
; 924  : 													if(pLoopUnit->getDomainType() == DOMAIN_SEA)

	mov	ecx, edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	jne	SHORT $LN17@CalculateM

; 925  : 													{
; 926  : 														pZone->AddEnemyNavalUnitCount(1);

	inc	DWORD PTR [esi+56]
$LN17@CalculateM:

; 868  : 					{
; 869  : 						for(pLoopUnit = kPlayer.firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = kPlayer.nextUnit(&iLoop))

	mov	ecx, DWORD PTR _kPlayer$222737[esp+60]
	push	0
	lea	eax, DWORD PTR _iLoop$[esp+64]
	push	eax
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	edi, eax
	test	edi, edi
	jne	$LL201@CalculateM
	mov	ebx, DWORD PTR tv822[esp+60]
	mov	ebp, DWORD PTR tv846[esp+60]
$LN21@CalculateM:
	add	ebp, 63236				; 0000f704H
	cmp	ebp, 3983868				; 003cc9fcH
	mov	DWORD PTR tv846[esp+60], ebp
	jl	$LL22@CalculateM

; 856  : 									}
; 857  : 								}
; 858  : 							}
; 859  : 						}
; 860  : 					}
; 861  : 				}
; 862  : 
; 863  : 				// Repeat for all visible enemy units (or adjacent to visible)
; 864  : 				for(int iPlayerLoop = 0; iPlayerLoop < MAX_CIV_PLAYERS; iPlayerLoop++)

	mov	edi, DWORD PTR _this$[esp+60]
$LN41@CalculateM:

; 798  : 
; 799  : 	for(unsigned int iI = 0; iI < m_DominanceZones.size(); iI++)

	mov	eax, DWORD PTR _iI$222709[esp+60]
	add	DWORD PTR tv859[esp+60], 76		; 0000004cH
	inc	eax
	mov	DWORD PTR _iI$222709[esp+60], eax
	cmp	eax, DWORD PTR [edi+116]
	jb	$LL203@CalculateM
	pop	esi
	pop	ebp
	pop	ebx
$LN40@CalculateM:
	pop	edi

; 927  : 													}
; 928  : 												}
; 929  : 											}
; 930  : 										}
; 931  : 									}
; 932  : 								}
; 933  : 							}
; 934  : 						}
; 935  : 
; 936  : 					}
; 937  : 				}
; 938  : 			}
; 939  : 		}
; 940  : 	}
; 941  : }

	add	esp, 44					; 0000002cH
	ret	0
?CalculateMilitaryStrengths@CvTacticalAnalysisMap@@IAEXXZ ENDP ; CvTacticalAnalysisMap::CalculateMilitaryStrengths
_TEXT	ENDS
PUBLIC	?GetZoneByCity@CvTacticalAnalysisMap@@QAEPAVCvTacticalDominanceZone@@PAVCvCity@@_N@Z ; CvTacticalAnalysisMap::GetZoneByCity
; Function compile flags: /Ogtpy
;	COMDAT ?GetZoneByCity@CvTacticalAnalysisMap@@QAEPAVCvTacticalDominanceZone@@PAVCvCity@@_N@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
_bWater$ = 12						; size = 1
?GetZoneByCity@CvTacticalAnalysisMap@@QAEPAVCvTacticalDominanceZone@@PAVCvCity@@_N@Z PROC ; CvTacticalAnalysisMap::GetZoneByCity, COMDAT
; _this$ = ecx

; 1178 : {

	push	ebx
	push	ebp
	push	esi
	mov	ebp, ecx

; 1179 : 	CvTacticalDominanceZone* pZone;
; 1180 : 	for(int iI = 0; iI < GetNumZones(); iI++)

	mov	eax, DWORD PTR [ebp+116]
	push	edi
	xor	edi, edi
	test	eax, eax
	jle	SHORT $LN2@GetZoneByC
	xor	ebx, ebx
$LL29@GetZoneByC:

; 1181 : 	{
; 1182 : 		pZone = GetZone(iI);

	test	edi, edi
	jl	SHORT $LN11@GetZoneByC
	cmp	edi, eax
	jge	SHORT $LN11@GetZoneByC
	mov	esi, DWORD PTR [ebp+112]
	add	esi, ebx
	jmp	SHORT $LN13@GetZoneByC
$LN11@GetZoneByC:
	xor	esi, esi
$LN13@GetZoneByC:

; 1183 : 		if(pZone->GetClosestCity() == pCity && pZone->IsWater() == bWater)

	mov	eax, DWORD PTR [esi+12]
	cmp	eax, -1
	je	SHORT $LN19@GetZoneByC
	mov	ecx, DWORD PTR [esi+16]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	jmp	SHORT $LN20@GetZoneByC
$LN19@GetZoneByC:
	xor	eax, eax
$LN20@GetZoneByC:
	cmp	eax, DWORD PTR _pCity$[esp+12]
	jne	SHORT $LN3@GetZoneByC
	mov	dl, BYTE PTR _bWater$[esp+12]
	cmp	BYTE PTR [esi+68], dl
	je	SHORT $LN27@GetZoneByC
$LN3@GetZoneByC:

; 1179 : 	CvTacticalDominanceZone* pZone;
; 1180 : 	for(int iI = 0; iI < GetNumZones(); iI++)

	mov	eax, DWORD PTR [ebp+116]
	inc	edi
	add	ebx, 76					; 0000004cH
	cmp	edi, eax
	jl	SHORT $LL29@GetZoneByC
$LN2@GetZoneByC:
	pop	edi
	pop	esi
	pop	ebp

; 1186 : 		}
; 1187 : 	}
; 1188 : 
; 1189 : 	return NULL;

	xor	eax, eax
	pop	ebx

; 1190 : }

	ret	8
$LN27@GetZoneByC:
	pop	edi

; 1184 : 		{
; 1185 : 			return pZone;

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 1190 : }

	ret	8
?GetZoneByCity@CvTacticalAnalysisMap@@QAEPAVCvTacticalDominanceZone@@PAVCvCity@@_N@Z ENDP ; CvTacticalAnalysisMap::GetZoneByCity
_TEXT	ENDS
PUBLIC	?IsInEnemyDominatedZone@CvTacticalAnalysisMap@@QAE_NPAVCvPlot@@@Z ; CvTacticalAnalysisMap::IsInEnemyDominatedZone
; Function compile flags: /Ogtpy
;	COMDAT ?IsInEnemyDominatedZone@CvTacticalAnalysisMap@@QAE_NPAVCvPlot@@@Z
_TEXT	SEGMENT
_pPlot$ = 8						; size = 4
?IsInEnemyDominatedZone@CvTacticalAnalysisMap@@QAE_NPAVCvPlot@@@Z PROC ; CvTacticalAnalysisMap::IsInEnemyDominatedZone, COMDAT
; _this$ = ecx

; 1195 : 	CvTacticalAnalysisCell* pCell;
; 1196 : 	int iPlotIndex;
; 1197 : 	CvTacticalDominanceZone* pZone;
; 1198 : 
; 1199 : 	iPlotIndex = GC.getMap().plotNum(pPlot->getX(), pPlot->getY());
; 1200 : 	pCell = GetCell(iPlotIndex);

	mov	edx, DWORD PTR _pPlot$[esp-4]
	movsx	eax, WORD PTR [edx+2]
	movsx	edx, WORD PTR [edx]
	push	ebx
	push	esi
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	imul	eax, DWORD PTR [esi+4020]
	add	eax, edx
	imul	eax, 44					; 0000002cH
	add	eax, DWORD PTR [ecx+12]
	push	edi

; 1201 : 
; 1202 : 	for(int iI = 0; iI < GetNumZones(); iI++)

	mov	edi, DWORD PTR [ecx+116]
	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN2@IsInEnemyD
	mov	eax, DWORD PTR [eax+40]
	xor	ebx, ebx
$LL4@IsInEnemyD:

; 1203 : 	{
; 1204 : 		pZone = GetZone(iI);

	test	esi, esi
	jl	SHORT $LN23@IsInEnemyD
	cmp	esi, edi
	jge	SHORT $LN23@IsInEnemyD
	mov	edx, DWORD PTR [ecx+112]
	add	edx, ebx
	jmp	SHORT $LN25@IsInEnemyD
$LN23@IsInEnemyD:
	xor	edx, edx
$LN25@IsInEnemyD:

; 1205 : 		if(pZone->GetDominanceZoneID() == pCell->GetDominanceZone())

	cmp	DWORD PTR [edx], eax
	je	SHORT $LN38@IsInEnemyD
	inc	esi
	add	ebx, 76					; 0000004cH
	cmp	esi, edi
	jl	SHORT $LL4@IsInEnemyD
$LN2@IsInEnemyD:
	pop	edi
	pop	esi

; 1208 : 		}
; 1209 : 	}
; 1210 : 
; 1211 : 	return false;

	xor	al, al
	pop	ebx

; 1212 : }

	ret	4
$LN38@IsInEnemyD:

; 1206 : 		{
; 1207 : 			return (pZone->GetDominanceFlag() == TACTICAL_DOMINANCE_ENEMY);

	xor	eax, eax
	cmp	DWORD PTR [edx+8], 2
	pop	edi
	pop	esi
	sete	al
	pop	ebx

; 1212 : }

	ret	4
?IsInEnemyDominatedZone@CvTacticalAnalysisMap@@QAE_NPAVCvPlot@@@Z ENDP ; CvTacticalAnalysisMap::IsInEnemyDominatedZone
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvTacticalDominanceZone,110,1,297,0>::~FStaticVector<CvTacticalDominanceZone,110,1,297,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvTacticalDominanceZone,110,1,297,0>::~FStaticVector<CvTacticalDominanceZone,110,1,297,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec:

; 619  : 	};

	ret	0
??1?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvTacticalDominanceZone,110,1,297,0>::~FStaticVector<CvTacticalDominanceZone,110,1,297,0>
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvUnit *,250,1,297,0>::~FStaticVector<CvUnit *,250,1,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvUnit *,250,1,297,0>::~FStaticVector<CvUnit *,250,1,297,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec@2:

; 619  : 	};

	ret	0
??1?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvUnit *,250,1,297,0>::~FStaticVector<CvUnit *,250,1,297,0>
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvTacticalDominanceZone,110,1,297,0>::GrowSize
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSize@?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<CvTacticalDominanceZone,110,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN30@GrowSize
	mov	DWORD PTR [esi+8], 1
$LN30@GrowSize:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize
	npad	6
$LL8@GrowSize:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN31@GrowSize

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize
$LN31@GrowSize:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 110				; 0000006eH
	jbe	SHORT $LN15@GrowSize
	mov	eax, ebp
	imul	eax, 76					; 0000004cH
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN14@GrowSize
$LN15@GrowSize:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 110			; 0000006eH
$LN14@GrowSize:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	imul	ecx, 76					; 0000004cH
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN33@GrowSize
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN33@GrowSize:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+8372], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvTacticalDominanceZone,110,1,297,0>::GrowSize
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvUnit *,250,1,297,0>::GrowSize
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSize@?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<CvUnit *,250,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN30@GrowSize@2
	mov	DWORD PTR [esi+8], 1
$LN30@GrowSize@2:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize@2
	npad	6
$LL8@GrowSize@2:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN31@GrowSize@2

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize@2

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize@2
$LN31@GrowSize@2:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize@2:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 250				; 000000faH
	jbe	SHORT $LN15@GrowSize@2
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [ebp*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN14@GrowSize@2
$LN15@GrowSize@2:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 250			; 000000faH
$LN14@GrowSize@2:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN33@GrowSize@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN33@GrowSize@2:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+1012], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvUnit *,250,1,297,0>::GrowSize
_TEXT	ENDS
PUBLIC	?_Maxlen@?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAEHXZ ; std::_Temp_iterator<CvTacticalDominanceZone>::_Maxlen
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ?_Maxlen@?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAEHXZ
_TEXT	SEGMENT
__Pair$223291 = -8					; size = 8
?_Maxlen@?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAEHXZ PROC ; std::_Temp_iterator<CvTacticalDominanceZone>::_Maxlen, COMDAT
; _this$ = ecx

; 607  : 		{	// return size of buffer

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 608  : 		if (_Pbuf->_Begin == 0 && 0 < _Pbuf->_Size)

	mov	eax, DWORD PTR [esi+16]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN4@Maxlen
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	jle	SHORT $LN5@Maxlen

; 609  : 			{	// allocate buffer on first size query
; 610  : 			pair<_Pty, _PDFT> _Pair =
; 611  : 				std::get_temporary_buffer<_Ty>(_Pbuf->_Size);

	push	eax
	lea	eax, DWORD PTR __Pair$223291[esp+16]
	push	eax
	call	??$get_temporary_buffer@VCvTacticalDominanceZone@@@std@@YA?AU?$pair@PAVCvTacticalDominanceZone@@H@0@H@Z ; std::get_temporary_buffer<CvTacticalDominanceZone>

; 612  : 
; 613  : 			_Pbuf->_Begin = _Pair.first;

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR __Pair$223291[esp+20]
	mov	DWORD PTR [ecx], eax

; 614  : 			_Pbuf->_Current = _Pair.first;

	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [edx+4], eax

; 615  : 			_Pbuf->_Hiwater = _Pair.first;

	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [ecx+8], eax

; 616  : 			_Pbuf->_Size = _Pair.second;

	mov	edx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR __Pair$223291[esp+24]
	mov	DWORD PTR [edx+12], eax

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [ecx+12]
	add	esp, 8
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
$LN4@Maxlen:

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	edx, eax
	mov	eax, DWORD PTR [edx+12]
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
$LN5@Maxlen:

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	eax, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [eax+12]
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
?_Maxlen@?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAEHXZ ENDP ; std::_Temp_iterator<CvTacticalDominanceZone>::_Maxlen
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@PAVCvTacticalDominanceZone@@V1@@std@@YAXPAVCvTacticalDominanceZone@@00@Z ; std::_Insertion_sort1<CvTacticalDominanceZone *,CvTacticalDominanceZone>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Insertion_sort1@PAVCvTacticalDominanceZone@@V1@@std@@YAXPAVCvTacticalDominanceZone@@00@Z
_TEXT	SEGMENT
__Val$223501 = -80					; size = 76
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@PAVCvTacticalDominanceZone@@V1@@std@@YAXPAVCvTacticalDominanceZone@@00@Z PROC ; std::_Insertion_sort1<CvTacticalDominanceZone *,CvTacticalDominanceZone>, COMDAT

; 2967 : 	{	// insertion sort [_First, _Last), using operator<

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 2968 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Last$[ebp]
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	cmp	eax, ecx
	je	SHORT $LN6@Insertion_

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	lea	ebx, DWORD PTR [eax+76]
	cmp	ebx, ecx
	je	SHORT $LN6@Insertion_
	jmp	SHORT $LN7@Insertion_
	npad	1
$LL30@Insertion_:
	mov	eax, DWORD PTR __First$[ebp]
$LN7@Insertion_:

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;
; 2972 : 			_Ty _Val = *_Next;

	mov	ecx, 19					; 00000013H
	mov	esi, ebx
	lea	edi, DWORD PTR __Val$223501[esp+96]
	rep movsd

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	mov	ecx, DWORD PTR __Val$223501[esp+156]
	cmp	ecx, DWORD PTR [eax+60]
	mov	edx, ebx
	jle	SHORT $LN5@Insertion_

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, ebx
	cmp	edx, ebx
	je	SHORT $LN1@Insertion_
$LL20@Insertion_:
	sub	eax, 76					; 0000004cH
	lea	edi, DWORD PTR [eax+76]
	mov	ecx, 19					; 00000013H
	mov	esi, eax
	rep movsd
	cmp	eax, edx
	jne	SHORT $LL20@Insertion_

; 2977 : 				*_First = _Val;
; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN1@Insertion_
$LN5@Insertion_:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	cmp	ecx, DWORD PTR [ebx-16]
	lea	eax, DWORD PTR [ebx-76]
	jle	SHORT $LN1@Insertion_
$LL3@Insertion_:

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	esi, eax
	mov	edi, edx
	mov	ecx, 19					; 00000013H
	rep movsd
	mov	ecx, DWORD PTR __Val$223501[esp+156]
	mov	edx, eax
	sub	eax, 76					; 0000004cH
	cmp	ecx, DWORD PTR [eax+60]
	jg	SHORT $LL3@Insertion_
$LN1@Insertion_:

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	add	ebx, 76					; 0000004cH

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	ecx, 19					; 00000013H
	mov	edi, edx
	lea	esi, DWORD PTR __Val$223501[esp+96]
	rep movsd
	cmp	ebx, DWORD PTR __Last$[ebp]
	jne	SHORT $LL30@Insertion_
$LN6@Insertion_:

; 2986 : 				}
; 2987 : 			}
; 2988 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Insertion_sort1@PAVCvTacticalDominanceZone@@V1@@std@@YAXPAVCvTacticalDominanceZone@@00@Z ENDP ; std::_Insertion_sort1<CvTacticalDominanceZone *,CvTacticalDominanceZone>
_TEXT	ENDS
PUBLIC	??$_Unchecked_merge_backward@PAVCvTacticalDominanceZone@@PAV1@PAV1@@stdext@@YAPAVCvTacticalDominanceZone@@PAV1@0000@Z ; stdext::_Unchecked_merge_backward<CvTacticalDominanceZone *,CvTacticalDominanceZone *,CvTacticalDominanceZone *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_merge_backward@PAVCvTacticalDominanceZone@@PAV1@PAV1@@stdext@@YAPAVCvTacticalDominanceZone@@PAV1@0000@Z
_TEXT	SEGMENT
$T228709 = -4						; size = 1
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
??$_Unchecked_merge_backward@PAVCvTacticalDominanceZone@@PAV1@PAV1@@stdext@@YAPAVCvTacticalDominanceZone@@PAV1@0000@Z PROC ; stdext::_Unchecked_merge_backward<CvTacticalDominanceZone *,CvTacticalDominanceZone *,CvTacticalDominanceZone *>, COMDAT

; 5202 : 	{

	push	ecx

; 5203 : 		return _STD _Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Dest$[esp]
	mov	edx, DWORD PTR __Last2$[esp]
	mov	BYTE PTR $T228709[esp+4], 0
	mov	eax, DWORD PTR $T228709[esp+4]
	push	eax
	mov	eax, DWORD PTR __First2$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last1$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First1$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Merge_backward@PAVCvTacticalDominanceZone@@PAV1@PAV1@@std@@YAPAVCvTacticalDominanceZone@@PAV1@0000U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<CvTacticalDominanceZone *,CvTacticalDominanceZone *,CvTacticalDominanceZone *>

; 5204 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_merge_backward@PAVCvTacticalDominanceZone@@PAV1@PAV1@@stdext@@YAPAVCvTacticalDominanceZone@@PAV1@0000@Z ENDP ; stdext::_Unchecked_merge_backward<CvTacticalDominanceZone *,CvTacticalDominanceZone *,CvTacticalDominanceZone *>
_TEXT	ENDS
PUBLIC	??$lower_bound@PAVCvTacticalDominanceZone@@V1@@std@@YAPAVCvTacticalDominanceZone@@PAV1@0ABV1@@Z ; std::lower_bound<CvTacticalDominanceZone *,CvTacticalDominanceZone>
; Function compile flags: /Ogtpy
;	COMDAT ??$lower_bound@PAVCvTacticalDominanceZone@@V1@@std@@YAPAVCvTacticalDominanceZone@@PAV1@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$lower_bound@PAVCvTacticalDominanceZone@@V1@@std@@YAPAVCvTacticalDominanceZone@@PAV1@0ABV1@@Z PROC ; std::lower_bound<CvTacticalDominanceZone *,CvTacticalDominanceZone>, COMDAT

; 2276 : 	_ASSIGN_FROM_BASE(_First,

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Lower_bound@PAVCvTacticalDominanceZone@@V1@H@std@@YAPAVCvTacticalDominanceZone@@PAV1@0ABV1@PAH@Z ; std::_Lower_bound<CvTacticalDominanceZone *,CvTacticalDominanceZone,int>
	add	esp, 16					; 00000010H

; 2277 : 		_Lower_bound(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val, _Dist_type(_First)));
; 2278 : 	return _First;
; 2279 : 	}

	ret	0
??$lower_bound@PAVCvTacticalDominanceZone@@V1@@std@@YAPAVCvTacticalDominanceZone@@PAV1@0ABV1@@Z ENDP ; std::lower_bound<CvTacticalDominanceZone *,CvTacticalDominanceZone>
_TEXT	ENDS
PUBLIC	??$upper_bound@PAVCvTacticalDominanceZone@@V1@@std@@YAPAVCvTacticalDominanceZone@@PAV1@0ABV1@@Z ; std::upper_bound<CvTacticalDominanceZone *,CvTacticalDominanceZone>
; Function compile flags: /Ogtpy
;	COMDAT ??$upper_bound@PAVCvTacticalDominanceZone@@V1@@std@@YAPAVCvTacticalDominanceZone@@PAV1@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$upper_bound@PAVCvTacticalDominanceZone@@V1@@std@@YAPAVCvTacticalDominanceZone@@PAV1@0ABV1@@Z PROC ; std::upper_bound<CvTacticalDominanceZone *,CvTacticalDominanceZone>, COMDAT

; 2347 : 	_ASSIGN_FROM_BASE(_First,

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Upper_bound@PAVCvTacticalDominanceZone@@V1@H@std@@YAPAVCvTacticalDominanceZone@@PAV1@0ABV1@PAH@Z ; std::_Upper_bound<CvTacticalDominanceZone *,CvTacticalDominanceZone,int>
	add	esp, 16					; 00000010H

; 2348 : 		_Upper_bound(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val, _Dist_type(_First)));
; 2349 : 	return _First;
; 2350 : 	}

	ret	0
??$upper_bound@PAVCvTacticalDominanceZone@@V1@@std@@YAPAVCvTacticalDominanceZone@@PAV1@0ABV1@@Z ENDP ; std::upper_bound<CvTacticalDominanceZone *,CvTacticalDominanceZone>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@PAVCvTacticalDominanceZone@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone>,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_opt@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@PAVCvTacticalDominanceZone@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T228727 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
___formal$ = 48						; size = 1
??$_Copy_opt@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@PAVCvTacticalDominanceZone@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone>,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ecx

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	eax, DWORD PTR __First$[esp]
	push	ebx
	mov	ebx, DWORD PTR __Last$[esp+4]
	push	ebp
	xor	ebp, ebp
	push	esi
	mov	DWORD PTR $T228727[esp+16], ebp
	cmp	eax, ebx
	je	SHORT $LN1@Copy_opt@2
	lea	edx, DWORD PTR [ebp+76]
	push	edi
	npad	6
$LL3@Copy_opt@2:

; 2472 : 		*_Dest = *_First;

	mov	ecx, DWORD PTR __Dest$[esp+32]
	mov	edi, DWORD PTR [ecx+4]
	cmp	edi, DWORD PTR [ecx+8]
	jae	SHORT $LN14@Copy_opt@2
	mov	ecx, 19					; 00000013H
	mov	esi, eax
	rep movsd
	mov	ecx, DWORD PTR __Dest$[esp+32]
	add	DWORD PTR [ecx+4], edx
	jmp	SHORT $LN2@Copy_opt@2
$LN14@Copy_opt@2:
	cmp	edi, ebp
	je	SHORT $LN19@Copy_opt@2
	mov	ecx, 19					; 00000013H
	mov	esi, eax
	rep movsd
	mov	ecx, DWORD PTR __Dest$[esp+32]
$LN19@Copy_opt@2:
	add	DWORD PTR [ecx+4], edx
	mov	ecx, DWORD PTR __Dest$[esp+32]
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx+8], esi
$LN2@Copy_opt@2:
	add	eax, edx
	cmp	eax, ebx
	jne	SHORT $LL3@Copy_opt@2
	pop	edi
$LN1@Copy_opt@2:

; 2473 : 	return (_Dest);

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+12]
	mov	eax, DWORD PTR __Dest$[esp+28]
	mov	DWORD PTR [esi+16], eax
	mov	eax, DWORD PTR __Dest$[esp+12]
	mov	DWORD PTR [esi], ebp
	mov	DWORD PTR [esi+4], ebp
	mov	DWORD PTR [esi+8], ebp
	mov	DWORD PTR [esi+12], ebp
	cmp	eax, ebp
	je	SHORT $LN41@Copy_opt@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN41@Copy_opt@2:
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 2474 : 	}

	pop	ecx
	ret	0
??$_Copy_opt@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@PAVCvTacticalDominanceZone@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone>,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Merge@PAVCvTacticalDominanceZone@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalDominanceZone@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvTacticalDominanceZone *,CvTacticalDominanceZone *,CvTacticalDominanceZone *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Merge@PAVCvTacticalDominanceZone@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalDominanceZone@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Merge@PAVCvTacticalDominanceZone@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalDominanceZone@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<CvTacticalDominanceZone *,CvTacticalDominanceZone *,CvTacticalDominanceZone *,std::random_access_iterator_tag>, COMDAT

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	eax, DWORD PTR __First1$[esp-4]
	mov	edx, DWORD PTR __First2$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR __Dest$[esp]
	push	ebp
	mov	ebp, DWORD PTR __Last1$[esp+4]
	push	esi
	push	edi
	cmp	eax, ebp
	je	SHORT $LN16@Merge
$LL5@Merge:
	cmp	edx, DWORD PTR __Last2$[esp+12]
	je	SHORT $LN40@Merge

; 2514 : 		if (_DEBUG_LT(*_First2, *_First1))

	mov	ecx, DWORD PTR [edx+60]
	cmp	ecx, DWORD PTR [eax+60]

; 2515 : 			*_Dest = *_First2, ++_First2;

	mov	edi, ebx
	mov	ecx, 19					; 00000013H
	jle	SHORT $LN2@Merge
	mov	esi, edx
	add	edx, 76					; 0000004cH

; 2516 : 		else

	jmp	SHORT $LN41@Merge
$LN2@Merge:

; 2517 : 			*_Dest = *_First1, ++_First1;

	mov	esi, eax
	add	eax, 76					; 0000004cH
$LN41@Merge:
	add	ebx, 76					; 0000004cH
	rep movsd
	cmp	eax, ebp
	jne	SHORT $LL5@Merge
$LN40@Merge:

; 2518 : 
; 2519 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	cmp	eax, ebp
	je	SHORT $LN16@Merge
$LL18@Merge:
	mov	esi, eax
	mov	edi, ebx
	add	eax, 76					; 0000004cH
	mov	ecx, 19					; 00000013H
	add	ebx, 76					; 0000004cH
	rep movsd
	cmp	eax, ebp
	jne	SHORT $LL18@Merge
$LN16@Merge:

; 2520 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	eax, ebx
	cmp	edx, DWORD PTR __Last2$[esp+12]
	je	SHORT $LN27@Merge
$LL29@Merge:
	mov	esi, edx
	mov	edi, eax
	add	edx, 76					; 0000004cH
	mov	ecx, 19					; 00000013H
	add	eax, 76					; 0000004cH
	rep movsd
	cmp	edx, DWORD PTR __Last2$[esp+12]
	jne	SHORT $LL29@Merge
$LN27@Merge:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2521 : 	}

	ret	0
??$_Merge@PAVCvTacticalDominanceZone@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalDominanceZone@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<CvTacticalDominanceZone *,CvTacticalDominanceZone *,CvTacticalDominanceZone *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$rotate@PAVCvTacticalDominanceZone@@@std@@YAXPAVCvTacticalDominanceZone@@00@Z ; std::rotate<CvTacticalDominanceZone *>
; Function compile flags: /Ogtpy
;	COMDAT ??$rotate@PAVCvTacticalDominanceZone@@@std@@YAXPAVCvTacticalDominanceZone@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$rotate@PAVCvTacticalDominanceZone@@@std@@YAXPAVCvTacticalDominanceZone@@00@Z PROC ; std::rotate<CvTacticalDominanceZone *>, COMDAT

; 1719 : 	if (_First != _Mid && _Mid != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Mid$[esp-4]
	cmp	edx, eax
	je	SHORT $LN6@rotate
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN6@rotate

; 1720 : 		_Rotate(_CHECKED_BASE(_First), _CHECKED_BASE(_Mid), _CHECKED_BASE(_Last), _Iter_cat(_First));

	push	0
	push	0
	push	ecx
	push	eax
	push	edx
	call	??$_Rotate@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@00PAH0@Z ; std::_Rotate<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>
	add	esp, 20					; 00000014H
$LN6@rotate:

; 1721 : 	}

	ret	0
??$rotate@PAVCvTacticalDominanceZone@@@std@@YAXPAVCvTacticalDominanceZone@@00@Z ENDP ; std::rotate<CvTacticalDominanceZone *>
_TEXT	ENDS
PUBLIC	??0CvTacticalAnalysisMap@@QAE@XZ		; CvTacticalAnalysisMap::CvTacticalAnalysisMap
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??0CvTacticalAnalysisMap@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvTacticalAnalysisMap@@QAE@XZ$0
__ehfuncinfo$??0CvTacticalAnalysisMap@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CvTacticalAnalysisMap@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtacticalanalysismap.cpp
xdata$x	ENDS
;	COMDAT ??0CvTacticalAnalysisMap@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvTacticalAnalysisMap@@QAE@XZ PROC			; CvTacticalAnalysisMap::CvTacticalAnalysisMap, COMDAT
; _this$ = ecx

; 189  : {

	push	-1
	push	__ehhandler$??0CvTacticalAnalysisMap@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], 25			; 00000019H
	mov	DWORD PTR [eax+4], 5
	mov	DWORD PTR [eax+8], 8
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+28], ecx
	mov	BYTE PTR [eax+32], cl
	push	esi
	or	esi, -1
	mov	DWORD PTR [eax+36], esi
	mov	DWORD PTR [eax+40], ecx
	mov	DWORD PTR [eax+44], ecx
	mov	DWORD PTR [eax+48], esi
	mov	DWORD PTR [eax+52], esi
	mov	DWORD PTR [eax+56], ecx
	mov	DWORD PTR [eax+60], ecx
	mov	DWORD PTR [eax+64], ecx
	mov	DWORD PTR [eax+68], ecx
	mov	DWORD PTR [eax+72], ecx
	mov	DWORD PTR [eax+76], ecx
	mov	DWORD PTR [eax+80], ecx
	mov	DWORD PTR [eax+84], ecx
	mov	DWORD PTR [eax+88], ecx
	mov	DWORD PTR [eax+92], ecx
	mov	DWORD PTR [eax+96], ecx
	mov	DWORD PTR [eax+100], 2147483647		; 7fffffffH
	mov	BYTE PTR [eax+104], cl
	mov	BYTE PTR [eax+105], cl
	mov	DWORD PTR [eax+108], ecx
	lea	edx, DWORD PTR [eax+124]
	mov	DWORD PTR [eax+120], 110		; 0000006eH
	mov	DWORD PTR [eax+112], edx
	mov	DWORD PTR [eax+8492], ecx
	mov	DWORD PTR [eax+8496], 250		; 000000faH
	lea	edx, DWORD PTR [eax+8500]
	mov	DWORD PTR [eax+8488], edx

; 190  : 	m_bIsBuilt = false;

	mov	BYTE PTR [eax+34], cl

; 191  : 	m_iTurnBuilt = -1;

	mov	DWORD PTR [eax+24], esi

; 192  : 	m_bAtWar = false;

	mov	BYTE PTR [eax+33], cl

; 193  : 	m_DominanceZones.clear();

	mov	DWORD PTR [eax+116], ecx

; 194  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvTacticalAnalysisMap@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	jmp	??1?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvTacticalDominanceZone,110,1,297,0>::~FStaticVector<CvTacticalDominanceZone,110,1,297,0>
__ehhandler$??0CvTacticalAnalysisMap@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvTacticalAnalysisMap@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvTacticalAnalysisMap@@QAE@XZ ENDP			; CvTacticalAnalysisMap::CvTacticalAnalysisMap
PUBLIC	??1CvTacticalAnalysisMap@@QAE@XZ		; CvTacticalAnalysisMap::~CvTacticalAnalysisMap
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??1CvTacticalAnalysisMap@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvTacticalAnalysisMap@@QAE@XZ$0
__ehfuncinfo$??1CvTacticalAnalysisMap@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CvTacticalAnalysisMap@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtacticalanalysismap.cpp
xdata$x	ENDS
;	COMDAT ??1CvTacticalAnalysisMap@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvTacticalAnalysisMap@@QAE@XZ PROC			; CvTacticalAnalysisMap::~CvTacticalAnalysisMap, COMDAT
; _this$ = ecx

; 198  : {

	push	-1
	push	__ehhandler$??1CvTacticalAnalysisMap@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi

; 199  : 	SAFE_DELETE_ARRAY(m_pPlots);

	mov	eax, DWORD PTR [esi+12]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+32], 0
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+12], 0

; 200  : }

	mov	eax, DWORD PTR [esi+8488]
	lea	ecx, DWORD PTR [esi+8500]
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN9@CvTactical
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN9@CvTactical:
	mov	eax, DWORD PTR [esi+112]
	add	esi, 124				; 0000007cH
	cmp	eax, esi
	mov	DWORD PTR __$EHRec$[esp+28], -1
	pop	esi
	je	SHORT $LN23@CvTactical
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN23@CvTactical:
	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvTacticalAnalysisMap@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	jmp	??1?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvTacticalDominanceZone,110,1,297,0>::~FStaticVector<CvTacticalDominanceZone,110,1,297,0>
__ehhandler$??1CvTacticalAnalysisMap@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvTacticalAnalysisMap@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvTacticalAnalysisMap@@QAE@XZ ENDP			; CvTacticalAnalysisMap::~CvTacticalAnalysisMap
PUBLIC	?push_back@?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@QAEIABVCvTacticalDominanceZone@@@Z ; FStaticVector<CvTacticalDominanceZone,110,1,297,0>::push_back
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?push_back@?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@QAEIABVCvTacticalDominanceZone@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@QAEIABVCvTacticalDominanceZone@@@Z PROC ; FStaticVector<CvTacticalDominanceZone,110,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	ebx
	mov	ebx, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [ebx+8]
	push	edi
	mov	BYTE PTR [ebx+8372], 0
	cmp	DWORD PTR [ebx+4], eax
	jne	SHORT $LN1@push_back

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvTacticalDominanceZone,110,1,297,0>::GrowSize
$LN1@push_back:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	edi, DWORD PTR [ebx+4]
	imul	edi, 76					; 0000004cH
	add	edi, DWORD PTR [ebx]
	je	SHORT $LN4@push_back
	push	esi
	mov	esi, DWORD PTR _element$[esp+8]
	mov	ecx, 19					; 00000013H
	rep movsd
	pop	esi
$LN4@push_back:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [ebx+4]
	lea	ecx, DWORD PTR [eax+1]
	pop	edi
	mov	DWORD PTR [ebx+4], ecx
	pop	ebx

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@QAEIABVCvTacticalDominanceZone@@@Z ENDP ; FStaticVector<CvTacticalDominanceZone,110,1,297,0>::push_back
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@QAEIABQAVCvUnit@@@Z ; FStaticVector<CvUnit *,250,1,297,0>::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@QAEIABQAVCvUnit@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@QAEIABQAVCvUnit@@@Z PROC ; FStaticVector<CvUnit *,250,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+1012], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back@2

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvUnit *,250,1,297,0>::GrowSize
$LN1@push_back@2:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $LN4@push_back@2
	mov	edx, DWORD PTR _element$[esp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
$LN4@push_back@2:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@QAEIABQAVCvUnit@@@Z ENDP ; FStaticVector<CvUnit *,250,1,297,0>::push_back
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@PAVCvTacticalDominanceZone@@@std@@YAXPAVCvTacticalDominanceZone@@0@Z ; std::_Insertion_sort<CvTacticalDominanceZone *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Insertion_sort@PAVCvTacticalDominanceZone@@@std@@YAXPAVCvTacticalDominanceZone@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Insertion_sort@PAVCvTacticalDominanceZone@@@std@@YAXPAVCvTacticalDominanceZone@@0@Z PROC ; std::_Insertion_sort<CvTacticalDominanceZone *>, COMDAT

; 2993 : 	std::_Insertion_sort1(_First, _Last, _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	call	??$_Insertion_sort1@PAVCvTacticalDominanceZone@@V1@@std@@YAXPAVCvTacticalDominanceZone@@00@Z ; std::_Insertion_sort1<CvTacticalDominanceZone *,CvTacticalDominanceZone>
	add	esp, 12					; 0000000cH

; 2994 : 	}

	ret	0
??$_Insertion_sort@PAVCvTacticalDominanceZone@@@std@@YAXPAVCvTacticalDominanceZone@@0@Z ENDP ; std::_Insertion_sort<CvTacticalDominanceZone *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@0V12@@Z ; stdext::unchecked_copy<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@0V12@@Z
_TEXT	SEGMENT
$T229120 = -4						; size = 1
$T229127 = -4						; size = 4
$T229123 = -4						; size = 4
__Cat$229131 = 8					; size = 1
$T229122 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
??$unchecked_copy@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@0V12@@Z PROC ; stdext::unchecked_copy<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone> >, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ecx
	push	ebx
	xor	ebx, ebx
	mov	DWORD PTR $T229127[esp+8], ebx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$229131[esp+4]
	mov	edx, DWORD PTR $T229122[esp+4]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	BYTE PTR $T229120[esp+12], bl
	mov	eax, DWORD PTR $T229120[esp+12]
	push	eax
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last$[esp+20]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+56]
	mov	DWORD PTR $T229123[esp+44], esp
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR __First$[esp+40]
	push	edx
	push	eax
	push	esi
	call	??$_Copy_opt@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@PAVCvTacticalDominanceZone@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone>,std::forward_iterator_tag>
	mov	eax, DWORD PTR __Dest$[esp+52]
	add	esp, 44					; 0000002cH
	cmp	eax, ebx
	je	SHORT $LN27@unchecked_@3
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN27@unchecked_@3:
	mov	eax, esi

; 3607 : 	}

	pop	esi
	pop	ebx
	pop	ecx
	ret	0
??$unchecked_copy@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@0V12@@Z ENDP ; stdext::unchecked_copy<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone> >
_TEXT	ENDS
PUBLIC	??$unchecked_merge@PAVCvTacticalDominanceZone@@PAV1@PAV1@@stdext@@YAPAVCvTacticalDominanceZone@@PAV1@0000@Z ; stdext::unchecked_merge<CvTacticalDominanceZone *,CvTacticalDominanceZone *,CvTacticalDominanceZone *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$unchecked_merge@PAVCvTacticalDominanceZone@@PAV1@PAV1@@stdext@@YAPAVCvTacticalDominanceZone@@PAV1@0000@Z
_TEXT	SEGMENT
$T229171 = -4						; size = 1
$T229172 = -4						; size = 1
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
??$unchecked_merge@PAVCvTacticalDominanceZone@@PAV1@PAV1@@stdext@@YAPAVCvTacticalDominanceZone@@PAV1@0000@Z PROC ; stdext::unchecked_merge<CvTacticalDominanceZone *,CvTacticalDominanceZone *,CvTacticalDominanceZone *>, COMDAT

; 5114 : 	{	// copy merging ranges, both using operator<

	push	ecx

; 5115 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest,
; 5116 : 			_STD _Iter_random(_First1, _First2, _Dest), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Dest$[esp]
	mov	BYTE PTR $T229171[esp+4], 0
	mov	eax, DWORD PTR $T229171[esp+4]
	mov	ecx, DWORD PTR $T229172[esp+4]
	push	eax
	mov	eax, DWORD PTR __Last2$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __First2$[esp+8]
	push	edx
	mov	edx, DWORD PTR __Last1$[esp+12]
	push	eax
	mov	eax, DWORD PTR __First1$[esp+16]
	push	ecx
	push	edx
	push	eax
	call	??$_Merge@PAVCvTacticalDominanceZone@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalDominanceZone@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvTacticalDominanceZone *,CvTacticalDominanceZone *,CvTacticalDominanceZone *,std::random_access_iterator_tag>

; 5117 : 	}

	add	esp, 32					; 00000020H
	ret	0
??$unchecked_merge@PAVCvTacticalDominanceZone@@PAV1@PAV1@@stdext@@YAPAVCvTacticalDominanceZone@@PAV1@0000@Z ENDP ; stdext::unchecked_merge<CvTacticalDominanceZone *,CvTacticalDominanceZone *,CvTacticalDominanceZone *>
_TEXT	ENDS
PUBLIC	??$_Buffered_rotate@PAVCvTacticalDominanceZone@@HV1@@std@@YAPAVCvTacticalDominanceZone@@PAV1@00HHAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z ; std::_Buffered_rotate<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Buffered_rotate@PAVCvTacticalDominanceZone@@HV1@@std@@YAPAVCvTacticalDominanceZone@@PAV1@00HHAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z
_TEXT	SEGMENT
$T229183 = -20						; size = 20
$T229181 = -20						; size = 20
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
$T229182 = 20						; size = 4
$T229180 = 20						; size = 4
__Count1$ = 20						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
??$_Buffered_rotate@PAVCvTacticalDominanceZone@@HV1@@std@@YAPAVCvTacticalDominanceZone@@PAV1@00HHAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z PROC ; std::_Buffered_rotate<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>, COMDAT

; 2683 : 	{	// rotate [_First, _Last) using temp buffer

	sub	esp, 20					; 00000014H
	push	ebx

; 2684 : 	if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	mov	ebx, DWORD PTR __Tempbuf$[esp+20]
	push	ebp
	mov	ebp, DWORD PTR __Count2$[esp+24]
	push	esi
	mov	esi, DWORD PTR __Count1$[esp+28]
	cmp	esi, ebp
	push	edi
	jg	SHORT $LN4@Buffered_r
	mov	ecx, ebx
	call	?_Maxlen@?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAEHXZ ; std::_Temp_iterator<CvTacticalDominanceZone>::_Maxlen
	cmp	esi, eax
	jg	SHORT $LN4@Buffered_r

; 2685 : 		{	// buffer left partition, then copy parts
; 2686 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	eax, DWORD PTR [ebx+16]
	mov	ecx, DWORD PTR [eax]
	mov	edi, DWORD PTR __Mid$[esp+32]
	mov	ebp, DWORD PTR __First$[esp+32]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	esi, esi
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax+8], esi
	mov	DWORD PTR [eax+12], esi
	mov	edx, DWORD PTR [ebx+16]
	mov	DWORD PTR $T229180[esp+52], esp
	push	edi
	mov	DWORD PTR [eax+16], edx
	lea	eax, DWORD PTR $T229181[esp+60]
	push	ebp
	push	eax
	call	??$unchecked_copy@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@0V12@@Z ; stdext::unchecked_copy<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone> >
	mov	eax, DWORD PTR $T229181[esp+68]
	add	esp, 32					; 00000020H
	cmp	eax, esi
	je	SHORT $LN25@Buffered_r
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN25@Buffered_r:

; 2687 : 		_STDEXT unchecked_copy(_Mid, _Last, _First);

	mov	esi, DWORD PTR __Last$[esp+32]
	push	ebp
	push	esi
	push	edi
	call	??$unchecked_copy@PAVCvTacticalDominanceZone@@PAV1@@stdext@@YAPAVCvTacticalDominanceZone@@PAV1@00@Z ; stdext::unchecked_copy<CvTacticalDominanceZone *,CvTacticalDominanceZone *>

; 2688 : 		return (_STDEXT unchecked_copy_backward(_Tempbuf._First(), _Tempbuf._Last(),
; 2689 : 			_Last));

	mov	ebx, DWORD PTR [ebx+16]
	mov	eax, DWORD PTR [ebx+4]
	mov	ebx, DWORD PTR [ebx]
	push	esi
	push	eax
	push	ebx
	call	??$unchecked_copy_backward@PAVCvTacticalDominanceZone@@PAV1@@stdext@@YAPAVCvTacticalDominanceZone@@PAV1@00@Z ; stdext::unchecked_copy_backward<CvTacticalDominanceZone *,CvTacticalDominanceZone *>
	add	esp, 24					; 00000018H

; 2701 : 		return (_First);
; 2702 : 		}
; 2703 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
$LN4@Buffered_r:

; 2690 : 		}
; 2691 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, ebx
	call	?_Maxlen@?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAEHXZ ; std::_Temp_iterator<CvTacticalDominanceZone>::_Maxlen
	cmp	ebp, eax
	jg	$LN2@Buffered_r

; 2692 : 		{	// buffer right partition, then copy parts
; 2693 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR [ebx+16]
	mov	ecx, DWORD PTR [eax]
	mov	ebp, DWORD PTR __Last$[esp+32]
	mov	edi, DWORD PTR __Mid$[esp+32]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	esi, esi
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax+8], esi
	mov	DWORD PTR [eax+12], esi
	mov	edx, DWORD PTR [ebx+16]
	mov	DWORD PTR $T229182[esp+52], esp
	push	ebp
	mov	DWORD PTR [eax+16], edx
	lea	eax, DWORD PTR $T229183[esp+60]
	push	edi
	push	eax
	call	??$unchecked_copy@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@0V12@@Z ; stdext::unchecked_copy<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone> >
	mov	eax, DWORD PTR $T229183[esp+68]
	add	esp, 32					; 00000020H
	cmp	eax, esi
	je	SHORT $LN45@Buffered_r
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN45@Buffered_r:

; 2694 : 		_STDEXT unchecked_copy_backward(_First, _Mid, _Last);

	mov	edx, DWORD PTR __First$[esp+32]
	mov	eax, edi
	cmp	edx, edi
	je	SHORT $LN53@Buffered_r
	sub	ebp, edi
	npad	4
$LL54@Buffered_r:
	sub	eax, 76					; 0000004cH
	lea	edi, DWORD PTR [eax+ebp]
	mov	ecx, 19					; 00000013H
	mov	esi, eax
	rep movsd
	cmp	eax, edx
	jne	SHORT $LL54@Buffered_r
$LN53@Buffered_r:

; 2695 : 		return (_STDEXT unchecked_copy(_Tempbuf._First(), _Tempbuf._Last(), _First));

	mov	ebx, DWORD PTR [ebx+16]
	mov	ebp, DWORD PTR [ebx+4]
	mov	eax, edx
	mov	edx, DWORD PTR [ebx]
	cmp	edx, ebp
	je	SHORT $LN1@Buffered_r
$LL69@Buffered_r:
	mov	esi, edx
	mov	edi, eax
	add	edx, 76					; 0000004cH
	mov	ecx, 19					; 00000013H
	add	eax, 76					; 0000004cH
	rep movsd
	cmp	edx, ebp
	jne	SHORT $LL69@Buffered_r

; 2701 : 		return (_First);
; 2702 : 		}
; 2703 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
$LN2@Buffered_r:

; 2696 : 		}
; 2697 : 	else
; 2698 : 		{	// buffer too small, rotate in place
; 2699 : 		std::rotate(_First, _Mid, _Last);

	mov	edi, DWORD PTR __First$[esp+32]
	mov	eax, DWORD PTR __Mid$[esp+32]
	cmp	edi, eax
	je	SHORT $LN77@Buffered_r
	mov	ecx, DWORD PTR __Last$[esp+32]
	cmp	eax, ecx
	je	SHORT $LN77@Buffered_r
	xor	esi, esi
	push	esi
	push	esi
	push	ecx
	push	eax
	push	edi
	call	??$_Rotate@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@00PAH0@Z ; std::_Rotate<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>
	add	esp, 20					; 00000014H
$LN77@Buffered_r:

; 2700 : 		std::advance(_First, _Count2);

	mov	eax, ebp
	imul	eax, 76					; 0000004cH
	add	eax, edi
$LN1@Buffered_r:

; 2701 : 		return (_First);
; 2702 : 		}
; 2703 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
??$_Buffered_rotate@PAVCvTacticalDominanceZone@@HV1@@std@@YAPAVCvTacticalDominanceZone@@PAV1@00HHAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z ENDP ; std::_Buffered_rotate<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAVCvTacticalDominanceZone@@PAV1@H@std@@YAXPAVCvTacticalDominanceZone@@00HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvTacticalDominanceZone *,CvTacticalDominanceZone *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Chunked_merge@PAVCvTacticalDominanceZone@@PAV1@H@std@@YAXPAVCvTacticalDominanceZone@@00HHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T229450 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Chunk$ = 20						; size = 4
$T229526 = 24						; size = 1
$T229527 = 24						; size = 1
$T229451 = 24						; size = 1
__Count$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Chunked_merge@PAVCvTacticalDominanceZone@@PAV1@H@std@@YAXPAVCvTacticalDominanceZone@@00HHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<CvTacticalDominanceZone *,CvTacticalDominanceZone *,int>, COMDAT

; 3288 : 	{	// copy merging chunks, using operator<

	push	ecx

; 3289 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	edx, DWORD PTR __Count$[esp]
	mov	eax, DWORD PTR __Dest$[esp]
	mov	ecx, DWORD PTR __First$[esp]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR __Chunk$[esp+8]
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp+ebp]
	cmp	edi, edx
	jg	SHORT $LN3@Chunked_me
	imul	ebp, 76					; 0000004cH
$LL50@Chunked_me:

; 3290 : 		{	// copy merging pairs of adjacent chunks
; 3291 : 		_BidIt _Mid1 = _First;
; 3292 : 		std::advance(_Mid1, _Chunk);
; 3293 : 		_BidIt _Mid2 = _Mid1;
; 3294 : 		std::advance(_Mid2, _Chunk);
; 3295 : 
; 3296 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest);

	mov	BYTE PTR $T229450[esp+20], 0
	mov	ebx, DWORD PTR $T229450[esp+20]
	push	ebx
	mov	ebx, DWORD PTR $T229451[esp+20]
	push	ebx
	lea	edx, DWORD PTR [ecx+ebp]
	push	eax
	lea	esi, DWORD PTR [edx+ebp]
	push	esi
	push	edx
	push	edx
	push	ecx
	call	??$_Merge@PAVCvTacticalDominanceZone@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalDominanceZone@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvTacticalDominanceZone *,CvTacticalDominanceZone *,CvTacticalDominanceZone *,std::random_access_iterator_tag>
	mov	edx, DWORD PTR __Count$[esp+44]
	sub	edx, edi
	add	esp, 28					; 0000001cH
	cmp	edx, edi

; 3297 : 		_First = _Mid2;

	mov	ecx, esi
	mov	DWORD PTR __Count$[esp+16], edx
	jge	SHORT $LL50@Chunked_me

; 3289 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	ebp, DWORD PTR __Chunk$[esp+16]
$LN3@Chunked_me:

; 3298 : 		}
; 3299 : 
; 3300 : 	if (_Count <= _Chunk)

	cmp	edx, ebp
	jg	SHORT $LN2@Chunked_me

; 3301 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	mov	ebx, DWORD PTR __Last$[esp+16]
	mov	edx, ecx
	cmp	ecx, ebx
	je	SHORT $LN41@Chunked_me
	sub	eax, ecx
$LL32@Chunked_me:
	lea	edi, DWORD PTR [eax+edx]
	mov	esi, edx
	add	edx, 76					; 0000004cH
	mov	ecx, 19					; 00000013H
	rep movsd
	cmp	edx, ebx
	jne	SHORT $LL32@Chunked_me
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3308 : 		}
; 3309 : 	}

	pop	ecx
	ret	0
$LN2@Chunked_me:

; 3302 : 	else
; 3303 : 		{	// copy merging whole and partial last chunk
; 3304 : 		_BidIt _Mid = _First;
; 3305 : 		std::advance(_Mid, _Chunk);
; 3306 : 
; 3307 : 		_STDEXT unchecked_merge(_First, _Mid, _Mid, _Last, _Dest);

	mov	BYTE PTR $T229526[esp+16], 0
	imul	ebp, 76					; 0000004cH
	mov	edx, DWORD PTR $T229526[esp+16]
	push	edx
	mov	edx, DWORD PTR $T229527[esp+20]
	push	edx
	push	eax
	mov	eax, DWORD PTR __Last$[esp+28]
	push	eax
	add	ebp, ecx
	push	ebp
	push	ebp
	push	ecx
	call	??$_Merge@PAVCvTacticalDominanceZone@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalDominanceZone@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvTacticalDominanceZone *,CvTacticalDominanceZone *,CvTacticalDominanceZone *,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
$LN41@Chunked_me:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3308 : 		}
; 3309 : 	}

	pop	ecx
	ret	0
??$_Chunked_merge@PAVCvTacticalDominanceZone@@PAV1@H@std@@YAXPAVCvTacticalDominanceZone@@00HHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<CvTacticalDominanceZone *,CvTacticalDominanceZone *,int>
_TEXT	ENDS
PUBLIC	??$_Merge@PAVCvTacticalDominanceZone@@PAV1@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@PAVCvTacticalDominanceZone@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvTacticalDominanceZone *,CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone>,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Merge@PAVCvTacticalDominanceZone@@PAV1@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@PAVCvTacticalDominanceZone@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T229553 = -24						; size = 4
$T229546 = -20						; size = 20
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
$T229547 = 16						; size = 4
$T229545 = 16						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
___formal$ = 48						; size = 1
___formal$ = 52						; size = 1
??$_Merge@PAVCvTacticalDominanceZone@@PAV1@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@PAVCvTacticalDominanceZone@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<CvTacticalDominanceZone *,CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone>,std::forward_iterator_tag>, COMDAT

; 2509 : 	{	// copy merging ranges, both using operator<

	sub	esp, 24					; 00000018H

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	edx, DWORD PTR __First1$[esp+20]
	mov	ecx, DWORD PTR __Last1$[esp+20]
	push	ebx
	mov	ebx, DWORD PTR __First2$[esp+24]
	push	ebp
	push	esi
	push	edi
	xor	edi, edi
	mov	DWORD PTR $T229553[esp+40], edi
	cmp	edx, ecx
	je	$LN3@Merge@2
	lea	ebp, DWORD PTR [edi+76]
$LL4@Merge@2:
	cmp	ebx, DWORD PTR __Last2$[esp+36]
	je	$LN3@Merge@2

; 2514 : 		if (_DEBUG_LT(*_First2, *_First1))

	mov	eax, DWORD PTR [ebx+60]
	cmp	eax, DWORD PTR [edx+60]

; 2515 : 			*_Dest = *_First2, ++_First2;

	mov	eax, DWORD PTR __Dest$[esp+52]
	mov	edi, DWORD PTR [eax+4]
	jle	SHORT $LN2@Merge@2
	cmp	edi, DWORD PTR [eax+8]
	jae	SHORT $LN21@Merge@2
	mov	esi, ebx
	mov	ecx, 19					; 00000013H
	rep movsd
	mov	eax, DWORD PTR __Dest$[esp+52]
	add	DWORD PTR [eax+4], ebp
	add	ebx, ebp

; 2516 : 		else

	jmp	SHORT $LN1@Merge@2

; 2515 : 			*_Dest = *_First2, ++_First2;

$LN21@Merge@2:
	test	edi, edi
	je	SHORT $LN26@Merge@2
	mov	ecx, 19					; 00000013H
	mov	esi, ebx
	rep movsd
	mov	eax, DWORD PTR __Dest$[esp+52]
$LN26@Merge@2:
	add	DWORD PTR [eax+4], ebp
	mov	eax, DWORD PTR __Dest$[esp+52]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+8], ecx
	add	ebx, ebp

; 2516 : 		else

	jmp	SHORT $LN1@Merge@2
$LN2@Merge@2:

; 2517 : 			*_Dest = *_First1, ++_First1;

	cmp	edi, DWORD PTR [eax+8]
	jae	SHORT $LN33@Merge@2
	mov	ecx, 19					; 00000013H
	mov	esi, edx
	rep movsd
	mov	eax, DWORD PTR __Dest$[esp+52]
	add	DWORD PTR [eax+4], ebp
	jmp	SHORT $LN32@Merge@2
$LN33@Merge@2:
	test	edi, edi
	je	SHORT $LN38@Merge@2
	mov	ecx, 19					; 00000013H
	mov	esi, edx
	rep movsd
	mov	eax, DWORD PTR __Dest$[esp+52]
$LN38@Merge@2:
	add	DWORD PTR [eax+4], ebp
	mov	eax, DWORD PTR __Dest$[esp+52]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+8], ecx
$LN32@Merge@2:
	add	edx, ebp
$LN1@Merge@2:

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	ecx, DWORD PTR __Last1$[esp+36]
	xor	edi, edi
	cmp	edx, ecx
	jne	$LL4@Merge@2
$LN3@Merge@2:

; 2518 : 
; 2519 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T229545[esp+56], esp
	push	ecx
	push	edx
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], edi
	mov	esi, DWORD PTR __Dest$[esp+80]
	lea	edx, DWORD PTR $T229546[esp+68]
	push	edx
	mov	DWORD PTR [eax+16], esi
	call	??$unchecked_copy@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@0V12@@Z ; stdext::unchecked_copy<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone> >
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR __Dest$[esp+84], eax
	mov	eax, DWORD PTR $T229546[esp+72]
	add	esp, 32					; 00000020H
	cmp	eax, edi
	je	SHORT $LN56@Merge@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN56@Merge@2:

; 2520 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	edx, DWORD PTR __Last2$[esp+36]
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+36]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR $T229547[esp+56], esp
	push	edx
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], edi
	mov	ecx, DWORD PTR __Dest$[esp+76]
	push	ebx
	push	esi
	mov	DWORD PTR [eax+16], ecx
	call	??$unchecked_copy@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@0V12@@Z ; stdext::unchecked_copy<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone> >
	mov	eax, DWORD PTR __Dest$[esp+68]
	add	esp, 32					; 00000020H
	cmp	eax, edi
	je	SHORT $LN77@Merge@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN77@Merge@2:

; 2521 : 	}

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
??$_Merge@PAVCvTacticalDominanceZone@@PAV1@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@PAVCvTacticalDominanceZone@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<CvTacticalDominanceZone *,CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone>,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	?BuildEnemyUnitList@CvTacticalAnalysisMap@@IAEXXZ ; CvTacticalAnalysisMap::BuildEnemyUnitList
EXTRN	?IsCanAttack@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsCanAttack
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtacticalanalysismap.cpp
;	COMDAT ?BuildEnemyUnitList@CvTacticalAnalysisMap@@IAEXXZ
_TEXT	SEGMENT
tv324 = -8						; size = 4
_iLoop$222508 = -4					; size = 4
?BuildEnemyUnitList@CvTacticalAnalysisMap@@IAEXXZ PROC	; CvTacticalAnalysisMap::BuildEnemyUnitList, COMDAT
; _this$ = ecx

; 283  : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi

; 284  : 	CvTacticalAnalysisEnemy enemy;
; 285  : 	m_EnemyUnits.clear();

	xor	esi, esi
	mov	ebx, ecx
	push	edi
	mov	DWORD PTR [ebx+8492], esi
	mov	DWORD PTR tv324[esp+24], esi
$LL60@BuildEnemy:

; 288  : 	{
; 289  : 		const PlayerTypes ePlayer = (PlayerTypes)iPlayer;
; 290  : 		CvPlayer& kPlayer = GET_PLAYER(ePlayer);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ebp, DWORD PTR [esi+eax]

; 291  : 		const TeamTypes eTeam = kPlayer.getTeam();

	mov	eax, DWORD PTR [ebp+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN27@BuildEnemy
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN28@BuildEnemy
$LN27@BuildEnemy:
	or	eax, -1
$LN28@BuildEnemy:

; 292  : 
; 293  : 		// for each opposing civ
; 294  : 		if(kPlayer.isAlive() && GET_TEAM(eTeam).isAtWar(m_pPlayer->getTeam()))

	cmp	BYTE PTR [ebp+2256], 0
	je	$LN7@BuildEnemy
	mov	ecx, DWORD PTR [ebx+20]
	mov	ecx, DWORD PTR [ecx+44]
	cmp	ecx, 63					; 0000003fH
	ja	SHORT $LN40@BuildEnemy
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN41@BuildEnemy
$LN40@BuildEnemy:
	or	ecx, -1
$LN41@BuildEnemy:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ecx
	mov	ecx, eax
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	je	SHORT $LN7@BuildEnemy

; 295  : 		{
; 296  : 			int iLoop;
; 297  : 			CvUnit* pLoopUnit = NULL;
; 298  : 			for(pLoopUnit = kPlayer.firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = kPlayer.nextUnit(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$222508[esp+28]
	push	eax
	mov	ecx, ebp
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	edi, eax
	test	edi, edi
	je	SHORT $LN7@BuildEnemy
	npad	5
$LL4@BuildEnemy:

; 299  : 			{
; 300  : 				// Make sure this unit can attack
; 301  : 				if(pLoopUnit->IsCanAttack())

	mov	ecx, edi
	call	?IsCanAttack@CvUnit@@QBE_NXZ		; CvUnit::IsCanAttack
	test	al, al
	je	SHORT $LN3@BuildEnemy

; 302  : 				{
; 303  : 					m_EnemyUnits.push_back(pLoopUnit);

	mov	eax, DWORD PTR [ebx+8496]
	lea	esi, DWORD PTR [ebx+8488]
	mov	BYTE PTR [esi+1012], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN47@BuildEnemy
	push	eax
	mov	ecx, esi
	call	?GrowSize@?$FStaticVector@PAVCvUnit@@$0PK@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvUnit *,250,1,297,0>::GrowSize
$LN47@BuildEnemy:
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edx+ecx*4]
	test	eax, eax
	je	SHORT $LN50@BuildEnemy
	mov	DWORD PTR [eax], edi
$LN50@BuildEnemy:
	inc	DWORD PTR [esi+4]
$LN3@BuildEnemy:

; 295  : 		{
; 296  : 			int iLoop;
; 297  : 			CvUnit* pLoopUnit = NULL;
; 298  : 			for(pLoopUnit = kPlayer.firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = kPlayer.nextUnit(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$222508[esp+28]
	push	eax
	mov	ecx, ebp
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	edi, eax
	test	edi, edi
	jne	SHORT $LL4@BuildEnemy
	mov	esi, DWORD PTR tv324[esp+24]
$LN7@BuildEnemy:

; 286  : 
; 287  : 	for(int iPlayer = 0; iPlayer < MAX_PLAYERS; iPlayer++)

	add	esi, 63236				; 0000f704H
	cmp	esi, 4047104				; 003dc100H
	mov	DWORD PTR tv324[esp+24], esi
	jl	$LL60@BuildEnemy
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 304  : 				}
; 305  : 			}
; 306  : 		}
; 307  : 	}
; 308  : }

	add	esp, 8
	ret	0
?BuildEnemyUnitList@CvTacticalAnalysisMap@@IAEXXZ ENDP	; CvTacticalAnalysisMap::BuildEnemyUnitList
_TEXT	ENDS
PUBLIC	?AddTemporaryZones@CvTacticalAnalysisMap@@IAEXXZ ; CvTacticalAnalysisMap::AddTemporaryZones
EXTRN	?GetNextTemporaryZone@CvTacticalAI@@QAEPAVCvTemporaryZone@@XZ:PROC ; CvTacticalAI::GetNextTemporaryZone
EXTRN	?GetFirstTemporaryZone@CvTacticalAI@@QAEPAVCvTemporaryZone@@XZ:PROC ; CvTacticalAI::GetFirstTemporaryZone
EXTRN	?DropObsoleteZones@CvTacticalAI@@QAEXXZ:PROC	; CvTacticalAI::DropObsoleteZones
; Function compile flags: /Ogtpy
;	COMDAT ?AddTemporaryZones@CvTacticalAnalysisMap@@IAEXXZ
_TEXT	SEGMENT
_pZone$ = -88						; size = 4
_pTacticalAI$ = -84					; size = 4
_this$ = -80						; size = 4
_newZone$222610 = -76					; size = 76
?AddTemporaryZones@CvTacticalAnalysisMap@@IAEXXZ PROC	; CvTacticalAnalysisMap::AddTemporaryZones, COMDAT
; _this$ = ecx

; 501  : {

	sub	esp, 88					; 00000058H
	push	ebx
	mov	DWORD PTR _this$[esp+92], ecx

; 502  : 	CvTemporaryZone* pZone;
; 503  : 	CvTacticalAI* pTacticalAI = m_pPlayer->GetTacticalAI();

	mov	ecx, DWORD PTR [ecx+20]
	push	esi
	call	?GetTacticalAI@CvPlayer@@QBEPAVCvTacticalAI@@XZ ; CvPlayer::GetTacticalAI
	mov	esi, eax

; 504  : 
; 505  : 	if(pTacticalAI)

	xor	ebx, ebx
	mov	DWORD PTR _pTacticalAI$[esp+96], esi
	cmp	esi, ebx
	je	$LN3@AddTempora

; 506  : 	{
; 507  : 		pTacticalAI->DropObsoleteZones();

	mov	ecx, esi
	call	?DropObsoleteZones@CvTacticalAI@@QAEXXZ	; CvTacticalAI::DropObsoleteZones

; 508  : 
; 509  : 		pZone = pTacticalAI->GetFirstTemporaryZone();

	mov	ecx, esi
	call	?GetFirstTemporaryZone@CvTacticalAI@@QAEPAVCvTemporaryZone@@XZ ; CvTacticalAI::GetFirstTemporaryZone
	mov	DWORD PTR _pZone$[esp+96], eax

; 510  : 		while(pZone)

	cmp	eax, ebx
	je	$LN3@AddTempora
	push	ebp
	push	edi
	jmp	SHORT $LN4@AddTempora
	npad	1
$LL88@AddTempora:
	mov	eax, DWORD PTR _pZone$[esp+104]
$LN4@AddTempora:

; 511  : 		{
; 512  : 			// Can't be a city zone (which is just used to boost priority but not establish a new zone)
; 513  : 			if(pZone->GetTargetType() != AI_TACTICAL_TARGET_CITY)

	cmp	DWORD PTR [eax+8], 1
	je	$LN79@AddTempora

; 514  : 			{
; 515  : 				CvPlot* pPlot = GC.getMap().plot(pZone->GetX(), pZone->GetY());

	mov	edi, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax]
	cmp	eax, -2147483647			; 80000001H
	je	$LN79@AddTempora
	cmp	edi, -2147483647			; 80000001H
	je	$LN79@AddTempora
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	ecx, DWORD PTR [edx+4020]
	cmp	BYTE PTR [edx+4056], bl
	je	SHORT $LN26@AddTempora
	cmp	eax, ebx
	jge	SHORT $LN28@AddTempora
	cdq
	idiv	ecx
	mov	esi, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	esi, ecx
	jmp	SHORT $LN30@AddTempora
$LN28@AddTempora:
	cmp	eax, ecx
	jl	SHORT $LN26@AddTempora
	cdq
	idiv	ecx
	mov	esi, edx
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	jmp	SHORT $LN30@AddTempora
$LN26@AddTempora:
	mov	esi, eax
$LN30@AddTempora:
	mov	ebp, DWORD PTR [edx+4024]
	cmp	BYTE PTR [edx+4057], bl
	je	SHORT $LN36@AddTempora
	cmp	edi, ebx
	jge	SHORT $LN38@AddTempora
	mov	eax, edi
	cdq
	idiv	ebp
	add	edx, ebp
	jmp	SHORT $LN40@AddTempora
$LN38@AddTempora:
	cmp	edi, ebp
	jl	SHORT $LN36@AddTempora
	mov	eax, edi
	cdq
	idiv	ebp
	jmp	SHORT $LN40@AddTempora
$LN36@AddTempora:
	mov	edx, edi
$LN40@AddTempora:
	cmp	esi, ebx
	jl	$LN89@AddTempora
	cmp	esi, ecx
	jge	$LN89@AddTempora
	cmp	edx, ebx
	jl	$LN89@AddTempora
	cmp	edx, ebp
	jge	$LN89@AddTempora
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [eax+4068]

; 516  : 				if(pPlot)

	cmp	ecx, ebx
	je	$LN89@AddTempora

; 517  : 				{
; 518  : 					CvTacticalDominanceZone newZone;
; 519  : 					newZone.SetDominanceZoneID(m_DominanceZones.size());

	mov	ebp, DWORD PTR _this$[esp+104]
	mov	edx, DWORD PTR [ebp+116]
	or	eax, -1

; 520  : 					newZone.SetTerritoryType(TACTICAL_TERRITORY_TEMP_ZONE);
; 521  : 					newZone.SetOwner(NO_PLAYER);
; 522  : 					newZone.SetAreaID(pPlot->getArea());
; 523  : 					newZone.SetWater(pPlot->isWater());

	cmp	BYTE PTR [ecx+5], 3
	mov	DWORD PTR _newZone$222610[esp+120], eax
	mov	DWORD PTR _newZone$222610[esp+116], eax
	mov	eax, DWORD PTR [ecx+356]
	mov	DWORD PTR _newZone$222610[esp+124], eax

; 524  : 					newZone.SetTempZoneCenter(pPlot);
; 525  : 					newZone.SetNavalInvasion(pZone->IsNavalInvasion());

	mov	eax, DWORD PTR _pZone$[esp+104]
	mov	DWORD PTR _newZone$222610[esp+104], edx
	sete	dl

; 526  : 					m_DominanceZones.push_back(newZone);

	add	ebp, 112				; 00000070H
	mov	DWORD PTR _newZone$222610[esp+176], ecx
	mov	cl, BYTE PTR [eax+16]
	mov	eax, DWORD PTR [ebp+8]
	mov	DWORD PTR _newZone$222610[esp+112], ebx
	mov	DWORD PTR _newZone$222610[esp+128], ebx
	mov	DWORD PTR _newZone$222610[esp+132], ebx
	mov	DWORD PTR _newZone$222610[esp+136], ebx
	mov	DWORD PTR _newZone$222610[esp+140], ebx
	mov	DWORD PTR _newZone$222610[esp+144], ebx
	mov	DWORD PTR _newZone$222610[esp+148], ebx
	mov	DWORD PTR _newZone$222610[esp+152], ebx
	mov	DWORD PTR _newZone$222610[esp+156], ebx
	mov	DWORD PTR _newZone$222610[esp+160], ebx
	mov	DWORD PTR _newZone$222610[esp+164], ebx
	mov	DWORD PTR _newZone$222610[esp+168], 2147483647 ; 7fffffffH
	mov	DWORD PTR _newZone$222610[esp+108], 5
	mov	BYTE PTR _newZone$222610[esp+172], dl
	mov	BYTE PTR _newZone$222610[esp+173], cl
	mov	BYTE PTR [ebp+8372], bl
	cmp	DWORD PTR [ebp+4], eax
	jne	SHORT $LN78@AddTempora
	push	eax
	mov	ecx, ebp
	call	?GrowSize@?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvTacticalDominanceZone,110,1,297,0>::GrowSize
$LN78@AddTempora:
	mov	eax, DWORD PTR [ebp+4]
	imul	eax, 76					; 0000004cH
	add	eax, DWORD PTR [ebp]
	je	SHORT $LN81@AddTempora
	mov	ecx, 19					; 00000013H
	lea	esi, DWORD PTR _newZone$222610[esp+104]
	mov	edi, eax
	rep movsd
$LN81@AddTempora:
	inc	DWORD PTR [ebp+4]
$LN89@AddTempora:
	mov	esi, DWORD PTR _pTacticalAI$[esp+104]
$LN79@AddTempora:

; 527  : 				}
; 528  : 			}
; 529  : 
; 530  : 			pZone = pTacticalAI->GetNextTemporaryZone();

	mov	ecx, esi
	call	?GetNextTemporaryZone@CvTacticalAI@@QAEPAVCvTemporaryZone@@XZ ; CvTacticalAI::GetNextTemporaryZone
	mov	DWORD PTR _pZone$[esp+104], eax
	cmp	eax, ebx
	jne	$LL88@AddTempora
	pop	edi
	pop	ebp
$LN3@AddTempora:
	pop	esi
	pop	ebx

; 531  : 		}
; 532  : 	}
; 533  : }

	add	esp, 88					; 00000058H
	ret	0
?AddTemporaryZones@CvTacticalAnalysisMap@@IAEXXZ ENDP	; CvTacticalAnalysisMap::AddTemporaryZones
_TEXT	ENDS
PUBLIC	?AddToDominanceZones@CvTacticalAnalysisMap@@IAEXHPAVCvTacticalAnalysisCell@@@Z ; CvTacticalAnalysisMap::AddToDominanceZones
EXTRN	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::nextCity
EXTRN	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::firstCity
; Function compile flags: /Ogtpy
;	COMDAT ?AddToDominanceZones@CvTacticalAnalysisMap@@IAEXHPAVCvTacticalAnalysisCell@@@Z
_TEXT	SEGMENT
_iLoop$222666 = -4					; size = 4
_pBestCity$222668 = 8					; size = 4
_iIndex$ = 8						; size = 4
_pCell$ = 12						; size = 4
?AddToDominanceZones@CvTacticalAnalysisMap@@IAEXHPAVCvTacticalAnalysisCell@@@Z PROC ; CvTacticalAnalysisMap::AddToDominanceZones, COMDAT
; _this$ = ecx

; 662  : {

	push	ecx

; 663  : 	CvPlot* pPlot = GC.getMap().plotByIndex(iIndex);

	mov	eax, DWORD PTR _iIndex$[esp]
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	ebp, ecx
	test	eax, eax
	jl	SHORT $LN38@AddToDomin
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	eax, DWORD PTR [ecx+4028]
	jge	SHORT $LN38@AddToDomin
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]
	mov	ebx, eax
	jmp	SHORT $LN39@AddToDomin
$LN38@AddToDomin:
	xor	ebx, ebx
$LN39@AddToDomin:

; 664  : 
; 665  : 	// Compute zone data for this cell
; 666  : 	m_TempZone.SetAreaID(pPlot->getArea());

	mov	eax, DWORD PTR [ebx+356]
	mov	DWORD PTR [ebp+56], eax

; 667  : 	m_TempZone.SetOwner(pPlot->getOwner());

	movsx	ecx, BYTE PTR [ebx+4]
	mov	DWORD PTR [ebp+48], ecx

; 668  : 	m_TempZone.SetWater(pPlot->isWater());

	cmp	BYTE PTR [ebx+5], 3

; 669  : 	if(!pPlot->isOwned())

	mov	ecx, ebx
	sete	dl
	mov	BYTE PTR [ebp+104], dl
	call	?isOwned@CvPlot@@QBE_NXZ		; CvPlot::isOwned
	test	al, al
	jne	SHORT $LN31@AddToDomin

; 670  : 	{
; 671  : 		m_TempZone.SetTerritoryType(TACTICAL_TERRITORY_NO_OWNER);

	mov	DWORD PTR [ebp+40], 1
	jmp	$LN106@AddToDomin
$LN31@AddToDomin:

; 672  : 	}
; 673  : 	else if(pPlot->getTeam() == m_pPlayer->getTeam())

	movsx	eax, BYTE PTR [ebx+4]
	mov	edi, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	eax, -1
	je	SHORT $LN57@AddToDomin
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN64@AddToDomin
	mov	ecx, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	esi, ecx
	jmp	SHORT $LN56@AddToDomin
$LN64@AddToDomin:
	or	ecx, -1
	mov	esi, ecx
	jmp	SHORT $LN56@AddToDomin
$LN57@AddToDomin:
	or	esi, -1
$LN56@AddToDomin:
	mov	edx, DWORD PTR [ebp+20]
	mov	edx, DWORD PTR [edx+44]
	cmp	edx, 63					; 0000003fH
	ja	SHORT $LN73@AddToDomin
	mov	ecx, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN74@AddToDomin
$LN73@AddToDomin:
	or	ecx, -1
$LN74@AddToDomin:
	cmp	esi, ecx
	jne	SHORT $LN29@AddToDomin

; 674  : 	{
; 675  : 		m_TempZone.SetTerritoryType(TACTICAL_TERRITORY_FRIENDLY);

	mov	DWORD PTR [ebp+40], 2
	jmp	SHORT $LN106@AddToDomin
$LN29@AddToDomin:

; 676  : 	}
; 677  : 	else if(GET_TEAM(m_pPlayer->getTeam()).isAtWar(pPlot->getTeam()))

	cmp	eax, -1
	je	SHORT $LN81@AddToDomin
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN88@AddToDomin
	mov	ecx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	mov	ecx, eax
	jmp	SHORT $LN80@AddToDomin
$LN88@AddToDomin:
	or	eax, -1
	mov	ecx, eax
	jmp	SHORT $LN80@AddToDomin
$LN81@AddToDomin:
	or	ecx, -1
$LN80@AddToDomin:
	cmp	edx, 63					; 0000003fH
	ja	SHORT $LN97@AddToDomin
	mov	eax, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [eax+edx*4]
	jmp	SHORT $LN98@AddToDomin
$LN97@AddToDomin:
	or	eax, -1
$LN98@AddToDomin:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	ecx
	mov	ecx, eax
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	je	SHORT $LN27@AddToDomin

; 678  : 	{
; 679  : 		m_TempZone.SetTerritoryType(TACTICAL_TERRITORY_ENEMY);

	mov	DWORD PTR [ebp+40], 3

; 680  : 	}
; 681  : 	else

	jmp	SHORT $LN106@AddToDomin
$LN27@AddToDomin:

; 682  : 	{
; 683  : 		m_TempZone.SetTerritoryType(TACTICAL_TERRITORY_NEUTRAL);

	mov	DWORD PTR [ebp+40], 4
$LN106@AddToDomin:

; 684  : 	}
; 685  : 	m_TempZone.SetClosestCity(NULL);

	mov	DWORD PTR [ebp+52], -1

; 686  : 	if(m_TempZone.GetTerritoryType() == TACTICAL_TERRITORY_ENEMY ||
; 687  : 	        m_TempZone.GetTerritoryType() == TACTICAL_TERRITORY_NEUTRAL ||
; 688  : 	        m_TempZone.GetTerritoryType() == TACTICAL_TERRITORY_FRIENDLY)

	mov	eax, DWORD PTR [ebp+40]
	cmp	eax, 3
	je	SHORT $LN24@AddToDomin
	cmp	eax, 4
	je	SHORT $LN24@AddToDomin
	cmp	eax, 2
	jne	$LN227@AddToDomin
$LN24@AddToDomin:

; 689  : 	{
; 690  : 		int iLoop;
; 691  : 		int iBestDistance = MAX_INT;
; 692  : 		CvCity* pBestCity = NULL;
; 693  : 
; 694  : 		for(CvCity* pLoopCity = GET_PLAYER(m_TempZone.GetOwner()).firstCity(&iLoop); pLoopCity != NULL; pLoopCity = GET_PLAYER(m_TempZone.GetOwner()).nextCity(&iLoop))

	mov	ecx, DWORD PTR [ebp+48]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	lea	edx, DWORD PTR _iLoop$222666[esp+24]
	push	edx
	mov	edi, 2147483647				; 7fffffffH
	mov	DWORD PTR _pBestCity$222668[esp+24], 0
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN227@AddToDomin
	npad	4
$LL23@AddToDomin:

; 695  : 		{
; 696  : 			int iDistance = plotDistance(pLoopCity->getX(), pLoopCity->getY(), pPlot->getX(), pPlot->getY());

	movsx	eax, WORD PTR [ebx+2]
	movsx	ecx, WORD PTR [ebx]
	mov	edx, DWORD PTR [esi+108]
	push	eax
	mov	eax, DWORD PTR [esi+96]
	push	ecx
	push	edx
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H

; 697  : 			if(iDistance < iBestDistance)

	cmp	eax, edi
	jge	SHORT $LN22@AddToDomin

; 698  : 			{
; 699  : 				iBestDistance = iDistance;

	mov	edi, eax

; 700  : 				pBestCity = pLoopCity;

	mov	DWORD PTR _pBestCity$222668[esp+16], esi
$LN22@AddToDomin:
	mov	ecx, DWORD PTR [ebp+48]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	lea	edx, DWORD PTR _iLoop$222666[esp+24]
	push	edx
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL23@AddToDomin

; 701  : 			}
; 702  : 		}
; 703  : 
; 704  : 		if(pBestCity != NULL)

	mov	eax, DWORD PTR _pBestCity$222668[esp+16]
	test	eax, eax
	je	SHORT $LN227@AddToDomin

; 705  : 		{
; 706  : 			m_TempZone.SetClosestCity(pBestCity);

	mov	eax, DWORD PTR [eax+120]
	mov	DWORD PTR [ebp+52], eax
$LN227@AddToDomin:

; 707  : 		}
; 708  : 	}
; 709  : 
; 710  : 	// Now see if we already have a matching zone
; 711  : 	CvTacticalDominanceZone* pZone = FindExistingZone(pPlot);

	push	ebx
	mov	ecx, ebp
	call	?FindExistingZone@CvTacticalAnalysisMap@@IAEPAVCvTacticalDominanceZone@@PAVCvPlot@@@Z ; CvTacticalAnalysisMap::FindExistingZone
	mov	esi, eax

; 712  : 	if(!pZone)

	test	esi, esi
	jne	SHORT $LN18@AddToDomin

; 713  : 	{
; 714  : 		// Data populated, now add to vector
; 715  : 		m_TempZone.SetDominanceZoneID(m_DominanceZones.size());

	mov	ecx, DWORD PTR [ebp+116]

; 716  : 		m_DominanceZones.push_back(m_TempZone);

	lea	ebx, DWORD PTR [ebp+112]
	lea	esi, DWORD PTR [ebp+36]
	mov	DWORD PTR [esi], ecx
	mov	BYTE PTR [ebx+8372], al
	mov	eax, DWORD PTR [ebx+8]
	cmp	DWORD PTR [ebx+4], eax
	jne	SHORT $LN154@AddToDomin
	push	eax
	mov	ecx, ebx
	call	?GrowSize@?$FStaticVector@VCvTacticalDominanceZone@@$0GO@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvTacticalDominanceZone,110,1,297,0>::GrowSize
$LN154@AddToDomin:
	mov	edi, DWORD PTR [ebx+4]
	imul	edi, 76					; 0000004cH
	add	edi, DWORD PTR [ebx]
	je	SHORT $LN157@AddToDomin
	mov	ecx, 19					; 00000013H
	rep movsd
$LN157@AddToDomin:
	inc	DWORD PTR [ebx+4]

; 717  : 		pZone = &m_DominanceZones[m_DominanceZones.size() - 1];

	mov	edx, DWORD PTR [ebp+116]
	mov	eax, DWORD PTR [ebx]
	imul	edx, 76					; 0000004cH
	lea	esi, DWORD PTR [edx+eax-76]
$LN18@AddToDomin:

; 718  : 	}
; 719  : 
; 720  : 	// If this isn't owned territory, update zone with military strength info
; 721  : 	if(pZone->GetTerritoryType() == TACTICAL_TERRITORY_NO_OWNER ||
; 722  : 	        pZone->GetTerritoryType() == TACTICAL_TERRITORY_TEMP_ZONE)

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 1
	je	SHORT $LN16@AddToDomin
	cmp	eax, 5
	jne	$LN226@AddToDomin
$LN16@AddToDomin:

; 723  : 	{
; 724  : 		CvUnit* pFriendlyUnit = pCell->GetFriendlyMilitaryUnit();

	mov	ecx, DWORD PTR _pCell$[esp+16]
	mov	edi, DWORD PTR [ecx+20]

; 725  : 		if(pFriendlyUnit)

	test	edi, edi
	je	$LN224@AddToDomin

; 726  : 		{
; 727  : 			if(pFriendlyUnit->getDomainType() == DOMAIN_AIR ||
; 728  : 			        (pFriendlyUnit->getDomainType() == DOMAIN_LAND && !pZone->IsWater()) ||
; 729  : 			        (pFriendlyUnit->getDomainType() == DOMAIN_SEA && pZone->IsWater()))

	mov	ecx, edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 1
	je	SHORT $LN223@AddToDomin
	mov	ecx, edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	SHORT $LN12@AddToDomin
	cmp	BYTE PTR [esi+68], 0
	je	SHORT $LN223@AddToDomin
$LN12@AddToDomin:
	mov	ecx, edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	jne	SHORT $LN224@AddToDomin
	cmp	BYTE PTR [esi+68], al
	je	SHORT $LN224@AddToDomin
$LN223@AddToDomin:

; 730  : 			{
; 731  : 				int iStrength = pFriendlyUnit->GetBaseCombatStrengthConsideringDamage();

	mov	ecx, edi
	call	?GetBaseCombatStrengthConsideringDamage@CvUnit@@QBEHXZ ; CvUnit::GetBaseCombatStrengthConsideringDamage

; 732  : 				if(iStrength == 0 && pFriendlyUnit->isEmbarked() && !pZone->IsWater())

	test	eax, eax
	jne	SHORT $LN11@AddToDomin
	cmp	BYTE PTR [edi+1652], al
	je	SHORT $LN11@AddToDomin
	cmp	BYTE PTR [esi+68], al
	jne	SHORT $LN11@AddToDomin

; 733  : 				{
; 734  : 					iStrength = pFriendlyUnit->GetBaseCombatStrength(true);

	push	1
	mov	ecx, edi
	call	?GetBaseCombatStrength@CvUnit@@QBEH_N@Z	; CvUnit::GetBaseCombatStrength
$LN11@AddToDomin:

; 735  : 				}
; 736  : 				pZone->AddFriendlyStrength(iStrength * m_iUnitStrengthMultiplier);

	mov	edx, DWORD PTR [ebp+4]
	imul	edx, eax
	add	DWORD PTR [esi+24], edx

; 737  : 				pZone->AddFriendlyRangedStrength(pFriendlyUnit->GetMaxRangedCombatStrength(NULL, /*pCity*/ NULL, true, true));

	push	1
	push	1
	push	0
	push	0
	mov	ecx, edi
	call	?GetMaxRangedCombatStrength@CvUnit@@QBEHPBV1@PBVCvCity@@_N2@Z ; CvUnit::GetMaxRangedCombatStrength
	add	DWORD PTR [esi+32], eax

; 738  : 				if(pFriendlyUnit->GetRange() > GetBestFriendlyRange())

	mov	ebx, DWORD PTR [ebp+28]
	mov	ecx, edi
	call	?GetRange@CvUnit@@QBEHXZ		; CvUnit::GetRange
	cmp	eax, ebx
	jle	SHORT $LN187@AddToDomin

; 739  : 				{
; 740  : 					SetBestFriendlyRange(pFriendlyUnit->GetRange());

	mov	ecx, edi
	call	?GetRange@CvUnit@@QBEHXZ		; CvUnit::GetRange
	mov	DWORD PTR [ebp+28], eax
$LN187@AddToDomin:

; 741  : 				}
; 742  : 				if(pFriendlyUnit->IsRangeAttackIgnoreLOS())

	mov	ecx, edi
	call	?IsRangeAttackIgnoreLOS@CvUnit@@QBE_NXZ	; CvUnit::IsRangeAttackIgnoreLOS
	test	al, al
	je	SHORT $LN189@AddToDomin

; 743  : 				{
; 744  : 					SetIgnoreLOS(true);

	mov	BYTE PTR [ebp+32], 1
$LN189@AddToDomin:

; 745  : 				}
; 746  : 				pZone->AddFriendlyUnitCount(1);

	inc	DWORD PTR [esi+40]

; 747  : 				if(pFriendlyUnit->isRanged())

	mov	ecx, edi
	call	?isRanged@CvUnit@@QBE_NXZ		; CvUnit::isRanged
	test	al, al
	je	SHORT $LN224@AddToDomin

; 748  : 				{
; 749  : 					pZone->AddFriendlyRangedUnitCount(1);

	inc	DWORD PTR [esi+48]
$LN224@AddToDomin:

; 750  : 				}
; 751  : 			}
; 752  : 		}
; 753  : 
; 754  : 		CvUnit* pEnemyUnit = pCell->GetEnemyMilitaryUnit();

	mov	eax, DWORD PTR _pCell$[esp+16]
	mov	edi, DWORD PTR [eax+4]

; 755  : 		if(pEnemyUnit)

	test	edi, edi
	je	$LN226@AddToDomin

; 756  : 		{
; 757  : 			if(pEnemyUnit->getDomainType() == DOMAIN_AIR ||
; 758  : 			        (pEnemyUnit->getDomainType() == DOMAIN_LAND && !pZone->IsWater()) ||
; 759  : 			        (pEnemyUnit->getDomainType() == DOMAIN_SEA && pZone->IsWater()))

	mov	ecx, edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	mov	ebx, 1
	cmp	eax, ebx
	je	SHORT $LN5@AddToDomin
	mov	ecx, edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	SHORT $LN4@AddToDomin
	cmp	BYTE PTR [esi+68], 0
	je	SHORT $LN5@AddToDomin
$LN4@AddToDomin:
	mov	ecx, edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	jne	SHORT $LN226@AddToDomin
	cmp	BYTE PTR [esi+68], al
	je	SHORT $LN226@AddToDomin
$LN5@AddToDomin:

; 760  : 			{
; 761  : 				int iStrength = pEnemyUnit->GetBaseCombatStrengthConsideringDamage();

	mov	ecx, edi
	call	?GetBaseCombatStrengthConsideringDamage@CvUnit@@QBEHXZ ; CvUnit::GetBaseCombatStrengthConsideringDamage

; 762  : 				if(iStrength == 0 && pEnemyUnit->isEmbarked() && !pZone->IsWater())

	test	eax, eax
	jne	SHORT $LN3@AddToDomin
	cmp	BYTE PTR [edi+1652], al
	je	SHORT $LN3@AddToDomin
	cmp	BYTE PTR [esi+68], al
	jne	SHORT $LN3@AddToDomin

; 763  : 				{
; 764  : 					iStrength = pEnemyUnit->GetBaseCombatStrength(true);

	push	ebx
	mov	ecx, edi
	call	?GetBaseCombatStrength@CvUnit@@QBEH_N@Z	; CvUnit::GetBaseCombatStrength
$LN3@AddToDomin:

; 765  : 				}
; 766  : 				pZone->AddEnemyStrength(iStrength * m_iUnitStrengthMultiplier);

	mov	ecx, DWORD PTR [ebp+4]
	imul	ecx, eax
	add	DWORD PTR [esi+28], ecx

; 767  : 				pZone->AddEnemyRangedStrength(pEnemyUnit->GetMaxRangedCombatStrength(NULL, /*pCity*/ NULL, true, true));

	push	ebx
	push	ebx
	push	0
	push	0
	mov	ecx, edi
	call	?GetMaxRangedCombatStrength@CvUnit@@QBEHPBV1@PBVCvCity@@_N2@Z ; CvUnit::GetMaxRangedCombatStrength
	add	DWORD PTR [esi+36], eax

; 768  : 				pZone->AddEnemyUnitCount(1);

	add	DWORD PTR [esi+44], ebx

; 769  : 				if(pEnemyUnit->isRanged())

	mov	ecx, edi
	call	?isRanged@CvUnit@@QBE_NXZ		; CvUnit::isRanged
	test	al, al
	je	SHORT $LN213@AddToDomin

; 770  : 				{
; 771  : 					pZone->AddEnemyRangedUnitCount(1);

	add	DWORD PTR [esi+52], ebx
$LN213@AddToDomin:

; 772  : 				}
; 773  : 				if (pEnemyUnit->getDomainType() == DOMAIN_SEA)

	mov	ecx, edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	jne	SHORT $LN226@AddToDomin

; 774  : 				{
; 775  : 					pZone->AddEnemyNavalUnitCount(1);

	add	DWORD PTR [esi+56], ebx
$LN226@AddToDomin:

; 776  : 				}
; 777  : 			}
; 778  : 		}
; 779  : 	}
; 780  : 
; 781  : 	// Set zone for this cell
; 782  : 	pCell->SetDominanceZone(pZone->GetDominanceZoneID());

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR _pCell$[esp+16]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax+40], edx
	pop	ebx

; 783  : }

	pop	ecx
	ret	8
?AddToDominanceZones@CvTacticalAnalysisMap@@IAEXHPAVCvTacticalAnalysisCell@@@Z ENDP ; CvTacticalAnalysisMap::AddToDominanceZones
_TEXT	ENDS
PUBLIC	??$_Buffered_merge@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@00HHAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z ; std::_Buffered_merge<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Buffered_merge@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@00HHAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z
_TEXT	SEGMENT
__Midn$223449 = -24					; size = 4
$T230404 = -20						; size = 20
$T230402 = -20						; size = 20
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
tv368 = 20						; size = 4
__Count1$ = 20						; size = 4
$T230510 = 24						; size = 1
$T230459 = 24						; size = 1
$T230460 = 24						; size = 1
$T230403 = 24						; size = 4
$T230401 = 24						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
??$_Buffered_merge@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@00HHAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z PROC ; std::_Buffered_merge<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>, COMDAT

; 2759 : 	{	// merge [_First, _Mid) with [_Mid, _Last), using operator<

	sub	esp, 24					; 00000018H
	push	ebx

; 2760 : 	if (_Count1 + _Count2 == 2)

	mov	ebx, DWORD PTR __Count1$[esp+24]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Count2$[esp+36]
	lea	eax, DWORD PTR [ebx+edi]
	cmp	eax, 2
	je	$LN107@Buffered_m
	jmp	SHORT $LN96@Buffered_m
	npad	3
$LL108@Buffered_m:
	mov	edi, DWORD PTR __Count2$[esp+36]
	mov	ebx, DWORD PTR __Count1$[esp+36]
$LN96@Buffered_m:

; 2764 : 		}
; 2765 : 	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	cmp	ebx, edi
	mov	esi, DWORD PTR __Tempbuf$[esp+36]
	jg	SHORT $LN6@Buffered_m
	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAEHXZ ; std::_Temp_iterator<CvTacticalDominanceZone>::_Maxlen
	cmp	ebx, eax
	jle	$LN102@Buffered_m
$LN6@Buffered_m:

; 2769 : 		}
; 2770 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAEHXZ ; std::_Temp_iterator<CvTacticalDominanceZone>::_Maxlen
	cmp	edi, eax
	jle	$LN103@Buffered_m

; 2775 : 		}
; 2776 : 	else
; 2777 : 		{	// buffer too small, divide and conquer
; 2778 : 		_BidIt _Firstn, _Lastn;
; 2779 : 		_Diff _Count1n, _Count2n;
; 2780 : 
; 2781 : 		if (_Count2 < _Count1)

	cmp	edi, ebx

; 2782 : 			{	// left larger, cut it in half and partition right to match
; 2783 : 			_Count1n = _Count1 / 2, _Count2n = 0;
; 2784 : 			_Firstn = _First;
; 2785 : 			std::advance(_Firstn, _Count1n);
; 2786 : 			_Lastn = std::lower_bound(_Mid, _Last, *_Firstn);

	push	0
	jge	SHORT $LN2@Buffered_m
	mov	ecx, DWORD PTR __Last$[esp+40]
	mov	esi, DWORD PTR __Mid$[esp+40]
	mov	eax, ebx
	cdq
	sub	eax, edx
	mov	ebp, eax
	sar	ebp, 1
	mov	edi, ebp
	imul	edi, 76					; 0000004cH
	add	edi, DWORD PTR __First$[esp+40]
	push	edi
	push	ecx
	push	esi
	call	??$_Lower_bound@PAVCvTacticalDominanceZone@@V1@H@std@@YAPAVCvTacticalDominanceZone@@PAV1@0ABV1@PAH@Z ; std::_Lower_bound<CvTacticalDominanceZone *,CvTacticalDominanceZone,int>
	mov	ebx, eax

; 2787 : 			_Distance(_Mid, _Lastn, _Count2n);

	mov	ecx, ebx
	sub	ecx, esi
	mov	eax, 1808407283				; 6bca1af3H
	imul	ecx
	sar	edx, 5
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esp, 16					; 00000010H
	add	esi, edx

; 2788 : 			}
; 2789 : 		else

	jmp	SHORT $LN94@Buffered_m
$LN2@Buffered_m:

; 2790 : 			{	// right larger, cut it in half and partition left to match
; 2791 : 			_Count1n = 0, _Count2n = _Count2 / 2;
; 2792 : 			_Lastn = _Mid;
; 2793 : 			std::advance(_Lastn, _Count2n);
; 2794 : 			_Firstn = std::upper_bound(_First, _Mid, *_Lastn);

	mov	ebp, DWORD PTR __First$[esp+40]
	mov	eax, edi
	cdq
	sub	eax, edx
	mov	esi, eax
	mov	eax, DWORD PTR __Mid$[esp+40]
	sar	esi, 1
	mov	ebx, esi
	imul	ebx, 76					; 0000004cH
	add	ebx, eax
	push	ebx
	push	eax
	push	ebp
	call	??$_Upper_bound@PAVCvTacticalDominanceZone@@V1@H@std@@YAPAVCvTacticalDominanceZone@@PAV1@0ABV1@PAH@Z ; std::_Upper_bound<CvTacticalDominanceZone *,CvTacticalDominanceZone,int>
	mov	edi, eax

; 2795 : 			_Distance(_First, _Firstn, _Count1n);

	mov	ecx, edi
	sub	ecx, ebp
	mov	eax, 1808407283				; 6bca1af3H
	imul	ecx
	sar	edx, 5
	mov	ebp, edx
	shr	ebp, 31					; 0000001fH
	add	esp, 16					; 00000010H
	add	ebp, edx
$LN94@Buffered_m:

; 2796 : 			}
; 2797 : 
; 2798 : 		_BidIt _Midn = _Buffered_rotate(_Firstn, _Mid, _Lastn,
; 2799 : 			_Count1 - _Count1n, _Count2n, _Tempbuf);	// rearrange middle

	mov	edx, DWORD PTR __Tempbuf$[esp+36]
	mov	eax, DWORD PTR __Count1$[esp+36]
	push	edx
	sub	eax, ebp
	push	esi
	push	eax
	mov	DWORD PTR tv368[esp+48], eax
	mov	eax, DWORD PTR __Mid$[esp+48]
	push	ebx
	push	eax
	push	edi
	call	??$_Buffered_rotate@PAVCvTacticalDominanceZone@@HV1@@std@@YAPAVCvTacticalDominanceZone@@PAV1@00HHAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z ; std::_Buffered_rotate<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>

; 2800 : 		_Buffered_merge(_First, _Firstn, _Midn,
; 2801 : 			_Count1n, _Count2n, _Tempbuf);	// merge each new part

	mov	ecx, DWORD PTR __Tempbuf$[esp+60]
	mov	edx, DWORD PTR __First$[esp+60]
	push	ecx
	push	esi
	push	ebp
	push	eax
	push	edi
	push	edx
	mov	DWORD PTR __Midn$223449[esp+88], eax
	call	??$_Buffered_merge@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@00HHAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z ; std::_Buffered_merge<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>

; 2802 : 		_Buffered_merge(_Midn, _Lastn, _Last,
; 2803 : 			_Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf);

	mov	eax, DWORD PTR __Count2$[esp+84]
	mov	ecx, DWORD PTR tv368[esp+84]
	mov	edx, DWORD PTR __Midn$223449[esp+88]
	sub	eax, esi
	mov	DWORD PTR __Count1$[esp+84], ecx
	add	ecx, eax
	add	esp, 48					; 00000030H
	mov	DWORD PTR __Count2$[esp+36], eax
	mov	DWORD PTR __Mid$[esp+36], ebx
	mov	DWORD PTR __First$[esp+36], edx
	cmp	ecx, 2
	jne	$LL108@Buffered_m
$LN107@Buffered_m:

; 2761 : 		{	// order two one-element partitions
; 2762 : 		if (_DEBUG_LT(*_Mid, *_First))

	mov	eax, DWORD PTR __Mid$[esp+36]
	mov	edx, DWORD PTR [eax+60]
	mov	ecx, DWORD PTR __First$[esp+36]
	cmp	edx, DWORD PTR [ecx+60]
	jle	$LN3@Buffered_m

; 2763 : 			std::iter_swap(_First, _Mid);

	push	eax
	push	ecx
	call	??$iter_swap@PAVCvTacticalDominanceZone@@PAV1@@std@@YAXPAVCvTacticalDominanceZone@@0@Z ; std::iter_swap<CvTacticalDominanceZone *,CvTacticalDominanceZone *>
	add	esp, 8

; 2804 : 		}
; 2805 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
$LN102@Buffered_m:

; 2766 : 		{	// buffer left partition, then merge
; 2767 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	edi, DWORD PTR __Mid$[esp+36]
	mov	ebx, DWORD PTR __First$[esp+36]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	ebp, ebp
	mov	DWORD PTR [eax], ebp
	mov	DWORD PTR [eax+4], ebp
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], ebp
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR $T230401[esp+56], esp
	push	edi
	mov	DWORD PTR [eax+16], edx
	lea	eax, DWORD PTR $T230402[esp+64]
	push	ebx
	push	eax
	call	??$unchecked_copy@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@0V12@@Z ; stdext::unchecked_copy<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone> >
	mov	eax, DWORD PTR $T230402[esp+72]
	add	esp, 32					; 00000020H
	cmp	eax, ebp
	je	SHORT $LN32@Buffered_m
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN32@Buffered_m:

; 2768 : 		_STDEXT unchecked_merge(_Tempbuf._First(), _Tempbuf._Last(), _Mid, _Last, _First);

	mov	eax, DWORD PTR __Last$[esp+36]
	mov	esi, DWORD PTR [esi+16]
	mov	BYTE PTR $T230459[esp+36], 0
	mov	ecx, DWORD PTR $T230459[esp+36]
	mov	edx, DWORD PTR $T230460[esp+36]
	push	ecx
	mov	ecx, DWORD PTR [esi+4]
	push	edx
	mov	edx, DWORD PTR [esi]
	push	ebx
	push	eax
	push	edi
	push	ecx
	push	edx
	call	??$_Merge@PAVCvTacticalDominanceZone@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvTacticalDominanceZone@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvTacticalDominanceZone *,CvTacticalDominanceZone *,CvTacticalDominanceZone *,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH

; 2804 : 		}
; 2805 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
$LN103@Buffered_m:

; 2771 : 		{	// buffer right partition, then merge
; 2772 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	ebx, DWORD PTR __Last$[esp+36]
	mov	edi, DWORD PTR __Mid$[esp+36]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	ebp, ebp
	mov	DWORD PTR [eax], ebp
	mov	DWORD PTR [eax+4], ebp
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], ebp
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR $T230403[esp+56], esp
	push	ebx
	mov	DWORD PTR [eax+16], edx
	lea	eax, DWORD PTR $T230404[esp+64]
	push	edi
	push	eax
	call	??$unchecked_copy@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@0V12@@Z ; stdext::unchecked_copy<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone> >
	mov	eax, DWORD PTR $T230404[esp+72]
	add	esp, 32					; 00000020H
	cmp	eax, ebp
	je	SHORT $LN56@Buffered_m
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN56@Buffered_m:

; 2773 : 		_STDEXT _Unchecked_merge_backward(_First, _Mid,
; 2774 : 			_Tempbuf._First(), _Tempbuf._Last(), _Last);

	mov	esi, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi]
	mov	BYTE PTR $T230510[esp+36], 0
	mov	ecx, DWORD PTR $T230510[esp+36]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+40]
	push	ebx
	push	edx
	push	eax
	push	edi
	push	ecx
	call	??$_Merge_backward@PAVCvTacticalDominanceZone@@PAV1@PAV1@@std@@YAPAVCvTacticalDominanceZone@@PAV1@0000U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<CvTacticalDominanceZone *,CvTacticalDominanceZone *,CvTacticalDominanceZone *>
	add	esp, 24					; 00000018H
$LN3@Buffered_m:

; 2804 : 		}
; 2805 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
??$_Buffered_merge@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@00HHAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z ENDP ; std::_Buffered_merge<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>
_TEXT	ENDS
PUBLIC	??$_Unchecked_chunked_merge@PAVCvTacticalDominanceZone@@PAV1@H@stdext@@YAXPAVCvTacticalDominanceZone@@00HH@Z ; stdext::_Unchecked_chunked_merge<CvTacticalDominanceZone *,CvTacticalDominanceZone *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_chunked_merge@PAVCvTacticalDominanceZone@@PAV1@H@stdext@@YAXPAVCvTacticalDominanceZone@@00HH@Z
_TEXT	SEGMENT
$T230617 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Chunk$ = 20						; size = 4
__Count$ = 24						; size = 4
??$_Unchecked_chunked_merge@PAVCvTacticalDominanceZone@@PAV1@H@stdext@@YAXPAVCvTacticalDominanceZone@@00HH@Z PROC ; stdext::_Unchecked_chunked_merge<CvTacticalDominanceZone *,CvTacticalDominanceZone *,int>, COMDAT

; 5252 : 	{

	push	ecx

; 5253 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Count$[esp]
	mov	edx, DWORD PTR __Chunk$[esp]
	mov	BYTE PTR $T230617[esp+4], 0
	mov	eax, DWORD PTR $T230617[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Chunked_merge@PAVCvTacticalDominanceZone@@PAV1@H@std@@YAXPAVCvTacticalDominanceZone@@00HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvTacticalDominanceZone *,CvTacticalDominanceZone *,int>

; 5254 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_chunked_merge@PAVCvTacticalDominanceZone@@PAV1@H@stdext@@YAXPAVCvTacticalDominanceZone@@00HH@Z ENDP ; stdext::_Unchecked_chunked_merge<CvTacticalDominanceZone *,CvTacticalDominanceZone *,int>
_TEXT	ENDS
PUBLIC	??$unchecked_merge@PAVCvTacticalDominanceZone@@PAV1@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@000V12@@Z ; stdext::unchecked_merge<CvTacticalDominanceZone *,CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_merge@PAVCvTacticalDominanceZone@@PAV1@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@000V12@@Z
_TEXT	SEGMENT
$T230621 = -4						; size = 1
$T230627 = -4						; size = 4
$T230623 = -4						; size = 4
$T230622 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
??$unchecked_merge@PAVCvTacticalDominanceZone@@PAV1@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@000V12@@Z PROC ; stdext::unchecked_merge<CvTacticalDominanceZone *,CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone> >, COMDAT

; 5114 : 	{	// copy merging ranges, both using operator<

	push	ecx
	push	ebx
	xor	ebx, ebx
	mov	DWORD PTR $T230627[esp+8], ebx

; 5115 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest,
; 5116 : 			_STD _Iter_random(_First1, _First2, _Dest), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR $T230622[esp+4]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	BYTE PTR $T230621[esp+12], bl
	mov	eax, DWORD PTR $T230621[esp+12]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR __First2$[esp+16]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR __Dest$[esp+52]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Last2$[esp+36]
	mov	edx, DWORD PTR __Last1$[esp+36]
	mov	DWORD PTR $T230623[esp+40], esp
	push	eax
	mov	eax, DWORD PTR __First1$[esp+40]
	push	ecx
	push	edx
	push	eax
	push	esi
	call	??$_Merge@PAVCvTacticalDominanceZone@@PAV1@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@PAVCvTacticalDominanceZone@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvTacticalDominanceZone *,CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone>,std::forward_iterator_tag>
	mov	eax, DWORD PTR __Dest$[esp+56]
	add	esp, 48					; 00000030H
	cmp	eax, ebx
	je	SHORT $LN25@unchecked_@4
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN25@unchecked_@4:
	mov	eax, esi

; 5117 : 	}

	pop	esi
	pop	ebx
	pop	ecx
	ret	0
??$unchecked_merge@PAVCvTacticalDominanceZone@@PAV1@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@000V12@@Z ENDP ; stdext::unchecked_merge<CvTacticalDominanceZone *,CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone> >
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@H@std@@YAXPAVCvTacticalDominanceZone@@0V?$_Temp_iterator@VCvTacticalDominanceZone@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone>,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Chunked_merge@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@H@std@@YAXPAVCvTacticalDominanceZone@@0V?$_Temp_iterator@VCvTacticalDominanceZone@@@0@HHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T230667 = -24						; size = 4
$T230672 = -20						; size = 20
$T230670 = -20						; size = 20
$T230668 = -20						; size = 20
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
$T230669 = 40						; size = 4
__Count$ = 40						; size = 4
___formal$ = 44						; size = 1
??$_Chunked_merge@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@H@std@@YAXPAVCvTacticalDominanceZone@@0V?$_Temp_iterator@VCvTacticalDominanceZone@@@0@HHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone>,int>, COMDAT

; 3289 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	eax, DWORD PTR __Chunk$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	esp, 24					; 00000018H
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR __Count$[esp+32]
	lea	ecx, DWORD PTR [eax+eax]
	xor	ebx, ebx
	cmp	ecx, esi
	push	edi
	jg	SHORT $LN3@Chunked_me@2
	mov	edi, eax
	imul	edi, 76					; 0000004cH
$LL5@Chunked_me@2:

; 3290 : 		{	// copy merging pairs of adjacent chunks
; 3291 : 		_BidIt _Mid1 = _First;
; 3292 : 		std::advance(_Mid1, _Chunk);
; 3293 : 		_BidIt _Mid2 = _Mid1;
; 3294 : 		std::advance(_Mid2, _Chunk);
; 3295 : 
; 3296 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest);

	sub	esp, 20					; 00000014H
	mov	eax, esp
	lea	ecx, DWORD PTR [edi+edx]
	mov	DWORD PTR $T230667[esp+60], esp
	lea	esi, DWORD PTR [edi+ecx]
	push	esi
	push	ecx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ebp, DWORD PTR __Dest$[esp+80]
	push	ecx
	mov	DWORD PTR [eax+16], ebp
	push	edx
	lea	eax, DWORD PTR $T230668[esp+76]
	push	eax
	call	??$unchecked_merge@PAVCvTacticalDominanceZone@@PAV1@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@000V12@@Z ; stdext::unchecked_merge<CvTacticalDominanceZone *,CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone> >
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR $T230668[esp+80]
	add	esp, 40					; 00000028H
	mov	DWORD PTR __Dest$[esp+52], ecx
	cmp	eax, ebx
	je	SHORT $LN41@Chunked_me@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN41@Chunked_me@2:
	mov	eax, DWORD PTR __Chunk$[esp+36]

; 3297 : 		_First = _Mid2;

	mov	edx, esi
	mov	esi, DWORD PTR __Count$[esp+36]
	lea	ecx, DWORD PTR [eax+eax]
	sub	esi, ecx
	cmp	esi, ecx
	mov	DWORD PTR __Count$[esp+36], esi
	jge	SHORT $LL5@Chunked_me@2
$LN3@Chunked_me@2:

; 3298 : 		}
; 3299 : 
; 3300 : 	if (_Count <= _Chunk)
; 3301 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	sub	esp, 20					; 00000014H
	cmp	esi, eax
	mov	DWORD PTR $T230669[esp+56], esp
	jg	SHORT $LN2@Chunked_me@2
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+72]
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR __Last$[esp+56]
	push	eax
	push	edx
	lea	ecx, DWORD PTR $T230670[esp+68]
	push	ecx
	call	??$unchecked_copy@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@0V12@@Z ; stdext::unchecked_copy<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone> >
	add	esp, 32					; 00000020H

; 3302 : 	else

	jmp	SHORT $LN99@Chunked_me@2
$LN2@Chunked_me@2:

; 3303 : 		{	// copy merging whole and partial last chunk
; 3304 : 		_BidIt _Mid = _First;
; 3305 : 		std::advance(_Mid, _Chunk);

	imul	eax, 76					; 0000004cH
	add	eax, edx
	mov	ecx, eax

; 3306 : 
; 3307 : 		_STDEXT unchecked_merge(_First, _Mid, _Mid, _Last, _Dest);

	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	esi, DWORD PTR __Dest$[esp+72]
	mov	DWORD PTR [eax+16], esi
	mov	eax, DWORD PTR __Last$[esp+56]
	push	eax
	push	ecx
	push	ecx
	push	edx
	lea	ecx, DWORD PTR $T230672[esp+76]
	push	ecx
	call	??$unchecked_merge@PAVCvTacticalDominanceZone@@PAV1@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@PAVCvTacticalDominanceZone@@000V12@@Z ; stdext::unchecked_merge<CvTacticalDominanceZone *,CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone> >
	add	esp, 40					; 00000028H
$LN99@Chunked_me@2:
	mov	eax, DWORD PTR $T230672[esp+40]
	cmp	eax, ebx
	je	SHORT $LN75@Chunked_me@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN75@Chunked_me@2:

; 3308 : 		}
; 3309 : 	}

	mov	eax, DWORD PTR __Dest$[esp+36]
	cmp	eax, ebx
	je	SHORT $LN85@Chunked_me@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN85@Chunked_me@2:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
??$_Chunked_merge@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@H@std@@YAXPAVCvTacticalDominanceZone@@0V?$_Temp_iterator@VCvTacticalDominanceZone@@@0@HHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone>,int>
_TEXT	ENDS
PUBLIC	??$_Unchecked_chunked_merge@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@H@stdext@@YAXPAVCvTacticalDominanceZone@@0V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@HH@Z ; stdext::_Unchecked_chunked_merge<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone>,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_chunked_merge@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@H@stdext@@YAXPAVCvTacticalDominanceZone@@0V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@HH@Z
_TEXT	SEGMENT
$T230854 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
$T230855 = 40						; size = 4
__Count$ = 40						; size = 4
??$_Unchecked_chunked_merge@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@H@stdext@@YAXPAVCvTacticalDominanceZone@@0V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@HH@Z PROC ; stdext::_Unchecked_chunked_merge<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone>,int>, COMDAT

; 5252 : 	{

	push	ecx

; 5253 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Count$[esp]
	mov	edx, DWORD PTR __Chunk$[esp]
	push	ebx
	xor	ebx, ebx
	mov	BYTE PTR $T230854[esp+8], bl
	mov	eax, DWORD PTR $T230854[esp+8]
	push	eax
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last$[esp+16]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+52]
	mov	DWORD PTR $T230855[esp+36], esp
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR __First$[esp+36]
	push	edx
	push	eax
	call	??$_Chunked_merge@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@H@std@@YAXPAVCvTacticalDominanceZone@@0V?$_Temp_iterator@VCvTacticalDominanceZone@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone>,int>

; 5254 : 	}

	mov	eax, DWORD PTR __Dest$[esp+44]
	add	esp, 40					; 00000028H
	cmp	eax, ebx
	je	SHORT $LN17@Unchecked_
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@Unchecked_:
	pop	ebx
	pop	ecx
	ret	0
??$_Unchecked_chunked_merge@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@H@stdext@@YAXPAVCvTacticalDominanceZone@@0V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@HH@Z ENDP ; stdext::_Unchecked_chunked_merge<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone>,int>
_TEXT	ENDS
PUBLIC	??$_Buffered_merge_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0HAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z ; std::_Buffered_merge_sort<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Buffered_merge_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0HAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z
_TEXT	SEGMENT
$T231002 = -8						; size = 1
$T230973 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
$T230972 = 16						; size = 1
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
??$_Buffered_merge_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0HAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z PROC ; std::_Buffered_merge_sort<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>, COMDAT

; 3356 : 	_BidIt _Mid = _First;

	mov	eax, DWORD PTR __First$[esp-4]
	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi

; 3357 : 	for (_Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX)

	mov	edi, DWORD PTR __Count$[esp+20]
	xor	ebx, ebx
	cmp	edi, 32					; 00000020H
	jl	SHORT $LN4@Buffered_m@2
	mov	ebp, edi
	shr	ebp, 5
	npad	5
$LL6@Buffered_m@2:

; 3358 : 		{	// sort chunks
; 3359 : 		_BidIt _Midend = _Mid;
; 3360 : 		std::advance(_Midend, (int)_ISORT_MAX);

	lea	esi, DWORD PTR [eax+2432]

; 3361 : 
; 3362 : 		std::_Insertion_sort(_Mid, _Midend);

	push	ebx
	push	esi
	push	eax
	call	??$_Insertion_sort1@PAVCvTacticalDominanceZone@@V1@@std@@YAXPAVCvTacticalDominanceZone@@00@Z ; std::_Insertion_sort1<CvTacticalDominanceZone *,CvTacticalDominanceZone>
	add	esp, 12					; 0000000cH
	sub	ebp, 1

; 3363 : 		_Mid = _Midend;

	mov	eax, esi
	jne	SHORT $LL6@Buffered_m@2
$LN4@Buffered_m@2:

; 3364 : 		}
; 3365 : 	std::_Insertion_sort(_Mid, _Last);	// sort partial last chunk

	mov	ecx, DWORD PTR __Last$[esp+20]
	push	ebx
	push	ecx
	push	eax
	call	??$_Insertion_sort1@PAVCvTacticalDominanceZone@@V1@@std@@YAXPAVCvTacticalDominanceZone@@00@Z ; std::_Insertion_sort1<CvTacticalDominanceZone *,CvTacticalDominanceZone>

; 3366 : 
; 3367 : 	for (_Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2)

	mov	esi, 32					; 00000020H
	add	esp, 12					; 0000000cH
	cmp	edi, esi
	jle	SHORT $LN1@Buffered_m@2
	mov	ebp, DWORD PTR __Tempbuf$[esp+20]
$LL3@Buffered_m@2:

; 3368 : 		{	// merge adjacent pairs of chunks to and from temp buffer
; 3369 : 		_STDEXT _Unchecked_chunked_merge(_First, _Last, _Tempbuf._Init(),
; 3370 : 			_Chunk, _Count);

	mov	eax, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR __First$[esp+20]
	mov	BYTE PTR $T230972[esp+20], bl
	mov	eax, DWORD PTR $T230972[esp+20]
	push	eax
	push	edi
	push	esi
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax+16], ecx
	mov	ecx, DWORD PTR __Last$[esp+52]
	mov	DWORD PTR $T230973[esp+56], esp
	push	ecx
	push	edx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	call	??$_Chunked_merge@PAVCvTacticalDominanceZone@@V?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@H@std@@YAXPAVCvTacticalDominanceZone@@0V?$_Temp_iterator@VCvTacticalDominanceZone@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvTacticalDominanceZone *,std::_Temp_iterator<CvTacticalDominanceZone>,int>

; 3371 : 		_STDEXT _Unchecked_chunked_merge(_Tempbuf._First(), _Tempbuf._Last(), _First,
; 3372 : 			_Chunk *= 2, _Count);

	mov	eax, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR __First$[esp+60]
	mov	BYTE PTR $T231002[esp+64], bl
	mov	ecx, DWORD PTR $T231002[esp+64]
	push	ecx
	mov	ecx, DWORD PTR [eax+4]
	push	edi
	add	esi, esi
	push	esi
	push	edx
	mov	edx, DWORD PTR [eax]
	push	ecx
	push	edx
	call	??$_Chunked_merge@PAVCvTacticalDominanceZone@@PAV1@H@std@@YAXPAVCvTacticalDominanceZone@@00HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvTacticalDominanceZone *,CvTacticalDominanceZone *,int>
	add	esi, esi
	add	esp, 64					; 00000040H
	cmp	esi, edi
	jl	SHORT $LL3@Buffered_m@2
$LN1@Buffered_m@2:

; 3373 : 		}
; 3374 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	0
??$_Buffered_merge_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0HAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z ENDP ; std::_Buffered_merge_sort<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>
_TEXT	ENDS
PUBLIC	??$_Stable_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0HAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z ; std::_Stable_sort<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Stable_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0HAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
??$_Stable_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0HAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z PROC ; std::_Stable_sort<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>, COMDAT

; 3381 : 	{	//  sort preserving order of equivalents, using operator<

	push	ebx

; 3382 : 	if (_Count <= _ISORT_MAX)

	mov	ebx, DWORD PTR __Count$[esp]
	cmp	ebx, 32					; 00000020H
	jg	SHORT $LN4@Stable_sor

; 3383 : 		std::_Insertion_sort(_First, _Last);	// small

	mov	eax, DWORD PTR __Last$[esp]
	mov	ecx, DWORD PTR __First$[esp]
	push	0
	push	eax
	push	ecx
	call	??$_Insertion_sort1@PAVCvTacticalDominanceZone@@V1@@std@@YAXPAVCvTacticalDominanceZone@@00@Z ; std::_Insertion_sort1<CvTacticalDominanceZone *,CvTacticalDominanceZone>
	add	esp, 12					; 0000000cH
	pop	ebx

; 3403 : 		}
; 3404 : 	}

	ret	0
$LN4@Stable_sor:

; 3384 : 	else
; 3385 : 		{	// sort halves and merge
; 3386 : 		_Diff _Count2 = (_Count + 1) / 2;

	lea	eax, DWORD PTR [ebx+1]
	push	ebp

; 3387 : 		_BidIt _Mid = _First;
; 3388 : 		std::advance(_Mid, _Count2);
; 3389 : 
; 3390 : 		if (_Count2 <= _Tempbuf._Maxlen())

	mov	ebp, DWORD PTR __Tempbuf$[esp+4]
	cdq
	push	esi
	sub	eax, edx
	mov	esi, eax
	push	edi
	sar	esi, 1
	mov	edi, esi
	imul	edi, 76					; 0000004cH
	add	edi, DWORD PTR __First$[esp+12]
	mov	ecx, ebp
	call	?_Maxlen@?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAEHXZ ; std::_Temp_iterator<CvTacticalDominanceZone>::_Maxlen
	cmp	esi, eax

; 3391 : 			{	// temp buffer big enough, sort each half using buffer
; 3392 : 			_Buffered_merge_sort(_First, _Mid, _Count2, _Tempbuf);

	push	ebp
	push	esi
	push	edi
	jg	SHORT $LN2@Stable_sor
	mov	edx, DWORD PTR __First$[esp+24]
	push	edx
	call	??$_Buffered_merge_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0HAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z ; std::_Buffered_merge_sort<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>

; 3393 : 			_Buffered_merge_sort(_Mid, _Last, _Count - _Count2, _Tempbuf);

	mov	eax, DWORD PTR __Last$[esp+28]
	push	ebp
	sub	ebx, esi
	push	ebx
	push	eax
	push	edi
	call	??$_Buffered_merge_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0HAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z ; std::_Buffered_merge_sort<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>

; 3394 : 			}
; 3395 : 		else

	jmp	SHORT $LN17@Stable_sor
$LN2@Stable_sor:

; 3396 : 			{	// temp buffer not big enough, divide and conquer
; 3397 : 			_Stable_sort(_First, _Mid, _Count2, _Tempbuf);

	mov	ecx, DWORD PTR __First$[esp+24]
	push	ecx
	call	??$_Stable_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0HAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z ; std::_Stable_sort<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>

; 3398 : 			_Stable_sort(_Mid, _Last, _Count - _Count2, _Tempbuf);

	mov	edx, DWORD PTR __Last$[esp+28]
	push	ebp
	sub	ebx, esi
	push	ebx
	push	edx
	push	edi
	call	??$_Stable_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0HAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z ; std::_Stable_sort<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>
$LN17@Stable_sor:

; 3399 : 			}
; 3400 : 
; 3401 : 		_Buffered_merge(_First, _Mid, _Last,
; 3402 : 			_Count2, _Count - _Count2, _Tempbuf);	// merge sorted halves

	mov	eax, DWORD PTR __Last$[esp+44]
	mov	ecx, DWORD PTR __First$[esp+44]
	add	esp, 32					; 00000020H
	push	ebp
	push	ebx
	push	esi
	push	eax
	push	edi
	push	ecx
	call	??$_Buffered_merge@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@00HHAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z ; std::_Buffered_merge<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3403 : 		}
; 3404 : 	}

	ret	0
??$_Stable_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0HAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z ENDP ; std::_Stable_sort<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>
_TEXT	ENDS
PUBLIC	??$_Stable_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0PAH0@Z ; std::_Stable_sort<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Stable_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0PAH0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Stable_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0PAH0@Z$0
__ehfuncinfo$??$_Stable_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0PAH0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Stable_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0PAH0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Stable_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0PAH0@Z
_TEXT	SEGMENT
__Tempbuf$ = -32					; size = 20
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Stable_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0PAH0@Z PROC ; std::_Stable_sort<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>, COMDAT

; 3410 : 	{	// sort preserving order of equivalents, using operator<

	push	-1
	push	__ehhandler$??$_Stable_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0PAH0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi

; 3411 : 	_Diff _Count = 0;
; 3412 : 	_Distance(_First, _Last, _Count);

	mov	esi, DWORD PTR __Last$[esp+36]
	push	edi
	mov	edi, DWORD PTR __First$[esp+40]
	mov	ecx, esi
	sub	ecx, edi
	mov	eax, 1808407283				; 6bca1af3H
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 3413 : 	_Temp_iterator<_Ty> _Tempbuf((_Count + 1) / 2);

	lea	eax, DWORD PTR [ecx+1]
	cdq
	sub	eax, edx
	sar	eax, 1
	xor	ebx, ebx
	mov	DWORD PTR __Tempbuf$[esp+56], eax
	lea	eax, DWORD PTR __Tempbuf$[esp+44]
	mov	DWORD PTR __Tempbuf$[esp+44], ebx
	mov	DWORD PTR __Tempbuf$[esp+48], ebx
	mov	DWORD PTR __Tempbuf$[esp+52], ebx
	mov	DWORD PTR __Tempbuf$[esp+60], eax

; 3414 : 	_Stable_sort(_First, _Last, _Count, _Tempbuf);

	mov	edx, eax
	push	edx
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[esp+68], ebx
	call	??$_Stable_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0HAAV?$_Temp_iterator@VCvTacticalDominanceZone@@@0@@Z ; std::_Stable_sort<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>

; 3415 : 	}

	mov	eax, DWORD PTR __Tempbuf$[esp+60]
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	cmp	eax, ebx
	pop	ebx
	je	SHORT $LN20@Stable_sor@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN20@Stable_sor@2:
	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	add	esp, 32					; 00000020H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Stable_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0PAH0@Z$0:
	lea	ecx, DWORD PTR __Tempbuf$[ebp]
	jmp	??1?$_Temp_iterator@VCvTacticalDominanceZone@@@std@@QAE@XZ ; std::_Temp_iterator<CvTacticalDominanceZone>::~_Temp_iterator<CvTacticalDominanceZone>
__ehhandler$??$_Stable_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0PAH0@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Stable_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0PAH0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Stable_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0PAH0@Z ENDP ; std::_Stable_sort<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>
PUBLIC	??$stable_sort@PAVCvTacticalDominanceZone@@@std@@YAXPAVCvTacticalDominanceZone@@0@Z ; std::stable_sort<CvTacticalDominanceZone *>
; Function compile flags: /Ogtpy
;	COMDAT ??$stable_sort@PAVCvTacticalDominanceZone@@@std@@YAXPAVCvTacticalDominanceZone@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$stable_sort@PAVCvTacticalDominanceZone@@@std@@YAXPAVCvTacticalDominanceZone@@0@Z PROC ; std::stable_sort<CvTacticalDominanceZone *>, COMDAT

; 3420 : 	_DEBUG_RANGE(_First, _Last);
; 3421 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@stable_sor

; 3422 : 		{
; 3423 : 		_Stable_sort(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dist_type(_First), _Val_type(_First));

	push	0
	push	0
	push	ecx
	push	eax
	call	??$_Stable_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0PAH0@Z ; std::_Stable_sort<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>
	add	esp, 16					; 00000010H
$LN1@stable_sor:

; 3424 : 		}
; 3425 : 	}

	ret	0
??$stable_sort@PAVCvTacticalDominanceZone@@@std@@YAXPAVCvTacticalDominanceZone@@0@Z ENDP ; std::stable_sort<CvTacticalDominanceZone *>
_TEXT	ENDS
PUBLIC	?PrioritizeZones@CvTacticalAnalysisMap@@IAEXXZ	; CvTacticalAnalysisMap::PrioritizeZones
EXTRN	?GetStateAllWars@CvDiplomacyAI@@QBE?AW4StateAllWars@@XZ:PROC ; CvDiplomacyAI::GetStateAllWars
EXTRN	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ:PROC ; CvPlayer::GetDiplomacyAI
EXTRN	?isVisible@CvCity@@QBE_NW4TeamTypes@@_N@Z:PROC	; CvCity::isVisible
EXTRN	?isMinorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMinorCiv
EXTRN	?GetPlayer@CvCity@@QAEPAVCvPlayer@@XZ:PROC	; CvCity::GetPlayer
EXTRN	?isCapital@CvCity@@QBE_NXZ:PROC			; CvCity::isCapital
EXTRN	?getPopulation@CvCity@@QBEHXZ:PROC		; CvCity::getPopulation
EXTRN	__ftol2_sse_excpt:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtacticalanalysismap.cpp
;	COMDAT ?PrioritizeZones@CvTacticalAnalysisMap@@IAEXXZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
tv546 = -20						; size = 4
_iI$222769 = -16					; size = 4
tv503 = -12						; size = 4
tv498 = -12						; size = 4
$T231139 = -12						; size = 4
$T231144 = -12						; size = 4
$T231145 = -8						; size = 4
_eDominance$222773 = -4					; size = 4
?PrioritizeZones@CvTacticalAnalysisMap@@IAEXXZ PROC	; CvTacticalAnalysisMap::PrioritizeZones, COMDAT
; _this$ = ecx

; 945  : {

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	sub	esp, 48					; 00000030H
	push	ebx
	push	ebp
	mov	ebx, ecx

; 946  : 	// Loop through the dominance zones
; 947  : 	CvTacticalDominanceZone* pZone;
; 948  : 	int iBaseValue;
; 949  : 	int iMultiplier;
; 950  : 	CvCity* pClosestCity = NULL;
; 951  : 
; 952  : 	for(unsigned int iI = 0; iI < m_DominanceZones.size(); iI++)

	xor	eax, eax
	push	esi
	push	edi
	mov	DWORD PTR _this$[esp+64], ebx
	mov	DWORD PTR _iI$222769[esp+64], eax
	cmp	DWORD PTR [ebx+116], eax
	jbe	$LN31@Prioritize
	mov	DWORD PTR tv546[esp+64], eax
$LN33@Prioritize:

; 953  : 	{
; 954  : 		// Find the zone and compute dominance here
; 955  : 		pZone = &m_DominanceZones[iI];

	mov	esi, DWORD PTR [ebx+112]
	add	esi, DWORD PTR tv546[esp+64]

; 956  : 		eTacticalDominanceFlags eDominance = ComputeDominance(pZone);

	mov	ecx, ebx
	push	esi
	call	?ComputeDominance@CvTacticalAnalysisMap@@IAE?AW4eTacticalDominanceFlags@@PAVCvTacticalDominanceZone@@@Z ; CvTacticalAnalysisMap::ComputeDominance

; 957  : 
; 958  : 		// Establish a base value for the region
; 959  : 		iBaseValue = 1;
; 960  : 
; 961  : 		// Temporary zone?
; 962  : 		if(pZone->GetTerritoryType() == TACTICAL_TERRITORY_TEMP_ZONE)

	cmp	DWORD PTR [esi+4], 5
	mov	DWORD PTR _eDominance$222773[esp+64], eax
	mov	ebp, 1
	jne	SHORT $LN30@Prioritize

; 963  : 		{
; 964  : 			iMultiplier = 1000;

	mov	edi, 1000				; 000003e8H

; 965  : 		}
; 966  : 		else

	jmp	$LN2@Prioritize
$LN30@Prioritize:

; 967  : 		{
; 968  : 			pClosestCity = pZone->GetClosestCity();

	mov	eax, DWORD PTR [esi+12]
	cmp	eax, -1
	je	$LN23@Prioritize
	mov	ecx, DWORD PTR [esi+16]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	ebx, eax

; 969  : 
; 970  : 			if(pClosestCity)

	test	ebx, ebx
	je	$LN103@Prioritize

; 971  : 			{
; 972  : 				iBaseValue += (1 + (int)sqrt((float)pZone->GetClosestCity()->getPopulation()));

	mov	eax, DWORD PTR [esi+12]
	cmp	eax, -1
	je	SHORT $LN47@Prioritize
	mov	edx, DWORD PTR [esi+16]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	jmp	SHORT $LN48@Prioritize
$LN47@Prioritize:
	xor	eax, eax
$LN48@Prioritize:
	mov	ecx, eax
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	mov	DWORD PTR tv503[esp+64], eax
	fild	DWORD PTR tv503[esp+64]
	sub	esp, 8
	fstp	DWORD PTR $T231144[esp+72]
	fld	DWORD PTR $T231144[esp+72]
	fstp	QWORD PTR [esp]
	call	_sqrt
	fstp	DWORD PTR tv498[esp+72]
	add	esp, 8
	fld	DWORD PTR tv498[esp+64]
	fstp	DWORD PTR $T231139[esp+64]
	mov	eax, DWORD PTR $T231139[esp+64]
	mov	DWORD PTR $T231145[esp+64], eax
	fld	DWORD PTR $T231145[esp+64]
	call	__ftol2_sse_excpt
	mov	ebp, eax

; 973  : 
; 974  : 				if(pClosestCity->isCapital() && !pClosestCity->GetPlayer()->isMinorCiv())

	mov	ecx, ebx
	add	ebp, 2
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	test	al, al
	je	SHORT $LN27@Prioritize
	mov	ecx, ebx
	call	?GetPlayer@CvCity@@QAEPAVCvPlayer@@XZ	; CvCity::GetPlayer
	mov	ecx, eax
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN27@Prioritize

; 975  : 				{
; 976  : 					iBaseValue *= 2;

	add	ebp, ebp
$LN27@Prioritize:

; 977  : 				}
; 978  : 
; 979  : 				if(m_pPlayer->GetTacticalAI()->IsTemporaryZoneCity(pClosestCity))

	mov	edi, DWORD PTR _this$[esp+64]
	mov	ecx, DWORD PTR [edi+20]
	push	ebx
	call	?GetTacticalAI@CvPlayer@@QBEPAVCvTacticalAI@@XZ ; CvPlayer::GetTacticalAI
	mov	ecx, eax
	call	?IsTemporaryZoneCity@CvTacticalAI@@QAE_NPAVCvCity@@@Z ; CvTacticalAI::IsTemporaryZoneCity
	test	al, al
	je	SHORT $LN26@Prioritize

; 980  : 				{
; 981  : 					iBaseValue *= 20;

	lea	ebp, DWORD PTR [ebp+ebp*4]
	add	ebp, ebp
	add	ebp, ebp
	mov	ebx, edi
	jmp	$LN23@Prioritize
$LN26@Prioritize:

; 982  : 				}
; 983  : 
; 984  : 				else if (pZone->GetClosestCity()->isVisible(m_pPlayer->getTeam(), false))

	mov	ecx, DWORD PTR [edi+20]
	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN60@Prioritize
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	edi, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN61@Prioritize
$LN60@Prioritize:
	or	edi, -1
$LN61@Prioritize:
	mov	eax, DWORD PTR [esi+12]
	cmp	eax, -1
	je	SHORT $LN65@Prioritize
	mov	edx, DWORD PTR [esi+16]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	jmp	SHORT $LN66@Prioritize
$LN65@Prioritize:
	xor	eax, eax
$LN66@Prioritize:
	push	0
	push	edi
	mov	ecx, eax
	call	?isVisible@CvCity@@QBE_NW4TeamTypes@@_N@Z ; CvCity::isVisible
	test	al, al
	je	SHORT $LN103@Prioritize

; 985  : 				{
; 986  : 					iBaseValue *= 4;

	add	ebp, ebp

; 987  : 
; 988  : 					// How damaged is this visible city?
; 989  : 					int iMaxDamageMultiplier = 10;
; 990  : 					int iDamage = pClosestCity->getDamage();

	mov	ecx, ebx
	add	ebp, ebp
	call	?getDamage@CvCity@@QBEHXZ		; CvCity::getDamage

; 991  : 					if (iDamage > (pClosestCity->GetMaxHitPoints() / iMaxDamageMultiplier))

	mov	ecx, ebx
	mov	edi, eax
	call	?GetMaxHitPoints@CvCity@@QBEHXZ		; CvCity::GetMaxHitPoints
	mov	ecx, eax
	mov	eax, 1717986919				; 66666667H
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	edi, eax
	jle	SHORT $LN103@Prioritize

; 992  : 					{
; 993  : 						iBaseValue *= (int)((iDamage + 1) * 10 / pClosestCity->GetMaxHitPoints());

	mov	ecx, ebx
	call	?GetMaxHitPoints@CvCity@@QBEHXZ		; CvCity::GetMaxHitPoints
	mov	ecx, eax
	lea	eax, DWORD PTR [edi+edi*4+5]
	add	eax, eax
	cdq
	idiv	ecx
	imul	ebp, eax
$LN103@Prioritize:
	mov	ebx, DWORD PTR _this$[esp+64]
$LN23@Prioritize:

; 994  : 					}
; 995  : 				}
; 996  : 			}
; 997  : 
; 998  : 			if(!pZone->IsWater())

	cmp	BYTE PTR [esi+68], 0
	jne	SHORT $LN22@Prioritize

; 999  : 			{
; 1000 : 				iBaseValue *= 3;

	lea	ebp, DWORD PTR [ebp+ebp*2]
$LN22@Prioritize:

; 1001 : 			}
; 1002 : 
; 1003 : 			// Now compute a multiplier based on current conditions here
; 1004 : 			iMultiplier = 1;
; 1005 : 			if(eDominance == TACTICAL_DOMINANCE_ENEMY)

	mov	eax, DWORD PTR _eDominance$222773[esp+64]
	mov	edi, 1
	cmp	eax, 2
	jne	SHORT $LN21@Prioritize

; 1006 : 			{
; 1007 : 				if(pZone->GetTerritoryType() == TACTICAL_TERRITORY_ENEMY)

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 3
	jne	SHORT $LN20@Prioritize

; 1008 : 				{
; 1009 : 					iMultiplier = 2;

	lea	edi, DWORD PTR [eax-1]
	jmp	SHORT $LN8@Prioritize
$LN20@Prioritize:

; 1010 : 				}
; 1011 : 				else if(pZone->GetTerritoryType() == TACTICAL_TERRITORY_FRIENDLY)

	cmp	eax, 2
	jne	SHORT $LN8@Prioritize

; 1012 : 				{
; 1013 : 					iMultiplier = 6;

	lea	edi, DWORD PTR [eax+4]

; 1014 : 				}
; 1015 : 			}

	jmp	SHORT $LN8@Prioritize
$LN21@Prioritize:

; 1016 : 			else if(eDominance == TACTICAL_DOMINANCE_EVEN)

	cmp	eax, 3
	jne	SHORT $LN16@Prioritize

; 1017 : 			{
; 1018 : 				if(pZone->GetTerritoryType() == TACTICAL_TERRITORY_ENEMY)

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 3

; 1019 : 				{
; 1020 : 					iMultiplier = 4;

	je	SHORT $LN107@Prioritize

; 1021 : 				}
; 1022 : 				else if(pZone->GetTerritoryType() == TACTICAL_TERRITORY_FRIENDLY)

	cmp	eax, 2
	jne	SHORT $LN8@Prioritize
$LN107@Prioritize:

; 1019 : 				{
; 1020 : 					iMultiplier = 4;

	mov	edi, 4
$LN8@Prioritize:

; 1032 : 				}
; 1033 : 				else if(pZone->GetTerritoryType() == TACTICAL_TERRITORY_FRIENDLY)
; 1034 : 				{
; 1035 : 					iMultiplier = 1;
; 1036 : 				}
; 1037 : 			}
; 1038 : 			if(!m_pPlayer->isMinorCiv())

	mov	ecx, DWORD PTR [ebx+20]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN2@Prioritize

; 1039 : 			{
; 1040 : 				if(m_pPlayer->GetDiplomacyAI()->GetStateAllWars() == STATE_ALL_WARS_WINNING)

	mov	ecx, DWORD PTR [ebx+20]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetStateAllWars@CvDiplomacyAI@@QBE?AW4StateAllWars@@XZ ; CvDiplomacyAI::GetStateAllWars
	cmp	eax, 1
	jne	SHORT $LN6@Prioritize

; 1041 : 				{
; 1042 : 					if(pZone->GetTerritoryType() == TACTICAL_TERRITORY_ENEMY)

	cmp	DWORD PTR [esi+4], 3
	jne	SHORT $LN2@Prioritize

; 1043 : 					{
; 1044 : 						iMultiplier *= 2;
; 1045 : 					}
; 1046 : 				}

	jmp	SHORT $LN108@Prioritize
$LN16@Prioritize:

; 1023 : 				{
; 1024 : 					iMultiplier = 4;
; 1025 : 				}
; 1026 : 			}
; 1027 : 			else if(eDominance == TACTICAL_DOMINANCE_FRIENDLY)

	cmp	eax, 1
	jne	SHORT $LN8@Prioritize

; 1028 : 			{
; 1029 : 				if(pZone->GetTerritoryType() == TACTICAL_TERRITORY_ENEMY)

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 3
	jne	SHORT $LN8@Prioritize

; 1030 : 				{
; 1031 : 					iMultiplier = 8;

	lea	edi, DWORD PTR [eax+5]
	jmp	SHORT $LN8@Prioritize
$LN6@Prioritize:

; 1047 : 				else if(m_pPlayer->GetDiplomacyAI()->GetStateAllWars() == STATE_ALL_WARS_LOSING)

	mov	ecx, DWORD PTR [ebx+20]
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetStateAllWars@CvDiplomacyAI@@QBE?AW4StateAllWars@@XZ ; CvDiplomacyAI::GetStateAllWars
	cmp	eax, 2
	jne	SHORT $LN2@Prioritize

; 1048 : 				{
; 1049 : 					if(pZone->GetTerritoryType() == TACTICAL_TERRITORY_FRIENDLY)

	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN2@Prioritize

; 1050 : 					{
; 1051 : 						iMultiplier *= 4;

	add	edi, edi
$LN108@Prioritize:
	add	edi, edi
$LN2@Prioritize:

; 946  : 	// Loop through the dominance zones
; 947  : 	CvTacticalDominanceZone* pZone;
; 948  : 	int iBaseValue;
; 949  : 	int iMultiplier;
; 950  : 	CvCity* pClosestCity = NULL;
; 951  : 
; 952  : 	for(unsigned int iI = 0; iI < m_DominanceZones.size(); iI++)

	mov	eax, DWORD PTR _iI$222769[esp+64]

; 1052 : 					}
; 1053 : 				}
; 1054 : 			}
; 1055 : 		}
; 1056 : 
; 1057 : 		// Save off the value for this zone
; 1058 : 		if((iBaseValue * iMultiplier) <= 0)
; 1059 : 		{
; 1060 : 			FAssertMsg((iBaseValue * iMultiplier) > 0, "Invalid Dominance Zone Value");
; 1061 : 		}
; 1062 : 		pZone->SetDominanceZoneValue(iBaseValue * iMultiplier);

	imul	edi, ebp
	add	DWORD PTR tv546[esp+64], 76		; 0000004cH
	inc	eax
	mov	DWORD PTR [esi+60], edi
	mov	DWORD PTR _iI$222769[esp+64], eax
	cmp	eax, DWORD PTR [ebx+116]
	jb	$LN33@Prioritize
$LN31@Prioritize:

; 1063 : 	}
; 1064 : 
; 1065 : 	std::stable_sort(m_DominanceZones.begin(), m_DominanceZones.end());

	mov	eax, DWORD PTR [ebx+116]
	mov	ecx, DWORD PTR [ebx+112]
	imul	eax, 76					; 0000004cH
	add	eax, ecx
	cmp	ecx, eax
	je	SHORT $LN94@Prioritize
	push	0
	push	0
	push	eax
	push	ecx
	call	??$_Stable_sort@PAVCvTacticalDominanceZone@@HV1@@std@@YAXPAVCvTacticalDominanceZone@@0PAH0@Z ; std::_Stable_sort<CvTacticalDominanceZone *,int,CvTacticalDominanceZone>
	add	esp, 16					; 00000010H
$LN94@Prioritize:

; 1066 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?PrioritizeZones@CvTacticalAnalysisMap@@IAEXXZ ENDP	; CvTacticalAnalysisMap::PrioritizeZones
_TEXT	ENDS
PUBLIC	?RefreshDataForNextPlayer@CvTacticalAnalysisMap@@QAEXPAVCvPlayer@@@Z ; CvTacticalAnalysisMap::RefreshDataForNextPlayer
EXTRN	?isBarbarian@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isBarbarian
EXTRN	?getCurrentEra@CvGame@@QBE?AW4EraTypes@@XZ:PROC	; CvGame::getCurrentEra
EXTRN	?getGameTurn@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurn
; Function compile flags: /Ogtpy
;	COMDAT ?RefreshDataForNextPlayer@CvTacticalAnalysisMap@@QAEXPAVCvPlayer@@@Z
_TEXT	SEGMENT
tv328 = 8						; size = 4
_pPlayer$ = 8						; size = 4
?RefreshDataForNextPlayer@CvTacticalAnalysisMap@@QAEXPAVCvPlayer@@@Z PROC ; CvTacticalAnalysisMap::RefreshDataForNextPlayer, COMDAT
; _this$ = ecx

; 220  : {

	push	ebx
	push	esi
	mov	esi, ecx

; 221  : 	if(m_pPlots)

	xor	ebx, ebx
	cmp	DWORD PTR [esi+12], ebx
	je	$LN7@RefreshDat
	push	edi

; 222  : 	{
; 223  : 		if(pPlayer != m_pPlayer || m_iTurnBuilt < GC.getGame().getGameTurn())

	mov	edi, DWORD PTR _pPlayer$[esp+8]
	cmp	edi, DWORD PTR [esi+20]
	jne	SHORT $LN8@RefreshDat
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	cmp	DWORD PTR [esi+24], eax
	jge	$LN46@RefreshDat
$LN8@RefreshDat:

; 224  : 		{
; 225  : 			m_pPlayer = pPlayer;

	mov	DWORD PTR [esi+20], edi

; 226  : 			m_iTurnBuilt = GC.getGame().getGameTurn();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	DWORD PTR [esi+24], eax

; 227  : 			m_iTacticalRange = ((GC.getAI_TACTICAL_RECRUIT_RANGE() + GC.getGame().getCurrentEra()) * 2) / 3;  // Have this increase as game goes on

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2460
	call	?getCurrentEra@CvGame@@QBE?AW4EraTypes@@XZ ; CvGame::getCurrentEra
	mov	ecx, eax
	add	ecx, edi
	add	ecx, ecx
	mov	eax, 1431655766				; 55555556H
	imul	ecx

; 228  : 			m_iUnitStrengthMultiplier = GC.getAI_TACTICAL_MAP_UNIT_STRENGTH_MULTIPLIER() * m_iTacticalRange;
; 229  : 
; 230  : #ifdef AUI_PERF_LOGGING_FORMATTING_TWEAKS
; 231  : 			AI_PERF_FORMAT("AI-perf.csv", ("Tactical Analysis Map, Turn %03d, %s", GC.getGame().getGameTurn(), m_pPlayer->getCivilizationShortDescription()));
; 232  : #else
; 233  : 			AI_PERF_FORMAT("AI-perf.csv", ("Tactical Analysis Map, Turn %d, %s", GC.getGame().getGameTurn(), m_pPlayer->getCivilizationShortDescription()) );
; 234  : #endif
; 235  : 
; 236  : 			m_bIsBuilt = false;
; 237  : 
; 238  : 			// AI civs build this map every turn
; 239  : 			//if (!m_pPlayer->isHuman() && !m_pPlayer->isBarbarian())
; 240  : 			if(!m_pPlayer->isBarbarian())

	mov	ecx, DWORD PTR [esi+20]
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR [esi+8], eax
	imul	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2440
	mov	DWORD PTR [esi+4], eax
	mov	BYTE PTR [esi+34], bl
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	test	al, al
	jne	$LN46@RefreshDat

; 241  : 			{
; 242  : 				m_DominanceZones.clear();
; 243  : 
; 244  : 				AddTemporaryZones();

	mov	ecx, esi
	mov	DWORD PTR [esi+116], ebx
	call	?AddTemporaryZones@CvTacticalAnalysisMap@@IAEXXZ ; CvTacticalAnalysisMap::AddTemporaryZones

; 245  : 
; 246  : #ifdef AUI_WARNING_FIXES
; 247  : 				for (uint iI = 0; iI < GC.getMap().numPlots(); iI++)
; 248  : #else
; 249  : 				for(int iI = 0; iI < GC.getMap().numPlots(); iI++)

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	xor	edi, edi
	cmp	DWORD PTR [eax+4028], ebx
	jle	SHORT $LN4@RefreshDat
	push	ebp
	xor	ebp, ebp
	mov	DWORD PTR tv328[esp+12], ebx
$LL6@RefreshDat:

; 250  : #endif
; 251  : 				{
; 252  : 					CvAssertMsg((iI < m_iNumPlots), "Plot to be accessed exceeds allocation!");
; 253  : 
; 254  : 					CvPlot* pPlot = GC.getMap().plotByIndexUnchecked(iI);

	mov	eax, DWORD PTR [eax+4068]
	add	eax, DWORD PTR tv328[esp+12]

; 255  : 					if(pPlot == NULL)

	jne	SHORT $LN3@RefreshDat

; 256  : 					{
; 257  : 						// Erase this cell
; 258  : 						m_pPlots[iI].Clear();

	mov	eax, DWORD PTR [esi+12]
	add	eax, ebp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	DWORD PTR [eax+16], ebx
	mov	DWORD PTR [eax+20], ebx
	mov	DWORD PTR [eax+24], ebx
	mov	DWORD PTR [eax+28], ebx
	mov	DWORD PTR [eax+32], ebx
	mov	DWORD PTR [eax+36], ebx
	mov	DWORD PTR [eax+40], -1

; 259  : 					}
; 260  : 					else

	jmp	SHORT $LN5@RefreshDat
$LN3@RefreshDat:

; 261  : 					{
; 262  : 						if(PopulateCell(iI, pPlot))

	push	eax
	push	edi
	mov	ecx, esi
	call	?PopulateCell@CvTacticalAnalysisMap@@IAE_NHPAVCvPlot@@@Z ; CvTacticalAnalysisMap::PopulateCell
	test	al, al
	je	SHORT $LN5@RefreshDat

; 263  : 						{
; 264  : 							AddToDominanceZones(iI, &m_pPlots[iI]);

	mov	eax, DWORD PTR [esi+12]
	add	eax, ebp
	push	eax
	push	edi
	mov	ecx, esi
	call	?AddToDominanceZones@CvTacticalAnalysisMap@@IAEXHPAVCvTacticalAnalysisCell@@@Z ; CvTacticalAnalysisMap::AddToDominanceZones
$LN5@RefreshDat:
	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	DWORD PTR tv328[esp+12], 484		; 000001e4H
	inc	edi
	add	ebp, 44					; 0000002cH
	cmp	edi, DWORD PTR [eax+4028]
	jl	SHORT $LL6@RefreshDat
	pop	ebp
$LN4@RefreshDat:

; 265  : 						}
; 266  : 					}
; 267  : 				}
; 268  : 
; 269  : 				CalculateMilitaryStrengths();

	mov	ecx, esi
	call	?CalculateMilitaryStrengths@CvTacticalAnalysisMap@@IAEXXZ ; CvTacticalAnalysisMap::CalculateMilitaryStrengths

; 270  : 				PrioritizeZones();

	mov	ecx, esi
	call	?PrioritizeZones@CvTacticalAnalysisMap@@IAEXXZ ; CvTacticalAnalysisMap::PrioritizeZones

; 271  : 				LogZones();

	mov	ecx, esi
	call	?LogZones@CvTacticalAnalysisMap@@IAEXXZ	; CvTacticalAnalysisMap::LogZones

; 272  : 				BuildEnemyUnitList();

	mov	ecx, esi
	call	?BuildEnemyUnitList@CvTacticalAnalysisMap@@IAEXXZ ; CvTacticalAnalysisMap::BuildEnemyUnitList

; 273  : 				MarkCellsNearEnemy();

	mov	ecx, esi
	call	?MarkCellsNearEnemy@CvTacticalAnalysisMap@@IAEXXZ ; CvTacticalAnalysisMap::MarkCellsNearEnemy

; 274  : 
; 275  : 				m_bIsBuilt = true;

	mov	BYTE PTR [esi+34], 1
$LN46@RefreshDat:
	pop	edi
$LN7@RefreshDat:
	pop	esi
	pop	ebx

; 276  : 			}
; 277  : 		}
; 278  : 	}
; 279  : }

	ret	4
?RefreshDataForNextPlayer@CvTacticalAnalysisMap@@QAEXPAVCvPlayer@@@Z ENDP ; CvTacticalAnalysisMap::RefreshDataForNextPlayer
_TEXT	ENDS
END
