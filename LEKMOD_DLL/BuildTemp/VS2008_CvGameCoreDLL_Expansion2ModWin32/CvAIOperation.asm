; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Documents\GitHub\Lekmod\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvAIOperation.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?NO_QUEST_DATA@CvMinorCivQuest@@2HB		; CvMinorCivQuest::NO_QUEST_DATA
PUBLIC	?NO_TURN@CvMinorCivQuest@@2HB			; CvMinorCivQuest::NO_TURN
CONST	SEGMENT
$SG224723 DB	'%03d, ', 00H
$SG224791 DB	00H
$SG224728 DB	', ', 00H
$SG224824 DB	00H
$SG224729 DB	', ', 00H
$SG224840 DB	00H
$SG224735 DB	'Started, Army: %d, Units Recruited: %d, Max Formation Si'
	DB	'ze: %d, ', 00H
	ORG $+3
$SG224742 DB	'Aborted', 00H
$SG224744 DB	'Recruiting Units', 00H
	ORG $+3
$SG224746 DB	'Gathering Forces', 00H
	ORG $+3
$SG224748 DB	'Moving To Target', 00H
	ORG $+3
$SG224750 DB	'At Target', 00H
	ORG $+2
$SG224752 DB	'Completed', 00H
	ORG $+2
$SG224760 DB	', ', 00H
	ORG $+1
$SG224764 DB	', vs. ', 00H
	ORG $+1
$SG224777 DB	'%03d, ', 00H
	ORG $+1
$SG224782 DB	', ', 00H
	ORG $+1
$SG224783 DB	', ', 00H
	ORG $+1
$SG224789 DB	'Aborted', 00H
$SG224797 DB	'Recruiting Units, Army: %d, Muster Turn: %d, SLOT DETAIL'
	DB	':, ', 00H
$SG224804 DB	'No Info, ', 00H
	ORG $+2
$SG224807 DB	'Skipping, ', 00H
	ORG $+1
$SG224810 DB	'Turn %d, ', 00H
	ORG $+2
$SG224812 DB	'Training - ', 00H
$SG224817 DB	'Gathering at (%d-%d), ', 00H
	ORG $+1
$SG224822 DB	'%s - Turn %d, ', 00H
	ORG $+1
$SG224830 DB	'Gathering Forces, Army: %d, Gather X: %d, Gather Y: %d, '
	DB	00H
	ORG $+3
$SG224838 DB	'%s at (%d-%d),', 00H
	ORG $+5
$SG224846 DB	'Moving To Target, Army: %d, At X: %d, At Y: %d, To X: %d'
	DB	', To Y: %d, ', 00H
	ORG $+3
$SG224854 DB	'%s at (%d-%d),', 00H
	ORG $+1
$SG224856 DB	'At Target', 00H
	ORG $+2
$SG224858 DB	'Completed', 00H
	ORG $+2
$SG224870 DB	'%03d, ', 00H
	ORG $+1
$SG224875 DB	', ', 00H
	ORG $+1
$SG224876 DB	', ', 00H
	ORG $+1
$SG224888 DB	'%03d, ', 00H
	ORG $+1
$SG224893 DB	', ', 00H
	ORG $+1
$SG224894 DB	', ', 00H
	ORG $+1
$SG224895 DB	'Ended, ', 00H
$SG224901 DB	'Success', 00H
$SG224903 DB	'No target', 00H
	ORG $+2
$SG224905 DB	'Repeat target', 00H
	ORG $+2
$SG224907 DB	'Lost target', 00H
$SG224909 DB	'Target already captured', 00H
$SG224911 DB	'No room to deploy', 00H
	ORG $+2
$SG224913 DB	'Half strength', 00H
	ORG $+2
$SG224915 DB	'No muster point', 00H
$SG224917 DB	'Lost civilian', 00H
	ORG $+2
$SG224919 DB	'Escort died', 00H
$SG224921 DB	'No nukes', 00H
	ORG $+3
$SG224923 DB	'Killed', 00H
	ORG $+1
$SG224925 DB	'War State Change', 00H
	ORG $+3
$SG224927 DB	'Diplo Opinion Change', 00H
	ORG $+3
$SG224929 DB	'Lost Path to Target', 00H
$SG224938 DB	', ', 00H
	ORG $+1
$SG224948 DB	'.csv', 00H
	ORG $+3
$SG224949 DB	'OperationalAILog_', 00H
	ORG $+2
$SG224951 DB	'OperationalAILog.csv', 00H
	ORG $+7
$SG225224 DB	'Could not recruit from primary units for muster at x=%d '
	DB	'y=%d, target of x=%d y=%d', 00H
	ORG $+6
$SG225255 DB	'Could not recruit from secondary units for muster at x=%'
	DB	'd y=%d, target of x=%d y=%d', 00H
	ORG $+4
$SG225341 DB	'No muster point found, Operation aborting, Target was, X'
	DB	': %d, Y: %d', 00H
$SG225508 DB	'Barbarian camp at (x=%d y=%d) no longer exists. Aborting'
	DB	00H
	ORG $+3
$SG225517 DB	'Civilian can no longer be rescued from barbarians. Abort'
	DB	'ing', 00H
$SG225523 DB	'Civilian can no longer be rescued from barbarians. Abort'
	DB	'ing', 00H
$SG225533 DB	'Barbarian camp stronger (%d) than our units (%d). Aborti'
	DB	'ng', 00H
	ORG $+5
$SG225785 DB	'Now at target but can no longer settle here. Target was '
	DB	'(X=%d Y=%d)', 00H
$SG225796 DB	'City founded, At X=%d, At Y=%d, %s, %d, %d', 00H
	ORG $+1
$SG225800 DB	'At target but can no longer settle here. Target was (X=%'
	DB	'd Y=%d)', 00H
$SG225921 DB	'Great Merchant buying city-state, At X=%d, At Y=%d', 00H
	ORG $+1
$SG225924 DB	'Great Merchant finishing trade mission, At X=%d, At Y=%d'
	DB	00H
	ORG $+3
$SG225929 DB	'At target but can no longer trade here. Target was (X=%d'
	DB	' Y=%d)', 00H
	ORG $+1
$SG225982 DB	'Great Musician performing concert tour, At X=%d, At Y=%d'
	DB	00H
	ORG $+7
$SG225987 DB	'At target but can no longer hold concert here. Target wa'
	DB	's (X=%d Y=%d)', 00H
	ORG $+2
$SG226060 DB	'No muster point found, Naval operation aborting, Target '
	DB	'was, X: %d, Y: %d', 00H
	ORG $+6
$SG226832 DB	'Not at target but can no longer settle here. Target was '
	DB	'(X=%d Y=%d)', 00H
$SG226837 DB	'City founded, At X=%d, At Y=%d', 00H
	ORG $+5
$SG226841 DB	'At target but can no longer settle here. Target was (X=%'
	DB	'd Y=%d)', 00H
$SG226995 DB	'City nuked, At X=%d, At Y=%d', 00H
CONST	ENDS
;	COMDAT ?NO_TURN@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_TURN@CvMinorCivQuest@@2HB DD 0ffffffffH		; CvMinorCivQuest::NO_TURN
CONST	ENDS
;	COMDAT ?NO_QUEST_DATA@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_QUEST_DATA@CvMinorCivQuest@@2HB DD 0ffffffffH	; CvMinorCivQuest::NO_QUEST_DATA
CONST	ENDS
PUBLIC	?wrapCoordDifference@@YAHHI_N@Z			; wrapCoordDifference
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?wrapCoordDifference@@YAHHI_N@Z
_TEXT	SEGMENT
_iDiff$ = 8						; size = 4
_uiRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?wrapCoordDifference@@YAHHI_N@Z PROC			; wrapCoordDifference, COMDAT

; 57   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iDiff$[esp-4]
	je	SHORT $LN5@wrapCoordD

; 58   : 	{
; 59   : 		if(iDiff > (int)(uiRange >> 1))		// Using an unsigned int so we can safely assume that value >> 1 == value / 2

	mov	edx, DWORD PTR _uiRange$[esp-4]
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN3@wrapCoordD

; 60   : 		{
; 61   : 			return (iDiff - (int)uiRange);

	sub	eax, edx

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
$LN3@wrapCoordD:

; 62   : 		}
; 63   : 		else if(iDiff < -(int)(uiRange >> 1))

	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN5@wrapCoordD

; 64   : 		{
; 65   : 			return (iDiff + (int)uiRange);

	add	eax, edx
$LN5@wrapCoordD:

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
?wrapCoordDifference@@YAHHI_N@Z ENDP			; wrapCoordDifference
_TEXT	ENDS
PUBLIC	?xToHexspaceX@@YAHHH@Z				; xToHexspaceX
; Function compile flags: /Ogtpy
;	COMDAT ?xToHexspaceX@@YAHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?xToHexspaceX@@YAHHH@Z PROC				; xToHexspaceX, COMDAT

; 86   : 	return iX - ((iY >= 0) ? (iY>>1) : ((iY - 1)/2));

	mov	ecx, DWORD PTR _iY$[esp-4]
	test	ecx, ecx
	jge	SHORT $LN5@xToHexspac
	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
	mov	ecx, eax
$LN5@xToHexspac:
	mov	eax, DWORD PTR _iX$[esp-4]
	sar	ecx, 1
	sub	eax, ecx

; 87   : }

	ret	0
?xToHexspaceX@@YAHHH@Z ENDP				; xToHexspaceX
_TEXT	ENDS
PUBLIC	?hexspaceXToX@@YAHHH@Z				; hexspaceXToX
; Function compile flags: /Ogtpy
;	COMDAT ?hexspaceXToX@@YAHHH@Z
_TEXT	SEGMENT
_iHexspaceX$ = 8					; size = 4
_iHexspaceY$ = 12					; size = 4
?hexspaceXToX@@YAHHH@Z PROC				; hexspaceXToX, COMDAT

; 91   : 	return iHexspaceX + ((iHexspaceY >= 0) ? (iHexspaceY>>1) : ((iHexspaceY - 1)/2));

	mov	eax, DWORD PTR _iHexspaceY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@hexspaceXT
	mov	ecx, DWORD PTR _iHexspaceX$[esp-4]
	sar	eax, 1
	add	eax, ecx

; 92   : }

	ret	0
$LN3@hexspaceXT:

; 91   : 	return iHexspaceX + ((iHexspaceY >= 0) ? (iHexspaceY>>1) : ((iHexspaceY - 1)/2));

	dec	eax
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _iHexspaceX$[esp-4]
	sar	eax, 1
	add	eax, edx

; 92   : }

	ret	0
?hexspaceXToX@@YAHHH@Z ENDP				; hexspaceXToX
_TEXT	ENDS
PUBLIC	?GetID@CvAIOperation@@QBEHXZ			; CvAIOperation::GetID
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
;	COMDAT ?GetID@CvAIOperation@@QBEHXZ
_TEXT	SEGMENT
?GetID@CvAIOperation@@QBEHXZ PROC			; CvAIOperation::GetID, COMDAT
; _this$ = ecx

; 125  : 	return m_iID;

	mov	eax, DWORD PTR [ecx+52]

; 126  : }

	ret	0
?GetID@CvAIOperation@@QBEHXZ ENDP			; CvAIOperation::GetID
_TEXT	ENDS
PUBLIC	?SetID@CvAIOperation@@QAEXH@Z			; CvAIOperation::SetID
; Function compile flags: /Ogtpy
;	COMDAT ?SetID@CvAIOperation@@QAEXH@Z
_TEXT	SEGMENT
_iID$ = 8						; size = 4
?SetID@CvAIOperation@@QAEXH@Z PROC			; CvAIOperation::SetID, COMDAT
; _this$ = ecx

; 131  : 	m_iID = iID;

	mov	eax, DWORD PTR _iID$[esp-4]
	mov	DWORD PTR [ecx+52], eax

; 132  : }

	ret	4
?SetID@CvAIOperation@@QAEXH@Z ENDP			; CvAIOperation::SetID
_TEXT	ENDS
PUBLIC	?SetOwner@CvAIOperation@@QAEXW4PlayerTypes@@@Z	; CvAIOperation::SetOwner
; Function compile flags: /Ogtpy
;	COMDAT ?SetOwner@CvAIOperation@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?SetOwner@CvAIOperation@@QAEXW4PlayerTypes@@@Z PROC	; CvAIOperation::SetOwner, COMDAT
; _this$ = ecx

; 137  : 	m_eOwner = ePlayer;

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	mov	DWORD PTR [ecx+72], eax

; 138  : }

	ret	4
?SetOwner@CvAIOperation@@QAEXW4PlayerTypes@@@Z ENDP	; CvAIOperation::SetOwner
_TEXT	ENDS
PUBLIC	?GetEnemy@CvAIOperation@@QBE?AW4PlayerTypes@@XZ	; CvAIOperation::GetEnemy
; Function compile flags: /Ogtpy
;	COMDAT ?GetEnemy@CvAIOperation@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetEnemy@CvAIOperation@@QBE?AW4PlayerTypes@@XZ PROC	; CvAIOperation::GetEnemy, COMDAT
; _this$ = ecx

; 143  : 	return m_eEnemy;

	mov	eax, DWORD PTR [ecx+76]

; 144  : }

	ret	0
?GetEnemy@CvAIOperation@@QBE?AW4PlayerTypes@@XZ ENDP	; CvAIOperation::GetEnemy
_TEXT	ENDS
PUBLIC	?SetEnemy@CvAIOperation@@QAEXW4PlayerTypes@@@Z	; CvAIOperation::SetEnemy
; Function compile flags: /Ogtpy
;	COMDAT ?SetEnemy@CvAIOperation@@QAEXW4PlayerTypes@@@Z
_TEXT	SEGMENT
_eEnemy$ = 8						; size = 4
?SetEnemy@CvAIOperation@@QAEXW4PlayerTypes@@@Z PROC	; CvAIOperation::SetEnemy, COMDAT
; _this$ = ecx

; 149  : 	m_eEnemy = eEnemy;

	mov	eax, DWORD PTR _eEnemy$[esp-4]
	mov	DWORD PTR [ecx+76], eax

; 150  : }

	ret	4
?SetEnemy@CvAIOperation@@QAEXW4PlayerTypes@@@Z ENDP	; CvAIOperation::SetEnemy
_TEXT	ENDS
PUBLIC	?GetDefaultArea@CvAIOperation@@QBEHXZ		; CvAIOperation::GetDefaultArea
; Function compile flags: /Ogtpy
;	COMDAT ?GetDefaultArea@CvAIOperation@@QBEHXZ
_TEXT	SEGMENT
?GetDefaultArea@CvAIOperation@@QBEHXZ PROC		; CvAIOperation::GetDefaultArea, COMDAT
; _this$ = ecx

; 155  : 	return m_iDefaultArea;

	mov	eax, DWORD PTR [ecx+64]

; 156  : }

	ret	0
?GetDefaultArea@CvAIOperation@@QBEHXZ ENDP		; CvAIOperation::GetDefaultArea
_TEXT	ENDS
PUBLIC	?SetDefaultArea@CvAIOperation@@QAEXH@Z		; CvAIOperation::SetDefaultArea
; Function compile flags: /Ogtpy
;	COMDAT ?SetDefaultArea@CvAIOperation@@QAEXH@Z
_TEXT	SEGMENT
_iDefaultArea$ = 8					; size = 4
?SetDefaultArea@CvAIOperation@@QAEXH@Z PROC		; CvAIOperation::SetDefaultArea, COMDAT
; _this$ = ecx

; 161  : 	m_iDefaultArea = iDefaultArea;

	mov	eax, DWORD PTR _iDefaultArea$[esp-4]
	mov	DWORD PTR [ecx+64], eax

; 162  : }

	ret	4
?SetDefaultArea@CvAIOperation@@QAEXH@Z ENDP		; CvAIOperation::SetDefaultArea
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	esi
	lea	eax, DWORD PTR __Message$[esp]
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[esp-4]

; 60   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	}

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	eax, DWORD PTR __Message$[esp+16]
	push	eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 31   : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
_TEXT	ENDS
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 35   : 		return (_Str.c_str());

	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
; Function compile flags: /Ogtpy
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 110  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@3:
	mov	eax, esi
	pop	esi
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z ; CvAIOperation::SetToAbort
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
;	COMDAT ?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
_TEXT	SEGMENT
_eReason$ = 8						; size = 4
?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z PROC ; CvAIOperation::SetToAbort, COMDAT
; _this$ = ecx

; 836  : 	m_eCurrentState = AI_OPERATION_STATE_ABORTED;
; 837  : 	m_eAbortReason = eReason;

	mov	eax, DWORD PTR _eReason$[esp-4]
	mov	DWORD PTR [ecx+56], 0
	mov	DWORD PTR [ecx+60], eax

; 838  : }

	ret	4
?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z ENDP ; CvAIOperation::SetToAbort
_TEXT	ENDS
PUBLIC	?DoDelayedDeath@CvAIOperation@@UAE_NXZ		; CvAIOperation::DoDelayedDeath
; Function compile flags: /Ogtpy
;	COMDAT ?DoDelayedDeath@CvAIOperation@@UAE_NXZ
_TEXT	SEGMENT
?DoDelayedDeath@CvAIOperation@@UAE_NXZ PROC		; CvAIOperation::DoDelayedDeath, COMDAT
; _this$ = ecx

; 864  : {

	push	esi
	mov	esi, ecx

; 865  : 	if(ShouldAbort())

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+72]
	call	edx
	test	al, al
	je	SHORT $LN3@DoDelayedD

; 866  : 	{
; 867  : 		if (m_eCurrentState == AI_OPERATION_STATE_SUCCESSFUL_FINISH)

	cmp	DWORD PTR [esi+56], 5

; 868  : 		{
; 869  : 			Kill(AI_ABORT_SUCCESS);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+80]
	mov	ecx, esi
	jne	SHORT $LN2@DoDelayedD
	push	0

; 870  : 		}
; 871  : 		else
; 872  : 		{
; 873  : 			Kill(AI_ABORT_KILLED);

	call	edx

; 874  : 		}
; 875  : 		return true;

	mov	al, 1
	pop	esi

; 879  : }

	ret	0
$LN2@DoDelayedD:

; 870  : 		}
; 871  : 		else
; 872  : 		{
; 873  : 			Kill(AI_ABORT_KILLED);

	push	11					; 0000000bH
	call	edx

; 874  : 		}
; 875  : 		return true;

	mov	al, 1
	pop	esi

; 879  : }

	ret	0
$LN3@DoDelayedD:

; 876  : 	}
; 877  : 
; 878  : 	return false;

	xor	al, al
	pop	esi

; 879  : }

	ret	0
?DoDelayedDeath@CvAIOperation@@UAE_NXZ ENDP		; CvAIOperation::DoDelayedDeath
_TEXT	ENDS
PUBLIC	??0CvOperationSearchUnit@@QAE@PAVCvUnit@@H@Z	; CvOperationSearchUnit::CvOperationSearchUnit
; Function compile flags: /Ogtpy
;	COMDAT ??0CvOperationSearchUnit@@QAE@PAVCvUnit@@H@Z
_TEXT	SEGMENT
_pkUnit$ = 8						; size = 4
_iDistance$ = 12					; size = 4
??0CvOperationSearchUnit@@QAE@PAVCvUnit@@H@Z PROC	; CvOperationSearchUnit::CvOperationSearchUnit, COMDAT
; _this$ = ecx

; 1590 : 	CvOperationSearchUnit(CvUnit* pkUnit, int iDistance) { m_pkUnit = pkUnit; m_iDistance = iDistance; };

	mov	edx, DWORD PTR _iDistance$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _pkUnit$[esp-4]
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax], edx
	ret	8
??0CvOperationSearchUnit@@QAE@PAVCvUnit@@H@Z ENDP	; CvOperationSearchUnit::CvOperationSearchUnit
_TEXT	ENDS
PUBLIC	?GetUnit@CvOperationSearchUnit@@QBEPAVCvUnit@@XZ ; CvOperationSearchUnit::GetUnit
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnit@CvOperationSearchUnit@@QBEPAVCvUnit@@XZ
_TEXT	SEGMENT
?GetUnit@CvOperationSearchUnit@@QBEPAVCvUnit@@XZ PROC	; CvOperationSearchUnit::GetUnit, COMDAT
; _this$ = ecx

; 1604 : 		return m_pkUnit;

	mov	eax, DWORD PTR [ecx+4]

; 1605 : 	};

	ret	0
?GetUnit@CvOperationSearchUnit@@QBEPAVCvUnit@@XZ ENDP	; CvOperationSearchUnit::GetUnit
_TEXT	ENDS
PUBLIC	?GetDistance@CvOperationSearchUnit@@QBEHXZ	; CvOperationSearchUnit::GetDistance
; Function compile flags: /Ogtpy
;	COMDAT ?GetDistance@CvOperationSearchUnit@@QBEHXZ
_TEXT	SEGMENT
?GetDistance@CvOperationSearchUnit@@QBEHXZ PROC		; CvOperationSearchUnit::GetDistance, COMDAT
; _this$ = ecx

; 1612 : 		return m_iDistance;

	mov	eax, DWORD PTR [ecx]

; 1613 : 	};

	ret	0
?GetDistance@CvOperationSearchUnit@@QBEHXZ ENDP		; CvOperationSearchUnit::GetDistance
_TEXT	ENDS
PUBLIC	?FindBestTarget@CvAIOperationBasicCityAttack@@MAEPAVCvPlot@@XZ ; CvAIOperationBasicCityAttack::FindBestTarget
; Function compile flags: /Ogtpy
;	COMDAT ?FindBestTarget@CvAIOperationBasicCityAttack@@MAEPAVCvPlot@@XZ
_TEXT	SEGMENT
?FindBestTarget@CvAIOperationBasicCityAttack@@MAEPAVCvPlot@@XZ PROC ; CvAIOperationBasicCityAttack::FindBestTarget, COMDAT
; _this$ = ecx

; 2293 : 	CvAssertMsg(false, "Obsolete function called CvAIOperationBasicCityAttack::FindBestTarget()");
; 2294 : 
; 2295 : 	return NULL;

	xor	eax, eax

; 2296 : }

	ret	0
?FindBestTarget@CvAIOperationBasicCityAttack@@MAEPAVCvPlot@@XZ ENDP ; CvAIOperationBasicCityAttack::FindBestTarget
_TEXT	ENDS
PUBLIC	?UnitWasRemoved@CvAIEscortedOperation@@UAEXHH@Z	; CvAIEscortedOperation::UnitWasRemoved
; Function compile flags: /Ogtpy
;	COMDAT ?UnitWasRemoved@CvAIEscortedOperation@@UAEXHH@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_iSlotID$ = 12						; size = 4
?UnitWasRemoved@CvAIEscortedOperation@@UAEXHH@Z PROC	; CvAIEscortedOperation::UnitWasRemoved, COMDAT
; _this$ = ecx

; 2953 : 	// Assumes civilian is in the first slot of the formation
; 2954 : 	if(iSlotID == 0)

	xor	eax, eax
	cmp	DWORD PTR _iSlotID$[esp-4], eax
	jne	SHORT $LN2@UnitWasRem

; 2955 : 	{
; 2956 : 		m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	DWORD PTR [ecx+56], eax

; 2957 : 		m_eAbortReason = AI_ABORT_LOST_CIVILIAN;

	mov	DWORD PTR [ecx+60], 8

; 2962 : 	}
; 2963 : }

	ret	8
$LN2@UnitWasRem:

; 2958 : 	}
; 2959 : 	else
; 2960 : 	{
; 2961 : 		m_bEscorted = false;

	mov	BYTE PTR [ecx+112], al

; 2962 : 	}
; 2963 : }

	ret	8
?UnitWasRemoved@CvAIEscortedOperation@@UAEXHH@Z ENDP	; CvAIEscortedOperation::UnitWasRemoved
_TEXT	ENDS
PUBLIC	?FindBestTarget@CvAIOperationPureNavalCityAttack@@MAEPAVCvPlot@@XZ ; CvAIOperationPureNavalCityAttack::FindBestTarget
; Function compile flags: /Ogtpy
;	COMDAT ?FindBestTarget@CvAIOperationPureNavalCityAttack@@MAEPAVCvPlot@@XZ
_TEXT	SEGMENT
?FindBestTarget@CvAIOperationPureNavalCityAttack@@MAEPAVCvPlot@@XZ PROC ; CvAIOperationPureNavalCityAttack::FindBestTarget, COMDAT
; _this$ = ecx

; 4756 : 	CvAssertMsg(false, "Obsolete function called CvAIOperationPureNavalCityAttack::FindBestTarget()");
; 4757 : 
; 4758 : 	return NULL;

	xor	eax, eax

; 4759 : }

	ret	0
?FindBestTarget@CvAIOperationPureNavalCityAttack@@MAEPAVCvPlot@@XZ ENDP ; CvAIOperationPureNavalCityAttack::FindBestTarget
_TEXT	ENDS
PUBLIC	?UnitWasRemoved@CvAINavalEscortedOperation@@UAEXHH@Z ; CvAINavalEscortedOperation::UnitWasRemoved
; Function compile flags: /Ogtpy
;	COMDAT ?UnitWasRemoved@CvAINavalEscortedOperation@@UAEXHH@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_iSlotID$ = 12						; size = 4
?UnitWasRemoved@CvAINavalEscortedOperation@@UAEXHH@Z PROC ; CvAINavalEscortedOperation::UnitWasRemoved, COMDAT
; _this$ = ecx

; 5185 : 	// Assumes civilian is in the first slot of the formation
; 5186 : 	if(iSlotID == 0)

	cmp	DWORD PTR _iSlotID$[esp-4], 0
	jne	SHORT $LN1@UnitWasRem@2

; 5187 : 	{
; 5188 : 		m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	DWORD PTR [ecx+56], 0

; 5189 : 		m_eAbortReason = AI_ABORT_LOST_CIVILIAN;

	mov	DWORD PTR [ecx+60], 8
$LN1@UnitWasRem@2:

; 5190 : 	}
; 5191 : }

	ret	8
?UnitWasRemoved@CvAINavalEscortedOperation@@UAEXHH@Z ENDP ; CvAINavalEscortedOperation::UnitWasRemoved
_TEXT	ENDS
PUBLIC	?FindBestTarget@CvAIOperationNavalAttack@@MAEPAVCvPlot@@XZ ; CvAIOperationNavalAttack::FindBestTarget
; Function compile flags: /Ogtpy
;	COMDAT ?FindBestTarget@CvAIOperationNavalAttack@@MAEPAVCvPlot@@XZ
_TEXT	SEGMENT
?FindBestTarget@CvAIOperationNavalAttack@@MAEPAVCvPlot@@XZ PROC ; CvAIOperationNavalAttack::FindBestTarget, COMDAT
; _this$ = ecx

; 5522 : 	CvAssertMsg(false, "Obsolete function called CvAIOperationNavalAttack::FindBestTarget()");
; 5523 : 
; 5524 : 	return NULL;

	xor	eax, eax

; 5525 : }

	ret	0
?FindBestTarget@CvAIOperationNavalAttack@@MAEPAVCvPlot@@XZ ENDP ; CvAIOperationNavalAttack::FindBestTarget
_TEXT	ENDS
PUBLIC	?GetGatherRangeForXUnits@OperationalAIHelpers@@YAHH@Z ; OperationalAIHelpers::GetGatherRangeForXUnits
; Function compile flags: /Ogtpy
;	COMDAT ?GetGatherRangeForXUnits@OperationalAIHelpers@@YAHH@Z
_TEXT	SEGMENT
_iTotalUnits$ = 8					; size = 4
?GetGatherRangeForXUnits@OperationalAIHelpers@@YAHH@Z PROC ; OperationalAIHelpers::GetGatherRangeForXUnits, COMDAT

; 5881 : 	int iRange = 0;
; 5882 : 
; 5883 : 	if(iTotalUnits <= 2)

	mov	eax, DWORD PTR _iTotalUnits$[esp-4]
	cmp	eax, 2
	jg	SHORT $LN6@GetGatherR

; 5884 : 	{
; 5885 : 		iRange = 1;

	mov	eax, 1

; 5892 : 	{
; 5893 : 		iRange = 3;
; 5894 : 	}
; 5895 : 	else
; 5896 : 	{
; 5897 : 		iRange = 4;
; 5898 : 	}
; 5899 : 
; 5900 : 	return iRange;
; 5901 : }

	ret	0
$LN6@GetGatherR:

; 5886 : 	}
; 5887 : 	else if(iTotalUnits <= 6)

	cmp	eax, 6
	jg	SHORT $LN4@GetGatherR

; 5888 : 	{
; 5889 : 		iRange = 2;

	mov	eax, 2

; 5892 : 	{
; 5893 : 		iRange = 3;
; 5894 : 	}
; 5895 : 	else
; 5896 : 	{
; 5897 : 		iRange = 4;
; 5898 : 	}
; 5899 : 
; 5900 : 	return iRange;
; 5901 : }

	ret	0
$LN4@GetGatherR:

; 5890 : 	}
; 5891 : 	else if(iTotalUnits <= 10)

	xor	ecx, ecx
	cmp	eax, 10					; 0000000aH
	setg	cl
	add	ecx, 3
	mov	eax, ecx

; 5892 : 	{
; 5893 : 		iRange = 3;
; 5894 : 	}
; 5895 : 	else
; 5896 : 	{
; 5897 : 		iRange = 4;
; 5898 : 	}
; 5899 : 
; 5900 : 	return iRange;
; 5901 : }

	ret	0
?GetGatherRangeForXUnits@OperationalAIHelpers@@YAHH@Z ENDP ; OperationalAIHelpers::GetGatherRangeForXUnits
_TEXT	ENDS
PUBLIC	??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int> >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z PROC	; std::vector<int,std::allocator<int> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ENDP	; std::vector<int,std::allocator<int> >::operator[]
_TEXT	ENDS
PUBLIC	??A?$BaseVector@PAVCvAStarNode@@$00@@QAEAAPAVCvAStarNode@@I@Z ; BaseVector<CvAStarNode *,1>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@PAVCvAStarNode@@$00@@QAEAAPAVCvAStarNode@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@PAVCvAStarNode@@$00@@QAEAAPAVCvAStarNode@@I@Z PROC ; BaseVector<CvAStarNode *,1>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 131  : 	};

	ret	4
??A?$BaseVector@PAVCvAStarNode@@$00@@QAEAAPAVCvAStarNode@@I@Z ENDP ; BaseVector<CvAStarNode *,1>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@PAVCvAStarNode@@$00@@QBEIXZ	; BaseVector<CvAStarNode *,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@PAVCvAStarNode@@$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@PAVCvAStarNode@@$00@@QBEIXZ PROC	; BaseVector<CvAStarNode *,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@PAVCvAStarNode@@$00@@QBEIXZ ENDP	; BaseVector<CvAStarNode *,1>::size
_TEXT	ENDS
PUBLIC	??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ	; FObjectHandle<CvUnit>::operator->
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
;	COMDAT ??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ
_TEXT	SEGMENT
??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ PROC	; FObjectHandle<CvUnit>::operator->, COMDAT
; _this$ = ecx

; 88   : 		return m_target;

	mov	eax, DWORD PTR [ecx]

; 89   : 	}

	ret	0
??C?$FObjectHandle@VCvUnit@@@@QAEPAVCvUnit@@XZ ENDP	; FObjectHandle<CvUnit>::operator->
_TEXT	ENDS
PUBLIC	??B?$FObjectHandle@VCvUnit@@@@QBE_NXZ		; FObjectHandle<CvUnit>::operator bool
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FObjectHandle@VCvUnit@@@@QBE_NXZ
_TEXT	SEGMENT
??B?$FObjectHandle@VCvUnit@@@@QBE_NXZ PROC		; FObjectHandle<CvUnit>::operator bool, COMDAT
; _this$ = ecx

; 108  : 		return m_target != 0;

	xor	eax, eax
	cmp	DWORD PTR [ecx], eax
	setne	al

; 109  : 	}

	ret	0
??B?$FObjectHandle@VCvUnit@@@@QBE_NXZ ENDP		; FObjectHandle<CvUnit>::operator bool
_TEXT	ENDS
PUBLIC	??0?$FObjectHandle@VCvUnit@@@@QAE@XZ		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FObjectHandle@VCvUnit@@@@QAE@XZ
_TEXT	SEGMENT
??0?$FObjectHandle@VCvUnit@@@@QAE@XZ PROC		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 215  : 	{

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	BYTE PTR [eax+4], 0

; 216  : 		OBJECT_HANDLE_STACK;
; 217  : 	}

	ret	0
??0?$FObjectHandle@VCvUnit@@@@QAE@XZ ENDP		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@VCvOperationSearchUnit@@$00@@QBEIXZ ; BaseVector<CvOperationSearchUnit,1>::size
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?size@?$BaseVector@VCvOperationSearchUnit@@$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@VCvOperationSearchUnit@@$00@@QBEIXZ PROC ; BaseVector<CvOperationSearchUnit,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@VCvOperationSearchUnit@@$00@@QBEIXZ ENDP ; BaseVector<CvOperationSearchUnit,1>::size
_TEXT	ENDS
PUBLIC	?begin@?$BaseVector@VCvOperationSearchUnit@@$00@@QAEPAVCvOperationSearchUnit@@XZ ; BaseVector<CvOperationSearchUnit,1>::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$BaseVector@VCvOperationSearchUnit@@$00@@QAEPAVCvOperationSearchUnit@@XZ
_TEXT	SEGMENT
?begin@?$BaseVector@VCvOperationSearchUnit@@$00@@QAEPAVCvOperationSearchUnit@@XZ PROC ; BaseVector<CvOperationSearchUnit,1>::begin, COMDAT
; _this$ = ecx

; 194  :         return m_pData; 

	mov	eax, DWORD PTR [ecx]

; 195  :     };

	ret	0
?begin@?$BaseVector@VCvOperationSearchUnit@@$00@@QAEPAVCvOperationSearchUnit@@XZ ENDP ; BaseVector<CvOperationSearchUnit,1>::begin
_TEXT	ENDS
PUBLIC	?end@?$BaseVector@VCvOperationSearchUnit@@$00@@QAEPAVCvOperationSearchUnit@@XZ ; BaseVector<CvOperationSearchUnit,1>::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$BaseVector@VCvOperationSearchUnit@@$00@@QAEPAVCvOperationSearchUnit@@XZ
_TEXT	SEGMENT
?end@?$BaseVector@VCvOperationSearchUnit@@$00@@QAEPAVCvOperationSearchUnit@@XZ PROC ; BaseVector<CvOperationSearchUnit,1>::end, COMDAT
; _this$ = ecx

; 197  :         return m_pData+m_uiCurrSize; 

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [ecx+eax*8]

; 198  :     };

	ret	0
?end@?$BaseVector@VCvOperationSearchUnit@@$00@@QAEPAVCvOperationSearchUnit@@XZ ENDP ; BaseVector<CvOperationSearchUnit,1>::end
_TEXT	ENDS
PUBLIC	?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ; DestructionNotification<FObjectHandle<CvUnit> >::addTarget
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
;	COMDAT ?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z PROC ; DestructionNotification<FObjectHandle<CvUnit> >::addTarget, COMDAT
; _this$ = ecx

; 52   : #ifdef TRACK_DESTRUCTION_NOTIFICATION
; 53   : 		m_targets.insert(&target);
; 54   : #endif
; 55   : 	}

	ret	4
?addTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ENDP ; DestructionNotification<FObjectHandle<CvUnit> >::addTarget
_TEXT	ENDS
PUBLIC	?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget
; Function compile flags: /Ogtpy
;	COMDAT ?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z PROC ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget, COMDAT
; _this$ = ecx

; 63   : #ifdef TRACK_DESTRUCTION_NOTIFICATION
; 64   : 		m_targets.erase(&target);
; 65   : #endif
; 66   : 	}

	ret	4
?removeTarget@?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@QAEXABV?$FObjectHandle@VCvUnit@@@@@Z ENDP ; DestructionNotification<FObjectHandle<CvUnit> >::removeTarget
_TEXT	ENDS
PUBLIC	?capacity@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBEIXZ ; std::vector<OperationSlot,std::allocator<OperationSlot> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBEIXZ PROC ; std::vector<OperationSlot,std::allocator<OperationSlot> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jne	SHORT $LN3@capacity

; 636  : 		}

	ret	0
$LN3@capacity:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	ecx, DWORD PTR [ecx+12]
	sub	ecx, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 636  : 		}

	ret	0
?capacity@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBEIXZ ENDP ; std::vector<OperationSlot,std::allocator<OperationSlot> >::capacity
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@UOperationSlot@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<OperationSlot> >::~_Container_base_aux_alloc_empty<std::allocator<OperationSlot> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@UOperationSlot@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@UOperationSlot@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<OperationSlot> >::~_Container_base_aux_alloc_empty<std::allocator<OperationSlot> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@UOperationSlot@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<OperationSlot> >::~_Container_base_aux_alloc_empty<std::allocator<OperationSlot> >
_TEXT	ENDS
PUBLIC	??0?$allocator@UOperationSlot@@@std@@QAE@XZ	; std::allocator<OperationSlot>::allocator<OperationSlot>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UOperationSlot@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@UOperationSlot@@@std@@QAE@XZ PROC	; std::allocator<OperationSlot>::allocator<OperationSlot>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@UOperationSlot@@@std@@QAE@XZ ENDP	; std::allocator<OperationSlot>::allocator<OperationSlot>
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<OperationSlot,std::allocator<OperationSlot> >::_Vector_const_iterator<OperationSlot,std::allocator<OperationSlot> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<OperationSlot,std::allocator<OperationSlot> >::_Vector_const_iterator<OperationSlot,std::allocator<OperationSlot> >, COMDAT
; _this$ = ecx

; 62   : 	_Vector_const_iterator()

	mov	eax, ecx

; 63   : 		{	// construct with null pointer
; 64   : 		_Myptr = 0;

	mov	DWORD PTR [eax], 0

; 65   : 		}

	ret	0
??0?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<OperationSlot,std::allocator<OperationSlot> >::_Vector_const_iterator<OperationSlot,std::allocator<OperationSlot> >
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBEABUOperationSlot@@XZ ; std::_Vector_const_iterator<OperationSlot,std::allocator<OperationSlot> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBEABUOperationSlot@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBEABUOperationSlot@@XZ PROC ; std::_Vector_const_iterator<OperationSlot,std::allocator<OperationSlot> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBEABUOperationSlot@@XZ ENDP ; std::_Vector_const_iterator<OperationSlot,std::allocator<OperationSlot> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<OperationSlot,std::allocator<OperationSlot> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<OperationSlot,std::allocator<OperationSlot> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 12			; 0000000cH

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<OperationSlot,std::allocator<OperationSlot> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<OperationSlot,std::allocator<OperationSlot> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<OperationSlot,std::allocator<OperationSlot> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<OperationSlot,std::allocator<OperationSlot> >::operator==
_TEXT	ENDS
PUBLIC	??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@ ; `string'
PUBLIC	?Alloc@?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@IAEPAPAVCvAStarNode@@I@Z ; FStaticVector<CvAStarNode *,200,1,297,0>::Alloc
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
CONST	SEGMENT
??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@ DB 'c:\users\eno'
	DB	'rmousapplepie\documents\github\lekmod\lekmod_dll\fireplace\in'
	DB	'clude\fireworks\FFastVector.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?Alloc@?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@IAEPAPAVCvAStarNode@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@IAEPAPAVCvAStarNode@@I@Z PROC ; FStaticVector<CvAStarNode *,200,1,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 200				; 000000c8H
	jbe	SHORT $LN2@Alloc

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 200			; 000000c8H
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@IAEPAPAVCvAStarNode@@I@Z ENDP ; FStaticVector<CvAStarNode *,200,1,297,0>::Alloc
_TEXT	ENDS
PUBLIC	?Alloc@?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@IAEPAVCvOperationSearchUnit@@I@Z ; FStaticVector<CvOperationSearchUnit,128,1,297,0>::Alloc
; Function compile flags: /Ogtpy
;	COMDAT ?Alloc@?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@IAEPAVCvOperationSearchUnit@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@IAEPAVCvOperationSearchUnit@@I@Z PROC ; FStaticVector<CvOperationSearchUnit,128,1,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 128				; 00000080H
	jbe	SHORT $LN2@Alloc@2

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc@2:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 128			; 00000080H
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@IAEPAVCvOperationSearchUnit@@I@Z ENDP ; FStaticVector<CvOperationSearchUnit,128,1,297,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@VCvOperationSearchUnit@@$00@@QAE@XZ ; BaseVector<CvOperationSearchUnit,1>::~BaseVector<CvOperationSearchUnit,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@VCvOperationSearchUnit@@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@VCvOperationSearchUnit@@$00@@QAE@XZ PROC ; BaseVector<CvOperationSearchUnit,1>::~BaseVector<CvOperationSearchUnit,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@VCvOperationSearchUnit@@$00@@QAE@XZ ENDP ; BaseVector<CvOperationSearchUnit,1>::~BaseVector<CvOperationSearchUnit,1>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@VCvOperationSearchUnit@@$00@@IAE@XZ ; BaseVector<CvOperationSearchUnit,1>::BaseVector<CvOperationSearchUnit,1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@VCvOperationSearchUnit@@$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@VCvOperationSearchUnit@@$00@@IAE@XZ PROC ; BaseVector<CvOperationSearchUnit,1>::BaseVector<CvOperationSearchUnit,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@VCvOperationSearchUnit@@$00@@IAE@XZ ENDP ; BaseVector<CvOperationSearchUnit,1>::BaseVector<CvOperationSearchUnit,1>
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@VCvOperationSearchUnit@@$00@@IAEXPAVCvOperationSearchUnit@@I@Z ; BaseVector<CvOperationSearchUnit,1>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@VCvOperationSearchUnit@@$00@@IAEXPAVCvOperationSearchUnit@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@VCvOperationSearchUnit@@$00@@IAEXPAVCvOperationSearchUnit@@I@Z PROC ; BaseVector<CvOperationSearchUnit,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@VCvOperationSearchUnit@@$00@@IAEXPAVCvOperationSearchUnit@@I@Z ENDP ; BaseVector<CvOperationSearchUnit,1>::Destroy
_TEXT	ENDS
PUBLIC	??A?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@I@Z ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@I@Z PROC ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::operator[], COMDAT
; _this$ = ecx

; 135  : 		FAssert(ui < m_uiCurrSize);
; 136  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 137  : 	};

	ret	4
??A?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QBEABUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@I@Z ENDP ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::operator[]
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QBEIXZ ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QBEIXZ PROC ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QBEIXZ ENDP ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::size
_TEXT	ENDS
PUBLIC	?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@XZ ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@XZ
_TEXT	SEGMENT
?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@XZ PROC ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::begin, COMDAT
; _this$ = ecx

; 194  :         return m_pData; 

	mov	eax, DWORD PTR [ecx]

; 195  :     };

	ret	0
?begin@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@XZ ENDP ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::begin
_TEXT	ENDS
PUBLIC	?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@XZ ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@XZ
_TEXT	SEGMENT
?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@XZ PROC ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::end, COMDAT
; _this$ = ecx

; 197  :         return m_pData+m_uiCurrSize; 

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [ecx+eax*8]

; 198  :     };

	ret	0
?end@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QAEPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@XZ ENDP ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::end
_TEXT	ENDS
PUBLIC	??0WeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAE@XZ ; CvWeightedVector<CvPlot *,1,1>::WeightedElement::WeightedElement
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0WeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAE@XZ
_TEXT	SEGMENT
??0WeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAE@XZ PROC ; CvWeightedVector<CvPlot *,1,1>::WeightedElement::WeightedElement, COMDAT
; _this$ = ecx

; 31   : 		{

	mov	eax, ecx
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0

; 32   : 		}

	ret	0
??0WeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAE@XZ ENDP ; CvWeightedVector<CvPlot *,1,1>::WeightedElement::WeightedElement
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@KAXXZ ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Xlen
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T231072 = -80						; size = 28
$T231071 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@KAXXZ PROC ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T231072[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T231071[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T231072[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T231071[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T231071[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T231071[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T231071[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen:
$LN12@Xlen:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T231072[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T231071[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@KAXXZ ENDP ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Xlen
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+20]
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	add	edi, 12					; 0000000cH
	push	edi
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@UOperationSlot@@@std@@@std@@IAE@V?$allocator@UOperationSlot@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<OperationSlot> >::_Container_base_aux_alloc_empty<std::allocator<OperationSlot> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@UOperationSlot@@@std@@@std@@IAE@V?$allocator@UOperationSlot@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@UOperationSlot@@@std@@@std@@IAE@V?$allocator@UOperationSlot@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<OperationSlot> >::_Container_base_aux_alloc_empty<std::allocator<OperationSlot> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@UOperationSlot@@@std@@@std@@IAE@V?$allocator@UOperationSlot@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<OperationSlot> >::_Container_base_aux_alloc_empty<std::allocator<OperationSlot> >
_TEXT	ENDS
PUBLIC	??0?$allocator@UOperationSlot@@@std@@QAE@ABV01@@Z ; std::allocator<OperationSlot>::allocator<OperationSlot>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UOperationSlot@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@UOperationSlot@@@std@@QAE@ABV01@@Z PROC	; std::allocator<OperationSlot>::allocator<OperationSlot>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@UOperationSlot@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<OperationSlot>::allocator<OperationSlot>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UOperationSlot@@@std@@QAEXPAUOperationSlot@@I@Z ; std::allocator<OperationSlot>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@UOperationSlot@@@std@@QAEXPAUOperationSlot@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UOperationSlot@@@std@@QAEXPAUOperationSlot@@I@Z PROC ; std::allocator<OperationSlot>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@UOperationSlot@@@std@@QAEXPAUOperationSlot@@I@Z ENDP ; std::allocator<OperationSlot>::deallocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@PAUOperationSlot@@@Z ; std::_Vector_const_iterator<OperationSlot,std::allocator<OperationSlot> >::_Vector_const_iterator<OperationSlot,std::allocator<OperationSlot> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@PAUOperationSlot@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@PAUOperationSlot@@@Z PROC ; std::_Vector_const_iterator<OperationSlot,std::allocator<OperationSlot> >::_Vector_const_iterator<OperationSlot,std::allocator<OperationSlot> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@PAUOperationSlot@@@Z ENDP ; std::_Vector_const_iterator<OperationSlot,std::allocator<OperationSlot> >::_Vector_const_iterator<OperationSlot,std::allocator<OperationSlot> >
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<OperationSlot,std::allocator<OperationSlot> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<OperationSlot,std::allocator<OperationSlot> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	sub	ecx, DWORD PTR [eax]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<OperationSlot,std::allocator<OperationSlot> >::operator-
_TEXT	ENDS
PUBLIC	?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@I@Z ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::Alloc
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@I@Z PROC ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 1
	jbe	SHORT $LN2@Alloc@3

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc@3:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 1
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@I@Z ENDP ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QAE@XZ ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QAE@XZ PROC ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@QAE@XZ ENDP ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::~BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@IAE@XZ ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@IAE@XZ PROC ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@IAE@XZ ENDP ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>
_TEXT	ENDS
PUBLIC	??0WeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAE@ABU01@@Z ; CvWeightedVector<CvPlot *,1,1>::WeightedElement::WeightedElement
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0WeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAE@ABU01@@Z
_TEXT	SEGMENT
_source$ = 8						; size = 4
??0WeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAE@ABU01@@Z PROC ; CvWeightedVector<CvPlot *,1,1>::WeightedElement::WeightedElement, COMDAT
; _this$ = ecx

; 37   : 		{

	mov	eax, ecx
	mov	ecx, DWORD PTR _source$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx

; 38   : 		}

	ret	4
??0WeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAE@ABU01@@Z ENDP ; CvWeightedVector<CvPlot *,1,1>::WeightedElement::WeightedElement
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UOperationSlot@@@std@@QBEIXZ ; std::allocator<OperationSlot>::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@UOperationSlot@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UOperationSlot@@@std@@QBEIXZ PROC	; std::allocator<OperationSlot>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 357913941				; 15555555H

; 167  : 		}

	ret	0
?max_size@?$allocator@UOperationSlot@@@std@@QBEIXZ ENDP	; std::allocator<OperationSlot>::max_size
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@I@Z ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::Destroy
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@I@Z PROC ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00@@IAEXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@I@Z ENDP ; BaseVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1>::Destroy
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<OperationSlot,std::allocator<OperationSlot> >::operator+=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<OperationSlot,std::allocator<OperationSlot> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [eax], ecx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<OperationSlot,std::allocator<OperationSlot> >::operator+=
_TEXT	ENDS
PUBLIC	??$max@H@std@@YAABHABH0@Z			; std::max<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$max@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@H@std@@YAABHABH0@Z PROC				; std::max<int>, COMDAT

; 3384 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN4@max
	mov	eax, ecx
$LN4@max:

; 3385 : 	}

	ret	0
??$max@H@std@@YAABHABH0@Z ENDP				; std::max<int>
_TEXT	ENDS
PUBLIC	??$min@H@std@@YAABHABH0@Z			; std::min<int>
; Function compile flags: /Ogtpy
;	COMDAT ??$min@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@H@std@@YAABHABH0@Z PROC				; std::min<int>, COMDAT

; 3399 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Left$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jl	SHORT $LN4@min
	mov	eax, ecx
$LN4@min:

; 3400 : 	}

	ret	0
??$min@H@std@@YAABHABH0@Z ENDP				; std::min<int>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@UOperationSlot@@@std@@YAPAUOperationSlot@@IPAU1@@Z ; std::_Allocate<OperationSlot>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@UOperationSlot@@@std@@YAPAUOperationSlot@@IPAU1@@Z
_TEXT	SEGMENT
$T231158 = -12						; size = 12
$T231162 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UOperationSlot@@@std@@YAPAUOperationSlot@@IPAU1@@Z PROC ; std::_Allocate<OperationSlot>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx+ecx*2]
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 12					; 0000000cH
	jae	SHORT $LN1@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T231162[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T231158[esp+16]
	mov	DWORD PTR $T231162[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T231158[esp+16]
	push	ecx
	mov	DWORD PTR $T231158[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate:
$LN8@Allocate:
	int	3
??$_Allocate@UOperationSlot@@@std@@YAPAUOperationSlot@@IPAU1@@Z ENDP ; std::_Allocate<OperationSlot>
_TEXT	ENDS
PUBLIC	?begin@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@XZ ; std::vector<OperationSlot,std::allocator<OperationSlot> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@XZ PROC ; std::vector<OperationSlot,std::allocator<OperationSlot> >::begin, COMDAT
; _this$ = ecx

; 672  : 		return (const_iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 673  : 		}

	ret	4
?begin@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@XZ ENDP ; std::vector<OperationSlot,std::allocator<OperationSlot> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@XZ ; std::vector<OperationSlot,std::allocator<OperationSlot> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@XZ PROC ; std::vector<OperationSlot,std::allocator<OperationSlot> >::end, COMDAT
; _this$ = ecx

; 682  : 		return (const_iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 683  : 		}

	ret	4
?end@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@XZ ENDP ; std::vector<OperationSlot,std::allocator<OperationSlot> >::end
_TEXT	ENDS
PUBLIC	??$_Dist_type@PAVCvOperationSearchUnit@@@std@@YAPAHPAVCvOperationSearchUnit@@@Z ; std::_Dist_type<CvOperationSearchUnit *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Dist_type@PAVCvOperationSearchUnit@@@std@@YAPAHPAVCvOperationSearchUnit@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@PAVCvOperationSearchUnit@@@std@@YAPAHPAVCvOperationSearchUnit@@@Z PROC ; std::_Dist_type<CvOperationSearchUnit *>, COMDAT

; 1831 : 	return (0);

	xor	eax, eax

; 1832 : 	}

	ret	0
??$_Dist_type@PAVCvOperationSearchUnit@@@std@@YAPAHPAVCvOperationSearchUnit@@@Z ENDP ; std::_Dist_type<CvOperationSearchUnit *>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAVCvOperationSearchUnit@@@std@@YAPAVCvOperationSearchUnit@@PAV1@@Z ; std::_Val_type<CvOperationSearchUnit *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Val_type@PAVCvOperationSearchUnit@@@std@@YAPAVCvOperationSearchUnit@@PAV1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAVCvOperationSearchUnit@@@std@@YAPAVCvOperationSearchUnit@@PAV1@@Z PROC ; std::_Val_type<CvOperationSearchUnit *>, COMDAT

; 1766 : 	return (0);

	xor	eax, eax

; 1767 : 	}

	ret	0
??$_Val_type@PAVCvOperationSearchUnit@@@std@@YAPAVCvOperationSearchUnit@@PAV1@@Z ENDP ; std::_Val_type<CvOperationSearchUnit *>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAUOperationSlot@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUOperationSlot@@0@Z ; std::_Iter_random<OperationSlot *,OperationSlot *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAUOperationSlot@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUOperationSlot@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUOperationSlot@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUOperationSlot@@0@Z PROC ; std::_Iter_random<OperationSlot *,OperationSlot *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAUOperationSlot@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUOperationSlot@@0@Z ENDP ; std::_Iter_random<OperationSlot *,OperationSlot *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAUOperationSlot@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUOperationSlot@@0@Z ; std::_Ptr_cat<OperationSlot *,OperationSlot *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAUOperationSlot@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUOperationSlot@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUOperationSlot@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUOperationSlot@@0@Z PROC ; std::_Ptr_cat<OperationSlot *,OperationSlot *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAUOperationSlot@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUOperationSlot@@0@Z ENDP ; std::_Ptr_cat<OperationSlot *,OperationSlot *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUOperationSlot@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUOperationSlot@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<OperationSlot *,OperationSlot *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAUOperationSlot@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUOperationSlot@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUOperationSlot@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUOperationSlot@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<OperationSlot *,OperationSlot *,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN1@Copy_opt
	push	esi
$LL3@Copy_opt:

; 2472 : 		*_Dest = *_First;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	add	ecx, 12					; 0000000cH
	add	eax, 12					; 0000000cH
	cmp	ecx, edx
	jne	SHORT $LL3@Copy_opt
	pop	esi
$LN1@Copy_opt:

; 2473 : 	return (_Dest);
; 2474 : 	}

	ret	0
??$_Copy_opt@PAUOperationSlot@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUOperationSlot@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<OperationSlot *,OperationSlot *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@XZ				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??0CvString@@QAE@XZ
_TEXT	SEGMENT
??0CvString@@QAE@XZ PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 23   : 	CvString() {}

	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, esi
	pop	esi
	ret	0
??0CvString@@QAE@XZ ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??0CvString@@QAE@PBD@Z				; CvString::CvString
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvString@@QAE@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??0CvString@@QAE@PBD@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 25   : 	CvString(const char* s) : std::string(s ? s : "") {CvAssertMsg(s != NULL, "Passing NULL to std::string; possible heap corruption!");}

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	jne	SHORT $LN4@CvString
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN4@CvString:
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@PBD@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
; Function compile flags: /Ogtpy
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	??BCvString@@QBEPBDXZ				; CvString::operator char const *
; Function compile flags: /Ogtpy
;	COMDAT ??BCvString@@QBEPBDXZ
_TEXT	SEGMENT
??BCvString@@QBEPBDXZ PROC				; CvString::operator char const *, COMDAT
; _this$ = ecx

; 31   : 	operator const char*() const 	{ return c_str(); }												

	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
??BCvString@@QBEPBDXZ ENDP				; CvString::operator char const *
_TEXT	ENDS
PUBLIC	??$_Fill@PAUOperationSlot@@U1@@std@@YAXPAUOperationSlot@@0ABU1@@Z ; std::_Fill<OperationSlot *,OperationSlot>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill@PAUOperationSlot@@U1@@std@@YAXPAUOperationSlot@@0ABU1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAUOperationSlot@@U1@@std@@YAXPAUOperationSlot@@0ABU1@@Z PROC ; std::_Fill<OperationSlot *,OperationSlot>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN1@Fill
	mov	ecx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	add	eax, 12					; 0000000cH
	cmp	eax, edx
	jne	SHORT $LL3@Fill
	pop	esi
$LN1@Fill:

; 3160 : 	}

	ret	0
??$_Fill@PAUOperationSlot@@U1@@std@@YAXPAUOperationSlot@@0ABU1@@Z ENDP ; std::_Fill<OperationSlot *,OperationSlot>
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@PBD@Z			; CvString::operator=
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??4CvString@@QAEAAV0@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@PBD@Z PROC				; CvString::operator=, COMDAT
; _this$ = ecx

; 37   : 	CvString& operator=( const char* s) { if (s) assign(s); else clear();	return *this; }	

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	je	SHORT $LN2@operator
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
$LN2@operator:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@PBD@Z ENDP				; CvString::operator=
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAUOperationSlot@@@std@@YA?AU_Undefined_move_tag@0@ABQAUOperationSlot@@@Z ; std::_Move_cat<OperationSlot *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Move_cat@PAUOperationSlot@@@std@@YA?AU_Undefined_move_tag@0@ABQAUOperationSlot@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAUOperationSlot@@@std@@YA?AU_Undefined_move_tag@0@ABQAUOperationSlot@@@Z PROC ; std::_Move_cat<OperationSlot *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAUOperationSlot@@@std@@YA?AU_Undefined_move_tag@0@ABQAUOperationSlot@@@Z ENDP ; std::_Move_cat<OperationSlot *>
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvString::operator=
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CvString::operator=, COMDAT
; _this$ = ecx

; 38   : 	CvString& operator=( const std::string& s) { assign(s.c_str());	return *this; }	

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _s$[esp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CvString::operator=
_TEXT	ENDS
PUBLIC	?GetCString@CvString@@QBEPBDXZ			; CvString::GetCString
; Function compile flags: /Ogtpy
;	COMDAT ?GetCString@CvString@@QBEPBDXZ
_TEXT	SEGMENT
?GetCString@CvString@@QBEPBDXZ PROC			; CvString::GetCString, COMDAT
; _this$ = ecx

; 42   : 	const char* GetCString() const 	{ return c_str(); }

	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetCString@CvString@@QBEPBDXZ ENDP			; CvString::GetCString
_TEXT	ENDS
PUBLIC	??0?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAE@H@Z ; std::_Temp_iterator<CvOperationSearchUnit>::_Temp_iterator<CvOperationSearchUnit>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??0?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAE@H@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
??0?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAE@H@Z PROC ; std::_Temp_iterator<CvOperationSearchUnit>::_Temp_iterator<CvOperationSearchUnit>, COMDAT
; _this$ = ecx

; 526  : 	_Temp_iterator(_PDFT _Count = 0)

	mov	eax, ecx

; 527  : 		{	// construct from desired temporary buffer size
; 528  : 		_Buf._Begin = 0;

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 529  : 		_Buf._Current = 0;

	mov	DWORD PTR [eax+4], ecx

; 530  : 		_Buf._Hiwater = 0;

	mov	DWORD PTR [eax+8], ecx

; 531  : 		_Buf._Size = _Count;	// memorize size for lazy allocation

	mov	ecx, DWORD PTR __Count$[esp-4]
	mov	DWORD PTR [eax+12], ecx

; 532  : 		_Pbuf = &_Buf;

	mov	DWORD PTR [eax+16], eax

; 533  : 		}

	ret	4
??0?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAE@H@Z ENDP ; std::_Temp_iterator<CvOperationSearchUnit>::_Temp_iterator<CvOperationSearchUnit>
_TEXT	ENDS
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__imp___vsnprintf:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
_buf$ = -2048						; size = 2048
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	sub	esp, 2048				; 00000800H
	push	ebx
	push	ebp

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	mov	ebp, DWORD PTR _args$[esp+2052]
	push	esi
	push	edi
	lea	edi, DWORD PTR _buf$[esp+2064]
	mov	esi, 2047				; 000007ffH
	npad	6
$LL10@formatv:

; 194  : 	int len = 0;
; 195  : 	int attempts = 0;
; 196  : 	bool success = false;
; 197  : 	const int kMaxAttempts = 40;
; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;
; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	eax, DWORD PTR _fmt$[esp+2060]
	push	ebp
	push	eax
	push	esi
	push	edi
	mov	ebx, esi
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H

; 203  : 		attempts++;

	add	esi, 2048				; 00000800H

; 204  : 		success = (len>=0 && len<=maxlen);

	test	eax, eax
	jl	SHORT $LN13@formatv
	cmp	eax, ebx
	jle	SHORT $LN18@formatv
$LN13@formatv:

; 205  : 		if (!success)
; 206  : 		{
; 207  : 			if (pbuf!=buf)

	lea	ecx, DWORD PTR _buf$[esp+2064]
	xor	bl, bl
	cmp	edi, ecx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	lea	edx, DWORD PTR [esi+1]
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	cmp	esi, 83967				; 000147ffH
	mov	edi, eax
	jl	SHORT $LL10@formatv

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN21@formatv:
	mov	ecx, DWORD PTR _out$[esp+2064]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 223  : 
; 224  : 	if (pbuf!=buf)

	lea	eax, DWORD PTR _buf$[esp+2064]
	cmp	edi, eax
	je	SHORT $LN20@formatv

; 225  : 		delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN20@formatv:
	pop	edi
	pop	esi
	pop	ebp

; 226  : 
; 227  : 	return success;

	mov	al, bl
	pop	ebx

; 228  : }

	add	esp, 2048				; 00000800H
	ret	0
$LN18@formatv:

; 204  : 		success = (len>=0 && len<=maxlen);

	mov	bl, 1

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)
; 220  : 		out = pbuf;

	push	edi

; 221  : 	else

	jmp	SHORT $LN21@formatv
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUOperationSlot@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUOperationSlot@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<OperationSlot *,OperationSlot *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_backward_opt@PAUOperationSlot@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUOperationSlot@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUOperationSlot@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUOperationSlot@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<OperationSlot *,OperationSlot *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw
	push	esi
$LL2@Copy_backw:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-12]
	sub	ecx, 12					; 0000000cH
	sub	eax, 12					; 0000000cH
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw
	pop	esi
$LN1@Copy_backw:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAUOperationSlot@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUOperationSlot@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<OperationSlot *,OperationSlot *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Construct@UOperationSlot@@U1@@std@@YAXPAUOperationSlot@@ABU1@@Z ; std::_Construct<OperationSlot,OperationSlot>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Construct@UOperationSlot@@U1@@std@@YAXPAUOperationSlot@@ABU1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UOperationSlot@@U1@@std@@YAXPAUOperationSlot@@ABU1@@Z PROC ; std::_Construct<OperationSlot,OperationSlot>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx
$LN3@Construct:

; 53   : 	}

	ret	0
??$_Construct@UOperationSlot@@U1@@std@@YAXPAUOperationSlot@@ABU1@@Z ENDP ; std::_Construct<OperationSlot,OperationSlot>
_TEXT	ENDS
PUBLIC	??$_Destroy@UOperationSlot@@@std@@YAXPAUOperationSlot@@@Z ; std::_Destroy<OperationSlot>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@UOperationSlot@@@std@@YAXPAUOperationSlot@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UOperationSlot@@@std@@YAXPAUOperationSlot@@@Z PROC ; std::_Destroy<OperationSlot>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@UOperationSlot@@@std@@YAXPAUOperationSlot@@@Z ENDP ; std::_Destroy<OperationSlot>
_TEXT	ENDS
PUBLIC	??$_Destroy@VCvOperationSearchUnit@@@std@@YAXPAVCvOperationSearchUnit@@@Z ; std::_Destroy<CvOperationSearchUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@VCvOperationSearchUnit@@@std@@YAXPAVCvOperationSearchUnit@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@VCvOperationSearchUnit@@@std@@YAXPAVCvOperationSearchUnit@@@Z PROC ; std::_Destroy<CvOperationSearchUnit>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@VCvOperationSearchUnit@@@std@@YAXPAVCvOperationSearchUnit@@@Z ENDP ; std::_Destroy<CvOperationSearchUnit>
_TEXT	ENDS
PUBLIC	??$return_temporary_buffer@VCvOperationSearchUnit@@@std@@YAXPAVCvOperationSearchUnit@@@Z ; std::return_temporary_buffer<CvOperationSearchUnit>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$return_temporary_buffer@VCvOperationSearchUnit@@@std@@YAXPAVCvOperationSearchUnit@@@Z
_TEXT	SEGMENT
__Pbuf$ = 8						; size = 4
??$return_temporary_buffer@VCvOperationSearchUnit@@@std@@YAXPAVCvOperationSearchUnit@@@Z PROC ; std::return_temporary_buffer<CvOperationSearchUnit>, COMDAT

; 39   : 	operator delete(_Pbuf);

	jmp	??3@YAXPAX@Z				; operator delete
??$return_temporary_buffer@VCvOperationSearchUnit@@@std@@YAXPAVCvOperationSearchUnit@@@Z ENDP ; std::return_temporary_buffer<CvOperationSearchUnit>
_TEXT	ENDS
PUBLIC	??MWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@QBE_NABU01@@Z ; CvWeightedVector<CvPlot *,1,1>::WeightedElement::operator<
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??MWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@QBE_NABU01@@Z
_TEXT	SEGMENT
_b2$ = 8						; size = 4
??MWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@QBE_NABU01@@Z PROC ; CvWeightedVector<CvPlot *,1,1>::WeightedElement::operator<, COMDAT
; _this$ = ecx

; 45   : 			// Reverse of the normal direction because we want highest weight first in our list
; 46   : 			return m_iWeight > b2.m_iWeight;

	mov	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _b2$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	setg	cl
	mov	al, cl

; 47   : 		};

	ret	4
??MWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@QBE_NABU01@@Z ENDP ; CvWeightedVector<CvPlot *,1,1>::WeightedElement::operator<
_TEXT	ENDS
PUBLIC	?Format@CvString@@QAAXPBDZZ			; CvString::Format
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?Format@CvString@@QAAXPBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0
__ehfuncinfo$?Format@CvString@@QAAXPBDZZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Format@CvString@@QAAXPBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?Format@CvString@@QAAXPBDZZ
_TEXT	SEGMENT
_result$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Format@CvString@@QAAXPBDZZ PROC			; CvString::Format, COMDAT

; 269  : {

	push	-1
	push	__ehhandler$?Format@CvString@@QAAXPBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH

; 270  : 	std::string result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 271  : 	va_list args;
; 272  : 	va_start(args,lpszFormat);
; 273  : 	formatv(result,lpszFormat,args);

	mov	ecx, DWORD PTR _lpszFormat$[esp+36]
	lea	eax, DWORD PTR _lpszFormat$[esp+40]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _result$[esp+48]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+60], 0
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 274  : 	va_end(args);
; 275  : 	*this = result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR _this$[esp+36]
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 276  : }

	lea	ecx, DWORD PTR _result$[esp+40]
	mov	DWORD PTR __$EHRec$[esp+48], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Format@CvString@@QAAXPBDZZ:
	mov	eax, OFFSET __ehfuncinfo$?Format@CvString@@QAAXPBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Format@CvString@@QAAXPBDZZ ENDP			; CvString::Format
PUBLIC	??0?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ; std::pair<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement *>::pair<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z PROC ; std::pair<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement *>::pair<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement *>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@std@@QAE@ABQAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ENDP ; std::pair<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement *>::pair<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Iter_cat@PAVCvOperationSearchUnit@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvOperationSearchUnit@@@Z ; std::_Iter_cat<CvOperationSearchUnit *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_cat@PAVCvOperationSearchUnit@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvOperationSearchUnit@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAVCvOperationSearchUnit@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvOperationSearchUnit@@@Z PROC ; std::_Iter_cat<CvOperationSearchUnit *>, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@PAVCvOperationSearchUnit@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvOperationSearchUnit@@@Z ENDP ; std::_Iter_cat<CvOperationSearchUnit *>
_TEXT	ENDS
PUBLIC	??$_Distance2@PAVCvOperationSearchUnit@@H@std@@YAXPAVCvOperationSearchUnit@@0AAHUrandom_access_iterator_tag@0@@Z ; std::_Distance2<CvOperationSearchUnit *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Distance2@PAVCvOperationSearchUnit@@H@std@@YAXPAVCvOperationSearchUnit@@0AAHUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Distance2@PAVCvOperationSearchUnit@@H@std@@YAXPAVCvOperationSearchUnit@@0AAHUrandom_access_iterator_tag@0@@Z PROC ; std::_Distance2<CvOperationSearchUnit *,int>, COMDAT

; 1867 : 
; 1868 :  #if _HAS_ITERATOR_DEBUGGING
; 1869 : 	if (_First != _Last)
; 1870 : 		{	// check for null pointers
; 1871 : 		_DEBUG_POINTER(_First);
; 1872 : 		_DEBUG_POINTER(_Last);
; 1873 : 		}
; 1874 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1875 : 
; 1876 : 	_Off += _Last - _First;

	mov	ecx, DWORD PTR __Last$[esp-4]
	sub	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Off$[esp-4]
	sar	ecx, 3
	add	DWORD PTR [eax], ecx

; 1877 : 	}

	ret	0
??$_Distance2@PAVCvOperationSearchUnit@@H@std@@YAXPAVCvOperationSearchUnit@@0AAHUrandom_access_iterator_tag@0@@Z ENDP ; std::_Distance2<CvOperationSearchUnit *,int>
_TEXT	ENDS
PUBLIC	??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@Z ; std::_Dist_type<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@Z PROC ; std::_Dist_type<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>, COMDAT

; 1831 : 	return (0);

	xor	eax, eax

; 1832 : 	}

	ret	0
??$_Dist_type@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAPAHPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@Z ENDP ; std::_Dist_type<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@Z ; std::_Val_type<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Val_type@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@Z PROC ; std::_Val_type<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>, COMDAT

; 1766 : 	return (0);

	xor	eax, eax

; 1767 : 	}

	ret	0
??$_Val_type@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@Z ENDP ; std::_Val_type<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	?_Init@?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAEAAV12@XZ ; std::_Temp_iterator<CvOperationSearchUnit>::_Init
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ?_Init@?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT
?_Init@?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAEAAV12@XZ PROC ; std::_Temp_iterator<CvOperationSearchUnit>::_Init, COMDAT
; _this$ = ecx

; 591  : 		{	// set pointer at beginning of buffer

	mov	eax, ecx

; 592  : 		_Pbuf->_Current = _Pbuf->_Begin;

	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], edx

; 593  : 		return (*this);
; 594  : 		}

	ret	0
?_Init@?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAEAAV12@XZ ENDP ; std::_Temp_iterator<CvOperationSearchUnit>::_Init
_TEXT	ENDS
PUBLIC	?_First@?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QBEPAVCvOperationSearchUnit@@XZ ; std::_Temp_iterator<CvOperationSearchUnit>::_First
; Function compile flags: /Ogtpy
;	COMDAT ?_First@?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QBEPAVCvOperationSearchUnit@@XZ
_TEXT	SEGMENT
?_First@?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QBEPAVCvOperationSearchUnit@@XZ PROC ; std::_Temp_iterator<CvOperationSearchUnit>::_First, COMDAT
; _this$ = ecx

; 598  : 		return (_Pbuf->_Begin);

	mov	eax, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax]

; 599  : 		}

	ret	0
?_First@?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QBEPAVCvOperationSearchUnit@@XZ ENDP ; std::_Temp_iterator<CvOperationSearchUnit>::_First
_TEXT	ENDS
PUBLIC	?_Last@?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QBEPAVCvOperationSearchUnit@@XZ ; std::_Temp_iterator<CvOperationSearchUnit>::_Last
; Function compile flags: /Ogtpy
;	COMDAT ?_Last@?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QBEPAVCvOperationSearchUnit@@XZ
_TEXT	SEGMENT
?_Last@?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QBEPAVCvOperationSearchUnit@@XZ PROC ; std::_Temp_iterator<CvOperationSearchUnit>::_Last, COMDAT
; _this$ = ecx

; 603  : 		return (_Pbuf->_Current);

	mov	eax, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [eax+4]

; 604  : 		}

	ret	0
?_Last@?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QBEPAVCvOperationSearchUnit@@XZ ENDP ; std::_Temp_iterator<CvOperationSearchUnit>::_Last
_TEXT	ENDS
PUBLIC	??0?$pair@PAVCvOperationSearchUnit@@H@std@@QAE@ABQAVCvOperationSearchUnit@@ABH@Z ; std::pair<CvOperationSearchUnit *,int>::pair<CvOperationSearchUnit *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@PAVCvOperationSearchUnit@@H@std@@QAE@ABQAVCvOperationSearchUnit@@ABH@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@PAVCvOperationSearchUnit@@H@std@@QAE@ABQAVCvOperationSearchUnit@@ABH@Z PROC ; std::pair<CvOperationSearchUnit *,int>::pair<CvOperationSearchUnit *,int>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@PAVCvOperationSearchUnit@@H@std@@QAE@ABQAVCvOperationSearchUnit@@ABH@Z ENDP ; std::pair<CvOperationSearchUnit *,int>::pair<CvOperationSearchUnit *,int>
_TEXT	ENDS
PUBLIC	??4?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAEAAV01@ABV01@@Z ; std::_Temp_iterator<CvOperationSearchUnit>::operator=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??4?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Temp_iterator<CvOperationSearchUnit>::operator=, COMDAT
; _this$ = ecx

; 556  : 		{	// assign _Right (share active buffer)

	mov	eax, ecx

; 557  : 		_Pbuf = _Right._Pbuf;

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 558  : 		return (*this);
; 559  : 		}

	ret	4
??4?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Temp_iterator<CvOperationSearchUnit>::operator=
_TEXT	ENDS
PUBLIC	??$_Advance@PAVCvOperationSearchUnit@@H@std@@YAXAAPAVCvOperationSearchUnit@@HUrandom_access_iterator_tag@0@@Z ; std::_Advance<CvOperationSearchUnit *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Advance@PAVCvOperationSearchUnit@@H@std@@YAXAAPAVCvOperationSearchUnit@@HUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Advance@PAVCvOperationSearchUnit@@H@std@@YAXAAPAVCvOperationSearchUnit@@HUrandom_access_iterator_tag@0@@Z PROC ; std::_Advance<CvOperationSearchUnit *,int>, COMDAT

; 1822 : 	_Where += _Off;

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [eax*8]
	mov	eax, DWORD PTR __Where$[esp-4]
	add	DWORD PTR [eax], ecx

; 1823 : 	}

	ret	0
??$_Advance@PAVCvOperationSearchUnit@@H@std@@YAXAAPAVCvOperationSearchUnit@@HUrandom_access_iterator_tag@0@@Z ENDP ; std::_Advance<CvOperationSearchUnit *,int>
_TEXT	ENDS
PUBLIC	??$swap@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ; std::swap<CvWeightedVector<CvPlot *,1,1>::WeightedElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$swap@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z PROC ; std::swap<CvWeightedVector<CvPlot *,1,1>::WeightedElement>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi

; 21   : 
; 22   : 		_Left = _Right;

	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	pop	edi

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx], edx
	pop	esi
$LN1@swap:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXAAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ENDP ; std::swap<CvWeightedVector<CvPlot *,1,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$swap@VCvOperationSearchUnit@@@std@@YAXAAVCvOperationSearchUnit@@0@Z ; std::swap<CvOperationSearchUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??$swap@VCvOperationSearchUnit@@@std@@YAXAAVCvOperationSearchUnit@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@VCvOperationSearchUnit@@@std@@YAXAAVCvOperationSearchUnit@@0@Z PROC ; std::swap<CvOperationSearchUnit>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap@2

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi

; 21   : 
; 22   : 		_Left = _Right;

	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	pop	edi

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx], edx
	pop	esi
$LN1@swap@2:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@VCvOperationSearchUnit@@@std@@YAXAAVCvOperationSearchUnit@@0@Z ENDP ; std::swap<CvOperationSearchUnit>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvOperationSearchUnit@@ABV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z ; std::_Iter_random<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvOperationSearchUnit@@ABV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvOperationSearchUnit@@ABV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z PROC ; std::_Iter_random<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit> >, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvOperationSearchUnit@@ABV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z ENDP ; std::_Iter_random<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvOperationSearchUnit@@AAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z ; std::_Ptr_cat<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvOperationSearchUnit@@AAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvOperationSearchUnit@@AAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z PROC ; std::_Ptr_cat<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit> >, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvOperationSearchUnit@@AAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z ENDP ; std::_Ptr_cat<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit> >
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvOperationSearchUnit@@PAV1@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvOperationSearchUnit@@00@Z ; std::_Iter_random<CvOperationSearchUnit *,CvOperationSearchUnit *,CvOperationSearchUnit *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_random@PAVCvOperationSearchUnit@@PAV1@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvOperationSearchUnit@@00@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Iter_random@PAVCvOperationSearchUnit@@PAV1@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvOperationSearchUnit@@00@Z PROC ; std::_Iter_random<CvOperationSearchUnit *,CvOperationSearchUnit *,CvOperationSearchUnit *>, COMDAT

; 1007 : 	typename _Iter_random_helper3<
; 1008 : 		iterator_traits<_Iter1>::iterator_category, 
; 1009 : 		iterator_traits<_Iter2>::iterator_category,
; 1010 : 		iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat _Cat;
; 1011 : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1012 : 	}

	ret	0
??$_Iter_random@PAVCvOperationSearchUnit@@PAV1@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvOperationSearchUnit@@00@Z ENDP ; std::_Iter_random<CvOperationSearchUnit *,CvOperationSearchUnit *,CvOperationSearchUnit *>
_TEXT	ENDS
PUBLIC	??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HHU12@@Z ; std::_Push_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HHU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Top$ = 16						; size = 4
__Val$ = 20						; size = 8
??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HHU12@@Z PROC ; std::_Push_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>, COMDAT

; 1973 : 	for (_Diff _Idx = (_Hole - 1) / 2;

	mov	ecx, DWORD PTR __Hole$[esp-4]
	push	ebx

; 1974 : 		_Top < _Hole && _DEBUG_LT(*(_First + _Idx), _Val);
; 1975 : 		_Idx = (_Hole - 1) / 2)

	mov	ebx, DWORD PTR __Val$[esp+4]
	lea	eax, DWORD PTR [ecx-1]
	cdq
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]
	sub	eax, edx
	push	edi
	mov	edi, DWORD PTR __Top$[esp+8]
	sar	eax, 1
	cmp	edi, ecx
	jge	SHORT $LN1@Push_heap
	npad	1
$LL3@Push_heap:
	cmp	DWORD PTR [esi+eax*8+4], ebx
	jle	SHORT $LN1@Push_heap

; 1976 : 		{	// move _Hole up to parent
; 1977 : 		*(_First + _Hole) = *(_First + _Idx);

	mov	edx, DWORD PTR [esi+eax*8]
	mov	DWORD PTR [esi+ecx*8], edx
	mov	edx, DWORD PTR [esi+eax*8+4]
	mov	DWORD PTR [esi+ecx*8+4], edx

; 1978 : 		_Hole = _Idx;

	mov	ecx, eax
	dec	eax
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	edi, ecx
	jl	SHORT $LL3@Push_heap
$LN1@Push_heap:

; 1979 : 		}
; 1980 : 
; 1981 : 	*(_First + _Hole) = _Val;	// drop _Val into final hole

	mov	eax, DWORD PTR __Val$[esp+8]
	pop	edi
	mov	DWORD PTR [esi+ecx*8+4], ebx
	mov	DWORD PTR [esi+ecx*8], eax
	pop	esi
	pop	ebx

; 1982 : 	}

	ret	0
??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HHU12@@Z ENDP ; std::_Push_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ; std::_Iter_random<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z PROC ; std::_Iter_random<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ENDP ; std::_Iter_random<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ; std::_Ptr_cat<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z PROC ; std::_Ptr_cat<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ENDP ; std::_Ptr_cat<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw@2
	push	esi
$LL2@Copy_backw@2:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw@2
	pop	esi
$LN1@Copy_backw@2:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@Urandom_access_iterator_tag@std@@@std@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??D?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAEAAV01@XZ ; std::_Temp_iterator<CvOperationSearchUnit>::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??D?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??D?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAEAAV01@XZ PROC ; std::_Temp_iterator<CvOperationSearchUnit>::operator*, COMDAT
; _this$ = ecx

; 576  : 		{	// pretend to return designated value

	mov	eax, ecx

; 577  : 		return (*this);
; 578  : 		}

	ret	0
??D?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAEAAV01@XZ ENDP ; std::_Temp_iterator<CvOperationSearchUnit>::operator*
_TEXT	ENDS
PUBLIC	??E?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAEAAV01@XZ ; std::_Temp_iterator<CvOperationSearchUnit>::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAEAAV01@XZ PROC ; std::_Temp_iterator<CvOperationSearchUnit>::operator++, COMDAT
; _this$ = ecx

; 581  : 		{	// pretend to preincrement

	mov	eax, ecx

; 582  : 		return (*this);
; 583  : 		}

	ret	0
??E?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAEAAV01@XZ ENDP ; std::_Temp_iterator<CvOperationSearchUnit>::operator++
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvOperationSearchUnit@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvOperationSearchUnit@@0@Z ; std::_Iter_random<CvOperationSearchUnit *,CvOperationSearchUnit *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAVCvOperationSearchUnit@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvOperationSearchUnit@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAVCvOperationSearchUnit@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvOperationSearchUnit@@0@Z PROC ; std::_Iter_random<CvOperationSearchUnit *,CvOperationSearchUnit *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAVCvOperationSearchUnit@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvOperationSearchUnit@@0@Z ENDP ; std::_Iter_random<CvOperationSearchUnit *,CvOperationSearchUnit *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAVCvOperationSearchUnit@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvOperationSearchUnit@@0@Z ; std::_Ptr_cat<CvOperationSearchUnit *,CvOperationSearchUnit *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAVCvOperationSearchUnit@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvOperationSearchUnit@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCvOperationSearchUnit@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvOperationSearchUnit@@0@Z PROC ; std::_Ptr_cat<CvOperationSearchUnit *,CvOperationSearchUnit *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAVCvOperationSearchUnit@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvOperationSearchUnit@@0@Z ENDP ; std::_Ptr_cat<CvOperationSearchUnit *,CvOperationSearchUnit *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAVCvOperationSearchUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvOperationSearchUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvOperationSearchUnit *,CvOperationSearchUnit *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAVCvOperationSearchUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvOperationSearchUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAVCvOperationSearchUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvOperationSearchUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvOperationSearchUnit *,CvOperationSearchUnit *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw@3
	push	esi
$LL2@Copy_backw@3:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw@3
	pop	esi
$LN1@Copy_backw@3:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAVCvOperationSearchUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvOperationSearchUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvOperationSearchUnit *,CvOperationSearchUnit *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAVCvOperationSearchUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvOperationSearchUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvOperationSearchUnit *,CvOperationSearchUnit *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAVCvOperationSearchUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvOperationSearchUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAVCvOperationSearchUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvOperationSearchUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvOperationSearchUnit *,CvOperationSearchUnit *,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN1@Copy_opt@2
	push	esi
$LL3@Copy_opt@2:

; 2472 : 		*_Dest = *_First;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	add	ecx, 8
	add	eax, 8
	cmp	ecx, edx
	jne	SHORT $LL3@Copy_opt@2
	pop	esi
$LN1@Copy_opt@2:

; 2473 : 	return (_Dest);
; 2474 : 	}

	ret	0
??$_Copy_opt@PAVCvOperationSearchUnit@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvOperationSearchUnit@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvOperationSearchUnit *,CvOperationSearchUnit *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Construct@VCvOperationSearchUnit@@V1@@std@@YAXPAVCvOperationSearchUnit@@ABV1@@Z ; std::_Construct<CvOperationSearchUnit,CvOperationSearchUnit>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Construct@VCvOperationSearchUnit@@V1@@std@@YAXPAVCvOperationSearchUnit@@ABV1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@VCvOperationSearchUnit@@V1@@std@@YAXPAVCvOperationSearchUnit@@ABV1@@Z PROC ; std::_Construct<CvOperationSearchUnit,CvOperationSearchUnit>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct@2
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN3@Construct@2:

; 53   : 	}

	ret	0
??$_Construct@VCvOperationSearchUnit@@V1@@std@@YAXPAVCvOperationSearchUnit@@ABV1@@Z ENDP ; std::_Construct<CvOperationSearchUnit,CvOperationSearchUnit>
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvOperationSearchUnit@@PAV1@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvOperationSearchUnit@@0ABV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z ; std::_Iter_random<CvOperationSearchUnit *,CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAVCvOperationSearchUnit@@PAV1@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvOperationSearchUnit@@0ABV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Iter_random@PAVCvOperationSearchUnit@@PAV1@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvOperationSearchUnit@@0ABV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z PROC ; std::_Iter_random<CvOperationSearchUnit *,CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit> >, COMDAT

; 1007 : 	typename _Iter_random_helper3<
; 1008 : 		iterator_traits<_Iter1>::iterator_category, 
; 1009 : 		iterator_traits<_Iter2>::iterator_category,
; 1010 : 		iterator_traits<_Iter3>::iterator_category>::_Iter_random_cat _Cat;
; 1011 : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1012 : 	}

	ret	0
??$_Iter_random@PAVCvOperationSearchUnit@@PAV1@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@std@@YA?AUforward_iterator_tag@0@ABQAVCvOperationSearchUnit@@0ABV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z ENDP ; std::_Iter_random<CvOperationSearchUnit *,CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit> >
_TEXT	ENDS
PUBLIC	??$_Rotate@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@00PAH0@Z ; std::_Rotate<CvOperationSearchUnit *,int,CvOperationSearchUnit>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Rotate@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@00PAH0@Z
_TEXT	SEGMENT
__Holeval$229599 = -8					; size = 8
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Rotate@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@00PAH0@Z PROC ; std::_Rotate<CvOperationSearchUnit *,int,CvOperationSearchUnit>, COMDAT

; 1679 : 	{	// rotate [_First, _Last), random-access iterators

	sub	esp, 8
	push	ebx

; 1680 : 	_DEBUG_RANGE(_First, _Mid);
; 1681 : 	_DEBUG_RANGE(_Mid, _Last);
; 1682 : 	_Diff _Shift = _Mid - _First;

	mov	ebx, DWORD PTR __Mid$[esp+8]
	push	ebp

; 1683 : 	_Diff _Count = _Last - _First;

	mov	ebp, DWORD PTR __Last$[esp+12]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+20]
	sub	ebx, edi
	mov	ecx, ebp
	sub	ecx, edi
	sar	ebx, 3
	sar	ecx, 3
	mov	eax, ecx

; 1684 : 
; 1685 : 	for (_Diff _Factor = _Shift; _Factor != 0; )

	mov	esi, ebx
	test	ebx, ebx
	je	SHORT $LN7@Rotate
$LL8@Rotate:

; 1686 : 		{	// find subcycle count as GCD of shift count and length
; 1687 : 		_Diff _Tmp = _Count % _Factor;

	cdq
	idiv	esi

; 1688 : 		_Count = _Factor, _Factor = _Tmp;

	mov	eax, esi
	mov	esi, edx
	test	edx, edx
	jne	SHORT $LL8@Rotate
$LN7@Rotate:

; 1689 : 		}
; 1690 : 
; 1691 : 	if (_Count < _Last - _First)

	cmp	eax, ecx
	jge	SHORT $LN3@Rotate

; 1692 : 		for (; 0 < _Count; --_Count)

	test	eax, eax
	jle	SHORT $LN3@Rotate
	lea	edi, DWORD PTR [edi+eax*8]
	npad	3
$LL5@Rotate:

; 1693 : 			{	// rotate each subcycle
; 1694 : 			_RanIt _Hole = _First + _Count;
; 1695 : 			_RanIt _Next = _Hole;
; 1696 : 			_Ty _Holeval = *_Hole;

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [edi+4]
	mov	DWORD PTR __Holeval$229599[esp+24], ecx

; 1697 : 			_RanIt _Next1 = _Next + _Shift == _Last ? _First : _Next + _Shift;

	lea	ecx, DWORD PTR [edi+ebx*8]
	mov	esi, edi
	mov	DWORD PTR __Holeval$229599[esp+28], edx
	cmp	ecx, ebp
	jne	SHORT $LN11@Rotate
	mov	ecx, DWORD PTR __First$[esp+20]
$LN11@Rotate:

; 1698 : 			while (_Next1 != _Hole)

	cmp	ecx, edi
	je	SHORT $LN1@Rotate
	npad	2
$LL2@Rotate:

; 1699 : 				{	// percolate elements back around subcycle
; 1700 : 				*_Next = *_Next1;

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [esi], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+4], edx

; 1701 : 				_Next = _Next1;
; 1702 : 				_Next1 = _Shift < _Last - _Next1 ? _Next1 + _Shift
; 1703 : 					: _First + (_Shift - (_Last - _Next1));

	mov	edx, ebp
	sub	edx, ecx
	sar	edx, 3
	cmp	ebx, edx
	mov	esi, ecx
	jge	SHORT $LN13@Rotate
	lea	edx, DWORD PTR [ebx*8]
	add	ecx, edx
	jmp	SHORT $LN14@Rotate
$LN13@Rotate:
	mov	ecx, ebx
	sub	ecx, edx
	mov	edx, DWORD PTR __First$[esp+20]
	lea	ecx, DWORD PTR [edx+ecx*8]
$LN14@Rotate:

; 1698 : 			while (_Next1 != _Hole)

	cmp	ecx, edi
	jne	SHORT $LL2@Rotate
$LN1@Rotate:

; 1704 : 				}
; 1705 : 			*_Next = _Holeval;

	mov	ecx, DWORD PTR __Holeval$229599[esp+24]
	mov	edx, DWORD PTR __Holeval$229599[esp+28]
	dec	eax
	sub	edi, 8
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [esi+4], edx
	test	eax, eax
	jg	SHORT $LL5@Rotate
$LN3@Rotate:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1706 : 			}
; 1707 : 	}

	add	esp, 8
	ret	0
??$_Rotate@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@00PAH0@Z ENDP ; std::_Rotate<CvOperationSearchUnit *,int,CvOperationSearchUnit>
_TEXT	ENDS
PUBLIC	?GetID@CvBaseInfo@@QBEHXZ			; CvBaseInfo::GetID
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
;	COMDAT ?GetID@CvBaseInfo@@QBEHXZ
_TEXT	SEGMENT
?GetID@CvBaseInfo@@QBEHXZ PROC				; CvBaseInfo::GetID, COMDAT
; _this$ = ecx

; 54   : 		return m_iID;

	mov	eax, DWORD PTR [ecx+4]

; 55   : 	}

	ret	0
?GetID@CvBaseInfo@@QBEHXZ ENDP				; CvBaseInfo::GetID
_TEXT	ENDS
PUBLIC	?getMap@CvGlobals@@QAEAAVCvMap@@XZ		; CvGlobals::getMap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMap@CvGlobals@@QAEAAVCvMap@@XZ
_TEXT	SEGMENT
?getMap@CvGlobals@@QAEAAVCvMap@@XZ PROC			; CvGlobals::getMap, COMDAT
; _this$ = ecx

; 175  : 		return *m_map;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+52]

; 176  : 	}

	ret	0
?getMap@CvGlobals@@QAEAAVCvMap@@XZ ENDP			; CvGlobals::getMap
_TEXT	ENDS
PUBLIC	?getGame@CvGlobals@@QAEAAVCvGame@@XZ		; CvGlobals::getGame
; Function compile flags: /Ogtpy
;	COMDAT ?getGame@CvGlobals@@QAEAAVCvGame@@XZ
_TEXT	SEGMENT
?getGame@CvGlobals@@QAEAAVCvGame@@XZ PROC		; CvGlobals::getGame, COMDAT
; _this$ = ecx

; 183  : 		return *m_game;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+48]

; 184  : 	}

	ret	0
?getGame@CvGlobals@@QAEAAVCvGame@@XZ ENDP		; CvGlobals::getGame
_TEXT	ENDS
PUBLIC	?getPlotDirectionX@CvGlobals@@QAEPAHXZ		; CvGlobals::getPlotDirectionX
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotDirectionX@CvGlobals@@QAEPAHXZ
_TEXT	SEGMENT
?getPlotDirectionX@CvGlobals@@QAEPAHXZ PROC		; CvGlobals::getPlotDirectionX, COMDAT
; _this$ = ecx

; 191  : 		return m_aiPlotDirectionX;

	lea	eax, DWORD PTR [ecx+112]

; 192  : 	}

	ret	0
?getPlotDirectionX@CvGlobals@@QAEPAHXZ ENDP		; CvGlobals::getPlotDirectionX
_TEXT	ENDS
PUBLIC	?getPlotDirectionY@CvGlobals@@QAEPAHXZ		; CvGlobals::getPlotDirectionY
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotDirectionY@CvGlobals@@QAEPAHXZ
_TEXT	SEGMENT
?getPlotDirectionY@CvGlobals@@QAEPAHXZ PROC		; CvGlobals::getPlotDirectionY, COMDAT
; _this$ = ecx

; 195  : 		return m_aiPlotDirectionY;

	lea	eax, DWORD PTR [ecx+136]

; 196  : 	}

	ret	0
?getPlotDirectionY@CvGlobals@@QAEPAHXZ ENDP		; CvGlobals::getPlotDirectionY
_TEXT	ENDS
PUBLIC	?getAI_OPERATIONAL_BARBARIAN_CAMP_DEPLOY_RANGE@CvGlobals@@QAEHXZ ; CvGlobals::getAI_OPERATIONAL_BARBARIAN_CAMP_DEPLOY_RANGE
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_OPERATIONAL_BARBARIAN_CAMP_DEPLOY_RANGE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_OPERATIONAL_BARBARIAN_CAMP_DEPLOY_RANGE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_OPERATIONAL_BARBARIAN_CAMP_DEPLOY_RANGE, COMDAT
; _this$ = ecx

; 1481 : 		return m_iAI_OPERATIONAL_BARBARIAN_CAMP_DEPLOY_RANGE;

	mov	eax, DWORD PTR [ecx+2416]

; 1482 : 	}

	ret	0
?getAI_OPERATIONAL_BARBARIAN_CAMP_DEPLOY_RANGE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_OPERATIONAL_BARBARIAN_CAMP_DEPLOY_RANGE
_TEXT	ENDS
PUBLIC	?getAI_OPERATIONAL_CITY_ATTACK_DEPLOY_RANGE@CvGlobals@@QAEHXZ ; CvGlobals::getAI_OPERATIONAL_CITY_ATTACK_DEPLOY_RANGE
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_OPERATIONAL_CITY_ATTACK_DEPLOY_RANGE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_OPERATIONAL_CITY_ATTACK_DEPLOY_RANGE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_OPERATIONAL_CITY_ATTACK_DEPLOY_RANGE, COMDAT
; _this$ = ecx

; 1485 : 		return m_iAI_OPERATIONAL_CITY_ATTACK_DEPLOY_RANGE;

	mov	eax, DWORD PTR [ecx+2420]

; 1486 : 	}

	ret	0
?getAI_OPERATIONAL_CITY_ATTACK_DEPLOY_RANGE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_OPERATIONAL_CITY_ATTACK_DEPLOY_RANGE
_TEXT	ENDS
PUBLIC	?getAI_OPERATIONAL_PILLAGE_ENEMY_DEPLOY_RANGE@CvGlobals@@QAEHXZ ; CvGlobals::getAI_OPERATIONAL_PILLAGE_ENEMY_DEPLOY_RANGE
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_OPERATIONAL_PILLAGE_ENEMY_DEPLOY_RANGE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_OPERATIONAL_PILLAGE_ENEMY_DEPLOY_RANGE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_OPERATIONAL_PILLAGE_ENEMY_DEPLOY_RANGE, COMDAT
; _this$ = ecx

; 1489 : 		return m_iAI_OPERATIONAL_PILLAGE_ENEMY_DEPLOY_RANGE;

	mov	eax, DWORD PTR [ecx+2424]

; 1490 : 	}

	ret	0
?getAI_OPERATIONAL_PILLAGE_ENEMY_DEPLOY_RANGE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_OPERATIONAL_PILLAGE_ENEMY_DEPLOY_RANGE
_TEXT	ENDS
PUBLIC	?getAI_OPERATIONAL_NAVAL_BOMBARDMENT_DEPLOY_RANGE@CvGlobals@@QAEHXZ ; CvGlobals::getAI_OPERATIONAL_NAVAL_BOMBARDMENT_DEPLOY_RANGE
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_OPERATIONAL_NAVAL_BOMBARDMENT_DEPLOY_RANGE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_OPERATIONAL_NAVAL_BOMBARDMENT_DEPLOY_RANGE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_OPERATIONAL_NAVAL_BOMBARDMENT_DEPLOY_RANGE, COMDAT
; _this$ = ecx

; 1493 : 		return m_iAI_OPERATIONAL_NAVAL_BOMBARDMENT_DEPLOY_RANGE;

	mov	eax, DWORD PTR [ecx+2428]

; 1494 : 	}

	ret	0
?getAI_OPERATIONAL_NAVAL_BOMBARDMENT_DEPLOY_RANGE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_OPERATIONAL_NAVAL_BOMBARDMENT_DEPLOY_RANGE
_TEXT	ENDS
PUBLIC	?getAI_OPERATIONAL_PERCENT_DANGER_FOR_FORWARD_MUSTER@CvGlobals@@QAEHXZ ; CvGlobals::getAI_OPERATIONAL_PERCENT_DANGER_FOR_FORWARD_MUSTER
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_OPERATIONAL_PERCENT_DANGER_FOR_FORWARD_MUSTER@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_OPERATIONAL_PERCENT_DANGER_FOR_FORWARD_MUSTER@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_OPERATIONAL_PERCENT_DANGER_FOR_FORWARD_MUSTER, COMDAT
; _this$ = ecx

; 1497 : 		return m_iAI_OPERATIONAL_PERCENT_DANGER_FOR_FORWARD_MUSTER;

	mov	eax, DWORD PTR [ecx+2432]

; 1498 : 	}

	ret	0
?getAI_OPERATIONAL_PERCENT_DANGER_FOR_FORWARD_MUSTER@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_OPERATIONAL_PERCENT_DANGER_FOR_FORWARD_MUSTER
_TEXT	ENDS
PUBLIC	?getAI_OPERATIONAL_PERCENT_HEALTH_FOR_OPERATION@CvGlobals@@QAEHXZ ; CvGlobals::getAI_OPERATIONAL_PERCENT_HEALTH_FOR_OPERATION
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_OPERATIONAL_PERCENT_HEALTH_FOR_OPERATION@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_OPERATIONAL_PERCENT_HEALTH_FOR_OPERATION@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_OPERATIONAL_PERCENT_HEALTH_FOR_OPERATION, COMDAT
; _this$ = ecx

; 1501 : 		return m_iAI_OPERATIONAL_PERCENT_HEALTH_FOR_OPERATION;

	mov	eax, DWORD PTR [ecx+2436]

; 1502 : 	}

	ret	0
?getAI_OPERATIONAL_PERCENT_HEALTH_FOR_OPERATION@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_OPERATIONAL_PERCENT_HEALTH_FOR_OPERATION
_TEXT	ENDS
PUBLIC	?getAI_TACTICAL_MAP_TEMP_ZONE_TURNS@CvGlobals@@QAEHXZ ; CvGlobals::getAI_TACTICAL_MAP_TEMP_ZONE_TURNS
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_TACTICAL_MAP_TEMP_ZONE_TURNS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_TACTICAL_MAP_TEMP_ZONE_TURNS@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_TACTICAL_MAP_TEMP_ZONE_TURNS, COMDAT
; _this$ = ecx

; 1517 : 		return m_iAI_TACTICAL_MAP_TEMP_ZONE_TURNS;

	mov	eax, DWORD PTR [ecx+2452]

; 1518 : 	}

	ret	0
?getAI_TACTICAL_MAP_TEMP_ZONE_TURNS@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_TACTICAL_MAP_TEMP_ZONE_TURNS
_TEXT	ENDS
PUBLIC	?getAI_TACTICAL_MAP_BOMBARDMENT_ZONE_TURNS@CvGlobals@@QAEHXZ ; CvGlobals::getAI_TACTICAL_MAP_BOMBARDMENT_ZONE_TURNS
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_TACTICAL_MAP_BOMBARDMENT_ZONE_TURNS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_TACTICAL_MAP_BOMBARDMENT_ZONE_TURNS@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_TACTICAL_MAP_BOMBARDMENT_ZONE_TURNS, COMDAT
; _this$ = ecx

; 1521 : 		return m_iAI_TACTICAL_MAP_BOMBARDMENT_ZONE_TURNS;

	mov	eax, DWORD PTR [ecx+2456]

; 1522 : 	}

	ret	0
?getAI_TACTICAL_MAP_BOMBARDMENT_ZONE_TURNS@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_TACTICAL_MAP_BOMBARDMENT_ZONE_TURNS
_TEXT	ENDS
PUBLIC	?getAI_HOMELAND_ESTIMATE_TURNS_DISTANCE@CvGlobals@@QAEHXZ ; CvGlobals::getAI_HOMELAND_ESTIMATE_TURNS_DISTANCE
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_HOMELAND_ESTIMATE_TURNS_DISTANCE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_HOMELAND_ESTIMATE_TURNS_DISTANCE@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_HOMELAND_ESTIMATE_TURNS_DISTANCE, COMDAT
; _this$ = ecx

; 1637 : 		return m_iAI_HOMELAND_ESTIMATE_TURNS_DISTANCE;

	mov	eax, DWORD PTR [ecx+2572]

; 1638 : 	}

	ret	0
?getAI_HOMELAND_ESTIMATE_TURNS_DISTANCE@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_HOMELAND_ESTIMATE_TURNS_DISTANCE
_TEXT	ENDS
PUBLIC	?getNUKE_BLAST_RADIUS@CvGlobals@@QAEHXZ		; CvGlobals::getNUKE_BLAST_RADIUS
; Function compile flags: /Ogtpy
;	COMDAT ?getNUKE_BLAST_RADIUS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNUKE_BLAST_RADIUS@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNUKE_BLAST_RADIUS, COMDAT
; _this$ = ecx

; 5748 : 		return m_iNUKE_BLAST_RADIUS;

	mov	eax, DWORD PTR [ecx+6672]

; 5749 : 	}

	ret	0
?getNUKE_BLAST_RADIUS@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNUKE_BLAST_RADIUS
_TEXT	ENDS
PUBLIC	?getAI_OPERATIONAL_MAX_RECRUIT_TURNS_DEFAULT@CvGlobals@@QAEHXZ ; CvGlobals::getAI_OPERATIONAL_MAX_RECRUIT_TURNS_DEFAULT
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_OPERATIONAL_MAX_RECRUIT_TURNS_DEFAULT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_OPERATIONAL_MAX_RECRUIT_TURNS_DEFAULT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_OPERATIONAL_MAX_RECRUIT_TURNS_DEFAULT, COMDAT
; _this$ = ecx

; 6981 : 		return m_iAI_OPERATIONAL_MAX_RECRUIT_TURNS_DEFAULT;

	mov	eax, DWORD PTR [ecx+7852]

; 6982 : 	}

	ret	0
?getAI_OPERATIONAL_MAX_RECRUIT_TURNS_DEFAULT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_OPERATIONAL_MAX_RECRUIT_TURNS_DEFAULT
_TEXT	ENDS
PUBLIC	?getAI_OPERATIONAL_MAX_RECRUIT_TURNS_ENEMY_TERRITORY@CvGlobals@@QAEHXZ ; CvGlobals::getAI_OPERATIONAL_MAX_RECRUIT_TURNS_ENEMY_TERRITORY
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_OPERATIONAL_MAX_RECRUIT_TURNS_ENEMY_TERRITORY@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_OPERATIONAL_MAX_RECRUIT_TURNS_ENEMY_TERRITORY@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_OPERATIONAL_MAX_RECRUIT_TURNS_ENEMY_TERRITORY, COMDAT
; _this$ = ecx

; 6985 : 		return m_iAI_OPERATIONAL_MAX_RECRUIT_TURNS_ENEMY_TERRITORY;

	mov	eax, DWORD PTR [ecx+7856]

; 6986 : 	}

	ret	0
?getAI_OPERATIONAL_MAX_RECRUIT_TURNS_ENEMY_TERRITORY@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_OPERATIONAL_MAX_RECRUIT_TURNS_ENEMY_TERRITORY
_TEXT	ENDS
PUBLIC	?getBARBARIAN_CAMP_IMPROVEMENT@CvGlobals@@QAEHXZ ; CvGlobals::getBARBARIAN_CAMP_IMPROVEMENT
; Function compile flags: /Ogtpy
;	COMDAT ?getBARBARIAN_CAMP_IMPROVEMENT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getBARBARIAN_CAMP_IMPROVEMENT@CvGlobals@@QAEHXZ PROC	; CvGlobals::getBARBARIAN_CAMP_IMPROVEMENT, COMDAT
; _this$ = ecx

; 7355 : 		return m_iBARBARIAN_CAMP_IMPROVEMENT;

	mov	eax, DWORD PTR [ecx+8548]

; 7356 : 	}

	ret	0
?getBARBARIAN_CAMP_IMPROVEMENT@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getBARBARIAN_CAMP_IMPROVEMENT
_TEXT	ENDS
PUBLIC	??0OperationSlot@@QAE@XZ			; OperationSlot::OperationSlot
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
;	COMDAT ??0OperationSlot@@QAE@XZ
_TEXT	SEGMENT
??0OperationSlot@@QAE@XZ PROC				; OperationSlot::OperationSlot, COMDAT
; _this$ = ecx

; 94   : 	OperationSlot()

	mov	eax, ecx

; 95   : 	{
; 96   : 		m_iOperationID = -1;

	or	ecx, -1
	mov	DWORD PTR [eax], ecx

; 97   : 		m_iArmyID = FFreeList::INVALID_INDEX;

	mov	DWORD PTR [eax+4], ecx

; 98   : 		m_iSlotID = -1;

	mov	DWORD PTR [eax+8], ecx

; 99   : 	}

	ret	0
??0OperationSlot@@QAE@XZ ENDP				; OperationSlot::OperationSlot
_TEXT	ENDS
PUBLIC	??8OperationSlot@@QBE_NABU0@@Z			; OperationSlot::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8OperationSlot@@QBE_NABU0@@Z
_TEXT	SEGMENT
_other$ = 8						; size = 4
??8OperationSlot@@QBE_NABU0@@Z PROC			; OperationSlot::operator==, COMDAT
; _this$ = ecx

; 103  : 		return (other.m_iArmyID == m_iArmyID && other.m_iSlotID == m_iSlotID && other.m_iOperationID == m_iOperationID);

	mov	eax, DWORD PTR _other$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN3@operator@2
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN3@operator@2
	mov	eax, DWORD PTR [eax]
	cmp	eax, DWORD PTR [ecx]
	jne	SHORT $LN3@operator@2
	mov	eax, 1

; 104  : 	}

	ret	4
$LN3@operator@2:

; 103  : 		return (other.m_iArmyID == m_iArmyID && other.m_iSlotID == m_iSlotID && other.m_iOperationID == m_iOperationID);

	xor	eax, eax

; 104  : 	}

	ret	4
??8OperationSlot@@QBE_NABU0@@Z ENDP			; OperationSlot::operator==
_TEXT	ENDS
PUBLIC	?GetOwner@CvAIOperation@@QBE?AW4PlayerTypes@@XZ	; CvAIOperation::GetOwner
; Function compile flags: /Ogtpy
;	COMDAT ?GetOwner@CvAIOperation@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetOwner@CvAIOperation@@QBE?AW4PlayerTypes@@XZ PROC	; CvAIOperation::GetOwner, COMDAT
; _this$ = ecx

; 186  : 		return m_eOwner;

	mov	eax, DWORD PTR [ecx+72]

; 187  : 	}

	ret	0
?GetOwner@CvAIOperation@@QBE?AW4PlayerTypes@@XZ ENDP	; CvAIOperation::GetOwner
_TEXT	ENDS
PUBLIC	?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z	; CvAIOperation::ArmyMoved
; Function compile flags: /Ogtpy
;	COMDAT ?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
_TEXT	SEGMENT
_pArmy$ = 8						; size = 4
?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z PROC	; CvAIOperation::ArmyMoved, COMDAT
; _this$ = ecx

; 225  : 		return false;

	xor	al, al

; 226  : 	};

	ret	4
?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ENDP	; CvAIOperation::ArmyMoved
_TEXT	ENDS
PUBLIC	?GetUnitID@CvArmyFormationSlot@@QAEHXZ		; CvArmyFormationSlot::GetUnitID
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvarmyai.h
;	COMDAT ?GetUnitID@CvArmyFormationSlot@@QAEHXZ
_TEXT	SEGMENT
?GetUnitID@CvArmyFormationSlot@@QAEHXZ PROC		; CvArmyFormationSlot::GetUnitID, COMDAT
; _this$ = ecx

; 41   : 		return m_iUnitID;

	mov	eax, DWORD PTR [ecx]

; 42   : 	};

	ret	0
?GetUnitID@CvArmyFormationSlot@@QAEHXZ ENDP		; CvArmyFormationSlot::GetUnitID
_TEXT	ENDS
PUBLIC	?GetTurnAtCheckpoint@CvArmyFormationSlot@@QAEHXZ ; CvArmyFormationSlot::GetTurnAtCheckpoint
; Function compile flags: /Ogtpy
;	COMDAT ?GetTurnAtCheckpoint@CvArmyFormationSlot@@QAEHXZ
_TEXT	SEGMENT
?GetTurnAtCheckpoint@CvArmyFormationSlot@@QAEHXZ PROC	; CvArmyFormationSlot::GetTurnAtCheckpoint, COMDAT
; _this$ = ecx

; 49   : 		return m_iEstimatedTurnAtCheckpoint;

	mov	eax, DWORD PTR [ecx+4]

; 50   : 	};

	ret	0
?GetTurnAtCheckpoint@CvArmyFormationSlot@@QAEHXZ ENDP	; CvArmyFormationSlot::GetTurnAtCheckpoint
_TEXT	ENDS
PUBLIC	?HasStartedOnOperation@CvArmyFormationSlot@@QAE_NXZ ; CvArmyFormationSlot::HasStartedOnOperation
; Function compile flags: /Ogtpy
;	COMDAT ?HasStartedOnOperation@CvArmyFormationSlot@@QAE_NXZ
_TEXT	SEGMENT
?HasStartedOnOperation@CvArmyFormationSlot@@QAE_NXZ PROC ; CvArmyFormationSlot::HasStartedOnOperation, COMDAT
; _this$ = ecx

; 57   : 		return m_bStartedOnOperation;

	cmp	DWORD PTR [ecx+8], 0
	setne	al

; 58   : 	};

	ret	0
?HasStartedOnOperation@CvArmyFormationSlot@@QAE_NXZ ENDP ; CvArmyFormationSlot::HasStartedOnOperation
_TEXT	ENDS
PUBLIC	?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z	; CvPlayerAI::getPlayer
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
;	COMDAT ?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z PROC	; CvPlayerAI::getPlayer, COMDAT

; 28   : 		CvAssertMsg(ePlayer != NO_PLAYER, "Player is not assigned a valid value");
; 29   : 		CvAssertMsg(ePlayer < MAX_PLAYERS, "Player is not assigned a valid value");
; 30   : 		return m_aPlayers[ePlayer];

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 31   : 	}

	ret	0
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z ENDP	; CvPlayerAI::getPlayer
_TEXT	ENDS
PUBLIC	?GetID@CvArea@@QBEHXZ				; CvArea::GetID
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvarea.h
;	COMDAT ?GetID@CvArea@@QBEHXZ
_TEXT	SEGMENT
?GetID@CvArea@@QBEHXZ PROC				; CvArea::GetID, COMDAT
; _this$ = ecx

; 54   : 		return m_iID;

	mov	eax, DWORD PTR [ecx+4]

; 55   : 	}

	ret	0
?GetID@CvArea@@QBEHXZ ENDP				; CvArea::GetID
_TEXT	ENDS
PUBLIC	?isCity@CvPlot@@QBE_NXZ				; CvPlot::isCity
EXTRN	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z:PROC	; CvPlayer::getCity
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?isCity@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isCity@CvPlot@@QBE_NXZ PROC				; CvPlot::isCity, COMDAT
; _this$ = ecx

; 245  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN1@isCity
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@isCity

; 246  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID)) != NULL;

	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	neg	eax
	sbb	eax, eax
	neg	eax

; 249  : 	}

	ret	0
$LN1@isCity:

; 247  : 
; 248  : 		return false;

	xor	al, al

; 249  : 	}

	ret	0
?isCity@CvPlot@@QBE_NXZ ENDP				; CvPlot::isCity
_TEXT	ENDS
PUBLIC	?getX@CvPlot@@QBEHXZ				; CvPlot::getX
; Function compile flags: /Ogtpy
;	COMDAT ?getX@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getX@CvPlot@@QBEHXZ PROC				; CvPlot::getX, COMDAT
; _this$ = ecx

; 307  : 		return m_iX;

	movsx	eax, WORD PTR [ecx]

; 308  : 	}

	ret	0
?getX@CvPlot@@QBEHXZ ENDP				; CvPlot::getX
_TEXT	ENDS
PUBLIC	?getY@CvPlot@@QBEHXZ				; CvPlot::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getY@CvPlot@@QBEHXZ PROC				; CvPlot::getY, COMDAT
; _this$ = ecx

; 312  : 		return m_iY;

	movsx	eax, WORD PTR [ecx+2]

; 313  : 	}

	ret	0
?getY@CvPlot@@QBEHXZ ENDP				; CvPlot::getY
_TEXT	ENDS
PUBLIC	?getArea@CvPlot@@QBEHXZ				; CvPlot::getArea
; Function compile flags: /Ogtpy
;	COMDAT ?getArea@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getArea@CvPlot@@QBEHXZ PROC				; CvPlot::getArea, COMDAT
; _this$ = ecx

; 324  : 		return m_iArea;

	mov	eax, DWORD PTR [ecx+356]

; 325  : 	}

	ret	0
?getArea@CvPlot@@QBEHXZ ENDP				; CvPlot::getArea
_TEXT	ENDS
PUBLIC	?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ	; CvPlot::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlot::getOwner, COMDAT
; _this$ = ecx

; 387  : 		return (PlayerTypes)m_eOwner;

	movsx	eax, BYTE PTR [ecx+4]

; 388  : 	}

	ret	0
?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlot::getOwner
_TEXT	ENDS
PUBLIC	?isWater@CvPlot@@QBE_NXZ			; CvPlot::isWater
; Function compile flags: /Ogtpy
;	COMDAT ?isWater@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isWater@CvPlot@@QBE_NXZ PROC				; CvPlot::isWater, COMDAT
; _this$ = ecx

; 409  : 		return (PlotTypes)m_ePlotType == PLOT_OCEAN;

	xor	eax, eax
	cmp	BYTE PTR [ecx+5], 3
	sete	al

; 410  : 	};

	ret	0
?isWater@CvPlot@@QBE_NXZ ENDP				; CvPlot::isWater
_TEXT	ENDS
PUBLIC	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ		; CvPlot::getPlotCity
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ
_TEXT	SEGMENT
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ PROC		; CvPlot::getPlotCity, COMDAT
; _this$ = ecx

; 533  : 		if((m_plotCity.eOwner >= 0) && m_plotCity.eOwner < MAX_PLAYERS)

	mov	eax, DWORD PTR [ecx+104]
	test	eax, eax
	jl	SHORT $LN1@getPlotCit
	cmp	eax, 64					; 00000040H
	jge	SHORT $LN1@getPlotCit

; 534  : 			return (GET_PLAYER((PlayerTypes)m_plotCity.eOwner).getCity(m_plotCity.iID));

	mov	ecx, DWORD PTR [ecx+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity

; 537  : 	}

	ret	0
$LN1@getPlotCit:

; 535  : 
; 536  : 		return NULL;

	xor	eax, eax

; 537  : 	}

	ret	0
?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ ENDP		; CvPlot::getPlotCity
_TEXT	ENDS
PUBLIC	?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z		; CvPlot::PlotBoolField::GetBit
; Function compile flags: /Ogtpy
;	COMDAT ?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z
_TEXT	SEGMENT
_uiEntry$ = 8						; size = 4
?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z PROC		; CvPlot::PlotBoolField::GetBit, COMDAT
; _this$ = ecx

; 767  : 		{

	mov	edx, ecx

; 768  : 			const uint uiOffset = uiEntry/eSize;

	mov	ecx, DWORD PTR _uiEntry$[esp-4]
	push	esi
	mov	eax, ecx
	shr	eax, 5

; 769  : 			return m_dwBits[uiOffset] & 1<<(uiEntry-(eSize*uiOffset));

	mov	esi, eax
	shl	esi, 5
	sub	ecx, esi
	mov	esi, 1
	shl	esi, cl
	test	esi, DWORD PTR [edx+eax*4]
	pop	esi
	setne	al

; 770  : 		}

	ret	4
?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z ENDP		; CvPlot::PlotBoolField::GetBit
_TEXT	ENDS
PUBLIC	?coordRange@@YAHHH_N@Z				; coordRange
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?coordRange@@YAHHH_N@Z
_TEXT	SEGMENT
_iCoord$ = 8						; size = 4
_iRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?coordRange@@YAHHH_N@Z PROC				; coordRange, COMDAT

; 88   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iCoord$[esp-4]
	je	SHORT $LN5@coordRange

; 89   : 	{
; 90   : 		if(iCoord < 0)
; 91   : 		{
; 92   : 			return (iRange + (iCoord % iRange));

	mov	ecx, DWORD PTR _iRange$[esp-4]
	test	eax, eax
	jge	SHORT $LN3@coordRange
	cdq
	idiv	ecx
	mov	eax, edx
	add	eax, ecx

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
$LN3@coordRange:

; 93   : 		}
; 94   : 		else if(iCoord >= iRange)

	cmp	eax, ecx
	jl	SHORT $LN5@coordRange

; 95   : 		{
; 96   : 			return (iCoord % iRange);

	cdq
	idiv	ecx
	mov	eax, edx
$LN5@coordRange:

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
?coordRange@@YAHHH_N@Z ENDP				; coordRange
_TEXT	ENDS
PUBLIC	?numPlots@CvMap@@QBEHXZ				; CvMap::numPlots
; Function compile flags: /Ogtpy
;	COMDAT ?numPlots@CvMap@@QBEHXZ
_TEXT	SEGMENT
?numPlots@CvMap@@QBEHXZ PROC				; CvMap::numPlots, COMDAT
; _this$ = ecx

; 170  : 		return m_iGridSize;

	mov	eax, DWORD PTR [ecx+4028]

; 171  : 	}

	ret	0
?numPlots@CvMap@@QBEHXZ ENDP				; CvMap::numPlots
_TEXT	ENDS
PUBLIC	?getGridWidth@CvMap@@QBEHXZ			; CvMap::getGridWidth
; Function compile flags: /Ogtpy
;	COMDAT ?getGridWidth@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridWidth@CvMap@@QBEHXZ PROC			; CvMap::getGridWidth, COMDAT
; _this$ = ecx

; 198  : 		return m_iGridWidth;

	mov	eax, DWORD PTR [ecx+4020]

; 199  : 	}

	ret	0
?getGridWidth@CvMap@@QBEHXZ ENDP			; CvMap::getGridWidth
_TEXT	ENDS
PUBLIC	?getGridHeight@CvMap@@QBEHXZ			; CvMap::getGridHeight
; Function compile flags: /Ogtpy
;	COMDAT ?getGridHeight@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridHeight@CvMap@@QBEHXZ PROC			; CvMap::getGridHeight, COMDAT
; _this$ = ecx

; 206  : 		return m_iGridHeight;

	mov	eax, DWORD PTR [ecx+4024]

; 207  : 	}

	ret	0
?getGridHeight@CvMap@@QBEHXZ ENDP			; CvMap::getGridHeight
_TEXT	ENDS
PUBLIC	?isWrapX@CvMap@@QBE_NXZ				; CvMap::isWrapX
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapX@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapX@CvMap@@QBE_NXZ PROC				; CvMap::isWrapX, COMDAT
; _this$ = ecx

; 228  : 		return m_bWrapX;

	mov	al, BYTE PTR [ecx+4056]

; 229  : 	}

	ret	0
?isWrapX@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapX
_TEXT	ENDS
PUBLIC	?isWrapY@CvMap@@QBE_NXZ				; CvMap::isWrapY
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapY@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapY@CvMap@@QBE_NXZ PROC				; CvMap::isWrapY, COMDAT
; _this$ = ecx

; 233  : 		return m_bWrapY;

	mov	al, BYTE PTR [ecx+4057]

; 234  : 	}

	ret	0
?isWrapY@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapY
_TEXT	ENDS
PUBLIC	?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z	; CvMap::plotByIndexUnchecked
; Function compile flags: /Ogtpy
;	COMDAT ?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z PROC	; CvMap::plotByIndexUnchecked, COMDAT
; _this$ = ecx

; 268  : 		return &m_pMapPlots[iIndex];

	mov	eax, DWORD PTR _iIndex$[esp-4]
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]

; 269  : 	}

	ret	4
?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z ENDP	; CvMap::plotByIndexUnchecked
_TEXT	ENDS
PUBLIC	?GetBit@CvTacticalAnalysisCell@@QBE_NI@Z	; CvTacticalAnalysisCell::GetBit
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtacticalanalysismap.h
;	COMDAT ?GetBit@CvTacticalAnalysisCell@@QBE_NI@Z
_TEXT	SEGMENT
_uiFlag$ = 8						; size = 4
?GetBit@CvTacticalAnalysisCell@@QBE_NI@Z PROC		; CvTacticalAnalysisCell::GetBit, COMDAT
; _this$ = ecx

; 83   : 	FBITFLAGS(uint);

	mov	eax, DWORD PTR [ecx]
	and	eax, DWORD PTR _uiFlag$[esp-4]
	neg	eax
	sbb	eax, eax
	neg	eax
	ret	4
?GetBit@CvTacticalAnalysisCell@@QBE_NI@Z ENDP		; CvTacticalAnalysisCell::GetBit
_TEXT	ENDS
PUBLIC	?IsOcean@CvTacticalAnalysisCell@@QAE_NXZ	; CvTacticalAnalysisCell::IsOcean
; Function compile flags: /Ogtpy
;	COMDAT ?IsOcean@CvTacticalAnalysisCell@@QAE_NXZ
_TEXT	SEGMENT
?IsOcean@CvTacticalAnalysisCell@@QAE_NXZ PROC		; CvTacticalAnalysisCell::IsOcean, COMDAT
; _this$ = ecx

; 192  : 		return GetBit(TACTICAL_FLAG_OCEAN);

	mov	eax, DWORD PTR [ecx]
	shr	eax, 12					; 0000000cH
	and	eax, 1

; 193  : 	};

	ret	0
?IsOcean@CvTacticalAnalysisCell@@QAE_NXZ ENDP		; CvTacticalAnalysisCell::IsOcean
_TEXT	ENDS
PUBLIC	?GetCell@CvTacticalAnalysisMap@@QAEPAVCvTacticalAnalysisCell@@H@Z ; CvTacticalAnalysisMap::GetCell
; Function compile flags: /Ogtpy
;	COMDAT ?GetCell@CvTacticalAnalysisMap@@QAEPAVCvTacticalAnalysisCell@@H@Z
_TEXT	SEGMENT
_iPlotIndex$ = 8					; size = 4
?GetCell@CvTacticalAnalysisMap@@QAEPAVCvTacticalAnalysisCell@@H@Z PROC ; CvTacticalAnalysisMap::GetCell, COMDAT
; _this$ = ecx

; 630  : 		return &m_pPlots[iPlotIndex];

	mov	eax, DWORD PTR _iPlotIndex$[esp-4]
	imul	eax, 44					; 0000002cH
	add	eax, DWORD PTR [ecx+12]

; 631  : 	};

	ret	4
?GetCell@CvTacticalAnalysisMap@@QAEPAVCvTacticalAnalysisCell@@H@Z ENDP ; CvTacticalAnalysisMap::GetCell
_TEXT	ENDS
PUBLIC	?Clear@CvTemporaryZone@@QAEXXZ			; CvTemporaryZone::Clear
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.h
;	COMDAT ?Clear@CvTemporaryZone@@QAEXXZ
_TEXT	SEGMENT
?Clear@CvTemporaryZone@@QAEXXZ PROC			; CvTemporaryZone::Clear, COMDAT
; _this$ = ecx

; 566  : 		m_iX = 0;

	xor	eax, eax
	mov	DWORD PTR [ecx], eax

; 567  : 		m_iY = 0;

	mov	DWORD PTR [ecx+4], eax

; 568  : 		m_eTargetType = AI_TACTICAL_TARGET_NONE;

	mov	DWORD PTR [ecx+8], eax

; 569  : 		m_iLastTurn = 0;

	mov	DWORD PTR [ecx+12], eax

; 570  : #ifdef AUI_WARNING_FIXES
; 571  : 		m_bIsNavalInvasion = false;
; 572  : #endif
; 573  : 	};

	ret	0
?Clear@CvTemporaryZone@@QAEXXZ ENDP			; CvTemporaryZone::Clear
_TEXT	ENDS
PUBLIC	?SetX@CvTemporaryZone@@QAEXH@Z			; CvTemporaryZone::SetX
; Function compile flags: /Ogtpy
;	COMDAT ?SetX@CvTemporaryZone@@QAEXH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
?SetX@CvTemporaryZone@@QAEXH@Z PROC			; CvTemporaryZone::SetX, COMDAT
; _this$ = ecx

; 581  : 		m_iX = iX;

	mov	eax, DWORD PTR _iX$[esp-4]
	mov	DWORD PTR [ecx], eax

; 582  : 	};

	ret	4
?SetX@CvTemporaryZone@@QAEXH@Z ENDP			; CvTemporaryZone::SetX
_TEXT	ENDS
PUBLIC	?SetY@CvTemporaryZone@@QAEXH@Z			; CvTemporaryZone::SetY
; Function compile flags: /Ogtpy
;	COMDAT ?SetY@CvTemporaryZone@@QAEXH@Z
_TEXT	SEGMENT
_iY$ = 8						; size = 4
?SetY@CvTemporaryZone@@QAEXH@Z PROC			; CvTemporaryZone::SetY, COMDAT
; _this$ = ecx

; 589  : 		m_iY = iY;

	mov	eax, DWORD PTR _iY$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 590  : 	};

	ret	4
?SetY@CvTemporaryZone@@QAEXH@Z ENDP			; CvTemporaryZone::SetY
_TEXT	ENDS
PUBLIC	?SetTargetType@CvTemporaryZone@@QAEXW4AITacticalTargetType@@@Z ; CvTemporaryZone::SetTargetType
; Function compile flags: /Ogtpy
;	COMDAT ?SetTargetType@CvTemporaryZone@@QAEXW4AITacticalTargetType@@@Z
_TEXT	SEGMENT
_eType$ = 8						; size = 4
?SetTargetType@CvTemporaryZone@@QAEXW4AITacticalTargetType@@@Z PROC ; CvTemporaryZone::SetTargetType, COMDAT
; _this$ = ecx

; 597  : 		m_eTargetType = eType;

	mov	eax, DWORD PTR _eType$[esp-4]
	mov	DWORD PTR [ecx+8], eax

; 598  : 	};

	ret	4
?SetTargetType@CvTemporaryZone@@QAEXW4AITacticalTargetType@@@Z ENDP ; CvTemporaryZone::SetTargetType
_TEXT	ENDS
PUBLIC	?SetLastTurn@CvTemporaryZone@@QAEXH@Z		; CvTemporaryZone::SetLastTurn
; Function compile flags: /Ogtpy
;	COMDAT ?SetLastTurn@CvTemporaryZone@@QAEXH@Z
_TEXT	SEGMENT
_iTurn$ = 8						; size = 4
?SetLastTurn@CvTemporaryZone@@QAEXH@Z PROC		; CvTemporaryZone::SetLastTurn, COMDAT
; _this$ = ecx

; 605  : 		m_iLastTurn = iTurn;

	mov	eax, DWORD PTR _iTurn$[esp-4]
	mov	DWORD PTR [ecx+12], eax

; 606  : 	};

	ret	4
?SetLastTurn@CvTemporaryZone@@QAEXH@Z ENDP		; CvTemporaryZone::SetLastTurn
_TEXT	ENDS
PUBLIC	?SetNavalInvasion@CvTemporaryZone@@QAEX_N@Z	; CvTemporaryZone::SetNavalInvasion
; Function compile flags: /Ogtpy
;	COMDAT ?SetNavalInvasion@CvTemporaryZone@@QAEX_N@Z
_TEXT	SEGMENT
_bIsNavalInvasion$ = 8					; size = 1
?SetNavalInvasion@CvTemporaryZone@@QAEX_N@Z PROC	; CvTemporaryZone::SetNavalInvasion, COMDAT
; _this$ = ecx

; 613  : 		m_bIsNavalInvasion = bIsNavalInvasion;

	mov	al, BYTE PTR _bIsNavalInvasion$[esp-4]
	mov	BYTE PTR [ecx+16], al

; 614  : 	};

	ret	4
?SetNavalInvasion@CvTemporaryZone@@QAEX_N@Z ENDP	; CvTemporaryZone::SetNavalInvasion
_TEXT	ENDS
PUBLIC	?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z		; CvTeam::getTeam
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.h
;	COMDAT ?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z PROC		; CvTeam::getTeam, COMDAT

; 29   : 		CvAssertMsg(eTeam != NO_TEAM, "eTeam is not assigned a valid value");
; 30   : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is not assigned a valid value");
; 31   : 		return m_aTeams[eTeam];

	mov	eax, DWORD PTR _eTeam$[esp-4]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 32   : 	}

	ret	0
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z ENDP		; CvTeam::getTeam
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@ABV0@@Z			; CvString::CvString
; Function compile flags: /Ogtpy
;	COMDAT ??0CvString@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0CvString@@QAE@ABV0@@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@ABV0@@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	?GetLastNode@CvAStar@@QAEPAVCvAStarNode@@XZ	; CvAStar::GetLastNode
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvastar.h
;	COMDAT ?GetLastNode@CvAStar@@QAEPAVCvAStarNode@@XZ
_TEXT	SEGMENT
?GetLastNode@CvAStar@@QAEPAVCvAStarNode@@XZ PROC	; CvAStar::GetLastNode, COMDAT
; _this$ = ecx

; 98   : 		return m_pBest;

	mov	eax, DWORD PTR [ecx+96]

; 99   : 	}

	ret	0
?GetLastNode@CvAStar@@QAEPAVCvAStarNode@@XZ ENDP	; CvAStar::GetLastNode
_TEXT	ENDS
PUBLIC	?SetData@CvAStar@@QAEXPBX@Z			; CvAStar::SetData
; Function compile flags: /Ogtpy
;	COMDAT ?SetData@CvAStar@@QAEXPBX@Z
_TEXT	SEGMENT
_pData$ = 8						; size = 4
?SetData@CvAStar@@QAEXPBX@Z PROC			; CvAStar::SetData, COMDAT
; _this$ = ecx

; 202  : 		if(m_bDataChangeInvalidatesCache && m_pData != pData)

	cmp	BYTE PTR [ecx+80], 0
	mov	eax, DWORD PTR _pData$[esp-4]
	je	SHORT $LN4@SetData
	cmp	DWORD PTR [ecx+44], eax

; 205  : 		m_pData = pData;

	mov	DWORD PTR [ecx+44], eax
	je	SHORT $LN1@SetData

; 203  : #endif
; 204  : 			m_bForceReset = true;

	mov	BYTE PTR [ecx+78], 1

; 206  : #ifdef AUI_ASTAR_TURN_LIMITER
; 207  : 		m_iMaxTurns = iMaxTurns;
; 208  : #endif
; 209  : 	}

	ret	4
$LN4@SetData:

; 205  : 		m_pData = pData;

	mov	DWORD PTR [ecx+44], eax
$LN1@SetData:

; 206  : #ifdef AUI_ASTAR_TURN_LIMITER
; 207  : 		m_iMaxTurns = iMaxTurns;
; 208  : #endif
; 209  : 	}

	ret	4
?SetData@CvAStar@@QAEXPBX@Z ENDP			; CvAStar::SetData
_TEXT	ENDS
PUBLIC	?SetDestValidFunc@CvAStar@@QAEXP6AHHHPBXPAV1@@Z@Z ; CvAStar::SetDestValidFunc
; Function compile flags: /Ogtpy
;	COMDAT ?SetDestValidFunc@CvAStar@@QAEXP6AHHHPBXPAV1@@Z@Z
_TEXT	SEGMENT
_newDestValidFunc$ = 8					; size = 4
?SetDestValidFunc@CvAStar@@QAEXP6AHHHPBXPAV1@@Z@Z PROC	; CvAStar::SetDestValidFunc, COMDAT
; _this$ = ecx

; 266  : 		udDestValid = newDestValidFunc;

	mov	eax, DWORD PTR _newDestValidFunc$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 267  : 	}

	ret	4
?SetDestValidFunc@CvAStar@@QAEXP6AHHHPBXPAV1@@Z@Z ENDP	; CvAStar::SetDestValidFunc
_TEXT	ENDS
PUBLIC	?SetValidFunc@CvAStar@@QAEXP6AHPAVCvAStarNode@@0HPBXPAV1@@Z@Z ; CvAStar::SetValidFunc
; Function compile flags: /Ogtpy
;	COMDAT ?SetValidFunc@CvAStar@@QAEXP6AHPAVCvAStarNode@@0HPBXPAV1@@Z@Z
_TEXT	SEGMENT
_newValidFunc$ = 8					; size = 4
?SetValidFunc@CvAStar@@QAEXP6AHPAVCvAStarNode@@0HPBXPAV1@@Z@Z PROC ; CvAStar::SetValidFunc, COMDAT
; _this$ = ecx

; 308  : 		udValid = newValidFunc;

	mov	eax, DWORD PTR _newValidFunc$[esp-4]
	mov	DWORD PTR [ecx+16], eax

; 309  : 	}

	ret	4
?SetValidFunc@CvAStar@@QAEXP6AHPAVCvAStarNode@@0HPBXPAV1@@Z@Z ENDP ; CvAStar::SetValidFunc
_TEXT	ENDS
PUBLIC	?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC	; std::vector<int,std::allocator<int> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP	; std::vector<int,std::allocator<int> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@HV?$allocator@H@std@@@std@@QBEABHI@Z ; std::vector<int,std::allocator<int> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@HV?$allocator@H@std@@@std@@QBEABHI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@HV?$allocator@H@std@@@std@@QBEABHI@Z PROC	; std::vector<int,std::allocator<int> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@HV?$allocator@H@std@@@std@@QBEABHI@Z ENDP	; std::vector<int,std::allocator<int> >::operator[]
_TEXT	ENDS
PUBLIC	??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z PROC ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ENDP ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBEIXZ ; std::vector<OperationSlot,std::allocator<OperationSlot> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBEIXZ PROC ; std::vector<OperationSlot,std::allocator<OperationSlot> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 727  : 		}

	ret	0
?size@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBEIXZ ENDP ; std::vector<OperationSlot,std::allocator<OperationSlot> >::size
_TEXT	ENDS
PUBLIC	??A?$BaseVector@VCvArmyFormationSlot@@$00@@QAEAAVCvArmyFormationSlot@@I@Z ; BaseVector<CvArmyFormationSlot,1>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@VCvArmyFormationSlot@@$00@@QAEAAVCvArmyFormationSlot@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@VCvArmyFormationSlot@@$00@@QAEAAVCvArmyFormationSlot@@I@Z PROC ; BaseVector<CvArmyFormationSlot,1>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR _ui$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*4]

; 131  : 	};

	ret	4
??A?$BaseVector@VCvArmyFormationSlot@@$00@@QAEAAVCvArmyFormationSlot@@I@Z ENDP ; BaseVector<CvArmyFormationSlot,1>::operator[]
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::~_Container_base_aux_alloc_empty<std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::~_Container_base_aux_alloc_empty<std::allocator<int> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::~_Container_base_aux_alloc_empty<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$allocator@H@std@@QAE@XZ			; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@H@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@H@std@@QAE@XZ PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@H@std@@QAE@XZ ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Isnil
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Isnil@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Isnil, COMDAT

; 157  : 		return ((_Charref)(*_Pnode)._Isnil);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 17					; 00000011H

; 158  : 		}

	ret	0
?_Isnil@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Isnil
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Left
; Function compile flags: /Ogtpy
;	COMDAT ?_Left@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Left, COMDAT

; 167  : 		return ((_Nodepref)(*_Pnode)._Left);

	mov	eax, DWORD PTR __Pnode$[esp-4]

; 168  : 		}

	ret	0
?_Left@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Left
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Right
; Function compile flags: /Ogtpy
;	COMDAT ?_Right@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Right, COMDAT

; 177  : 		return ((_Nodepref)(*_Pnode)._Right);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 8

; 178  : 		}

	ret	0
?_Right@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Right
_TEXT	ENDS
PUBLIC	?_Kfn@?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@SAABQAVFAutoVariableBase@@ABQAV3@@Z ; std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0>::_Kfn
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\set
;	COMDAT ?_Kfn@?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@SAABQAVFAutoVariableBase@@ABQAV3@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@SAABQAVFAutoVariableBase@@ABQAV3@@Z PROC ; std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0>::_Kfn, COMDAT

; 45   : 		return (_Val);

	mov	eax, DWORD PTR __Val$[esp-4]

; 46   : 		}

	ret	0
?_Kfn@?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@SAABQAVFAutoVariableBase@@ABQAV3@@Z ENDP ; std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0>::_Kfn
_TEXT	ENDS
PUBLIC	??R?$less@PAVFAutoVariableBase@@@std@@QBE_NABQAVFAutoVariableBase@@0@Z ; std::less<FAutoVariableBase *>::operator()
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\functional
;	COMDAT ??R?$less@PAVFAutoVariableBase@@@std@@QBE_NABQAVFAutoVariableBase@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@PAVFAutoVariableBase@@@std@@QBE_NABQAVFAutoVariableBase@@0@Z PROC ; std::less<FAutoVariableBase *>::operator(), COMDAT
; _this$ = ecx

; 143  : 		return (_Left < _Right);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Right$[esp-4]
	cmp	ecx, DWORD PTR [edx]
	sbb	eax, eax
	neg	eax

; 144  : 		}

	ret	8
??R?$less@PAVFAutoVariableBase@@@std@@QBE_NABQAVFAutoVariableBase@@0@Z ENDP ; std::less<FAutoVariableBase *>::operator()
_TEXT	ENDS
PUBLIC	??0?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::iterator,bool>::pair<std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::iterator,bool>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@1@AB_N@Z PROC ; std::pair<std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::iterator,bool>::pair<std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::iterator,bool>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax+4], dl

; 51   : 		}

	ret	8
??0?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@1@AB_N@Z ENDP ; std::pair<std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::iterator,bool>::pair<std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::iterator,bool>
_TEXT	ENDS
PUBLIC	??8const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::operator==
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 300  : 
; 301  :  #if _HAS_ITERATOR_DEBUGGING
; 302  : 			if (this->_Mycont == 0 || this->_Mycont != _Right._Mycont)
; 303  : 				{
; 304  : 				_DEBUG_ERROR("map/set iterators incompatible");
; 305  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 306  : 				}
; 307  :  #else
; 308  : 			_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 309  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 310  : 
; 311  : 			return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 312  : 			}

	ret	4
??8const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::operator==
_TEXT	ENDS
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@3@XZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::_Mynode
; Function compile flags: /Ogtpy
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@3@XZ PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::_Mynode, COMDAT
; _this$ = ecx

; 410  : 			return (_Ptr);

	mov	eax, DWORD PTR [ecx]

; 411  : 			}

	ret	0
?_Mynode@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::_Mynode
_TEXT	ENDS
PUBLIC	??1?$BaseVector@PAVCvAStarNode@@$00@@QAE@XZ	; BaseVector<CvAStarNode *,1>::~BaseVector<CvAStarNode *,1>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$BaseVector@PAVCvAStarNode@@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@PAVCvAStarNode@@$00@@QAE@XZ PROC	; BaseVector<CvAStarNode *,1>::~BaseVector<CvAStarNode *,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@PAVCvAStarNode@@$00@@QAE@XZ ENDP	; BaseVector<CvAStarNode *,1>::~BaseVector<CvAStarNode *,1>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@PAVCvAStarNode@@$00@@IAE@XZ	; BaseVector<CvAStarNode *,1>::BaseVector<CvAStarNode *,1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@PAVCvAStarNode@@$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@PAVCvAStarNode@@$00@@IAE@XZ PROC	; BaseVector<CvAStarNode *,1>::BaseVector<CvAStarNode *,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@PAVCvAStarNode@@$00@@IAE@XZ ENDP	; BaseVector<CvAStarNode *,1>::BaseVector<CvAStarNode *,1>
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@PAVCvAStarNode@@$00@@IAEXPAPAVCvAStarNode@@I@Z ; BaseVector<CvAStarNode *,1>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@PAVCvAStarNode@@$00@@IAEXPAPAVCvAStarNode@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@PAVCvAStarNode@@$00@@IAEXPAPAVCvAStarNode@@I@Z PROC ; BaseVector<CvAStarNode *,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@PAVCvAStarNode@@$00@@IAEXPAPAVCvAStarNode@@I@Z ENDP ; BaseVector<CvAStarNode *,1>::Destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T231662 = -80						; size = 28
$T231661 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ PROC	; std::vector<int,std::allocator<int> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T231662[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T231661[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T231662[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T231661[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T231661[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T231661[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T231661[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@2:
$LN12@Xlen@2:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T231662[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T231661[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ENDP	; std::vector<int,std::allocator<int> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::_Container_base_aux_alloc_empty<std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::_Container_base_aux_alloc_empty<std::allocator<int> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::_Container_base_aux_alloc_empty<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$allocator@H@std@@QAE@ABV01@@Z		; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@H@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@H@std@@QAE@ABV01@@Z PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@H@std@@QAE@ABV01@@Z ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@H@std@@QAEXPAHI@Z	; std::allocator<int>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXPAHI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@H@std@@QAEXPAHI@Z PROC		; std::allocator<int>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@H@std@@QAEXPAHI@Z ENDP		; std::allocator<int>::deallocate
_TEXT	ENDS
PUBLIC	?_Color@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Color
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Color@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Color, COMDAT

; 152  : 		return ((_Charref)(*_Pnode)._Color);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 16					; 00000010H

; 153  : 		}

	ret	0
?_Color@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Color
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Parent
; Function compile flags: /Ogtpy
;	COMDAT ?_Parent@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Parent, COMDAT

; 172  : 		return ((_Nodepref)(*_Pnode)._Parent);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 4

; 173  : 		}

	ret	0
?_Parent@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Parent
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAVFAutoVariableBase@@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Myval
; Function compile flags: /Ogtpy
;	COMDAT ?_Myval@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAVFAutoVariableBase@@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAVFAutoVariableBase@@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Myval, COMDAT

; 182  : 		return ((_Vref)(*_Pnode)._Myval);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 12					; 0000000cH

; 183  : 		}

	ret	0
?_Myval@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAAAPAVFAutoVariableBase@@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Myval
_TEXT	ENDS
PUBLIC	?_Lmost@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Lmost
; Function compile flags: /Ogtpy
;	COMDAT ?_Lmost@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1281 : 		return (_Left(_Myhead));

	mov	eax, DWORD PTR [ecx+4]

; 1282 : 		}

	ret	0
?_Lmost@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Lmost
_TEXT	ENDS
PUBLIC	?_Rmost@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Rmost
; Function compile flags: /Ogtpy
;	COMDAT ?_Rmost@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1320 : 		return (_Right(_Myhead));

	mov	eax, DWORD PTR [ecx+4]
	add	eax, 8

; 1321 : 		}

	ret	0
?_Rmost@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Rmost
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::const_iterator
; Function compile flags: /Ogtpy
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 244  : 			{	// construct with node pointer _Pnode

	mov	eax, ecx
	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [eax], ecx

; 245  : 			}

	ret	4
??0const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@H@std@@QBEIXZ		; std::allocator<int>::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@H@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@H@std@@QBEIXZ PROC		; std::allocator<int>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@H@std@@QBEIXZ ENDP		; std::allocator<int>::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVFAutoVariableBase@@@std@@QBEIXZ ; std::allocator<FAutoVariableBase *>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@PAVFAutoVariableBase@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVFAutoVariableBase@@@std@@QBEIXZ PROC ; std::allocator<FAutoVariableBase *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVFAutoVariableBase@@@std@@QBEIXZ ENDP ; std::allocator<FAutoVariableBase *>::max_size
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??0_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE@PAU012@00ABQAVFAutoVariableBase@@D@Z ; std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node::_Node
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE@PAU012@00ABQAVFAutoVariableBase@@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
??0_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE@PAU012@00ABQAVFAutoVariableBase@@D@Z PROC ; std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node::_Node, COMDAT
; _this$ = ecx

; 38   : 			{	// construct a node with value

	mov	edx, DWORD PTR __Parg$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR __Larg$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Rarg$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx]
	mov	dl, BYTE PTR __Carg$[esp-4]
	mov	DWORD PTR [eax+12], ecx
	mov	BYTE PTR [eax+16], dl
	mov	BYTE PTR [eax+17], 0

; 39   : 			}

	ret	20					; 00000014H
??0_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE@PAU012@00ABQAVFAutoVariableBase@@D@Z ENDP ; std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node::_Node
_TEXT	ENDS
PUBLIC	?_Max@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Max
; Function compile flags: /Ogtpy
;	COMDAT ?_Max@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Max, COMDAT

; 1306 : 		while (!_Isnil(_Right(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[esp-4]
	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+17], 0
	jne	SHORT $LN1@Max
	npad	3
$LL2@Max:

; 1307 : 			_Pnode = _Right(_Pnode);

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax+8]
	cmp	BYTE PTR [ecx+17], 0
	je	SHORT $LL2@Max
$LN1@Max:

; 1308 : 		return (_Pnode);
; 1309 : 		}

	ret	0
?_Max@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Max
_TEXT	ENDS
PUBLIC	?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvUnit>::get
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvUnit>::get, COMDAT
; _this$ = ecx

; 177  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 178  : }

	ret	0
?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvUnit>::get
_TEXT	ENDS
PUBLIC	?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ	; FAutoVariable<int,CvUnit>::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ
_TEXT	SEGMENT
?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ PROC		; FAutoVariable<int,CvUnit>::get, COMDAT
; _this$ = ecx

; 177  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 178  : }

	ret	0
?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvUnit>::get
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ		; FAutoVariable<int,CvUnit>::operator int const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ
_TEXT	SEGMENT
??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ PROC		; FAutoVariable<int,CvUnit>::operator int const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@HVCvUnit@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvUnit>::operator int const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@_NVCvUnit@@@@QBEAB_NXZ	; FAutoVariable<bool,CvUnit>::operator bool const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@_NVCvUnit@@@@QBEAB_NXZ
_TEXT	SEGMENT
??B?$FAutoVariable@_NVCvUnit@@@@QBEAB_NXZ PROC		; FAutoVariable<bool,CvUnit>::operator bool const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@_NVCvUnit@@@@QBEAB_NXZ ENDP		; FAutoVariable<bool,CvUnit>::operator bool const &
_TEXT	ENDS
PUBLIC	??A?$FAutoVariable@V?$vector@HV?$allocator@H@std@@@std@@VCvUnit@@@@QBEABHI@Z ; FAutoVariable<std::vector<int,std::allocator<int> >,CvUnit>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovector.h
;	COMDAT ??A?$FAutoVariable@V?$vector@HV?$allocator@H@std@@@std@@VCvUnit@@@@QBEABHI@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
??A?$FAutoVariable@V?$vector@HV?$allocator@H@std@@@std@@VCvUnit@@@@QBEABHI@Z PROC ; FAutoVariable<std::vector<int,std::allocator<int> >,CvUnit>::operator[], COMDAT
; _this$ = ecx

; 329  : 	return m_value[index];

	mov	eax, DWORD PTR [ecx+24]
	mov	ecx, DWORD PTR _index$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 330  : }

	ret	4
??A?$FAutoVariable@V?$vector@HV?$allocator@H@std@@@std@@VCvUnit@@@@QBEABHI@Z ENDP ; FAutoVariable<std::vector<int,std::allocator<int> >,CvUnit>::operator[]
_TEXT	ENDS
PUBLIC	??$?6H@FDataStream@@QAEAAV0@ABH@Z		; FDataStream::operator<<<int>
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6H@FDataStream@@QAEAAV0@ABH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6H@FDataStream@@QAEAAV0@ABH@Z PROC			; FDataStream::operator<<<int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6H@FDataStream@@QAEAAV0@ABH@Z ENDP			; FDataStream::operator<<<int>
_TEXT	ENDS
PUBLIC	??$?5H@FDataStream@@QAEAAV0@AAH@Z		; FDataStream::operator>><int>
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5H@FDataStream@@QAEAAV0@AAH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5H@FDataStream@@QAEAAV0@AAH@Z PROC			; FDataStream::operator>><int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5H@FDataStream@@QAEAAV0@AAH@Z ENDP			; FDataStream::operator>><int>
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ		; FAutoVariable<int,CvCity>::operator int const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ
_TEXT	SEGMENT
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ PROC		; FAutoVariable<int,CvCity>::operator int const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvCity>::operator int const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ	; FAutoVariable<bool,CvPlayer>::operator bool const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ
_TEXT	SEGMENT
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ PROC	; FAutoVariable<bool,CvPlayer>::operator bool const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ ENDP	; FAutoVariable<bool,CvPlayer>::operator bool const &
_TEXT	ENDS
PUBLIC	??$_Allocate@H@std@@YAPAHIPAH@Z			; std::_Allocate<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Allocate@H@std@@YAPAHIPAH@Z
_TEXT	SEGMENT
$T231787 = -12						; size = 12
$T231791 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@H@std@@YAPAHIPAH@Z PROC			; std::_Allocate<int>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T231791[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T231787[esp+16]
	mov	DWORD PTR $T231791[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T231787[esp+16]
	push	ecx
	mov	DWORD PTR $T231787[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@2:
$LN8@Allocate@2:
	int	3
??$_Allocate@H@std@@YAPAHIPAH@Z ENDP			; std::_Allocate<int>
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T231797 = -12						; size = 12
$T231801 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@3

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@3:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx+ecx*4]
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@3:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 20					; 00000014H
	jae	SHORT $LN1@Allocate@3

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T231801[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T231797[esp+16]
	mov	DWORD PTR $T231801[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T231797[esp+16]
	push	ecx
	mov	DWORD PTR $T231797[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@3:
$LN8@Allocate@3:
	int	3
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator==
_TEXT	ENDS
PUBLIC	??$?5_N@FDataStream@@QAEAAV0@AA_N@Z		; FDataStream::operator>><bool>
EXTRN	?Read@FDataStream@@IAEXAA_N@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5_N@FDataStream@@QAEAAV0@AA_N@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5_N@FDataStream@@QAEAAV0@AA_N@Z PROC		; FDataStream::operator>><bool>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5_N@FDataStream@@QAEAAV0@AA_N@Z ENDP		; FDataStream::operator>><bool>
_TEXT	ENDS
PUBLIC	??$?6_N@FDataStream@@QAEAAV0@AB_N@Z		; FDataStream::operator<<<bool>
EXTRN	?Write@FDataStream@@IAEXAB_N@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6_N@FDataStream@@QAEAAV0@AB_N@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6_N@FDataStream@@QAEAAV0@AB_N@Z PROC		; FDataStream::operator<<<bool>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6_N@FDataStream@@QAEAAV0@AB_N@Z ENDP		; FDataStream::operator<<<bool>
_TEXT	ENDS
PUBLIC	??$?5I@FDataStream@@QAEAAV0@AAI@Z		; FDataStream::operator>><unsigned int>
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5I@FDataStream@@QAEAAV0@AAI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5I@FDataStream@@QAEAAV0@AAI@Z PROC			; FDataStream::operator>><unsigned int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5I@FDataStream@@QAEAAV0@AAI@Z ENDP			; FDataStream::operator>><unsigned int>
_TEXT	ENDS
PUBLIC	??$?6I@FDataStream@@QAEAAV0@ABI@Z		; FDataStream::operator<<<unsigned int>
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6I@FDataStream@@QAEAAV0@ABI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6I@FDataStream@@QAEAAV0@ABI@Z PROC			; FDataStream::operator<<<unsigned int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6I@FDataStream@@QAEAAV0@ABI@Z ENDP			; FDataStream::operator<<<unsigned int>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z ; std::_Ptr_cat<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z PROC ; std::_Ptr_cat<int *,int *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z ENDP ; std::_Ptr_cat<int *,int *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
PUBLIC	?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::begin, COMDAT
; _this$ = ecx

; 672  : 		return (const_iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 673  : 		}

	ret	4
?begin@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::end, COMDAT
; _this$ = ecx

; 682  : 		return (const_iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 683  : 		}

	ret	4
?end@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::end
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 62   : 	_Vector_const_iterator()

	mov	eax, ecx

; 63   : 		{	// construct with null pointer
; 64   : 		_Myptr = 0;

	mov	DWORD PTR [eax], 0

; 65   : 		}

	ret	0
??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ ; std::_Vector_const_iterator<int,std::allocator<int> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<int,std::allocator<int> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator++
_TEXT	ENDS
PUBLIC	??0?$SerializeFromSequenceContainer@$$CBH$$CBV?$vector@HV?$allocator@H@std@@@std@@@@QAE@AAVFDataStream@@ABV?$vector@HV?$allocator@H@std@@@std@@@Z ; SerializeFromSequenceContainer<int const ,std::vector<int,std::allocator<int> > const >::SerializeFromSequenceContainer<int const ,std::vector<int,std::allocator<int> > const >
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??0?$SerializeFromSequenceContainer@$$CBH$$CBV?$vector@HV?$allocator@H@std@@@std@@@@QAE@AAVFDataStream@@ABV?$vector@HV?$allocator@H@std@@@std@@@Z
_TEXT	SEGMENT
$T231858 = 8						; size = 4
_saveTo$ = 8						; size = 4
_container$ = 12					; size = 4
??0?$SerializeFromSequenceContainer@$$CBH$$CBV?$vector@HV?$allocator@H@std@@@std@@@@QAE@AAVFDataStream@@ABV?$vector@HV?$allocator@H@std@@@std@@@Z PROC ; SerializeFromSequenceContainer<int const ,std::vector<int,std::allocator<int> > const >::SerializeFromSequenceContainer<int const ,std::vector<int,std::allocator<int> > const >, COMDAT
; _this$ = ecx

; 69   : 	{

	mov	eax, DWORD PTR _container$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _saveTo$[esp]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi], ecx

; 70   : 		m_saveTo << container.size();

	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR $T231858[esp]
	sar	edx, 2
	push	eax
	mov	DWORD PTR $T231858[esp+4], edx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 71   : 	}

	mov	eax, esi
	pop	esi
	ret	8
??0?$SerializeFromSequenceContainer@$$CBH$$CBV?$vector@HV?$allocator@H@std@@@std@@@@QAE@AAVFDataStream@@ABV?$vector@HV?$allocator@H@std@@@std@@@Z ENDP ; SerializeFromSequenceContainer<int const ,std::vector<int,std::allocator<int> > const >::SerializeFromSequenceContainer<int const ,std::vector<int,std::allocator<int> > const >
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z ; std::_Iter_random<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z PROC ; std::_Iter_random<int *,int *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z ENDP ; std::_Iter_random<int *,int *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<int *,int *,std::random_access_iterator_tag>
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<int *,int *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt@3

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt@3:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<int *,int *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??R?$SerializeFromSequenceContainer@$$CBH$$CBV?$vector@HV?$allocator@H@std@@@std@@@@QAEXABH@Z ; SerializeFromSequenceContainer<int const ,std::vector<int,std::allocator<int> > const >::operator()
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??R?$SerializeFromSequenceContainer@$$CBH$$CBV?$vector@HV?$allocator@H@std@@@std@@@@QAEXABH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??R?$SerializeFromSequenceContainer@$$CBH$$CBV?$vector@HV?$allocator@H@std@@@std@@@@QAEXABH@Z PROC ; SerializeFromSequenceContainer<int const ,std::vector<int,std::allocator<int> > const >::operator(), COMDAT
; _this$ = ecx

; 75   : 		m_saveTo << i;

	mov	ecx, DWORD PTR [ecx]
	jmp	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
??R?$SerializeFromSequenceContainer@$$CBH$$CBV?$vector@HV?$allocator@H@std@@@std@@@@QAEXABH@Z ENDP ; SerializeFromSequenceContainer<int const ,std::vector<int,std::allocator<int> > const >::operator()
_TEXT	ENDS
PUBLIC	?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity@2
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@2:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::capacity
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=
_TEXT	ENDS
PUBLIC	??$_Fill@PAHH@std@@YAXPAH0ABH@Z			; std::_Fill<int *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill@PAHH@std@@YAXPAH0ABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAHH@std@@YAXPAH0ABH@Z PROC			; std::_Fill<int *,int>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@Fill@2
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill@2:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL3@Fill@2
	pop	esi
$LN1@Fill@2:

; 3160 : 	}

	ret	0
??$_Fill@PAHH@std@@YAXPAH0ABH@Z ENDP			; std::_Fill<int *,int>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z ; std::_Move_cat<int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z PROC ; std::_Move_cat<int *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z ENDP ; std::_Move_cat<int *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>, COMDAT

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi

; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;

	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx

; 2711 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_backw@4

; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_backw@4:

; 2713 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2714 : 	}

	ret	0
??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z ; std::_Iter_cat<int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z PROC ; std::_Iter_cat<int *>, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z ENDP ; std::_Iter_cat<int *>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<int *,unsigned int,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<int *,unsigned int,int>, COMDAT

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	mov	eax, DWORD PTR __Count$[esp-4]
	test	eax, eax
	jbe	SHORT $LN1@Fill_n
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
$LL3@Fill_n:

; 3198 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL3@Fill_n
	pop	esi
$LN1@Fill_n:

; 3199 : 	}

	ret	0
??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<int *,unsigned int,int>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<int *,int *,std::allocator<int> >, COMDAT

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 150  : 	if (_Count > 0)

	test	eax, eax
	jbe	SHORT $LN4@Uninit_cop

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Uninit_cop:
	pop	edi

; 152  : 	return (_Result);

	mov	eax, esi
	pop	esi

; 153  : 	}

	ret	0
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?dxWrap@@YAHH@Z					; dxWrap
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?dxWrap@@YAHH@Z
_TEXT	SEGMENT
_iDX$ = 8						; size = 4
?dxWrap@@YAHH@Z PROC					; dxWrap, COMDAT

; 74   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

	mov	edx, DWORD PTR [eax+4020]
	cmp	BYTE PTR [eax+4056], 0
	mov	eax, DWORD PTR _iDX$[esp-4]
	je	SHORT $LN13@dxWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dxWrap
	sub	eax, edx

; 76   : }

	ret	0

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

$LN11@dxWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dxWrap
	add	eax, edx
$LN13@dxWrap:

; 76   : }

	ret	0
?dxWrap@@YAHH@Z ENDP					; dxWrap
_TEXT	ENDS
PUBLIC	?dyWrap@@YAHH@Z					; dyWrap
; Function compile flags: /Ogtpy
;	COMDAT ?dyWrap@@YAHH@Z
_TEXT	SEGMENT
_iDY$ = 8						; size = 4
?dyWrap@@YAHH@Z PROC					; dyWrap, COMDAT

; 80   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

	mov	edx, DWORD PTR [eax+4024]
	cmp	BYTE PTR [eax+4057], 0
	mov	eax, DWORD PTR _iDY$[esp-4]
	je	SHORT $LN13@dyWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dyWrap
	sub	eax, edx

; 82   : }

	ret	0

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

$LN11@dyWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dyWrap
	add	eax, edx
$LN13@dyWrap:

; 82   : }

	ret	0
?dyWrap@@YAHH@Z ENDP					; dyWrap
_TEXT	ENDS
PUBLIC	?plotDistance@@YAHHHHH@Z			; plotDistance
; Function compile flags: /Ogtpy
;	COMDAT ?plotDistance@@YAHHHHH@Z
_TEXT	SEGMENT
_iDY$ = -12						; size = 4
tv320 = -8						; size = 4
tv357 = -4						; size = 4
_iX1$ = 8						; size = 4
_iDX$ = 12						; size = 4
_iY1$ = 12						; size = 4
$T232020 = 16						; size = 4
_iX2$ = 16						; size = 4
_iY2$ = 20						; size = 4
?plotDistance@@YAHHHHH@Z PROC				; plotDistance, COMDAT

; 144  : {

	sub	esp, 12					; 0000000cH

; 145  : 	int iDX;
; 146  : 	int iWrappedDX = dxWrap(iX2 - iX1);

	mov	ecx, DWORD PTR _iX2$[esp+8]
	sub	ecx, DWORD PTR _iX1$[esp+8]
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [edi+4056], 0
	mov	edx, DWORD PTR [edi+4020]
	mov	DWORD PTR tv320[esp+28], ecx
	je	SHORT $LN18@plotDistan
	mov	eax, edx
	shr	eax, 1
	cmp	ecx, eax
	jle	SHORT $LN20@plotDistan
	sub	ecx, edx
	jmp	SHORT $LN18@plotDistan
$LN20@plotDistan:
	neg	eax
	cmp	ecx, eax
	jge	SHORT $LN18@plotDistan
	add	ecx, edx
$LN18@plotDistan:

; 147  : 	int iWrappedDY = dyWrap(iY2 - iY1);

	mov	ebp, DWORD PTR _iY2$[esp+24]
	sub	ebp, DWORD PTR _iY1$[esp+24]
	cmp	BYTE PTR [edi+4057], 0
	mov	eax, DWORD PTR [edi+4024]
	je	SHORT $LN32@plotDistan
	mov	edx, eax
	shr	edx, 1
	cmp	ebp, edx
	jle	SHORT $LN34@plotDistan
	mov	ebx, ebp
	sub	ebx, eax
	mov	DWORD PTR $T232020[esp+24], ebx
	jmp	SHORT $LN36@plotDistan
$LN34@plotDistan:
	neg	edx
	cmp	ebp, edx
	jge	SHORT $LN32@plotDistan
	lea	ebx, DWORD PTR [eax+ebp]
	mov	DWORD PTR $T232020[esp+24], ebx
	jmp	SHORT $LN36@plotDistan
$LN32@plotDistan:
	mov	ebx, ebp
	mov	DWORD PTR $T232020[esp+24], ebp
$LN36@plotDistan:

; 148  : 	int iDY = abs(iWrappedDY);

	mov	eax, ebx
	cdq
	mov	esi, eax
	xor	esi, edx
	sub	esi, edx

; 149  : 
; 150  : #ifdef GAMECOREUTILS_FIX_PLOT_DISTANCE
; 151  : 	const CvMap& kMap = GC.getMap();
; 152  : 	// equidistant column joint fix (on X-wrapped maps):
; 153  : 	if ((kMap.isWrapX()) && (abs(iWrappedDX * 2) == kMap.getGridWidth()) && (iDY % 2 != 0) && ((iY1 % 2 == 0) == (iWrappedDX > (kMap.getGridWidth() >> 2))))

	cmp	BYTE PTR [edi+4056], 0
	mov	DWORD PTR _iDY$[esp+28], esi
	je	$LN77@plotDistan
	lea	eax, DWORD PTR [ecx+ecx]
	cdq
	mov	ebx, eax
	mov	eax, DWORD PTR [edi+4020]
	xor	ebx, edx
	sub	ebx, edx
	cmp	ebx, eax
	jne	SHORT $LN73@plotDistan
	mov	edx, esi
	and	edx, -2147483647			; 80000001H
	jns	SHORT $LN79@plotDistan
	dec	edx
	or	edx, -2					; fffffffeH
	inc	edx
$LN79@plotDistan:
	je	SHORT $LN73@plotDistan
	sar	eax, 2
	xor	edx, edx
	cmp	ecx, eax
	mov	eax, DWORD PTR _iY1$[esp+24]
	setg	dl
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN80@plotDistan
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN80@plotDistan:

; 154  : 	{
; 155  : 		iWrappedDX *= -1;  // change polarity

	mov	ebx, DWORD PTR $T232020[esp+24]
	neg	eax
	sbb	eax, eax
	inc	eax
	cmp	eax, edx
	jne	SHORT $LN5@plotDistan
	neg	ecx
	jmp	SHORT $LN5@plotDistan
$LN73@plotDistan:
	mov	ebx, DWORD PTR $T232020[esp+24]
$LN5@plotDistan:

; 156  : 	}
; 157  : 	if ((kMap.isWrapX()) && (abs(iWrappedDX * 2) == kMap.getGridWidth()) && (abs(iWrappedDY) < abs(iY2 - iY1)) && (iDY % 2 == 0) && (iX2 - iX1 < 0))

	cmp	BYTE PTR [edi+4056], 0
	je	$LN77@plotDistan
	lea	eax, DWORD PTR [ecx+ecx]
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	eax, DWORD PTR [edi+4020]
	jne	SHORT $LN75@plotDistan
	mov	eax, ebp
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	esi, eax
	jge	SHORT $LN75@plotDistan
	mov	edx, DWORD PTR _iDY$[esp+28]
	and	edx, -2147483647			; 80000001H
	jns	SHORT $LN81@plotDistan
	dec	edx
	or	edx, -2					; fffffffeH
	inc	edx
$LN81@plotDistan:
	jne	SHORT $LN75@plotDistan
	cmp	DWORD PTR tv320[esp+28], 0
	jge	SHORT $LN75@plotDistan

; 158  : 	{
; 159  : 		iWrappedDX *= -1;  // change polarity

	neg	ecx
$LN75@plotDistan:

; 160  : 	}
; 161  : 	// special case when map is toroidal AND map height is odd
; 162  : 	// TODO works but ugly
; 163  : 	if ((kMap.isWrapX()) && (kMap.getGridHeight() % 2 != 0) && (iY1 % 2 == kMap.getGridWidth() % 2) && (iY2 % 2 == 0) &&
; 164  : 		(abs(iWrappedDY) < abs(iY2 - iY1)) && (abs(iX2 - iX1) == kMap.getGridWidth() / 2 + ((kMap.getGridWidth() % 2 == 1) && (iX2 - iX1 > 0)) ? 1 : 0))

	cmp	BYTE PTR [edi+4056], 0
	je	$LN77@plotDistan
	mov	eax, DWORD PTR [edi+4024]
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN82@plotDistan
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN82@plotDistan:
	je	$LN77@plotDistan
	mov	edi, DWORD PTR [edi+4020]
	mov	DWORD PTR tv357[esp+28], edi
	and	edi, -2147483647			; 80000001H
	jns	SHORT $LN83@plotDistan
	dec	edi
	or	edi, -2					; fffffffeH
	inc	edi
$LN83@plotDistan:
	mov	edx, DWORD PTR _iY1$[esp+24]
	and	edx, -2147483647			; 80000001H
	jns	SHORT $LN84@plotDistan
	dec	edx
	or	edx, -2					; fffffffeH
	inc	edx
$LN84@plotDistan:
	cmp	edx, edi
	jne	SHORT $LN77@plotDistan
	mov	eax, DWORD PTR _iY2$[esp+24]
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN85@plotDistan
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN85@plotDistan:
	jne	SHORT $LN77@plotDistan
	mov	eax, ebp
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	esi, eax
	jge	SHORT $LN77@plotDistan
	cmp	edi, 1
	jne	SHORT $LN76@plotDistan
	cmp	DWORD PTR tv320[esp+28], 0
	jle	SHORT $LN76@plotDistan
	mov	esi, edi
	jmp	SHORT $LN9@plotDistan
$LN76@plotDistan:
	xor	esi, esi
$LN9@plotDistan:
	mov	eax, DWORD PTR tv320[esp+28]
	cdq
	mov	edi, eax
	mov	eax, DWORD PTR tv357[esp+28]
	xor	edi, edx
	sub	edi, edx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, esi
	cmp	edi, eax
	jne	SHORT $LN77@plotDistan

; 165  : 	{
; 166  : 		iWrappedDX -= (iWrappedDX > 0) - (iWrappedDX < 0);  // decrease regardless of polarity

	xor	edx, edx
	test	ecx, ecx
	setl	dl
	xor	eax, eax
	test	ecx, ecx
	setg	al
	sub	edx, eax
	add	ecx, edx
$LN77@plotDistan:

; 167  : 	}
; 168  : #endif
; 169  : 
; 170  : 	// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 171  : 	int iHX1 = xToHexspaceX(iX1, iY1);

	mov	eax, DWORD PTR _iY1$[esp+24]
	test	eax, eax
	jge	SHORT $LN88@plotDistan
	dec	eax
	cdq
	sub	eax, edx
$LN88@plotDistan:
	mov	edi, DWORD PTR _iX1$[esp+24]

; 172  : 	int iHX2 = xToHexspaceX(iX1 + iWrappedDX, iY1 + iWrappedDY);

	mov	edx, DWORD PTR _iY1$[esp+24]
	sar	eax, 1
	mov	esi, edi
	sub	esi, eax
	lea	eax, DWORD PTR [ebx+edx]
	test	eax, eax
	jge	SHORT $LN89@plotDistan
	dec	eax
	cdq
	sub	eax, edx
$LN89@plotDistan:
	sar	eax, 1
	sub	ecx, eax
	add	ecx, edi

; 173  : 
; 174  : #ifdef GAMECOREUTILS_FIX_PLOT_DISTANCE
; 175  : 	// obvious bug
; 176  : 	iDX = abs(iHX2 - iHX1);

	sub	ecx, esi
	mov	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx

; 177  : #else
; 178  : 	iDX = abs(dxWrap(iHX2 - iHX1));
; 179  : #endif
; 180  : 
; 181  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 182  : 	if (((iHX2 - iHX1) ^ (iWrappedDY)) >= 0)  // the signs match
; 183  : #else
; 184  : 	if((iHX2 - iHX1 >= 0) == (iWrappedDY >= 0))  // the signs match

	xor	edx, edx
	test	ecx, ecx
	setge	dl
	xor	ecx, ecx
	test	ebx, ebx
	setge	cl
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR _iDX$[esp+12], eax
	pop	ebx
	cmp	edx, ecx
	jne	SHORT $LN2@plotDistan

; 185  : #endif
; 186  : 	{
; 187  : 		return iDX + iDY;

	mov	edx, DWORD PTR _iDY$[esp+12]
	add	eax, edx

; 195  : #endif
; 196  : 	}
; 197  : }

	add	esp, 12					; 0000000cH
	ret	0
$LN2@plotDistan:

; 188  : 	}
; 189  : 	else
; 190  : 	{
; 191  : #ifdef NQM_FAST_COMP
; 192  : 		return (MAX(iDX, iDY));
; 193  : #else
; 194  : 		return (std::max(iDX, iDY));

	cmp	eax, DWORD PTR _iDY$[esp+12]
	lea	eax, DWORD PTR _iDY$[esp+12]
	jl	SHORT $LN71@plotDistan
	lea	eax, DWORD PTR _iDX$[esp+8]
$LN71@plotDistan:
	mov	eax, DWORD PTR [eax]

; 195  : #endif
; 196  : 	}
; 197  : }

	add	esp, 12					; 0000000cH
	ret	0
?plotDistance@@YAHHHHH@Z ENDP				; plotDistance
_TEXT	ENDS
PUBLIC	?GetMaximumRecruitTurns@CvAIOperation@@UBEHXZ	; CvAIOperation::GetMaximumRecruitTurns
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
;	COMDAT ?GetMaximumRecruitTurns@CvAIOperation@@UBEHXZ
_TEXT	SEGMENT
?GetMaximumRecruitTurns@CvAIOperation@@UBEHXZ PROC	; CvAIOperation::GetMaximumRecruitTurns, COMDAT
; _this$ = ecx

; 119  : 	return GC.getAI_OPERATIONAL_MAX_RECRUIT_TURNS_DEFAULT();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7852

; 120  : }

	ret	0
?GetMaximumRecruitTurns@CvAIOperation@@UBEHXZ ENDP	; CvAIOperation::GetMaximumRecruitTurns
_TEXT	ENDS
PUBLIC	?SetTargetPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z	; CvAIOperation::SetTargetPlot
; Function compile flags: /Ogtpy
;	COMDAT ?SetTargetPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z
_TEXT	SEGMENT
_pTarget$ = 8						; size = 4
?SetTargetPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z PROC	; CvAIOperation::SetTargetPlot, COMDAT
; _this$ = ecx

; 188  : 	m_iTargetX = pTarget->getX();

	mov	eax, DWORD PTR _pTarget$[esp-4]
	movsx	edx, WORD PTR [eax]
	mov	DWORD PTR [ecx+104], edx

; 189  : 	m_iTargetY = pTarget->getY();

	movsx	eax, WORD PTR [eax+2]
	mov	DWORD PTR [ecx+108], eax

; 190  : }

	ret	4
?SetTargetPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ENDP	; CvAIOperation::SetTargetPlot
_TEXT	ENDS
PUBLIC	?SetMusterPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z	; CvAIOperation::SetMusterPlot
; Function compile flags: /Ogtpy
;	COMDAT ?SetMusterPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z
_TEXT	SEGMENT
_pMuster$ = 8						; size = 4
?SetMusterPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z PROC	; CvAIOperation::SetMusterPlot, COMDAT
; _this$ = ecx

; 203  : 	m_iMusterX = pMuster->getX();

	mov	eax, DWORD PTR _pMuster$[esp-4]
	movsx	edx, WORD PTR [eax]
	mov	DWORD PTR [ecx+96], edx

; 204  : 	m_iMusterY = pMuster->getY();

	movsx	eax, WORD PTR [eax+2]
	mov	DWORD PTR [ecx+100], eax

; 205  : }

	ret	4
?SetMusterPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ENDP	; CvAIOperation::SetMusterPlot
_TEXT	ENDS
PUBLIC	?SetStartCityPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ; CvAIOperation::SetStartCityPlot
; Function compile flags: /Ogtpy
;	COMDAT ?SetStartCityPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z
_TEXT	SEGMENT
_pStartCity$ = 8					; size = 4
?SetStartCityPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z PROC	; CvAIOperation::SetStartCityPlot, COMDAT
; _this$ = ecx

; 218  : 	m_iStartCityX = pStartCity->getX();

	mov	eax, DWORD PTR _pStartCity$[esp-4]
	movsx	edx, WORD PTR [eax]
	mov	DWORD PTR [ecx+88], edx

; 219  : 	m_iStartCityY = pStartCity->getY();

	movsx	eax, WORD PTR [eax+2]
	mov	DWORD PTR [ecx+92], eax

; 220  : }

	ret	4
?SetStartCityPlot@CvAIOperation@@QAEXPAVCvPlot@@@Z ENDP	; CvAIOperation::SetStartCityPlot
_TEXT	ENDS
PUBLIC	?HasOneMoreSlotToFill@CvAIOperation@@QBE_NXZ	; CvAIOperation::HasOneMoreSlotToFill
; Function compile flags: /Ogtpy
;	COMDAT ?HasOneMoreSlotToFill@CvAIOperation@@QBE_NXZ
_TEXT	SEGMENT
?HasOneMoreSlotToFill@CvAIOperation@@QBE_NXZ PROC	; CvAIOperation::HasOneMoreSlotToFill, COMDAT
; _this$ = ecx

; 1121 : 	if(m_viListOfUnitsWeStillNeedToBuild.size() == 1 && m_eCurrentState  == AI_OPERATION_STATE_RECRUITING_UNITS)

	mov	edx, DWORD PTR [ecx+28]
	sub	edx, DWORD PTR [ecx+24]
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	push	esi
	sar	edx, 1
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	mov	eax, 1
	cmp	esi, eax
	pop	esi
	jne	SHORT $LN1@HasOneMore
	cmp	DWORD PTR [ecx+56], eax

; 1122 : 	{
; 1123 : 		return true;

	je	SHORT $LN2@HasOneMore
$LN1@HasOneMore:

; 1124 : 	}
; 1125 : 
; 1126 : 	return false;

	xor	al, al
$LN2@HasOneMore:

; 1127 : }

	ret	0
?HasOneMoreSlotToFill@CvAIOperation@@QBE_NXZ ENDP	; CvAIOperation::HasOneMoreSlotToFill
_TEXT	ENDS
PUBLIC	?GetLogFileName@CvAIOperation@@IBE?AVCvString@@AAV2@@Z ; CvAIOperation::GetLogFileName
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z:PROC
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z:PROC
EXTRN	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ:PROC ; CvGlobals::getPlayerAndCityAILogSplit
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?GetLogFileName@CvAIOperation@@IBE?AVCvString@@AAV2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvAIOperation@@IBE?AVCvString@@AAV2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvAIOperation@@IBE?AVCvString@@AAV2@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?GetLogFileName@CvAIOperation@@IBE?AVCvString@@AAV2@@Z$2
__ehfuncinfo$?GetLogFileName@CvAIOperation@@IBE?AVCvString@@AAV2@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?GetLogFileName@CvAIOperation@@IBE?AVCvString@@AAV2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
xdata$x	ENDS
;	COMDAT ?GetLogFileName@CvAIOperation@@IBE?AVCvString@@AAV2@@Z
_TEXT	SEGMENT
$T232169 = -72						; size = 4
$T232167 = -68						; size = 28
$T232166 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_playerName$ = 12					; size = 4
?GetLogFileName@CvAIOperation@@IBE?AVCvString@@AAV2@@Z PROC ; CvAIOperation::GetLogFileName, COMDAT
; _this$ = ecx

; 1538 : {

	push	-1
	push	__ehhandler$?GetLogFileName@CvAIOperation@@IBE?AVCvString@@AAV2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 60					; 0000003cH
	push	ebx
	xor	ebx, ebx
	push	esi
	mov	DWORD PTR $T232169[esp+80], ebx

; 1539 : 	CvString strLogName;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+76]
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+88], ebx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1549 : 	}
; 1550 : 
; 1551 : 	return strLogName;

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR __$EHRec$[esp+88], ebx
	mov	DWORD PTR $T232169[esp+80], 1
	call	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ ; CvGlobals::getPlayerAndCityAILogSplit
	test	al, al
	je	SHORT $LN2@GetLogFile
	mov	eax, DWORD PTR _playerName$[esp+76]
	push	eax
	lea	ecx, DWORD PTR $T232166[esp+84]
	push	OFFSET $SG224949
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	push	OFFSET $SG224948
	push	eax
	lea	edx, DWORD PTR $T232167[esp+100]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+112], 1
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 24					; 00000018H
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+88], 2
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T232167[esp+80]
	mov	BYTE PTR __$EHRec$[esp+88], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T232166[esp+80]
	mov	BYTE PTR __$EHRec$[esp+88], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, esi
	pop	esi
	pop	ebx

; 1552 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+72]
	mov	DWORD PTR fs:0, ecx
	add	esp, 72					; 00000048H
	ret	8
$LN2@GetLogFile:

; 1540 : 
; 1541 : 	// Open the log file
; 1542 : 	if(GC.getPlayerAndCityAILogSplit())
; 1543 : 	{
; 1544 : 		strLogName = "OperationalAILog_" + playerName + ".csv";
; 1545 : 	}
; 1546 : 	else
; 1547 : 	{
; 1548 : 		strLogName = "OperationalAILog.csv";

	push	OFFSET $SG224951
	mov	ecx, esi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 1552 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+80]
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 72					; 00000048H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetLogFileName@CvAIOperation@@IBE?AVCvString@@AAV2@@Z$0:
	mov	eax, DWORD PTR $T232169[ebp]
	and	eax, 1
	je	$LN6@GetLogFile
	and	DWORD PTR $T232169[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN6@GetLogFile:
	ret	0
__unwindfunclet$?GetLogFileName@CvAIOperation@@IBE?AVCvString@@AAV2@@Z$1:
	lea	ecx, DWORD PTR $T232166[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?GetLogFileName@CvAIOperation@@IBE?AVCvString@@AAV2@@Z$2:
	lea	ecx, DWORD PTR $T232167[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?GetLogFileName@CvAIOperation@@IBE?AVCvString@@AAV2@@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetLogFileName@CvAIOperation@@IBE?AVCvString@@AAV2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetLogFileName@CvAIOperation@@IBE?AVCvString@@AAV2@@Z ENDP ; CvAIOperation::GetLogFileName
PUBLIC	?SelectInitialMusterPoint@CvAIOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z ; CvAIOperation::SelectInitialMusterPoint
EXTRN	?GetLastOwnedPlot@CvStepPathFinder@@QBEPAVCvPlot@@W4PlayerTypes@@0PAV2@1@Z:PROC ; CvStepPathFinder::GetLastOwnedPlot
EXTRN	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ:PROC ; CvGlobals::getStepFinder
EXTRN	?GetGoalPlot@CvArmyAI@@QBEPAVCvPlot@@XZ:PROC	; CvArmyAI::GetGoalPlot
EXTRN	?plot@CvCity@@QBEPAVCvPlot@@XZ:PROC		; CvCity::plot
; Function compile flags: /Ogtpy
;	COMDAT ?SelectInitialMusterPoint@CvAIOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
_TEXT	SEGMENT
_pThisArmy$ = 8						; size = 4
?SelectInitialMusterPoint@CvAIOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z PROC ; CvAIOperation::SelectInitialMusterPoint, COMDAT
; _this$ = ecx

; 1556 : {

	push	ebp
	push	esi
	mov	esi, ecx

; 1557 : 	CvPlot* pMusterPt = NULL;
; 1558 : 	CvPlot* pStartCityPlot;
; 1559 : 	CvCity* pStartCity;
; 1560 : 
; 1561 : 	pStartCity = GetOperationStartCity();

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+52]
	push	edi
	xor	edi, edi
	call	edx

; 1562 : 	if(pStartCity)

	test	eax, eax
	je	SHORT $LN11@SelectInit

; 1563 : 	{
; 1564 : 		pStartCityPlot = pStartCity->plot();

	mov	ecx, eax
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	ebp, eax

; 1565 : 
; 1566 : 		if(pStartCityPlot != NULL)

	test	ebp, ebp
	je	SHORT $LN11@SelectInit

; 1567 : 		{
; 1568 : 			// Generate a step path from our start to the target
; 1569 : 			pMusterPt = GC.getStepFinder().GetLastOwnedPlot(GetOwner(), GetEnemy(), pStartCityPlot, pThisArmy->GetGoalPlot());

	mov	ecx, DWORD PTR _pThisArmy$[esp+8]
	mov	edi, DWORD PTR [esi+76]
	push	ebx
	mov	ebx, DWORD PTR [esi+72]
	call	?GetGoalPlot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::GetGoalPlot
	push	eax
	push	ebp
	push	edi
	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, eax
	call	?GetLastOwnedPlot@CvStepPathFinder@@QBEPAVCvPlot@@W4PlayerTypes@@0PAV2@1@Z ; CvStepPathFinder::GetLastOwnedPlot
	mov	edi, eax
	pop	ebx

; 1570 : 
; 1571 : 			// Should find a space we own
; 1572 : 			if(pMusterPt == NULL)

	test	edi, edi
	jne	SHORT $LN2@SelectInit
	pop	edi
	pop	esi

; 1573 : 			{
; 1574 : 				return NULL;

	xor	eax, eax
	pop	ebp

; 1584 : }

	ret	4
$LN2@SelectInit:

; 1575 : 			}
; 1576 : 			else
; 1577 : 			{
; 1578 : 				SetMusterPlot(pMusterPt);

	movsx	eax, WORD PTR [edi]
	mov	DWORD PTR [esi+96], eax
	movsx	ecx, WORD PTR [edi+2]
	mov	DWORD PTR [esi+100], ecx
$LN11@SelectInit:

; 1579 : 			}
; 1580 : 		}
; 1581 : 	}
; 1582 : 
; 1583 : 	return pMusterPt;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp

; 1584 : }

	ret	4
?SelectInitialMusterPoint@CvAIOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z ENDP ; CvAIOperation::SelectInitialMusterPoint
_TEXT	ENDS
PUBLIC	??MCvOperationSearchUnit@@QBE_NABV0@@Z		; CvOperationSearchUnit::operator<
; Function compile flags: /Ogtpy
;	COMDAT ??MCvOperationSearchUnit@@QBE_NABV0@@Z
_TEXT	SEGMENT
_kUnit$ = 8						; size = 4
??MCvOperationSearchUnit@@QBE_NABV0@@Z PROC		; CvOperationSearchUnit::operator<, COMDAT
; _this$ = ecx

; 1594 : 		return (GetDistance() < kUnit.GetDistance());

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR _kUnit$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setl	cl
	mov	al, cl

; 1595 : 	}

	ret	4
??MCvOperationSearchUnit@@QBE_NABV0@@Z ENDP		; CvOperationSearchUnit::operator<
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABW4AIOperationMovementType@@@Z ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABW4AIOperationMovementType@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
$T232231 = 12						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABW4AIOperationMovementType@@@Z PROC ; operator<<, COMDAT

; 1888 : 	saveTo << static_cast<int>(readFrom);

	mov	eax, DWORD PTR _readFrom$[esp-4]
	mov	ecx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR _saveTo$[esp]
	lea	edx, DWORD PTR $T232231[esp]
	mov	DWORD PTR $T232231[esp], ecx
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1889 : 	return saveTo;

	mov	eax, esi
	pop	esi

; 1890 : }

	ret	0
??6@YAAAVFDataStream@@AAV0@ABW4AIOperationMovementType@@@Z ENDP ; operator<<
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAW4AIOperationMovementType@@@Z ; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAW4AIOperationMovementType@@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAW4AIOperationMovementType@@@Z PROC ; operator>>, COMDAT

; 1892 : {

	push	esi

; 1893 : 	int v;
; 1894 : 	loadFrom >> v;

	mov	esi, DWORD PTR _loadFrom$[esp]
	lea	eax, DWORD PTR _v$[esp]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1895 : 	writeTo = static_cast<AIOperationMovementType>(v);

	mov	ecx, DWORD PTR _writeTo$[esp]
	mov	edx, DWORD PTR _v$[esp]

; 1896 : 	return loadFrom;

	mov	eax, esi
	mov	DWORD PTR [ecx], edx
	pop	esi

; 1897 : }

	ret	0
??5@YAAAVFDataStream@@AAV0@AAW4AIOperationMovementType@@@Z ENDP ; operator>>
_TEXT	ENDS
PUBLIC	?GetMaximumRecruitTurns@CvAIEnemyTerritoryOperation@@UBEHXZ ; CvAIEnemyTerritoryOperation::GetMaximumRecruitTurns
; Function compile flags: /Ogtpy
;	COMDAT ?GetMaximumRecruitTurns@CvAIEnemyTerritoryOperation@@UBEHXZ
_TEXT	SEGMENT
?GetMaximumRecruitTurns@CvAIEnemyTerritoryOperation@@UBEHXZ PROC ; CvAIEnemyTerritoryOperation::GetMaximumRecruitTurns, COMDAT
; _this$ = ecx

; 1913 : 	return GC.getAI_OPERATIONAL_MAX_RECRUIT_TURNS_ENEMY_TERRITORY();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7856

; 1914 : }

	ret	0
?GetMaximumRecruitTurns@CvAIEnemyTerritoryOperation@@UBEHXZ ENDP ; CvAIEnemyTerritoryOperation::GetMaximumRecruitTurns
_TEXT	ENDS
PUBLIC	?GetDeployRange@CvAIEnemyTerritoryOperation@@UBEHXZ ; CvAIEnemyTerritoryOperation::GetDeployRange
; Function compile flags: /Ogtpy
;	COMDAT ?GetDeployRange@CvAIEnemyTerritoryOperation@@UBEHXZ
_TEXT	SEGMENT
?GetDeployRange@CvAIEnemyTerritoryOperation@@UBEHXZ PROC ; CvAIEnemyTerritoryOperation::GetDeployRange, COMDAT
; _this$ = ecx

; 2005 : 	return GC.getAI_OPERATIONAL_CITY_ATTACK_DEPLOY_RANGE();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2420

; 2006 : }

	ret	0
?GetDeployRange@CvAIEnemyTerritoryOperation@@UBEHXZ ENDP ; CvAIEnemyTerritoryOperation::GetDeployRange
_TEXT	ENDS
PUBLIC	?GetFormation@CvAIOperationBasicCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ ; CvAIOperationBasicCityAttack::GetFormation
EXTRN	?GetAIMapHint@CvMap@@QAEHXZ:PROC		; CvMap::GetAIMapHint
EXTRN	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ:PROC ; CvGame::getHandicapInfo
; Function compile flags: /Ogtpy
;	COMDAT ?GetFormation@CvAIOperationBasicCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ
_TEXT	SEGMENT
?GetFormation@CvAIOperationBasicCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ PROC ; CvAIOperationBasicCityAttack::GetFormation, COMDAT
; _this$ = ecx

; 2210 : 	return (GC.getGame().getHandicapInfo().GetID() > 4 && !(GC.getMap().GetAIMapHint() & 1)) ? MUFORMATION_BIGGER_CITY_ATTACK_FORCE : MUFORMATION_BASIC_CITY_ATTACK_FORCE;

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ ; CvGame::getHandicapInfo
	cmp	DWORD PTR [eax+4], 4
	jle	SHORT $LN3@GetFormati
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?GetAIMapHint@CvMap@@QAEHXZ		; CvMap::GetAIMapHint
	test	al, 1
	jne	SHORT $LN3@GetFormati
	mov	eax, 18					; 00000012H

; 2211 : }

	ret	0
$LN3@GetFormati:

; 2210 : 	return (GC.getGame().getHandicapInfo().GetID() > 4 && !(GC.getMap().GetAIMapHint() & 1)) ? MUFORMATION_BIGGER_CITY_ATTACK_FORCE : MUFORMATION_BASIC_CITY_ATTACK_FORCE;

	xor	eax, eax

; 2211 : }

	ret	0
?GetFormation@CvAIOperationBasicCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ ENDP ; CvAIOperationBasicCityAttack::GetFormation
_TEXT	ENDS
PUBLIC	?GetFormation@CvAIOperationSneakCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ ; CvAIOperationSneakCityAttack::GetFormation
; Function compile flags: /Ogtpy
;	COMDAT ?GetFormation@CvAIOperationSneakCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ
_TEXT	SEGMENT
?GetFormation@CvAIOperationSneakCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ PROC ; CvAIOperationSneakCityAttack::GetFormation, COMDAT
; _this$ = ecx

; 2308 : 	return (GC.getGame().getHandicapInfo().GetID() > 4 && !(GC.getMap().GetAIMapHint() & 1)) ? MUFORMATION_BIGGER_CITY_ATTACK_FORCE : MUFORMATION_BASIC_CITY_ATTACK_FORCE;

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ ; CvGame::getHandicapInfo
	cmp	DWORD PTR [eax+4], 4
	jle	SHORT $LN3@GetFormati@2
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?GetAIMapHint@CvMap@@QAEHXZ		; CvMap::GetAIMapHint
	test	al, 1
	jne	SHORT $LN3@GetFormati@2
	mov	eax, 18					; 00000012H

; 2309 : }

	ret	0
$LN3@GetFormati@2:

; 2308 : 	return (GC.getGame().getHandicapInfo().GetID() > 4 && !(GC.getMap().GetAIMapHint() & 1)) ? MUFORMATION_BIGGER_CITY_ATTACK_FORCE : MUFORMATION_BASIC_CITY_ATTACK_FORCE;

	xor	eax, eax

; 2309 : }

	ret	0
?GetFormation@CvAIOperationSneakCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ ENDP ; CvAIOperationSneakCityAttack::GetFormation
_TEXT	ENDS
PUBLIC	?GetFormation@CvAIOperationCityStateAttack@@UBE?AW4MultiunitFormationTypes@@XZ ; CvAIOperationCityStateAttack::GetFormation
; Function compile flags: /Ogtpy
;	COMDAT ?GetFormation@CvAIOperationCityStateAttack@@UBE?AW4MultiunitFormationTypes@@XZ
_TEXT	SEGMENT
?GetFormation@CvAIOperationCityStateAttack@@UBE?AW4MultiunitFormationTypes@@XZ PROC ; CvAIOperationCityStateAttack::GetFormation, COMDAT
; _this$ = ecx

; 2334 : 	return (GC.getGame().getHandicapInfo().GetID() > 4 && !(GC.getMap().GetAIMapHint() & 1)) ? MUFORMATION_BIGGER_CITY_ATTACK_FORCE : MUFORMATION_CITY_STATE_ATTACK_FORCE;

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ ; CvGame::getHandicapInfo
	cmp	DWORD PTR [eax+4], 4
	jle	SHORT $LN3@GetFormati@3
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?GetAIMapHint@CvMap@@QAEHXZ		; CvMap::GetAIMapHint
	test	al, 1
	mov	eax, 18					; 00000012H
	je	SHORT $LN4@GetFormati@3
$LN3@GetFormati@3:
	mov	eax, 1
$LN4@GetFormati@3:

; 2335 : }

	ret	0
?GetFormation@CvAIOperationCityStateAttack@@UBE?AW4MultiunitFormationTypes@@XZ ENDP ; CvAIOperationCityStateAttack::GetFormation
_TEXT	ENDS
PUBLIC	?GetDeployRange@CvAIOperationDestroyBarbarianCamp@@UBEHXZ ; CvAIOperationDestroyBarbarianCamp::GetDeployRange
; Function compile flags: /Ogtpy
;	COMDAT ?GetDeployRange@CvAIOperationDestroyBarbarianCamp@@UBEHXZ
_TEXT	SEGMENT
?GetDeployRange@CvAIOperationDestroyBarbarianCamp@@UBEHXZ PROC ; CvAIOperationDestroyBarbarianCamp::GetDeployRange, COMDAT
; _this$ = ecx

; 2356 : 	return GC.getAI_OPERATIONAL_BARBARIAN_CAMP_DEPLOY_RANGE();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2416

; 2357 : }

	ret	0
?GetDeployRange@CvAIOperationDestroyBarbarianCamp@@UBEHXZ ENDP ; CvAIOperationDestroyBarbarianCamp::GetDeployRange
_TEXT	ENDS
PUBLIC	?GetDeployRange@CvAIOperationPillageEnemy@@UBEHXZ ; CvAIOperationPillageEnemy::GetDeployRange
; Function compile flags: /Ogtpy
;	COMDAT ?GetDeployRange@CvAIOperationPillageEnemy@@UBEHXZ
_TEXT	SEGMENT
?GetDeployRange@CvAIOperationPillageEnemy@@UBEHXZ PROC	; CvAIOperationPillageEnemy::GetDeployRange, COMDAT
; _this$ = ecx

; 2628 : 	return GC.getAI_OPERATIONAL_PILLAGE_ENEMY_DEPLOY_RANGE();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2424

; 2629 : }

	ret	0
?GetDeployRange@CvAIOperationPillageEnemy@@UBEHXZ ENDP	; CvAIOperationPillageEnemy::GetDeployRange
_TEXT	ENDS
PUBLIC	?FindBestCivilian@CvAIEscortedOperation@@UAEPAVCvUnit@@XZ ; CvAIEscortedOperation::FindBestCivilian
EXTRN	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::nextUnit
EXTRN	?getArmyID@CvUnit@@QBEHXZ:PROC			; CvUnit::getArmyID
EXTRN	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ:PROC ; CvUnit::AI_getUnitAIType
EXTRN	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::firstUnit
; Function compile flags: /Ogtpy
;	COMDAT ?FindBestCivilian@CvAIEscortedOperation@@UAEPAVCvUnit@@XZ
_TEXT	SEGMENT
_iUnitLoop$ = -4					; size = 4
?FindBestCivilian@CvAIEscortedOperation@@UAEPAVCvUnit@@XZ PROC ; CvAIEscortedOperation::FindBestCivilian, COMDAT
; _this$ = ecx

; 2967 : {

	push	ecx
	push	esi
	push	edi
	mov	edi, ecx

; 2968 : 	int iUnitLoop;
; 2969 : 	CvUnit* pLoopUnit;
; 2970 : 
; 2971 : 	for(pLoopUnit = GET_PLAYER(m_eOwner).firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = GET_PLAYER(m_eOwner).nextUnit(&iUnitLoop))

	mov	ecx, DWORD PTR [edi+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	lea	eax, DWORD PTR _iUnitLoop$[esp+16]
	push	eax
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN4@FindBestCi
$LN17@FindBestCi:

; 2972 : 	{
; 2973 : 		if(pLoopUnit != NULL)
; 2974 : 		{
; 2975 : 			if(pLoopUnit->AI_getUnitAIType() == m_eCivilianType)

	mov	ecx, esi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, DWORD PTR [edi+116]
	jne	SHORT $LN5@FindBestCi

; 2976 : 			{
; 2977 : 				if(pLoopUnit->getArmyID() == FFreeList::INVALID_INDEX)

	mov	ecx, esi
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	cmp	eax, -1
	je	SHORT $LN14@FindBestCi
$LN5@FindBestCi:

; 2968 : 	int iUnitLoop;
; 2969 : 	CvUnit* pLoopUnit;
; 2970 : 
; 2971 : 	for(pLoopUnit = GET_PLAYER(m_eOwner).firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = GET_PLAYER(m_eOwner).nextUnit(&iUnitLoop))

	mov	ecx, DWORD PTR [edi+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	lea	edx, DWORD PTR _iUnitLoop$[esp+16]
	push	edx
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LN17@FindBestCi
$LN4@FindBestCi:
	pop	edi

; 2980 : 				}
; 2981 : 			}
; 2982 : 		}
; 2983 : 	}
; 2984 : 
; 2985 : 	return NULL;

	xor	eax, eax
	pop	esi

; 2986 : }

	pop	ecx
	ret	0
$LN14@FindBestCi:
	pop	edi

; 2978 : 				{
; 2979 : 					return pLoopUnit;

	mov	eax, esi
	pop	esi

; 2986 : }

	pop	ecx
	ret	0
?FindBestCivilian@CvAIEscortedOperation@@UAEPAVCvUnit@@XZ ENDP ; CvAIEscortedOperation::FindBestCivilian
_TEXT	ENDS
PUBLIC	?FindBestTarget@CvAIOperationFoundCity@@EAEPAVCvPlot@@PAVCvUnit@@_N@Z ; CvAIOperationFoundCity::FindBestTarget
EXTRN	?GetBestSettlePlot@CvPlayer@@QBEPAVCvPlot@@PAVCvUnit@@_NH@Z:PROC ; CvPlayer::GetBestSettlePlot
; Function compile flags: /Ogtpy
;	COMDAT ?FindBestTarget@CvAIOperationFoundCity@@EAEPAVCvPlot@@PAVCvUnit@@_N@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
_bOnlySafePaths$ = 12					; size = 1
?FindBestTarget@CvAIOperationFoundCity@@EAEPAVCvPlot@@PAVCvUnit@@_N@Z PROC ; CvAIOperationFoundCity::FindBestTarget, COMDAT
; _this$ = ecx

; 3298 : {

	push	ebx

; 3299 : 	CvPlot* pResult = GET_PLAYER(m_eOwner).GetBestSettlePlot(pUnit, bOnlySafePaths /*m_bEscorted*/, m_iTargetArea);

	mov	ebx, DWORD PTR _pUnit$[esp]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi+72]
	mov	eax, DWORD PTR [esi+120]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edi
	mov	edi, DWORD PTR _bOnlySafePaths$[esp+8]
	push	eax
	push	edi
	push	ebx
	call	?GetBestSettlePlot@CvPlayer@@QBEPAVCvPlot@@PAVCvUnit@@_NH@Z ; CvPlayer::GetBestSettlePlot

; 3300 : 	if (pResult == NULL)

	test	eax, eax
	jne	SHORT $LN1@FindBestTa

; 3301 : 	{
; 3302 : 		m_iTargetArea = -1;
; 3303 : 		pResult = GET_PLAYER(m_eOwner).GetBestSettlePlot(pUnit, bOnlySafePaths /*m_bEscorted*/, -1);

	mov	ecx, DWORD PTR [esi+72]
	imul	ecx, 63236				; 0000f704H
	push	-1
	mov	DWORD PTR [esi+120], -1
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edi
	push	ebx
	call	?GetBestSettlePlot@CvPlayer@@QBEPAVCvPlot@@PAVCvUnit@@_NH@Z ; CvPlayer::GetBestSettlePlot
$LN1@FindBestTa:
	pop	edi
	pop	esi
	pop	ebx

; 3304 : 	}
; 3305 : 	return pResult;
; 3306 : }

	ret	8
?FindBestTarget@CvAIOperationFoundCity@@EAEPAVCvPlot@@PAVCvUnit@@_N@Z ENDP ; CvAIOperationFoundCity::FindBestTarget
_TEXT	ENDS
PUBLIC	?FindBestCivilian@CvAIOperationQuickColonize@@UAEPAVCvUnit@@XZ ; CvAIOperationQuickColonize::FindBestCivilian
; Function compile flags: /Ogtpy
;	COMDAT ?FindBestCivilian@CvAIOperationQuickColonize@@UAEPAVCvUnit@@XZ
_TEXT	SEGMENT
_iUnitLoop$ = -4					; size = 4
?FindBestCivilian@CvAIOperationQuickColonize@@UAEPAVCvUnit@@XZ PROC ; CvAIOperationQuickColonize::FindBestCivilian, COMDAT
; _this$ = ecx

; 3441 : {

	push	ecx
	push	esi
	push	edi
	mov	edi, ecx

; 3442 : 	int iUnitLoop;
; 3443 : 	CvUnit* pLoopUnit;
; 3444 : 
; 3445 : 	for(pLoopUnit = GET_PLAYER(m_eOwner).firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = GET_PLAYER(m_eOwner).nextUnit(&iUnitLoop))

	mov	ecx, DWORD PTR [edi+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	lea	eax, DWORD PTR _iUnitLoop$[esp+16]
	push	eax
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN4@FindBestCi@2
$LN17@FindBestCi@2:

; 3446 : 	{
; 3447 : 		if(pLoopUnit != NULL)
; 3448 : 		{
; 3449 : 			if(pLoopUnit->AI_getUnitAIType() == m_eCivilianType)

	mov	ecx, esi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, DWORD PTR [edi+116]
	jne	SHORT $LN5@FindBestCi@2

; 3450 : 			{
; 3451 : 				if(pLoopUnit->getArmyID() == FFreeList::INVALID_INDEX)

	mov	ecx, esi
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	cmp	eax, -1
	je	SHORT $LN14@FindBestCi@2
$LN5@FindBestCi@2:

; 3442 : 	int iUnitLoop;
; 3443 : 	CvUnit* pLoopUnit;
; 3444 : 
; 3445 : 	for(pLoopUnit = GET_PLAYER(m_eOwner).firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = GET_PLAYER(m_eOwner).nextUnit(&iUnitLoop))

	mov	ecx, DWORD PTR [edi+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	lea	edx, DWORD PTR _iUnitLoop$[esp+16]
	push	edx
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LN17@FindBestCi@2
$LN4@FindBestCi@2:
	pop	edi

; 3454 : 				}
; 3455 : 			}
; 3456 : 		}
; 3457 : 	}
; 3458 : 	return NULL;

	xor	eax, eax
	pop	esi

; 3459 : }

	pop	ecx
	ret	0
$LN14@FindBestCi@2:
	pop	edi

; 3452 : 				{
; 3453 : 					return pLoopUnit;

	mov	eax, esi
	pop	esi

; 3459 : }

	pop	ecx
	ret	0
?FindBestCivilian@CvAIOperationQuickColonize@@UAEPAVCvUnit@@XZ ENDP ; CvAIOperationQuickColonize::FindBestCivilian
_TEXT	ENDS
PUBLIC	?FindBestTarget@CvAIOperationQuickColonize@@EAEPAVCvPlot@@PAVCvUnit@@_N@Z ; CvAIOperationQuickColonize::FindBestTarget
; Function compile flags: /Ogtpy
;	COMDAT ?FindBestTarget@CvAIOperationQuickColonize@@EAEPAVCvPlot@@PAVCvUnit@@_N@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
___formal$ = 12						; size = 1
?FindBestTarget@CvAIOperationQuickColonize@@EAEPAVCvPlot@@PAVCvUnit@@_N@Z PROC ; CvAIOperationQuickColonize::FindBestTarget, COMDAT
; _this$ = ecx

; 3463 : {

	push	esi
	mov	esi, ecx

; 3464 : 	CvPlot* pResult = GET_PLAYER(m_eOwner).GetBestSettlePlot(pUnit, false, m_iTargetArea);

	mov	ecx, DWORD PTR [esi+72]
	mov	eax, DWORD PTR [esi+120]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edi
	mov	edi, DWORD PTR _pUnit$[esp+4]
	push	eax
	push	0
	push	edi
	call	?GetBestSettlePlot@CvPlayer@@QBEPAVCvPlot@@PAVCvUnit@@_NH@Z ; CvPlayer::GetBestSettlePlot

; 3465 : 	if (pResult == NULL)

	test	eax, eax
	jne	SHORT $LN1@FindBestTa@2

; 3466 : 	{
; 3467 : 		m_iTargetArea = -1;
; 3468 : 		pResult = GET_PLAYER(m_eOwner).GetBestSettlePlot(pUnit, false, -1);

	mov	ecx, DWORD PTR [esi+72]
	imul	ecx, 63236				; 0000f704H
	push	-1
	mov	DWORD PTR [esi+120], -1
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	push	edi
	call	?GetBestSettlePlot@CvPlayer@@QBEPAVCvPlot@@PAVCvUnit@@_NH@Z ; CvPlayer::GetBestSettlePlot
$LN1@FindBestTa@2:
	pop	edi
	pop	esi

; 3469 : 	}
; 3470 : 	return pResult;
; 3471 : }

	ret	8
?FindBestTarget@CvAIOperationQuickColonize@@EAEPAVCvPlot@@PAVCvUnit@@_N@Z ENDP ; CvAIOperationQuickColonize::FindBestTarget
_TEXT	ENDS
PUBLIC	?GetDeployRange@CvAINavalOperation@@UBEHXZ	; CvAINavalOperation::GetDeployRange
; Function compile flags: /Ogtpy
;	COMDAT ?GetDeployRange@CvAINavalOperation@@UBEHXZ
_TEXT	SEGMENT
?GetDeployRange@CvAINavalOperation@@UBEHXZ PROC		; CvAINavalOperation::GetDeployRange, COMDAT
; _this$ = ecx

; 3828 : 	return GC.getAI_OPERATIONAL_NAVAL_BOMBARDMENT_DEPLOY_RANGE();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2428

; 3829 : }

	ret	0
?GetDeployRange@CvAINavalOperation@@UBEHXZ ENDP		; CvAINavalOperation::GetDeployRange
_TEXT	ENDS
PUBLIC	?FindInitialUnit@CvAINavalOperation@@MAEPAVCvUnit@@XZ ; CvAINavalOperation::FindInitialUnit
EXTRN	?GetUnitAIType@CvUnitEntry@@QBE_NH@Z:PROC	; CvUnitEntry::GetUnitAIType
EXTRN	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z:PROC ; CvGlobals::getUnitInfo
EXTRN	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ:PROC	; CvUnit::getUnitType
; Function compile flags: /Ogtpy
;	COMDAT ?FindInitialUnit@CvAINavalOperation@@MAEPAVCvUnit@@XZ
_TEXT	SEGMENT
_iUnitLoop$ = -4					; size = 4
?FindInitialUnit@CvAINavalOperation@@MAEPAVCvUnit@@XZ PROC ; CvAINavalOperation::FindInitialUnit, COMDAT
; _this$ = ecx

; 3928 : {

	push	ecx
	push	esi
	push	edi
	mov	edi, ecx

; 3929 : 	int iUnitLoop;
; 3930 : 	CvUnit* pLoopUnit;
; 3931 : 
; 3932 : 	for(pLoopUnit = GET_PLAYER(m_eOwner).firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = GET_PLAYER(m_eOwner).nextUnit(&iUnitLoop))

	mov	ecx, DWORD PTR [edi+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	lea	eax, DWORD PTR _iUnitLoop$[esp+16]
	push	eax
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN5@FindInitia
$LN18@FindInitia:

; 3933 : 	{
; 3934 : 		if(pLoopUnit != NULL)
; 3935 : 		{
; 3936 : 			if(pLoopUnit->AI_getUnitAIType() != UNITAI_EXPLORE_SEA)

	mov	ecx, esi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 21					; 00000015H
	je	SHORT $LN6@FindInitia

; 3937 : 			{
; 3938 : 				CvUnitEntry* pkUnitEntry = GC.getUnitInfo(pLoopUnit->getUnitType());

	mov	ecx, esi
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo

; 3939 : 				if(pkUnitEntry && pkUnitEntry->GetUnitAIType(UNITAI_ATTACK_SEA))

	test	eax, eax
	je	SHORT $LN6@FindInitia
	push	18					; 00000012H
	mov	ecx, eax
	call	?GetUnitAIType@CvUnitEntry@@QBE_NH@Z	; CvUnitEntry::GetUnitAIType
	test	al, al
	je	SHORT $LN6@FindInitia

; 3940 : 				{
; 3941 : 					if(pLoopUnit->getArmyID() == FFreeList::INVALID_INDEX)

	mov	ecx, esi
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	cmp	eax, -1
	je	SHORT $LN15@FindInitia
$LN6@FindInitia:

; 3929 : 	int iUnitLoop;
; 3930 : 	CvUnit* pLoopUnit;
; 3931 : 
; 3932 : 	for(pLoopUnit = GET_PLAYER(m_eOwner).firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = GET_PLAYER(m_eOwner).nextUnit(&iUnitLoop))

	mov	ecx, DWORD PTR [edi+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	lea	edx, DWORD PTR _iUnitLoop$[esp+16]
	push	edx
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LN18@FindInitia
$LN5@FindInitia:
	pop	edi

; 3944 : 					}
; 3945 : 				}
; 3946 : 			}
; 3947 : 		}
; 3948 : 	}
; 3949 : 	return NULL;

	xor	eax, eax
	pop	esi

; 3950 : }

	pop	ecx
	ret	0
$LN15@FindInitia:
	pop	edi

; 3942 : 					{
; 3943 : 						return pLoopUnit;

	mov	eax, esi
	pop	esi

; 3950 : }

	pop	ecx
	ret	0
?FindInitialUnit@CvAINavalOperation@@MAEPAVCvUnit@@XZ ENDP ; CvAINavalOperation::FindInitialUnit
_TEXT	ENDS
PUBLIC	?GetDeployRange@CvAIOperationPureNavalCityAttack@@UBEHXZ ; CvAIOperationPureNavalCityAttack::GetDeployRange
; Function compile flags: /Ogtpy
;	COMDAT ?GetDeployRange@CvAIOperationPureNavalCityAttack@@UBEHXZ
_TEXT	SEGMENT
?GetDeployRange@CvAIOperationPureNavalCityAttack@@UBEHXZ PROC ; CvAIOperationPureNavalCityAttack::GetDeployRange, COMDAT
; _this$ = ecx

; 4679 : 	return GC.getAI_OPERATIONAL_CITY_ATTACK_DEPLOY_RANGE();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2420

; 4680 : }

	ret	0
?GetDeployRange@CvAIOperationPureNavalCityAttack@@UBEHXZ ENDP ; CvAIOperationPureNavalCityAttack::GetDeployRange
_TEXT	ENDS
PUBLIC	?FindBestCivilian@CvAINavalEscortedOperation@@UAEPAVCvUnit@@XZ ; CvAINavalEscortedOperation::FindBestCivilian
; Function compile flags: /Ogtpy
;	COMDAT ?FindBestCivilian@CvAINavalEscortedOperation@@UAEPAVCvUnit@@XZ
_TEXT	SEGMENT
_iUnitLoop$ = -4					; size = 4
?FindBestCivilian@CvAINavalEscortedOperation@@UAEPAVCvUnit@@XZ PROC ; CvAINavalEscortedOperation::FindBestCivilian, COMDAT
; _this$ = ecx

; 5195 : {

	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	ebx, ecx

; 5196 : 	int iUnitLoop = 0;
; 5197 : 	CvUnit* pLoopUnit = NULL;
; 5198 : 
; 5199 : 	CvPlayerAI& kOwner = GET_PLAYER(m_eOwner);

	mov	edi, DWORD PTR [ebx+72]
	imul	edi, 63236				; 0000f704H
	add	edi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 5200 : 
; 5201 : 	for(pLoopUnit = kOwner.firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = kOwner.nextUnit(&iUnitLoop))

	push	0
	lea	eax, DWORD PTR _iUnitLoop$[esp+20]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR _iUnitLoop$[esp+24], 0
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN4@FindBestCi@3
$LN15@FindBestCi@3:

; 5202 : 	{
; 5203 : 		if(pLoopUnit != NULL)
; 5204 : 		{
; 5205 : 			if(pLoopUnit->AI_getUnitAIType() == m_eCivilianType)

	mov	ecx, esi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, DWORD PTR [ebx+112]
	jne	SHORT $LN5@FindBestCi@3

; 5206 : 			{
; 5207 : 				if(pLoopUnit->getArmyID() == FFreeList::INVALID_INDEX)

	mov	ecx, esi
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	cmp	eax, -1
	je	SHORT $LN12@FindBestCi@3
$LN5@FindBestCi@3:

; 5200 : 
; 5201 : 	for(pLoopUnit = kOwner.firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = kOwner.nextUnit(&iUnitLoop))

	push	0
	lea	ecx, DWORD PTR _iUnitLoop$[esp+20]
	push	ecx
	mov	ecx, edi
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LN15@FindBestCi@3
$LN4@FindBestCi@3:
	pop	edi
	pop	esi

; 5210 : 				}
; 5211 : 			}
; 5212 : 		}
; 5213 : 	}
; 5214 : 	return NULL;

	xor	eax, eax
	pop	ebx

; 5215 : }

	pop	ecx
	ret	0
$LN12@FindBestCi@3:
	pop	edi

; 5208 : 				{
; 5209 : 					return pLoopUnit;

	mov	eax, esi
	pop	esi
	pop	ebx

; 5215 : }

	pop	ecx
	ret	0
?FindBestCivilian@CvAINavalEscortedOperation@@UAEPAVCvUnit@@XZ ENDP ; CvAINavalEscortedOperation::FindBestCivilian
_TEXT	ENDS
PUBLIC	?FindBestTarget@CvAINavalEscortedOperation@@IAEPAVCvPlot@@PAVCvUnit@@@Z ; CvAINavalEscortedOperation::FindBestTarget
; Function compile flags: /Ogtpy
;	COMDAT ?FindBestTarget@CvAINavalEscortedOperation@@IAEPAVCvPlot@@PAVCvUnit@@@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
?FindBestTarget@CvAINavalEscortedOperation@@IAEPAVCvPlot@@PAVCvUnit@@@Z PROC ; CvAINavalEscortedOperation::FindBestTarget, COMDAT
; _this$ = ecx

; 5336 : 	return GET_PLAYER(m_eOwner).GetBestSettlePlot(pUnit, true, -1);

	mov	ecx, DWORD PTR [ecx+72]
	mov	eax, DWORD PTR _pUnit$[esp-4]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	-1
	push	1
	push	eax
	call	?GetBestSettlePlot@CvPlayer@@QBEPAVCvPlot@@PAVCvUnit@@_NH@Z ; CvPlayer::GetBestSettlePlot

; 5337 : }

	ret	4
?FindBestTarget@CvAINavalEscortedOperation@@IAEPAVCvPlot@@PAVCvUnit@@@Z ENDP ; CvAINavalEscortedOperation::FindBestTarget
_TEXT	ENDS
PUBLIC	?FindBestFitReserveUnit@CvAIOperationNukeAttack@@UAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z ; CvAIOperationNukeAttack::FindBestFitReserveUnit
EXTRN	?AddUnit@CvArmyAI@@QAEXHH@Z:PROC		; CvArmyAI::AddUnit
EXTRN	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z:PROC	; CvPlayer::getArmyAI
; Function compile flags: /Ogtpy
;	COMDAT ?FindBestFitReserveUnit@CvAIOperationNukeAttack@@UAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
_TEXT	SEGMENT
_thisOperationSlot$ = 8					; size = 12
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
_bRequired$ = 28					; size = 4
?FindBestFitReserveUnit@CvAIOperationNukeAttack@@UAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z PROC ; CvAIOperationNukeAttack::FindBestFitReserveUnit, COMDAT
; _this$ = ecx

; 5839 : 	// okay, this can be simplified to
; 5840 : 	*bRequired = true;

	mov	eax, DWORD PTR _bRequired$[esp-4]

; 5841 : 	CvPlayerAI& ownerPlayer = GET_PLAYER(m_eOwner);
; 5842 : 	CvArmyAI* pThisArmy = ownerPlayer.getArmyAI(thisOperationSlot.m_iArmyID);

	mov	edx, DWORD PTR _thisOperationSlot$[esp]
	push	esi
	mov	esi, ecx
	mov	BYTE PTR [eax], 1
	mov	ecx, DWORD PTR [esi+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI

; 5843 : 	pThisArmy->AddUnit(m_iBestUnitID, thisOperationSlot.m_iSlotID);

	mov	ecx, DWORD PTR _thisOperationSlot$[esp+8]
	mov	edx, DWORD PTR [esi+112]
	push	ecx
	push	edx
	mov	ecx, eax
	call	?AddUnit@CvArmyAI@@QAEXHH@Z		; CvArmyAI::AddUnit

; 5844 : 	return true;

	mov	al, 1
	pop	esi

; 5845 : }

	ret	24					; 00000018H
?FindBestFitReserveUnit@CvAIOperationNukeAttack@@UAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z ENDP ; CvAIOperationNukeAttack::FindBestFitReserveUnit
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABW4AIOperationState@@@Z ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABW4AIOperationState@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_v$ = 12						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABW4AIOperationState@@@Z PROC ; operator<<, COMDAT

; 5850 : 	int v = static_cast<int>(readFrom);

	mov	eax, DWORD PTR _readFrom$[esp-4]
	mov	ecx, DWORD PTR [eax]
	push	esi

; 5851 : 	saveTo << v;

	mov	esi, DWORD PTR _saveTo$[esp]
	lea	edx, DWORD PTR _v$[esp]
	mov	DWORD PTR _v$[esp], ecx
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 5852 : 	return saveTo;

	mov	eax, esi
	pop	esi

; 5853 : }

	ret	0
??6@YAAAVFDataStream@@AAV0@ABW4AIOperationState@@@Z ENDP ; operator<<
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAW4AIOperationState@@@Z ; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAW4AIOperationState@@@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAW4AIOperationState@@@Z PROC ; operator>>, COMDAT

; 5856 : {

	push	esi

; 5857 : 	int v;
; 5858 : 	loadFrom >> v;

	mov	esi, DWORD PTR _loadFrom$[esp]
	lea	eax, DWORD PTR _v$[esp]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 5859 : 	writeTo = static_cast<AIOperationState>(v);

	mov	ecx, DWORD PTR _writeTo$[esp]
	mov	edx, DWORD PTR _v$[esp]

; 5860 : 	return loadFrom;

	mov	eax, esi
	mov	DWORD PTR [ecx], edx
	pop	esi

; 5861 : }

	ret	0
??5@YAAAVFDataStream@@AAV0@AAW4AIOperationState@@@Z ENDP ; operator>>
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABUOperationSlot@@@Z	; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABUOperationSlot@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABUOperationSlot@@@Z PROC	; operator<<, COMDAT

; 5864 : {

	push	esi

; 5865 : 	saveTo << readFrom.m_iOperationID;

	mov	esi, DWORD PTR _saveTo$[esp]
	push	edi
	mov	edi, DWORD PTR _readFrom$[esp+4]
	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 5866 : 	saveTo << readFrom.m_iArmyID;

	lea	eax, DWORD PTR [edi+4]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 5867 : 	saveTo << readFrom.m_iSlotID;

	add	edi, 8
	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	pop	edi

; 5868 : 	return saveTo;

	mov	eax, esi
	pop	esi

; 5869 : }

	ret	0
??6@YAAAVFDataStream@@AAV0@ABUOperationSlot@@@Z ENDP	; operator<<
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAUOperationSlot@@@Z	; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAUOperationSlot@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAUOperationSlot@@@Z PROC	; operator>>, COMDAT

; 5872 : {

	push	esi

; 5873 : 	loadFrom >> writeTo.m_iOperationID;

	mov	esi, DWORD PTR _loadFrom$[esp]
	push	edi
	mov	edi, DWORD PTR _writeTo$[esp+4]
	push	edi
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 5874 : 	loadFrom >> writeTo.m_iArmyID;

	lea	eax, DWORD PTR [edi+4]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 5875 : 	loadFrom >> writeTo.m_iSlotID;

	add	edi, 8
	push	edi
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	pop	edi

; 5876 : 	return loadFrom;

	mov	eax, esi
	pop	esi

; 5877 : }

	ret	0
??5@YAAAVFDataStream@@AAV0@AAUOperationSlot@@@Z ENDP	; operator>>
_TEXT	ENDS
PUBLIC	?empty@?$vector@HV?$allocator@H@std@@@std@@QBE_NXZ ; std::vector<int,std::allocator<int> >::empty
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?empty@?$vector@HV?$allocator@H@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@HV?$allocator@H@std@@@std@@QBE_NXZ PROC	; std::vector<int,std::allocator<int> >::empty, COMDAT
; _this$ = ecx

; 736  : 		return (size() == 0);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	and	eax, -4					; fffffffcH
	neg	eax
	sbb	eax, eax
	inc	eax

; 737  : 		}

	ret	0
?empty@?$vector@HV?$allocator@H@std@@@std@@QBE_NXZ ENDP	; std::vector<int,std::allocator<int> >::empty
_TEXT	ENDS
PUBLIC	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
EXTRN	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ:PROC ; CvUnit::getDestructionNotification
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
;	COMDAT ??1?$FObjectHandle@VCvUnit@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ PROC		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 147  : 		if(m_target) 

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $LN4@FObjectHan

; 148  : 		{
; 149  : 			m_target->getDestructionNotification().removeTarget(*this);

	jmp	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN4@FObjectHan:

; 150  : 		}
; 151  : 	}

	ret	0
??1?$FObjectHandle@VCvUnit@@@@QAE@XZ ENDP		; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z	; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z
_TEXT	SEGMENT
_target$ = 8						; size = 4
??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z PROC	; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 156  : 	{

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _target$[esp]
	mov	DWORD PTR [esi], ecx
	mov	BYTE PTR [esi+4], 0

; 157  : 		OBJECT_HANDLE_STACK;
; 158  : 		if(m_target)

	test	ecx, ecx
	je	SHORT $LN6@FObjectHan@2

; 159  : 		{
; 160  : 			m_target->getDestructionNotification().addTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN6@FObjectHan@2:

; 161  : 		}
; 162  : 	}

	mov	eax, esi
	pop	esi
	ret	4
??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z ENDP	; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	??4?$FObjectHandle@VCvUnit@@@@QBEABV0@ABV0@@Z	; FObjectHandle<CvUnit>::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4?$FObjectHandle@VCvUnit@@@@QBEABV0@ABV0@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??4?$FObjectHandle@VCvUnit@@@@QBEABV0@ABV0@@Z PROC	; FObjectHandle<CvUnit>::operator=, COMDAT
; _this$ = ecx

; 195  : 	{

	push	esi
	push	edi

; 196  : 		if(&rhs != this)

	mov	edi, DWORD PTR _rhs$[esp+4]
	mov	esi, ecx
	cmp	edi, esi
	je	SHORT $LN11@operator@3

; 197  : 		{
; 198  : 			OBJECT_HANDLE_STACK;
; 199  : 			if(m_target)

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN6@operator@3

; 200  : 			{
; 201  : 				const_cast<FObjectHandle *>(this)->m_target->getDestructionNotification().removeTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN6@operator@3:

; 202  : 			}
; 203  : 			const_cast<FObjectHandle *>(this)->m_target = rhs.m_target;

	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [esi], ecx

; 204  : 			if(m_target)

	test	ecx, ecx
	je	SHORT $LN11@operator@3

; 205  : 			{
; 206  : 				const_cast<FObjectHandle *>(this)->m_target->getDestructionNotification().addTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN11@operator@3:
	pop	edi

; 207  : 			}
; 208  : 		}
; 209  : 		return *this;

	mov	eax, esi
	pop	esi

; 210  : 	}

	ret	4
??4?$FObjectHandle@VCvUnit@@@@QBEABV0@ABV0@@Z ENDP	; FObjectHandle<CvUnit>::operator=
_TEXT	ENDS
PUBLIC	??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z	; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z
_TEXT	SEGMENT
_source$ = 8						; size = 4
??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z PROC		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>, COMDAT
; _this$ = ecx

; 222  : 	{

	mov	eax, DWORD PTR _source$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [esi], ecx
	mov	dl, BYTE PTR [eax+4]
	mov	BYTE PTR [esi+4], dl

; 223  : 		OBJECT_HANDLE_STACK;
; 224  : 		if(m_target)

	test	ecx, ecx
	je	SHORT $LN6@FObjectHan@3

; 225  : 		{
; 226  : 			m_target->getDestructionNotification().addTarget(*this);

	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN6@FObjectHan@3:

; 227  : 		}
; 228  : 	}

	mov	eax, esi
	pop	esi
	ret	4
??0?$FObjectHandle@VCvUnit@@@@QAE@ABV0@@Z ENDP		; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>
_TEXT	ENDS
PUBLIC	?empty@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBE_NXZ ; std::vector<OperationSlot,std::allocator<OperationSlot> >::empty
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?empty@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBE_NXZ PROC ; std::vector<OperationSlot,std::allocator<OperationSlot> >::empty, COMDAT
; _this$ = ecx

; 736  : 		return (size() == 0);

	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	neg	eax
	sbb	eax, eax
	inc	eax

; 737  : 		}

	ret	0
?empty@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBE_NXZ ENDP ; std::vector<OperationSlot,std::allocator<OperationSlot> >::empty
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 314  : 	_Vector_iterator()

	mov	eax, ecx
	mov	DWORD PTR [eax], 0

; 315  : 		{	// construct with null vector pointer
; 316  : 		}

	ret	0
??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBEAAHXZ ; std::_Vector_iterator<int,std::allocator<int> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBEAAHXZ
_TEXT	SEGMENT
??D?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBEAAHXZ PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBEAAHXZ ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<int,std::allocator<int> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator++
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<OperationSlot,std::allocator<OperationSlot> >::_Vector_iterator<OperationSlot,std::allocator<OperationSlot> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<OperationSlot,std::allocator<OperationSlot> >::_Vector_iterator<OperationSlot,std::allocator<OperationSlot> >, COMDAT
; _this$ = ecx

; 314  : 	_Vector_iterator()

	mov	eax, ecx
	mov	DWORD PTR [eax], 0

; 315  : 		{	// construct with null vector pointer
; 316  : 		}

	ret	0
??0?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<OperationSlot,std::allocator<OperationSlot> >::_Vector_iterator<OperationSlot,std::allocator<OperationSlot> >
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBEAAUOperationSlot@@XZ ; std::_Vector_iterator<OperationSlot,std::allocator<OperationSlot> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBEAAUOperationSlot@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBEAAUOperationSlot@@XZ PROC ; std::_Vector_iterator<OperationSlot,std::allocator<OperationSlot> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBEAAUOperationSlot@@XZ ENDP ; std::_Vector_iterator<OperationSlot,std::allocator<OperationSlot> >::operator*
_TEXT	ENDS
PUBLIC	??C?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBEPAUOperationSlot@@XZ ; std::_Vector_iterator<OperationSlot,std::allocator<OperationSlot> >::operator->
; Function compile flags: /Ogtpy
;	COMDAT ??C?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBEPAUOperationSlot@@XZ
_TEXT	SEGMENT
??C?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBEPAUOperationSlot@@XZ PROC ; std::_Vector_iterator<OperationSlot,std::allocator<OperationSlot> >::operator->, COMDAT
; _this$ = ecx

; 344  : 		return (&**this);

	mov	eax, DWORD PTR [ecx]

; 345  : 		}

	ret	0
??C?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBEPAUOperationSlot@@XZ ENDP ; std::_Vector_iterator<OperationSlot,std::allocator<OperationSlot> >::operator->
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<OperationSlot,std::allocator<OperationSlot> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<OperationSlot,std::allocator<OperationSlot> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 12			; 0000000cH

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<OperationSlot,std::allocator<OperationSlot> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<OperationSlot,std::allocator<OperationSlot> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<OperationSlot,std::allocator<OperationSlot> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<OperationSlot,std::allocator<OperationSlot> >::operator!=
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvAStarNode *,200,1,297,0>::FStaticVector<CvAStarNode *,200,1,297,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvAStarNode *,200,1,297,0>::FStaticVector<CvAStarNode *,200,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 200			; 000000c8H
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvAStarNode *,200,1,297,0>::FStaticVector<CvAStarNode *,200,1,297,0>
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvOperationSearchUnit,128,1,297,0>::FStaticVector<CvOperationSearchUnit,128,1,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvOperationSearchUnit,128,1,297,0>::FStaticVector<CvOperationSearchUnit,128,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 128			; 00000080H
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvOperationSearchUnit,128,1,297,0>::FStaticVector<CvOperationSearchUnit,128,1,297,0>
_TEXT	ENDS
PUBLIC	?clear@?$BaseVector@VCvOperationSearchUnit@@$00@@QAEXXZ ; BaseVector<CvOperationSearchUnit,1>::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$BaseVector@VCvOperationSearchUnit@@$00@@QAEXXZ
_TEXT	SEGMENT
?clear@?$BaseVector@VCvOperationSearchUnit@@$00@@QAEXXZ PROC ; BaseVector<CvOperationSearchUnit,1>::clear, COMDAT
; _this$ = ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);
; 122  : 		m_uiCurrSize = 0;

	mov	DWORD PTR [ecx+4], 0

; 123  : 	};

	ret	0
?clear@?$BaseVector@VCvOperationSearchUnit@@$00@@QAEXXZ ENDP ; BaseVector<CvOperationSearchUnit,1>::clear
_TEXT	ENDS
PUBLIC	?GetElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@QBEABQAVCvPlot@@I@Z ; CvWeightedVector<CvPlot *,1,1>::GetElement
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?GetElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@QBEABQAVCvPlot@@I@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?GetElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@QBEABQAVCvPlot@@I@Z PROC ; CvWeightedVector<CvPlot *,1,1>::GetElement, COMDAT
; _this$ = ecx

; 64   : 		assert(iIndex < m_pItems.size());
; 65   : 		return m_pItems[iIndex].m_Element;

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iIndex$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 66   : 	};

	ret	4
?GetElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@QBEABQAVCvPlot@@I@Z ENDP ; CvWeightedVector<CvPlot *,1,1>::GetElement
_TEXT	ENDS
PUBLIC	?GetWeight@?$CvWeightedVector@PAVCvPlot@@$00$00@@QBEHI@Z ; CvWeightedVector<CvPlot *,1,1>::GetWeight
; Function compile flags: /Ogtpy
;	COMDAT ?GetWeight@?$CvWeightedVector@PAVCvPlot@@$00$00@@QBEHI@Z
_TEXT	SEGMENT
_elem$ = -8						; size = 8
_iIndex$ = 8						; size = 4
?GetWeight@?$CvWeightedVector@PAVCvPlot@@$00$00@@QBEHI@Z PROC ; CvWeightedVector<CvPlot *,1,1>::GetWeight, COMDAT
; _this$ = ecx

; 70   : 	{

	sub	esp, 8

; 71   : 		WeightedElement elem;
; 72   : 		assert(iIndex < m_pItems.size());
; 73   : 		elem = m_pItems[iIndex];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _iIndex$[esp+4]
	mov	edx, DWORD PTR [eax+ecx*8]

; 74   : 		return elem.m_iWeight;

	mov	eax, DWORD PTR [eax+ecx*8+4]
	mov	DWORD PTR _elem$[esp+8], edx

; 75   : 	}

	add	esp, 8
	ret	4
?GetWeight@?$CvWeightedVector@PAVCvPlot@@$00$00@@QBEHI@Z ENDP ; CvWeightedVector<CvPlot *,1,1>::GetWeight
_TEXT	ENDS
PUBLIC	?size@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAEHXZ ; CvWeightedVector<CvPlot *,1,1>::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAEHXZ
_TEXT	SEGMENT
?size@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAEHXZ PROC	; CvWeightedVector<CvPlot *,1,1>::size, COMDAT
; _this$ = ecx

; 134  : 		return m_pItems.size();

	mov	eax, DWORD PTR [ecx+4]

; 135  : 	};

	ret	0
?size@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAEHXZ ENDP	; CvWeightedVector<CvPlot *,1,1>::size
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ ; std::_Vector_val<OperationSlot,std::allocator<OperationSlot> >::~_Vector_val<OperationSlot,std::allocator<OperationSlot> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<OperationSlot,std::allocator<OperationSlot> >::~_Vector_val<OperationSlot,std::allocator<OperationSlot> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<OperationSlot,std::allocator<OperationSlot> >::~_Vector_val<OperationSlot,std::allocator<OperationSlot> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAE@V?$allocator@UOperationSlot@@@1@@Z ; std::_Vector_val<OperationSlot,std::allocator<OperationSlot> >::_Vector_val<OperationSlot,std::allocator<OperationSlot> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAE@V?$allocator@UOperationSlot@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAE@V?$allocator@UOperationSlot@@@1@@Z PROC ; std::_Vector_val<OperationSlot,std::allocator<OperationSlot> >::_Vector_val<OperationSlot,std::allocator<OperationSlot> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAE@V?$allocator@UOperationSlot@@@1@@Z ENDP ; std::_Vector_val<OperationSlot,std::allocator<OperationSlot> >::_Vector_val<OperationSlot,std::allocator<OperationSlot> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@PAUOperationSlot@@@Z ; std::_Vector_iterator<OperationSlot,std::allocator<OperationSlot> >::_Vector_iterator<OperationSlot,std::allocator<OperationSlot> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@PAUOperationSlot@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@PAUOperationSlot@@@Z PROC ; std::_Vector_iterator<OperationSlot,std::allocator<OperationSlot> >::_Vector_iterator<OperationSlot,std::allocator<OperationSlot> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@PAUOperationSlot@@@Z ENDP ; std::_Vector_iterator<OperationSlot,std::allocator<OperationSlot> >::_Vector_iterator<OperationSlot,std::allocator<OperationSlot> >
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@IAEXPAPAVCvAStarNode@@I@Z ; FStaticVector<CvAStarNode *,200,1,297,0>::Free
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Free@?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@IAEXPAPAVCvAStarNode@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@IAEXPAPAVCvAStarNode@@I@Z PROC ; FStaticVector<CvAStarNode *,200,1,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@IAEXPAPAVCvAStarNode@@I@Z ENDP ; FStaticVector<CvAStarNode *,200,1,297,0>::Free
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@IAEXPAVCvOperationSearchUnit@@I@Z ; FStaticVector<CvOperationSearchUnit,128,1,297,0>::Free
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@IAEXPAVCvOperationSearchUnit@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@IAEXPAVCvOperationSearchUnit@@I@Z PROC ; FStaticVector<CvOperationSearchUnit,128,1,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free@2

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free@2:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@IAEXPAVCvOperationSearchUnit@@I@Z ENDP ; FStaticVector<CvOperationSearchUnit,128,1,297,0>::Free
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 1
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>
_TEXT	ENDS
PUBLIC	?max_size@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBEIXZ ; std::vector<OperationSlot,std::allocator<OperationSlot> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBEIXZ PROC ; std::vector<OperationSlot,std::allocator<OperationSlot> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 357913941				; 15555555H

; 732  : 		}

	ret	0
?max_size@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBEIXZ ENDP ; std::vector<OperationSlot,std::allocator<OperationSlot> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UOperationSlot@@@std@@QAEPAUOperationSlot@@I@Z ; std::allocator<OperationSlot>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@UOperationSlot@@@std@@QAEPAUOperationSlot@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@UOperationSlot@@@std@@QAEPAUOperationSlot@@I@Z PROC ; std::allocator<OperationSlot>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@UOperationSlot@@@std@@YAPAUOperationSlot@@IPAU1@@Z ; std::_Allocate<OperationSlot>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@UOperationSlot@@@std@@QAEPAUOperationSlot@@I@Z ENDP ; std::allocator<OperationSlot>::allocate
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@I@Z ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::Free
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@I@Z PROC ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free@3

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free@3:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@I@Z ENDP ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::Free
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<OperationSlot,std::allocator<OperationSlot> >::operator+=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<OperationSlot,std::allocator<OperationSlot> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [eax], ecx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<OperationSlot,std::allocator<OperationSlot> >::operator+=
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAUOperationSlot@@PAU1@@stdext@@YAPAUOperationSlot@@PAU1@00@Z ; stdext::unchecked_copy<OperationSlot *,OperationSlot *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAUOperationSlot@@PAU1@@stdext@@YAPAUOperationSlot@@PAU1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAUOperationSlot@@PAU1@@stdext@@YAPAUOperationSlot@@PAU1@00@Z PROC ; stdext::unchecked_copy<OperationSlot *,OperationSlot *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN7@unchecked_
	push	esi
$LL9@unchecked_:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	add	ecx, 12					; 0000000cH
	add	eax, 12					; 0000000cH
	cmp	ecx, edx
	jne	SHORT $LL9@unchecked_
	pop	esi
$LN7@unchecked_:

; 3607 : 	}

	ret	0
??$unchecked_copy@PAUOperationSlot@@PAU1@@stdext@@YAPAUOperationSlot@@PAU1@00@Z ENDP ; stdext::unchecked_copy<OperationSlot *,OperationSlot *>
_TEXT	ENDS
PUBLIC	??$fill@PAUOperationSlot@@U1@@std@@YAXPAUOperationSlot@@0ABU1@@Z ; std::fill<OperationSlot *,OperationSlot>
; Function compile flags: /Ogtpy
;	COMDAT ??$fill@PAUOperationSlot@@U1@@std@@YAXPAUOperationSlot@@0ABU1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAUOperationSlot@@U1@@std@@YAXPAUOperationSlot@@0ABU1@@Z PROC ; std::fill<OperationSlot *,OperationSlot>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN3@fill
	mov	ecx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	add	eax, 12					; 0000000cH
	cmp	eax, edx
	jne	SHORT $LL5@fill
	pop	esi
$LN3@fill:

; 3188 : 	}

	ret	0
??$fill@PAUOperationSlot@@U1@@std@@YAXPAUOperationSlot@@0ABU1@@Z ENDP ; std::fill<OperationSlot *,OperationSlot>
_TEXT	ENDS
PUBLIC	??0?$SerializeFromSequenceContainer@$$CBUOperationSlot@@$$CBV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@@QAE@AAVFDataStream@@ABV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@Z ; SerializeFromSequenceContainer<OperationSlot const ,std::vector<OperationSlot,std::allocator<OperationSlot> > const >::SerializeFromSequenceContainer<OperationSlot const ,std::vector<OperationSlot,std::allocator<OperationSlot> > const >
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??0?$SerializeFromSequenceContainer@$$CBUOperationSlot@@$$CBV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@@QAE@AAVFDataStream@@ABV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@Z
_TEXT	SEGMENT
$T232763 = 8						; size = 4
_saveTo$ = 8						; size = 4
_container$ = 12					; size = 4
??0?$SerializeFromSequenceContainer@$$CBUOperationSlot@@$$CBV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@@QAE@AAVFDataStream@@ABV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@Z PROC ; SerializeFromSequenceContainer<OperationSlot const ,std::vector<OperationSlot,std::allocator<OperationSlot> > const >::SerializeFromSequenceContainer<OperationSlot const ,std::vector<OperationSlot,std::allocator<OperationSlot> > const >, COMDAT
; _this$ = ecx

; 69   : 	{

	mov	eax, DWORD PTR _container$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _saveTo$[esp]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi], ecx

; 70   : 		m_saveTo << container.size();

	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [eax+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	lea	edx, DWORD PTR $T232763[esp]
	push	edx
	mov	DWORD PTR $T232763[esp+4], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 71   : 	}

	mov	eax, esi
	pop	esi
	ret	8
??0?$SerializeFromSequenceContainer@$$CBUOperationSlot@@$$CBV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@@QAE@AAVFDataStream@@ABV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@Z ENDP ; SerializeFromSequenceContainer<OperationSlot const ,std::vector<OperationSlot,std::allocator<OperationSlot> > const >::SerializeFromSequenceContainer<OperationSlot const ,std::vector<OperationSlot,std::allocator<OperationSlot> > const >
_TEXT	ENDS
PUBLIC	??$_Find@V?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@UOperationSlot@@@std@@YA?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@0@V10@0ABUOperationSlot@@@Z ; std::_Find<std::_Vector_iterator<OperationSlot,std::allocator<OperationSlot> >,OperationSlot>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Find@V?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@UOperationSlot@@@std@@YA?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@0@V10@0ABUOperationSlot@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
??$_Find@V?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@UOperationSlot@@@std@@YA?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@0@V10@0ABUOperationSlot@@@Z PROC ; std::_Find<std::_Vector_iterator<OperationSlot,std::allocator<OperationSlot> >,OperationSlot>, COMDAT

; 38   : 	_DEBUG_RANGE(_First, _Last);
; 39   : 	for (; _First != _Last; ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN29@Find
	mov	eax, DWORD PTR __Val$[esp-4]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi
$LL9@Find:

; 40   : 		if (*_First == _Val)

	cmp	esi, DWORD PTR [ecx+4]
	jne	SHORT $LN21@Find
	mov	edi, DWORD PTR [eax+8]
	cmp	edi, DWORD PTR [ecx+8]
	jne	SHORT $LN21@Find
	mov	edi, DWORD PTR [eax]
	cmp	edi, DWORD PTR [ecx]
	je	SHORT $LN28@Find
$LN21@Find:
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR __First$[esp+4], ecx
	cmp	ecx, edx
	jne	SHORT $LL9@Find
$LN28@Find:

; 41   : 			break;
; 42   : 	return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 43   : 	}

	ret	0
$LN29@Find:

; 41   : 			break;
; 42   : 	return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 43   : 	}

	ret	0
??$_Find@V?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@UOperationSlot@@@std@@YA?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@0@V10@0ABUOperationSlot@@@Z ENDP ; std::_Find<std::_Vector_iterator<OperationSlot,std::allocator<OperationSlot> >,OperationSlot>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAUOperationSlot@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUOperationSlot@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<OperationSlot *,OperationSlot *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Move_backward_opt@PAUOperationSlot@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUOperationSlot@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAUOperationSlot@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUOperationSlot@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<OperationSlot *,OperationSlot *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN5@Move_backw
	push	esi
$LL6@Move_backw:
	mov	esi, DWORD PTR [ecx-12]
	sub	ecx, 12					; 0000000cH
	sub	eax, 12					; 0000000cH
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	cmp	ecx, edx
	jne	SHORT $LL6@Move_backw
	pop	esi
$LN5@Move_backw:

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAUOperationSlot@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUOperationSlot@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<OperationSlot *,OperationSlot *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UOperationSlot@@@std@@QAEXPAUOperationSlot@@ABU3@@Z ; std::allocator<OperationSlot>::construct
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?construct@?$allocator@UOperationSlot@@@std@@QAEXPAUOperationSlot@@ABU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UOperationSlot@@@std@@QAEXPAUOperationSlot@@ABU3@@Z PROC ; std::allocator<OperationSlot>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ecx
$LN5@construct:

; 156  : 		}

	ret	8
?construct@?$allocator@UOperationSlot@@@std@@QAEXPAUOperationSlot@@ABU3@@Z ENDP ; std::allocator<OperationSlot>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UOperationSlot@@@std@@QAEXPAUOperationSlot@@@Z ; std::allocator<OperationSlot>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@UOperationSlot@@@std@@QAEXPAUOperationSlot@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UOperationSlot@@@std@@QAEXPAUOperationSlot@@@Z PROC ; std::allocator<OperationSlot>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@UOperationSlot@@@std@@QAEXPAUOperationSlot@@@Z ENDP ; std::allocator<OperationSlot>::destroy
_TEXT	ENDS
PUBLIC	??R?$SerializeFromSequenceContainer@$$CBUOperationSlot@@$$CBV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@@QAEXABUOperationSlot@@@Z ; SerializeFromSequenceContainer<OperationSlot const ,std::vector<OperationSlot,std::allocator<OperationSlot> > const >::operator()
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??R?$SerializeFromSequenceContainer@$$CBUOperationSlot@@$$CBV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@@QAEXABUOperationSlot@@@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
??R?$SerializeFromSequenceContainer@$$CBUOperationSlot@@$$CBV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@@QAEXABUOperationSlot@@@Z PROC ; SerializeFromSequenceContainer<OperationSlot const ,std::vector<OperationSlot,std::allocator<OperationSlot> > const >::operator(), COMDAT
; _this$ = ecx

; 74   : 	{

	push	esi

; 75   : 		m_saveTo << i;

	mov	esi, DWORD PTR [ecx]
	push	edi
	mov	edi, DWORD PTR _i$[esp+4]
	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	lea	eax, DWORD PTR [edi+4]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	edi, 8
	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	pop	edi
	pop	esi

; 76   : 	}

	ret	4
??R?$SerializeFromSequenceContainer@$$CBUOperationSlot@@$$CBV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@@QAEXABUOperationSlot@@@Z ENDP ; SerializeFromSequenceContainer<OperationSlot const ,std::vector<OperationSlot,std::allocator<OperationSlot> > const >::operator()
_TEXT	ENDS
PUBLIC	??1?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAE@XZ ; std::_Temp_iterator<CvOperationSearchUnit>::~_Temp_iterator<CvOperationSearchUnit>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??1?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAE@XZ PROC ; std::_Temp_iterator<CvOperationSearchUnit>::~_Temp_iterator<CvOperationSearchUnit>, COMDAT
; _this$ = ecx

; 546  : 		if (_Buf._Begin != 0)

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN9@Temp_itera

; 547  : 			{	// destroy any constructed elements in buffer
; 548  : 			for (_Pty _Next = _Buf._Begin;
; 549  : 				_Next != _Buf._Hiwater; ++_Next)
; 550  : 				_Destroy(&*_Next);
; 551  : 			std::return_temporary_buffer(_Buf._Begin);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
$LN9@Temp_itera:

; 552  : 			}
; 553  : 		}

	ret	0
??1?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAE@XZ ENDP ; std::_Temp_iterator<CvOperationSearchUnit>::~_Temp_iterator<CvOperationSearchUnit>
_TEXT	ENDS
PUBLIC	??$_Distance@PAVCvOperationSearchUnit@@H@std@@YAXPAVCvOperationSearchUnit@@0AAH@Z ; std::_Distance<CvOperationSearchUnit *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Distance@PAVCvOperationSearchUnit@@H@std@@YAXPAVCvOperationSearchUnit@@0AAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
??$_Distance@PAVCvOperationSearchUnit@@H@std@@YAXPAVCvOperationSearchUnit@@0AAH@Z PROC ; std::_Distance<CvOperationSearchUnit *,int>, COMDAT

; 1893 : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

	mov	ecx, DWORD PTR __Last$[esp-4]
	sub	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Off$[esp-4]
	sar	ecx, 3
	add	DWORD PTR [eax], ecx

; 1894 : 	}

	ret	0
??$_Distance@PAVCvOperationSearchUnit@@H@std@@YAXPAVCvOperationSearchUnit@@0AAH@Z ENDP ; std::_Distance<CvOperationSearchUnit *,int>
_TEXT	ENDS
PUBLIC	??$advance@PAVCvOperationSearchUnit@@H@std@@YAXAAPAVCvOperationSearchUnit@@H@Z ; std::advance<CvOperationSearchUnit *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$advance@PAVCvOperationSearchUnit@@H@std@@YAXAAPAVCvOperationSearchUnit@@H@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Off$ = 12						; size = 4
??$advance@PAVCvOperationSearchUnit@@H@std@@YAXAAPAVCvOperationSearchUnit@@H@Z PROC ; std::advance<CvOperationSearchUnit *,int>, COMDAT

; 1774 : 	_Advance(_Where, _Off, _Iter_cat(_Where));

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	ecx, DWORD PTR [eax*8]
	mov	eax, DWORD PTR __Where$[esp-4]
	add	DWORD PTR [eax], ecx

; 1775 : 	}

	ret	0
??$advance@PAVCvOperationSearchUnit@@H@std@@YAXAAPAVCvOperationSearchUnit@@H@Z ENDP ; std::advance<CvOperationSearchUnit *,int>
_TEXT	ENDS
PUBLIC	??$iter_swap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ; std::iter_swap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$iter_swap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z PROC ; std::iter_swap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement *>, COMDAT

; 594  : 	swap(*_Left, *_Right);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@iter_swap
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	pop	edi
	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx], edx
	pop	esi
$LN3@iter_swap:

; 595  : 	}

	ret	0
??$iter_swap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ENDP ; std::iter_swap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$get_temporary_buffer@VCvOperationSearchUnit@@@std@@YA?AU?$pair@PAVCvOperationSearchUnit@@H@0@H@Z ; std::get_temporary_buffer<CvOperationSearchUnit>
EXTRN	??2@YAPAXIABUnothrow_t@std@@@Z:PROC		; operator new
EXTRN	?nothrow@std@@3Unothrow_t@1@B:BYTE		; std::nothrow
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$get_temporary_buffer@VCvOperationSearchUnit@@@std@@YA?AU?$pair@PAVCvOperationSearchUnit@@H@0@H@Z
_TEXT	SEGMENT
$T232935 = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
$T232939 = 12						; size = 4
__Count$ = 12						; size = 4
??$get_temporary_buffer@VCvOperationSearchUnit@@@std@@YA?AU?$pair@PAVCvOperationSearchUnit@@H@0@H@Z PROC ; std::get_temporary_buffer<CvOperationSearchUnit>, COMDAT

; 19   : 	{	// get raw temporary buffer of up to _Count elements

	sub	esp, 12					; 0000000cH
	push	esi

; 20   : 	_Ty _FARQ *_Pbuf;
; 21   : 
; 22   : 	if (_Count <= 0)

	mov	esi, DWORD PTR __Count$[esp+12]
	test	esi, esi
	jg	SHORT $LN7@get_tempor

; 23   : 		_Count = 0;

	xor	esi, esi
$LN5@get_tempor:

; 26   : 
; 27   : 	for (_Pbuf = 0; 0 < _Count; _Count /= 2)

	xor	ecx, ecx
	test	esi, esi
	jle	SHORT $LN15@get_tempor
	npad	12
$LL4@get_tempor:

; 28   : 		if ((_Pbuf = (_Ty _FARQ *)operator new(
; 29   : 			(_SIZT)_Count * sizeof (_Ty), nothrow)) != 0)

	lea	edx, DWORD PTR [esi*8]
	push	OFFSET ?nothrow@std@@3Unothrow_t@1@B	; std::nothrow
	push	edx
	call	??2@YAPAXIABUnothrow_t@std@@@Z		; operator new
	mov	ecx, eax
	add	esp, 8
	test	ecx, ecx
	jne	SHORT $LN15@get_tempor
	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	test	esi, esi
	jg	SHORT $LL4@get_tempor
$LN15@get_tempor:

; 30   : 			break;
; 31   : 
; 32   : 	return (pair<_Ty _FARQ *, _PDFT>(_Pbuf, _Count));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 33   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN7@get_tempor:

; 24   : 	else if (((size_t)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	esi
	cmp	eax, 8
	jae	SHORT $LN5@get_tempor

; 25   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T232939[esp+12]
	push	eax
	lea	ecx, DWORD PTR $T232935[esp+20]
	mov	DWORD PTR $T232939[esp+16], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T232935[esp+20]
	push	ecx
	mov	DWORD PTR $T232935[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN18@get_tempor:
$LN17@get_tempor:
	int	3
??$get_temporary_buffer@VCvOperationSearchUnit@@@std@@YA?AU?$pair@PAVCvOperationSearchUnit@@H@0@H@Z ENDP ; std::get_temporary_buffer<CvOperationSearchUnit>
_TEXT	ENDS
PUBLIC	??0?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAE@ABV01@@Z ; std::_Temp_iterator<CvOperationSearchUnit>::_Temp_iterator<CvOperationSearchUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAE@ABV01@@Z PROC ; std::_Temp_iterator<CvOperationSearchUnit>::_Temp_iterator<CvOperationSearchUnit>, COMDAT
; _this$ = ecx

; 535  : 	_Temp_iterator(const _Temp_iterator<_Ty>& _Right)

	mov	eax, ecx

; 536  : 		{	// construct from _Right (share active buffer)
; 537  : 		_Buf._Begin = 0;	// clear stored buffer, for safe destruction

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx

; 538  : 		_Buf._Current = 0;

	mov	DWORD PTR [eax+4], ecx

; 539  : 		_Buf._Hiwater = 0;

	mov	DWORD PTR [eax+8], ecx

; 540  : 		_Buf._Size = 0;

	mov	DWORD PTR [eax+12], ecx

; 541  : 		*this = _Right;

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx

; 542  : 		}

	ret	4
??0?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAE@ABV01@@Z ENDP ; std::_Temp_iterator<CvOperationSearchUnit>::_Temp_iterator<CvOperationSearchUnit>
_TEXT	ENDS
PUBLIC	??$iter_swap@PAVCvOperationSearchUnit@@PAV1@@std@@YAXPAVCvOperationSearchUnit@@0@Z ; std::iter_swap<CvOperationSearchUnit *,CvOperationSearchUnit *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$iter_swap@PAVCvOperationSearchUnit@@PAV1@@std@@YAXPAVCvOperationSearchUnit@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@PAVCvOperationSearchUnit@@PAV1@@std@@YAXPAVCvOperationSearchUnit@@0@Z PROC ; std::iter_swap<CvOperationSearchUnit *,CvOperationSearchUnit *>, COMDAT

; 594  : 	swap(*_Left, *_Right);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@iter_swap@2
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	pop	edi
	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx], edx
	pop	esi
$LN3@iter_swap@2:

; 595  : 	}

	ret	0
??$iter_swap@PAVCvOperationSearchUnit@@PAV1@@std@@YAXPAVCvOperationSearchUnit@@0@Z ENDP ; std::iter_swap<CvOperationSearchUnit *,CvOperationSearchUnit *>
_TEXT	ENDS
PUBLIC	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z ; std::_Med3<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z PROC ; std::_Med3<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>, COMDAT

; 2999 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	eax, DWORD PTR __Mid$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	push	esi
	push	edi
	jle	SHORT $LN10@Med3

; 3000 : 		std::iter_swap(_Mid, _First);

	cmp	eax, ecx
	je	SHORT $LN10@Med3
	mov	edi, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [ecx+4], edx
$LN10@Med3:

; 3001 : 	if (_DEBUG_LT(*_Last, *_Mid))

	mov	edx, DWORD PTR __Last$[esp+4]
	mov	esi, DWORD PTR [edx+4]
	cmp	esi, DWORD PTR [eax+4]
	jle	SHORT $LN19@Med3

; 3002 : 		std::iter_swap(_Last, _Mid);

	cmp	edx, eax
	je	SHORT $LN19@Med3
	mov	edi, DWORD PTR [edx]
	push	ebx
	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ebx
	mov	ebx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ebx
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], esi
	pop	ebx
$LN19@Med3:

; 3003 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jle	SHORT $LN28@Med3

; 3004 : 		std::iter_swap(_Mid, _First);

	cmp	eax, ecx
	je	SHORT $LN28@Med3
	mov	edi, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [ecx+4], edx
$LN28@Med3:
	pop	edi
	pop	esi

; 3005 : 	}

	ret	0
??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z ENDP ; std::_Med3<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HHU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 8
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HHU12@@Z PROC ; std::_Adjust_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>, COMDAT

; 2056 : 	_Diff _Top = _Hole;

	mov	edx, DWORD PTR __Hole$[esp-4]

; 2057 : 	_Diff _Idx = 2 * _Hole + 2;
; 2058 : 
; 2059 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

	mov	ecx, DWORD PTR __First$[esp-4]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Bottom$[esp+4]
	lea	eax, DWORD PTR [edx+edx+2]
	cmp	eax, esi
	push	edi
	mov	edi, edx
	jge	SHORT $LN14@Adjust_hea
	npad	7
$LL5@Adjust_hea:

; 2060 : 		{	// move _Hole down to larger child
; 2061 : 		if (_DEBUG_LT(*(_First + _Idx), *(_First + (_Idx - 1))))

	mov	ebx, DWORD PTR [ecx+eax*8+4]
	cmp	ebx, DWORD PTR [ecx+eax*8-4]
	jle	SHORT $LN2@Adjust_hea

; 2062 : 			--_Idx;

	dec	eax
$LN2@Adjust_hea:

; 2063 : 		*(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;

	mov	ebx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR [ecx+edx*8], ebx
	mov	ebx, DWORD PTR [ecx+eax*8+4]
	mov	DWORD PTR [ecx+edx*8+4], ebx
	mov	edx, eax
	lea	eax, DWORD PTR [eax+eax+2]
	cmp	eax, esi
	jl	SHORT $LL5@Adjust_hea
$LN14@Adjust_hea:

; 2064 : 		}
; 2065 : 
; 2066 : 	if (_Idx == _Bottom)

	jne	SHORT $LN1@Adjust_hea

; 2067 : 		{	// only child at bottom, move _Hole down to it
; 2068 : 		*(_First + _Hole) = *(_First + (_Bottom - 1));

	mov	eax, DWORD PTR [ecx+esi*8-8]
	mov	DWORD PTR [ecx+edx*8], eax
	mov	eax, DWORD PTR [ecx+esi*8-4]
	mov	DWORD PTR [ecx+edx*8+4], eax

; 2069 : 		_Hole = _Bottom - 1;

	lea	edx, DWORD PTR [esi-1]
$LN1@Adjust_hea:

; 2070 : 		}
; 2071 : 	std::_Push_heap(_First, _Hole, _Top, _Val);

	mov	esi, DWORD PTR __Val$[esp+8]
	sub	esp, 8
	mov	eax, esp
	push	edi
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR __Val$[esp+24]
	push	edx
	push	ecx
	mov	DWORD PTR [eax+4], esi
	call	??$_Push_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HHU12@@Z ; std::_Push_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2072 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HHU12@@Z ENDP ; std::_Adjust_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@00@Z ; stdext::unchecked_copy_backward<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@00@Z PROC ; stdext::unchecked_copy_backward<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement *>, COMDAT

; 3637 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3638 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN7@unchecked_@2
	push	esi
$LL8@unchecked_@2:
	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL8@unchecked_@2
	pop	esi
$LN7@unchecked_@2:

; 3639 : 	}

	ret	0
??$unchecked_copy_backward@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@stdext@@YAPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@00@Z ENDP ; stdext::unchecked_copy_backward<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@@std@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<OperationSlot *,OperationSlot *,std::allocator<OperationSlot> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@@std@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@@std@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<OperationSlot *,OperationSlot *,std::allocator<OperationSlot> >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@2
	push	esi
$LL6@Uninit_cop@2:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop@2
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
$LN5@Uninit_cop@2:
	add	ecx, 12					; 0000000cH
	add	eax, 12					; 0000000cH
	cmp	ecx, edx
	jne	SHORT $LL6@Uninit_cop@2
	pop	esi
$LN4@Uninit_cop@2:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@@std@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<OperationSlot *,OperationSlot *,std::allocator<OperationSlot> >
_TEXT	ENDS
PUBLIC	??$unchecked_copy_backward@PAVCvOperationSearchUnit@@PAV1@@stdext@@YAPAVCvOperationSearchUnit@@PAV1@00@Z ; stdext::unchecked_copy_backward<CvOperationSearchUnit *,CvOperationSearchUnit *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy_backward@PAVCvOperationSearchUnit@@PAV1@@stdext@@YAPAVCvOperationSearchUnit@@PAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy_backward@PAVCvOperationSearchUnit@@PAV1@@stdext@@YAPAVCvOperationSearchUnit@@PAV1@00@Z PROC ; stdext::unchecked_copy_backward<CvOperationSearchUnit *,CvOperationSearchUnit *>, COMDAT

; 3637 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3638 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN7@unchecked_@3
	push	esi
$LL8@unchecked_@3:
	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL8@unchecked_@3
	pop	esi
$LN7@unchecked_@3:

; 3639 : 	}

	ret	0
??$unchecked_copy_backward@PAVCvOperationSearchUnit@@PAV1@@stdext@@YAPAVCvOperationSearchUnit@@PAV1@00@Z ENDP ; stdext::unchecked_copy_backward<CvOperationSearchUnit *,CvOperationSearchUnit *>
_TEXT	ENDS
PUBLIC	??$_Merge_backward@PAVCvOperationSearchUnit@@PAV1@PAV1@@std@@YAPAVCvOperationSearchUnit@@PAV1@0000U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<CvOperationSearchUnit *,CvOperationSearchUnit *,CvOperationSearchUnit *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Merge_backward@PAVCvOperationSearchUnit@@PAV1@PAV1@@std@@YAPAVCvOperationSearchUnit@@PAV1@0000U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Merge_backward@PAVCvOperationSearchUnit@@PAV1@PAV1@@std@@YAPAVCvOperationSearchUnit@@PAV1@0000U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge_backward<CvOperationSearchUnit *,CvOperationSearchUnit *,CvOperationSearchUnit *>, COMDAT

; 2711 : 	for (; ; )
; 2712 : 		if (_First1 == _Last1)

	mov	ecx, DWORD PTR __Last1$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	edx, DWORD PTR __Last2$[esp-4]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __First1$[esp+4]
	push	edi
	mov	edi, DWORD PTR __First2$[esp+8]
	cmp	esi, ecx
	je	SHORT $LN41@Merge_back
	npad	5
$LL8@Merge_back:

; 2714 : 		else if (_First2 == _Last2)

	cmp	edi, edx
	je	SHORT $LN42@Merge_back

; 2716 : 		else if (_DEBUG_LT(*--_Last2, *--_Last1))

	mov	ebx, DWORD PTR [edx-8]
	sub	edx, 8
	sub	ecx, 8

; 2717 : 			*--_Dest = *_Last1, ++_Last2;

	sub	eax, 8
	cmp	ebx, DWORD PTR [ecx]
	jge	SHORT $LN2@Merge_back
	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ebx
	mov	ebx, DWORD PTR [ecx+4]
	add	edx, 8

; 2718 : 		else

	jmp	SHORT $LN46@Merge_back
$LN2@Merge_back:

; 2719 : 			*--_Dest = *_Last2, ++_Last1;

	mov	DWORD PTR [eax], ebx
	mov	ebx, DWORD PTR [edx+4]
	add	ecx, 8
$LN46@Merge_back:
	mov	DWORD PTR [eax+4], ebx
	cmp	esi, ecx
	jne	SHORT $LL8@Merge_back
$LN41@Merge_back:

; 2713 : 			return (_STDEXT unchecked_copy_backward(_First2, _Last2, _Dest));

	mov	ecx, edx
	cmp	edi, edx
	je	SHORT $LN7@Merge_back
$LL18@Merge_back:
	mov	edx, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	cmp	ecx, edi
	jne	SHORT $LL18@Merge_back
	pop	edi
	pop	esi
	pop	ebx

; 2720 : 	}

	ret	0
$LN42@Merge_back:

; 2715 : 			return (_STDEXT unchecked_copy_backward(_First1, _Last1, _Dest));

	cmp	esi, ecx
	je	SHORT $LN7@Merge_back
$LL28@Merge_back:
	mov	edx, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	cmp	ecx, esi
	jne	SHORT $LL28@Merge_back
$LN7@Merge_back:
	pop	edi
	pop	esi
	pop	ebx

; 2720 : 	}

	ret	0
??$_Merge_backward@PAVCvOperationSearchUnit@@PAV1@PAV1@@std@@YAPAVCvOperationSearchUnit@@PAV1@0000U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge_backward<CvOperationSearchUnit *,CvOperationSearchUnit *,CvOperationSearchUnit *>
_TEXT	ENDS
PUBLIC	??$_Lower_bound@PAVCvOperationSearchUnit@@V1@H@std@@YAPAVCvOperationSearchUnit@@PAV1@0ABV1@PAH@Z ; std::_Lower_bound<CvOperationSearchUnit *,CvOperationSearchUnit,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Lower_bound@PAVCvOperationSearchUnit@@V1@H@std@@YAPAVCvOperationSearchUnit@@PAV1@0ABV1@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Lower_bound@PAVCvOperationSearchUnit@@V1@H@std@@YAPAVCvOperationSearchUnit@@PAV1@0ABV1@PAH@Z PROC ; std::_Lower_bound<CvOperationSearchUnit *,CvOperationSearchUnit,int>, COMDAT

; 2253 : 	_DEBUG_ORDER_SINGLE(_First, _Last, true);
; 2254 : 	_Diff _Count = 0;
; 2255 : 	_Distance(_First, _Last, _Count);

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First$[esp]
	sub	ecx, esi
	sar	ecx, 3

; 2256 : 
; 2257 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jle	SHORT $LN26@Lower_boun
	mov	eax, DWORD PTR __Val$[esp]
	push	edi
	mov	edi, DWORD PTR [eax]
	npad	7
$LL4@Lower_boun:

; 2258 : 		{	// divide and conquer, find half that contains answer
; 2259 : 		_Diff _Count2 = _Count / 2;

	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1

; 2260 : 		_FwdIt _Mid = _First;
; 2261 : 		std::advance(_Mid, _Count2);
; 2262 : 		_DEBUG_ORDER_SINGLE(_Mid, _Last, false);
; 2263 : 
; 2264 : 		if (_DEBUG_LT(*_Mid, _Val))

	cmp	DWORD PTR [esi+eax*8], edi
	jge	SHORT $LN2@Lower_boun

; 2265 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	or	edx, -1
	sub	edx, eax
	lea	esi, DWORD PTR [esi+eax*8+8]
	add	ecx, edx

; 2266 : 		else

	jmp	SHORT $LN1@Lower_boun
$LN2@Lower_boun:

; 2267 : 			_Count = _Count2;

	mov	ecx, eax
$LN1@Lower_boun:

; 2256 : 
; 2257 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jg	SHORT $LL4@Lower_boun
	pop	edi
$LN26@Lower_boun:

; 2268 : 		}
; 2269 : 	return (_First);

	mov	eax, esi
	pop	esi

; 2270 : 	}

	ret	0
??$_Lower_bound@PAVCvOperationSearchUnit@@V1@H@std@@YAPAVCvOperationSearchUnit@@PAV1@0ABV1@PAH@Z ENDP ; std::_Lower_bound<CvOperationSearchUnit *,CvOperationSearchUnit,int>
_TEXT	ENDS
PUBLIC	??$_Upper_bound@PAVCvOperationSearchUnit@@V1@H@std@@YAPAVCvOperationSearchUnit@@PAV1@0ABV1@PAH@Z ; std::_Upper_bound<CvOperationSearchUnit *,CvOperationSearchUnit,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Upper_bound@PAVCvOperationSearchUnit@@V1@H@std@@YAPAVCvOperationSearchUnit@@PAV1@0ABV1@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Upper_bound@PAVCvOperationSearchUnit@@V1@H@std@@YAPAVCvOperationSearchUnit@@PAV1@0ABV1@PAH@Z PROC ; std::_Upper_bound<CvOperationSearchUnit *,CvOperationSearchUnit,int>, COMDAT

; 2325 : 	_DEBUG_ORDER_SINGLE(_First, _Last, true);
; 2326 : 	_Diff _Count = 0;
; 2327 : 	_Distance(_First, _Last, _Count);

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First$[esp]
	sub	ecx, esi
	sar	ecx, 3

; 2328 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jle	SHORT $LN26@Upper_boun
	mov	eax, DWORD PTR __Val$[esp]
	push	edi
	mov	edi, DWORD PTR [eax]
	npad	7
$LL4@Upper_boun:

; 2329 : 		{	// divide and conquer, find half that contains answer
; 2330 : 		_Diff _Count2 = _Count / 2;

	mov	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1

; 2331 : 		_FwdIt _Mid = _First;
; 2332 : 		std::advance(_Mid, _Count2);
; 2333 : 		_DEBUG_ORDER_SINGLE(_Mid, _Last, false);
; 2334 : 
; 2335 : 		if (!_DEBUG_LT(_Val, *_Mid))

	cmp	edi, DWORD PTR [esi+eax*8]
	jl	SHORT $LN2@Upper_boun

; 2336 : 			_First = ++_Mid, _Count -= _Count2 + 1;

	or	edx, -1
	sub	edx, eax
	lea	esi, DWORD PTR [esi+eax*8+8]
	add	ecx, edx

; 2337 : 		else

	jmp	SHORT $LN1@Upper_boun
$LN2@Upper_boun:

; 2338 : 			_Count = _Count2;

	mov	ecx, eax
$LN1@Upper_boun:

; 2328 : 	for (; 0 < _Count; )

	test	ecx, ecx
	jg	SHORT $LL4@Upper_boun
	pop	edi
$LN26@Upper_boun:

; 2339 : 		}
; 2340 : 	return (_First);

	mov	eax, esi
	pop	esi

; 2341 : 	}

	ret	0
??$_Upper_bound@PAVCvOperationSearchUnit@@V1@H@std@@YAPAVCvOperationSearchUnit@@PAV1@0ABV1@PAH@Z ENDP ; std::_Upper_bound<CvOperationSearchUnit *,CvOperationSearchUnit,int>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAVCvOperationSearchUnit@@PAV1@@stdext@@YAPAVCvOperationSearchUnit@@PAV1@00@Z ; stdext::unchecked_copy<CvOperationSearchUnit *,CvOperationSearchUnit *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAVCvOperationSearchUnit@@PAV1@@stdext@@YAPAVCvOperationSearchUnit@@PAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAVCvOperationSearchUnit@@PAV1@@stdext@@YAPAVCvOperationSearchUnit@@PAV1@00@Z PROC ; stdext::unchecked_copy<CvOperationSearchUnit *,CvOperationSearchUnit *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN7@unchecked_@4
	push	esi
$LL9@unchecked_@4:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	add	ecx, 8
	add	eax, 8
	cmp	ecx, edx
	jne	SHORT $LL9@unchecked_@4
	pop	esi
$LN7@unchecked_@4:

; 3607 : 	}

	ret	0
??$unchecked_copy@PAVCvOperationSearchUnit@@PAV1@@stdext@@YAPAVCvOperationSearchUnit@@PAV1@00@Z ENDP ; stdext::unchecked_copy<CvOperationSearchUnit *,CvOperationSearchUnit *>
_TEXT	ENDS
PUBLIC	??4?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAEAAV01@ABVCvOperationSearchUnit@@@Z ; std::_Temp_iterator<CvOperationSearchUnit>::operator=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??4?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAEAAV01@ABVCvOperationSearchUnit@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??4?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAEAAV01@ABVCvOperationSearchUnit@@@Z PROC ; std::_Temp_iterator<CvOperationSearchUnit>::operator=, COMDAT
; _this$ = ecx

; 562  : 		{	// assign or construct value into active buffer, and increment

	mov	eax, ecx

; 563  : 		if (_Pbuf->_Current < _Pbuf->_Hiwater)

	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [ecx+8]

; 564  : 			*_Pbuf->_Current++ = _Val;	// below high water mark, assign

	mov	ecx, DWORD PTR [ecx+4]
	push	esi
	jae	SHORT $LN2@operator@4
	mov	edx, DWORD PTR __Val$[esp]
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], edx
	mov	ecx, DWORD PTR [eax+16]
	add	DWORD PTR [ecx+4], 8
	pop	esi

; 571  : 			}
; 572  : 		return (*this);
; 573  : 		}

	ret	4
$LN2@operator@4:

; 565  : 		else
; 566  : 			{	// above high water mark, construct
; 567  : 			_SCL_SECURE_VALIDATE((_Pbuf->_Current - _Pbuf->_Begin) < _Pbuf->_Size);
; 568  : 			_Pty _Ptr = &*_Pbuf->_Current;
; 569  : 			_Construct(_Ptr, _Val);

	test	ecx, ecx
	je	SHORT $LN7@operator@4
	mov	edx, DWORD PTR __Val$[esp]
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], edx
$LN7@operator@4:

; 570  : 			_Pbuf->_Hiwater = ++_Pbuf->_Current;

	mov	ecx, DWORD PTR [eax+16]
	add	DWORD PTR [ecx+4], 8
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx+8], edx
	pop	esi

; 571  : 			}
; 572  : 		return (*this);
; 573  : 		}

	ret	4
??4?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAEAAV01@ABVCvOperationSearchUnit@@@Z ENDP ; std::_Temp_iterator<CvOperationSearchUnit>::operator=
_TEXT	ENDS
PUBLIC	??$_Rotate@PAVCvOperationSearchUnit@@@std@@YAXPAVCvOperationSearchUnit@@00Urandom_access_iterator_tag@0@@Z ; std::_Rotate<CvOperationSearchUnit *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Rotate@PAVCvOperationSearchUnit@@@std@@YAXPAVCvOperationSearchUnit@@00Urandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Rotate@PAVCvOperationSearchUnit@@@std@@YAXPAVCvOperationSearchUnit@@00Urandom_access_iterator_tag@0@@Z PROC ; std::_Rotate<CvOperationSearchUnit *>, COMDAT

; 1713 : 	_Rotate(_First, _Mid, _Last, _Dist_type(_First), _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __Mid$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	0
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Rotate@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@00PAH0@Z ; std::_Rotate<CvOperationSearchUnit *,int,CvOperationSearchUnit>
	add	esp, 20					; 00000014H

; 1714 : 	}

	ret	0
??$_Rotate@PAVCvOperationSearchUnit@@@std@@YAXPAVCvOperationSearchUnit@@00Urandom_access_iterator_tag@0@@Z ENDP ; std::_Rotate<CvOperationSearchUnit *>
_TEXT	ENDS
PUBLIC	??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00U12@PAH@Z ; std::_Pop_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00U12@PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Val$ = 20						; size = 8
___formal$ = 28						; size = 4
??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00U12@PAH@Z PROC ; std::_Pop_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>, COMDAT

; 2080 : 	*_Dest = *_First;

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx

; 2081 : 	std::_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First), _Val);

	mov	edx, DWORD PTR __Val$[esp-4]
	sub	esp, 8
	mov	ecx, esp
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR __Val$[esp+8]
	mov	DWORD PTR [ecx+4], edx
	mov	ecx, DWORD PTR __Last$[esp+4]
	sub	ecx, eax
	sar	ecx, 3
	push	ecx
	push	0
	push	eax
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2082 : 	}

	ret	0
??$_Pop_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00U12@PAH@Z ENDP ; std::_Pop_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	?isEmbarked@CvUnit@@QBE_NXZ			; CvUnit::isEmbarked
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunit.h
;	COMDAT ?isEmbarked@CvUnit@@QBE_NXZ
_TEXT	SEGMENT
?isEmbarked@CvUnit@@QBE_NXZ PROC			; CvUnit::isEmbarked, COMDAT
; _this$ = ecx

; 257  : 		return m_bEmbarked;

	mov	al, BYTE PTR [ecx+1652]

; 258  : 	}

	ret	0
?isEmbarked@CvUnit@@QBE_NXZ ENDP			; CvUnit::isEmbarked
_TEXT	ENDS
PUBLIC	?GetID@CvUnit@@QBEHXZ				; CvUnit::GetID
; Function compile flags: /Ogtpy
;	COMDAT ?GetID@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?GetID@CvUnit@@QBEHXZ PROC				; CvUnit::GetID, COMDAT
; _this$ = ecx

; 662  : 		return m_iID;

	mov	eax, DWORD PTR [ecx+100]

; 663  : 	}

	ret	0
?GetID@CvUnit@@QBEHXZ ENDP				; CvUnit::GetID
_TEXT	ENDS
PUBLIC	?getX@CvUnit@@QBEHXZ				; CvUnit::getX
; Function compile flags: /Ogtpy
;	COMDAT ?getX@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?getX@CvUnit@@QBEHXZ PROC				; CvUnit::getX, COMDAT
; _this$ = ecx

; 673  : 		return m_iX.get();

	mov	eax, DWORD PTR [ecx+76]

; 674  : 	}

	ret	0
?getX@CvUnit@@QBEHXZ ENDP				; CvUnit::getX
_TEXT	ENDS
PUBLIC	?getY@CvUnit@@QBEHXZ				; CvUnit::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?getY@CvUnit@@QBEHXZ PROC				; CvUnit::getY, COMDAT
; _this$ = ecx

; 678  : 		return m_iY.get();

	mov	eax, DWORD PTR [ecx+88]

; 679  : 	}

	ret	0
?getY@CvUnit@@QBEHXZ ENDP				; CvUnit::getY
_TEXT	ENDS
PUBLIC	?GetDeployFromOperationTurn@CvUnit@@QBEHXZ	; CvUnit::GetDeployFromOperationTurn
; Function compile flags: /Ogtpy
;	COMDAT ?GetDeployFromOperationTurn@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?GetDeployFromOperationTurn@CvUnit@@QBEHXZ PROC		; CvUnit::GetDeployFromOperationTurn, COMDAT
; _this$ = ecx

; 697  : 		return m_iDeployFromOperationTurn;

	mov	eax, DWORD PTR [ecx+124]

; 698  : 	};

	ret	0
?GetDeployFromOperationTurn@CvUnit@@QBEHXZ ENDP		; CvUnit::GetDeployFromOperationTurn
_TEXT	ENDS
PUBLIC	?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ	; CvUnit::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ PROC		; CvUnit::getOwner, COMDAT
; _this$ = ecx

; 1046 : 		return m_eOwner.get();

	mov	eax, DWORD PTR [ecx+40]

; 1047 : 	}

	ret	0
?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ ENDP		; CvUnit::getOwner
_TEXT	ENDS
PUBLIC	?isTerrainImpassable@CvUnit@@QBE_NW4TerrainTypes@@@Z ; CvUnit::isTerrainImpassable
; Function compile flags: /Ogtpy
;	COMDAT ?isTerrainImpassable@CvUnit@@QBE_NW4TerrainTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?isTerrainImpassable@CvUnit@@QBE_NW4TerrainTypes@@@Z PROC ; CvUnit::isTerrainImpassable, COMDAT
; _this$ = ecx

; 1125 : 		return m_terrainImpassableCount[eIndex] > 0;

	mov	eax, DWORD PTR [ecx+1996]
	mov	edx, DWORD PTR _eIndex$[esp-4]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+edx*4], ecx
	setg	cl
	mov	al, cl

; 1126 : 	}

	ret	4
?isTerrainImpassable@CvUnit@@QBE_NW4TerrainTypes@@@Z ENDP ; CvUnit::isTerrainImpassable
_TEXT	ENDS
PUBLIC	?IsCombatUnit@CvUnit@@QBE_NXZ			; CvUnit::IsCombatUnit
; Function compile flags: /Ogtpy
;	COMDAT ?IsCombatUnit@CvUnit@@QBE_NXZ
_TEXT	SEGMENT
?IsCombatUnit@CvUnit@@QBE_NXZ PROC			; CvUnit::IsCombatUnit, COMDAT
; _this$ = ecx

; 1243 : 		return (m_iBaseCombat > 0);

	xor	eax, eax
	cmp	DWORD PTR [ecx+1044], eax
	setg	al

; 1244 : 	}

	ret	0
?IsCombatUnit@CvUnit@@QBE_NXZ ENDP			; CvUnit::IsCombatUnit
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT
; _p$ = eax

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 302  : }

	ret	0
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1

; 302  : }

	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
PUBLIC	?getX@CvCity@@QBEHXZ				; CvCity::getX
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcity.h
;	COMDAT ?getX@CvCity@@QBEHXZ
_TEXT	SEGMENT
?getX@CvCity@@QBEHXZ PROC				; CvCity::getX, COMDAT
; _this$ = ecx

; 340  : 		return m_iX;

	mov	eax, DWORD PTR [ecx+96]

; 341  : 	}

	ret	0
?getX@CvCity@@QBEHXZ ENDP				; CvCity::getX
_TEXT	ENDS
PUBLIC	?getY@CvCity@@QBEHXZ				; CvCity::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvCity@@QBEHXZ
_TEXT	SEGMENT
?getY@CvCity@@QBEHXZ PROC				; CvCity::getY, COMDAT
; _this$ = ecx

; 345  : 		return m_iY;

	mov	eax, DWORD PTR [ecx+108]

; 346  : 	}

	ret	0
?getY@CvCity@@QBEHXZ ENDP				; CvCity::getY
_TEXT	ENDS
PUBLIC	?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ	; CvCity::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ PROC		; CvCity::getOwner, COMDAT
; _this$ = ecx

; 604  : 		return m_eOwner;

	mov	eax, DWORD PTR [ecx+84]

; 605  : 	}

	ret	0
?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ ENDP		; CvCity::getOwner
_TEXT	ENDS
PUBLIC	?GetFormationSlot@CvArmyAI@@QAEPAVCvArmyFormationSlot@@H@Z ; CvArmyAI::GetFormationSlot
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvarmyai.h
;	COMDAT ?GetFormationSlot@CvArmyAI@@QAEPAVCvArmyFormationSlot@@H@Z
_TEXT	SEGMENT
_iSlotID$ = 8						; size = 4
?GetFormationSlot@CvArmyAI@@QAEPAVCvArmyFormationSlot@@H@Z PROC ; CvArmyAI::GetFormationSlot, COMDAT
; _this$ = ecx

; 142  : 		return &m_FormationEntries[iSlotID];

	mov	eax, DWORD PTR _iSlotID$[esp-4]
	mov	ecx, DWORD PTR [ecx+44]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [ecx+eax*4]

; 143  : 	};

	ret	4
?GetFormationSlot@CvArmyAI@@QAEPAVCvArmyFormationSlot@@H@Z ENDP ; CvArmyAI::GetFormationSlot
_TEXT	ENDS
PUBLIC	?isAlive@CvPlayer@@QBE_NXZ			; CvPlayer::isAlive
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayer.h
;	COMDAT ?isAlive@CvPlayer@@QBE_NXZ
_TEXT	SEGMENT
?isAlive@CvPlayer@@QBE_NXZ PROC				; CvPlayer::isAlive, COMDAT
; _this$ = ecx

; 1096 : 		return m_bAlive;

	mov	al, BYTE PTR [ecx+2256]

; 1097 : 	}

	ret	0
?isAlive@CvPlayer@@QBE_NXZ ENDP				; CvPlayer::isAlive
_TEXT	ENDS
PUBLIC	?getTeam@CvPlayer@@SA?AW4TeamTypes@@W4PlayerTypes@@@Z ; CvPlayer::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@CvPlayer@@SA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayerID$ = 8						; size = 4
?getTeam@CvPlayer@@SA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPlayer::getTeam, COMDAT

; 1177 : 		return CvPreGame::teamType(ePlayerID);

	mov	eax, DWORD PTR _ePlayerID$[esp-4]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN3@getTeam
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1178 : 	}

	ret	0

; 1177 : 		return CvPreGame::teamType(ePlayerID);

$LN3@getTeam:
	or	eax, -1

; 1178 : 	}

	ret	0
?getTeam@CvPlayer@@SA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPlayer::getTeam
_TEXT	ENDS
PUBLIC	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ		; CvPlayer::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ PROC		; CvPlayer::getTeam, COMDAT
; _this$ = ecx

; 1182 : 		return CvPreGame::teamType(m_eID);

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN5@getTeam@2
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1183 : 	}

	ret	0

; 1182 : 		return CvPreGame::teamType(m_eID);

$LN5@getTeam@2:
	or	eax, -1

; 1183 : 	}

	ret	0
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ ENDP		; CvPlayer::getTeam
_TEXT	ENDS
PUBLIC	?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ		; CvPlot::getTeam
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ PROC		; CvPlot::getTeam, COMDAT
; _this$ = ecx

; 232  : 		PlayerTypes playerID = getOwner();

	movsx	eax, BYTE PTR [ecx+4]

; 233  : 		if(playerID != NO_PLAYER)

	cmp	eax, -1
	je	SHORT $LN2@getTeam@3

; 234  : 		{
; 235  : 			return CvPlayer::getTeam(playerID);

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN2@getTeam@3
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 240  : 		}
; 241  : 	}

	ret	0
$LN2@getTeam@3:

; 236  : 		}
; 237  : 		else
; 238  : 		{
; 239  : 			return NO_TEAM;

	or	eax, -1

; 240  : 		}
; 241  : 	}

	ret	0
?getTeam@CvPlot@@QBE?AW4TeamTypes@@XZ ENDP		; CvPlot::getTeam
_TEXT	ENDS
PUBLIC	?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z	; CvPlot::isRevealed
; Function compile flags: /Ogtpy
;	COMDAT ?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z PROC		; CvPlot::isRevealed, COMDAT
; _this$ = ecx

; 620  : 	{

	mov	edx, ecx

; 621  : 		CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 622  : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 623  : 		return m_bfRevealed.GetBit(eTeam);

	mov	ecx, DWORD PTR _eTeam$[esp-4]
	push	esi
	mov	eax, ecx
	shr	eax, 5
	mov	esi, eax
	shl	esi, 5
	sub	ecx, esi
	mov	esi, 1
	shl	esi, cl
	test	esi, DWORD PTR [edx+eax*4+8]
	pop	esi
	setne	al

; 624  : 	}

	ret	4
?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z ENDP		; CvPlot::isRevealed
_TEXT	ENDS
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	mov	eax, DWORD PTR _iX$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4020]
	jge	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _iY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4024]
	jge	SHORT $LN3@isPlot
	mov	eax, 1

; 161  : #endif
; 162  : 	}

	ret	8
$LN3@isPlot:

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	xor	eax, eax

; 161  : #endif
; 162  : 	}

	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
PUBLIC	?plotNum@CvMap@@QBEHHH@Z			; CvMap::plotNum
; Function compile flags: /Ogtpy
;	COMDAT ?plotNum@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plotNum@CvMap@@QBEHHH@Z PROC				; CvMap::plotNum, COMDAT
; _this$ = ecx

; 183  : 		return ((iY * getGridWidth()) + iX);

	mov	eax, DWORD PTR [ecx+4020]
	imul	eax, DWORD PTR _iY$[esp-4]
	add	eax, DWORD PTR _iX$[esp-4]

; 184  : #endif
; 185  : 	}

	ret	8
?plotNum@CvMap@@QBEHHH@Z ENDP				; CvMap::plotNum
_TEXT	ENDS
PUBLIC	?plot@CvMap@@QBEPAVCvPlot@@HH@Z			; CvMap::plot
; Function compile flags: /Ogtpy
;	COMDAT ?plot@CvMap@@QBEPAVCvPlot@@HH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plot@CvMap@@QBEPAVCvPlot@@HH@Z PROC			; CvMap::plot, COMDAT
; _this$ = ecx

; 273  : 		if((iX == INVALID_PLOT_COORD) || (iY == INVALID_PLOT_COORD))

	mov	eax, DWORD PTR _iX$[esp-4]
	push	ebp
	cmp	eax, -2147483647			; 80000001H
	je	$LN1@plot
	mov	ebp, DWORD PTR _iY$[esp]
	cmp	ebp, -2147483647			; 80000001H
	je	$LN1@plot

; 276  : 		}
; 277  : 		int iMapX = coordRange(iX, getGridWidth(), isWrapX());

	cmp	BYTE PTR [ecx+4056], 0
	push	ebx
	push	esi
	mov	esi, DWORD PTR [ecx+4020]
	push	edi
	je	SHORT $LN11@plot
	test	eax, eax
	jge	SHORT $LN13@plot
	cdq
	idiv	esi
	mov	edi, edx
	add	edi, esi
	jmp	SHORT $LN15@plot
$LN13@plot:
	cmp	eax, esi
	jl	SHORT $LN11@plot
	cdq
	idiv	esi
	mov	edi, edx
	jmp	SHORT $LN15@plot
$LN11@plot:
	mov	edi, eax
$LN15@plot:

; 278  : 		int iMapY = coordRange(iY, getGridHeight(), isWrapY());

	cmp	BYTE PTR [ecx+4057], 0
	mov	ebx, DWORD PTR [ecx+4024]
	je	SHORT $LN40@plot
	test	ebp, ebp
	jge	SHORT $LN23@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN25@plot
$LN23@plot:
	cmp	ebp, ebx
	jl	SHORT $LN40@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	jmp	SHORT $LN25@plot
$LN40@plot:
	mov	edx, ebp
$LN25@plot:

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	test	edi, edi
	jl	SHORT $LN5@plot
	cmp	edi, esi
	jge	SHORT $LN5@plot
	test	edx, edx
	jl	SHORT $LN5@plot
	cmp	edx, ebx
	jge	SHORT $LN5@plot
	imul	esi, edx
	add	esi, edi
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [ecx+4068]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	pop	ebp

; 280  : 	}

	ret	8
$LN5@plot:
	pop	edi
	pop	esi
	pop	ebx

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
$LN1@plot:

; 274  : 		{
; 275  : 			return NULL;

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
?plot@CvMap@@QBEPAVCvPlot@@HH@Z ENDP			; CvMap::plot
_TEXT	ENDS
PUBLIC	?plotCheckInvalid@CvMap@@QBEPAVCvPlot@@HH@Z	; CvMap::plotCheckInvalid
; Function compile flags: /Ogtpy
;	COMDAT ?plotCheckInvalid@CvMap@@QBEPAVCvPlot@@HH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plotCheckInvalid@CvMap@@QBEPAVCvPlot@@HH@Z PROC	; CvMap::plotCheckInvalid, COMDAT
; _this$ = ecx

; 282  : 	{

	push	esi

; 283  : 		if((iX == INVALID_PLOT_COORD) || (iY == INVALID_PLOT_COORD))

	mov	esi, DWORD PTR _iX$[esp]
	cmp	esi, -2147483647			; 80000001H
	je	SHORT $LN1@plotCheckI
	mov	edx, DWORD PTR _iY$[esp]
	cmp	edx, -2147483647			; 80000001H
	je	SHORT $LN1@plotCheckI

; 286  : 		}
; 287  : 		return &(m_pMapPlots[plotNum(iX, iY)]);

	mov	eax, DWORD PTR [ecx+4020]
	imul	eax, edx
	add	eax, esi
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]
	pop	esi

; 288  : 	}

	ret	8
$LN1@plotCheckI:

; 284  : 		{
; 285  : 			return NULL;

	xor	eax, eax
	pop	esi

; 288  : 	}

	ret	8
?plotCheckInvalid@CvMap@@QBEPAVCvPlot@@HH@Z ENDP	; CvMap::plotCheckInvalid
_TEXT	ENDS
PUBLIC	??0CvTemporaryZone@@QAE@XZ			; CvTemporaryZone::CvTemporaryZone
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtacticalai.h
;	COMDAT ??0CvTemporaryZone@@QAE@XZ
_TEXT	SEGMENT
??0CvTemporaryZone@@QAE@XZ PROC				; CvTemporaryZone::CvTemporaryZone, COMDAT
; _this$ = ecx

; 560  : 	CvTemporaryZone()

	mov	eax, ecx

; 561  : 	{
; 562  : 		Clear();

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 563  : 	}

	ret	0
??0CvTemporaryZone@@QAE@XZ ENDP				; CvTemporaryZone::CvTemporaryZone
_TEXT	ENDS
PUBLIC	?clear@?$BaseVector@PAVCvAStarNode@@$00@@QAEXXZ	; BaseVector<CvAStarNode *,1>::clear
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?clear@?$BaseVector@PAVCvAStarNode@@$00@@QAEXXZ
_TEXT	SEGMENT
?clear@?$BaseVector@PAVCvAStarNode@@$00@@QAEXXZ PROC	; BaseVector<CvAStarNode *,1>::clear, COMDAT
; _this$ = ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);
; 122  : 		m_uiCurrSize = 0;

	mov	DWORD PTR [ecx+4], 0

; 123  : 	};

	ret	0
?clear@?$BaseVector@PAVCvAStarNode@@$00@@QAEXXZ ENDP	; BaseVector<CvAStarNode *,1>::clear
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z PROC ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ENDP ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?_Key@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAABQAVFAutoVariableBase@@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Key
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Key@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAABQAVFAutoVariableBase@@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAABQAVFAutoVariableBase@@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Key, COMDAT

; 162  : 		return (_Mybase::_Kfn(_Myval(_Pnode)));

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 12					; 0000000cH

; 163  : 		}

	ret	0
?_Key@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@KAABQAVFAutoVariableBase@@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Key
_TEXT	ENDS
PUBLIC	?_Root@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Root
; Function compile flags: /Ogtpy
;	COMDAT ?_Root@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Root, COMDAT
; _this$ = ecx

; 1325 : 		return (_Parent(_Myhead));

	mov	eax, DWORD PTR [ecx+4]
	add	eax, 4

; 1326 : 		}

	ret	0
?_Root@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Root
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::iterator::iterator
; Function compile flags: /Ogtpy
;	COMDAT ??0iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 459  : 			{	// construct with node pointer _Pnode

	mov	eax, ecx
	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [eax], ecx

; 460  : 			}

	ret	4
??0iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::iterator::iterator
_TEXT	ENDS
PUBLIC	?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@H@std@@QAEPAHI@Z		; std::allocator<int>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@H@std@@QAEPAHI@Z PROC		; std::allocator<int>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@H@std@@QAEPAHI@Z ENDP		; std::allocator<int>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::max_size, COMDAT
; _this$ = ecx

; 606  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 607  : 		}

	ret	0
?max_size@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::max_size
_TEXT	ENDS
PUBLIC	?_Lrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Lrotate
; Function compile flags: /Ogtpy
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1286 : 		_Nodeptr _Pnode = _Right(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[esp-4]
	mov	eax, DWORD PTR [edx+8]
	push	esi

; 1287 : 		_Right(_Wherenode) = _Left(_Pnode);

	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [edx+8], esi

; 1288 : 
; 1289 : 		if (!_Isnil(_Left(_Pnode)))

	mov	esi, DWORD PTR [eax]
	cmp	BYTE PTR [esi+17], 0
	jne	SHORT $LN5@Lrotate

; 1290 : 			_Parent(_Left(_Pnode)) = _Wherenode;

	mov	DWORD PTR [esi+4], edx
$LN5@Lrotate:

; 1291 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi

; 1292 : 
; 1293 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR [ecx+4]
	pop	esi
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN4@Lrotate

; 1294 : 			_Root() = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
$LN4@Lrotate:

; 1295 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

	mov	ecx, DWORD PTR [edx+4]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN2@Lrotate

; 1296 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
$LN2@Lrotate:

; 1297 : 		else
; 1298 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx+8], eax

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], edx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1302 : 		}

	ret	4
?_Lrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Lrotate
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Rrotate
; Function compile flags: /Ogtpy
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1330 : 		_Nodeptr _Pnode = _Left(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[esp-4]
	mov	eax, DWORD PTR [edx]
	push	esi

; 1331 : 		_Left(_Wherenode) = _Right(_Pnode);

	mov	esi, DWORD PTR [eax+8]
	mov	DWORD PTR [edx], esi

; 1332 : 
; 1333 : 		if (!_Isnil(_Right(_Pnode)))

	mov	esi, DWORD PTR [eax+8]
	cmp	BYTE PTR [esi+17], 0
	jne	SHORT $LN5@Rrotate

; 1334 : 			_Parent(_Right(_Pnode)) = _Wherenode;

	mov	DWORD PTR [esi+4], edx
$LN5@Rrotate:

; 1335 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi

; 1336 : 
; 1337 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR [ecx+4]
	pop	esi
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN4@Rrotate

; 1338 : 			_Root() = _Pnode;

	mov	DWORD PTR [ecx+4], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
$LN4@Rrotate:

; 1339 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

	mov	ecx, DWORD PTR [edx+4]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN2@Rrotate

; 1340 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx+8], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
$LN2@Rrotate:

; 1341 : 		else
; 1342 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [ecx], eax

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], edx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1346 : 		}

	ret	4
?_Rrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::_Dec
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::_Dec, COMDAT
; _this$ = ecx

; 321  : 
; 322  :  #if _HAS_ITERATOR_DEBUGGING
; 323  : 			if (this->_Mycont == 0
; 324  : 				|| _Ptr == 0)
; 325  : 				{
; 326  : 				_DEBUG_ERROR("map/set iterator not decrementable");
; 327  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 				}
; 329  :  #else
; 330  : 			_SCL_SECURE_VALIDATE(this->_Has_container());
; 331  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 332  : 
; 333  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+17], 0
	je	SHORT $LN9@Dec

; 334  : 			{
; 335  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

	mov	eax, DWORD PTR [eax+8]

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;
; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move
; 370  :  #endif
; 371  : 				else
; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [ecx], eax

; 373  : 				}
; 374  : 			}

	ret	0
$LN9@Dec:

; 336  :    				if (_Isnil(_Ptr))
; 337  : #if _HAS_ITERATOR_DEBUGGING
; 338  : 				{
; 339  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 340  : 					_SCL_SECURE_OUT_OF_RANGE;
; 341  : 				}
; 342  : #elif _SECURE_SCL
; 343  : 				{
; 344  :     				_SCL_SECURE_OUT_OF_RANGE;
; 345  : 				}
; 346  : #else
; 347  : 				return;	// begin() shouldn't be incremented, don't move
; 348  : #endif
; 349  : 			}
; 350  : 			else if (!_Isnil(_Left(_Ptr)))

	mov	edx, DWORD PTR [eax]
	cmp	BYTE PTR [edx+17], 0
	jne	SHORT $LN43@Dec

; 351  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

	mov	eax, DWORD PTR [edx+8]
	cmp	BYTE PTR [eax+17], 0
	jne	SHORT $LN24@Dec
	npad	1
$LL25@Dec:
	mov	edx, eax
	mov	eax, DWORD PTR [edx+8]
	cmp	BYTE PTR [eax+17], 0
	je	SHORT $LL25@Dec
$LN24@Dec:
	mov	DWORD PTR [ecx], edx

; 373  : 				}
; 374  : 			}

	ret	0
$LN43@Dec:

; 352  : 			else
; 353  : 				{	// climb looking for left subtree
; 354  : 				_Nodeptr _Pnode;
; 355  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 356  : 					&& _Ptr == _Left(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+17], 0
	jne	SHORT $LN3@Dec
$LL4@Dec:
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN3@Dec

; 357  : 					_Ptr = _Pnode;	// ==> parent while left subtree

	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+17], 0
	je	SHORT $LL4@Dec
$LN3@Dec:

; 358  : 				if (_Isnil(_Ptr))

	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+17], 0
	jne	SHORT $LN1@Dec

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;
; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move
; 370  :  #endif
; 371  : 				else
; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [ecx], eax
$LN1@Dec:

; 373  : 				}
; 374  : 			}

	ret	0
?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::_Dec
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator!=
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z	; stdext::unchecked_copy<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z PROC	; stdext::unchecked_copy<int *,int *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_@5
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_@5:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z ENDP	; stdext::unchecked_copy<int *,int *>
_TEXT	ENDS
PUBLIC	??$for_each@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@U?$SerializeFromSequenceContainer@$$CBH$$CBV?$vector@HV?$allocator@H@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBH$$CBV?$vector@HV?$allocator@H@std@@@std@@@@V?$_Vector_const_iterator@HV?$allocator@H@std@@@0@0U1@@Z ; std::for_each<std::_Vector_const_iterator<int,std::allocator<int> >,SerializeFromSequenceContainer<int const ,std::vector<int,std::allocator<int> > const > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@U?$SerializeFromSequenceContainer@$$CBH$$CBV?$vector@HV?$allocator@H@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBH$$CBV?$vector@HV?$allocator@H@std@@@std@@@@V?$_Vector_const_iterator@HV?$allocator@H@std@@@0@0U1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Func$ = 20						; size = 8
??$for_each@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@U?$SerializeFromSequenceContainer@$$CBH$$CBV?$vector@HV?$allocator@H@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBH$$CBV?$vector@HV?$allocator@H@std@@@std@@@@V?$_Vector_const_iterator@HV?$allocator@H@std@@@0@0U1@@Z PROC ; std::for_each<std::_Vector_const_iterator<int,std::allocator<int> >,SerializeFromSequenceContainer<int const ,std::vector<int,std::allocator<int> > const > >, COMDAT

; 23   : 	{	// perform function for each element

	push	esi

; 24   : 	_DEBUG_RANGE(_First, _Last);
; 25   : 	_DEBUG_POINTER(_Func);
; 26   : 	_CHECKED_BASE_TYPE(_InIt) _ChkFirst(_CHECKED_BASE(_First));

	mov	esi, DWORD PTR __First$[esp]
	push	edi

; 27   : 	_CHECKED_BASE_TYPE(_InIt) _ChkLast(_CHECKED_BASE(_Last));

	mov	edi, DWORD PTR __Last$[esp+4]

; 28   : 	for (; _ChkFirst != _ChkLast; ++_ChkFirst)

	cmp	esi, edi
	je	SHORT $LN1@for_each
	npad	2
$LL6@for_each:

; 29   : 		_Func(*_ChkFirst);

	mov	ecx, DWORD PTR __Func$[esp+4]
	push	esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	esi, 4
	cmp	esi, edi
	jne	SHORT $LL6@for_each
$LN1@for_each:

; 30   : 	return (_Func);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	ecx, DWORD PTR __Func$[esp+4]
	mov	edx, DWORD PTR __Func$[esp+8]
	pop	edi
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	pop	esi

; 31   : 	}

	ret	0
??$for_each@V?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@U?$SerializeFromSequenceContainer@$$CBH$$CBV?$vector@HV?$allocator@H@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBH$$CBV?$vector@HV?$allocator@H@std@@@std@@@@V?$_Vector_const_iterator@HV?$allocator@H@std@@@0@0U1@@Z ENDP ; std::for_each<std::_Vector_const_iterator<int,std::allocator<int> >,SerializeFromSequenceContainer<int const ,std::vector<int,std::allocator<int> > const > >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<int,std::allocator<int> >::operator+=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator+=
_TEXT	ENDS
PUBLIC	??$fill@PAHH@std@@YAXPAH0ABH@Z			; std::fill<int *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAHH@std@@YAXPAH0ABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAHH@std@@YAXPAH0ABH@Z PROC			; std::fill<int *,int>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@fill@2
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill@2:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL5@fill@2
	pop	esi
$LN3@fill@2:

; 3188 : 	}

	ret	0
??$fill@PAHH@std@@YAXPAH0ABH@Z ENDP			; std::fill<int *,int>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN8@Move_backw@2
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@Move_backw@2:
	mov	eax, esi
	pop	esi

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<int *,unsigned int,int,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<int *,unsigned int,int,std::random_access_iterator_tag>, COMDAT

; 3242 : 		_Fill_n(_First, _Count, _Val, _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN3@Fill_n@2
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@Fill_n@2:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL5@Fill_n@2
	pop	esi
$LN3@Fill_n@2:

; 3243 : 	}

	ret	0
??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<int *,unsigned int,int,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >, COMDAT

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN8@unchecked_@6
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@unchecked_@6:
	pop	edi
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_eDirection$ = 16					; size = 4
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z PROC ; plotDirection, COMDAT

; 219  : 	if(eDirection == NO_DIRECTION)

	mov	ecx, DWORD PTR _eDirection$[esp-4]
	push	ebx
	push	ebp
	push	esi
	push	edi
	cmp	ecx, -1
	jne	$LN2@plotDirect

; 220  : 	{
; 221  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR _iX$[esp+12]
	cmp	eax, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebx, DWORD PTR _iY$[esp+12]
	cmp	ebx, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN99@plotDirect
	test	eax, eax
	jge	SHORT $LN19@plotDirect
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN21@plotDirect
$LN19@plotDirect:
	cmp	eax, ecx
	jl	SHORT $LN99@plotDirect
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN21@plotDirect
$LN99@plotDirect:
	mov	esi, eax
$LN21@plotDirect:
	cmp	BYTE PTR [ebp+4057], 0
	mov	edi, DWORD PTR [ebp+4024]
	je	SHORT $LN101@plotDirect
	test	ebx, ebx
	jge	SHORT $LN29@plotDirect
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN31@plotDirect
$LN29@plotDirect:
	cmp	ebx, edi
	jl	SHORT $LN101@plotDirect
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN31@plotDirect
$LN101@plotDirect:
	mov	edx, ebx
$LN31@plotDirect:
	test	esi, esi
	jl	$LN59@plotDirect
	cmp	esi, ecx
	jge	$LN59@plotDirect
	test	edx, edx
	jl	$LN59@plotDirect
	cmp	edx, edi
	jge	$LN59@plotDirect
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ecx
	pop	ebx

; 234  : 	}
; 235  : }

	ret	0
$LN2@plotDirect:

; 222  : 	}
; 223  : 	else
; 224  : 	{
; 225  : 		// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 226  : 		iX = xToHexspaceX(iX , iY);

	mov	esi, DWORD PTR _iY$[esp+12]
	test	esi, esi
	jl	SHORT $LN47@plotDirect
	mov	eax, esi
	jmp	SHORT $LN103@plotDirect
$LN47@plotDirect:
	lea	eax, DWORD PTR [esi-1]
	cdq
	sub	eax, edx
$LN103@plotDirect:

; 227  : 		iX += GC.getPlotDirectionX()[eDirection];

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A[ecx*4+112]
	mov	edi, DWORD PTR _iX$[esp+12]
	sar	eax, 1
	sub	edx, eax
	add	edi, edx

; 228  : 		iY += GC.getPlotDirectionY()[eDirection];

	add	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A[ecx*4+136]

; 229  : 
; 230  : 		// convert from hex-space coordinates to the storage array
; 231  : 		iX = hexspaceXToX(iX, iY);

	js	SHORT $LN55@plotDirect
	mov	eax, esi
	jmp	SHORT $LN104@plotDirect
$LN55@plotDirect:
	lea	eax, DWORD PTR [esi-1]
	cdq
	sub	eax, edx
$LN104@plotDirect:
	sar	eax, 1
	add	edi, eax

; 232  : 
; 233  : 		return GC.getMap().plot(iX, iY);

	cmp	edi, -2147483647			; 80000001H
	je	$LN59@plotDirect
	cmp	esi, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN69@plotDirect
	test	edi, edi
	jge	SHORT $LN71@plotDirect
	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, edx
	add	edi, ecx
	jmp	SHORT $LN69@plotDirect
$LN71@plotDirect:
	cmp	edi, ecx
	jl	SHORT $LN69@plotDirect
	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, edx
$LN69@plotDirect:
	cmp	BYTE PTR [ebp+4057], 0
	mov	ebx, DWORD PTR [ebp+4024]
	je	SHORT $LN100@plotDirect
	test	esi, esi
	jge	SHORT $LN81@plotDirect
	mov	eax, esi
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN83@plotDirect
$LN81@plotDirect:
	cmp	esi, ebx
	jl	SHORT $LN100@plotDirect
	mov	eax, esi
	cdq
	idiv	ebx
	jmp	SHORT $LN83@plotDirect
$LN100@plotDirect:
	mov	edx, esi
$LN83@plotDirect:
	test	edi, edi
	jl	SHORT $LN59@plotDirect
	cmp	edi, ecx
	jge	SHORT $LN59@plotDirect
	test	edx, edx
	jl	SHORT $LN59@plotDirect
	cmp	edx, ebx
	jge	SHORT $LN59@plotDirect
	imul	ecx, edx
	add	ecx, edi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ecx
	pop	ebx

; 234  : 	}
; 235  : }

	ret	0

; 232  : 
; 233  : 		return GC.getMap().plot(iX, iY);

$LN59@plotDirect:
	pop	edi
	pop	esi
	pop	ebp
	xor	eax, eax
	pop	ebx

; 234  : 	}
; 235  : }

	ret	0
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ENDP ; plotDirection
_TEXT	ENDS
PUBLIC	?plotXY@@YAPAVCvPlot@@HHHH@Z			; plotXY
; Function compile flags: /Ogtpy
;	COMDAT ?plotXY@@YAPAVCvPlot@@HHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
?plotXY@@YAPAVCvPlot@@HHHH@Z PROC			; plotXY, COMDAT

; 239  : 	// convert the start coord to hex-space coordinates
; 240  : 	int iStartHexX = xToHexspaceX(iX, iY);

	mov	ecx, DWORD PTR _iY$[esp-4]
	test	ecx, ecx
	jl	SHORT $LN5@plotXY
	mov	eax, ecx
	jmp	SHORT $LN55@plotXY
$LN5@plotXY:
	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
$LN55@plotXY:
	push	esi

; 241  : 
; 242  : 	int iPlotHexX = iStartHexX + iDX;

	mov	esi, DWORD PTR _iX$[esp]
	sar	eax, 1
	sub	esi, eax

; 243  : 	int iPlotY = iY + iDY; // Y is the same in both coordinate systems

	mov	eax, DWORD PTR _iDY$[esp]
	add	esi, DWORD PTR _iDX$[esp]
	push	edi
	lea	edi, DWORD PTR [ecx+eax]

; 244  : 
; 245  : 	// convert from hex-space coordinates to the storage array
; 246  : 	iPlotHexX = hexspaceXToX(iPlotHexX, iPlotY);

	test	edi, edi
	jl	SHORT $LN9@plotXY
	mov	eax, edi
	jmp	SHORT $LN56@plotXY
$LN9@plotXY:
	lea	eax, DWORD PTR [edi-1]
	cdq
	sub	eax, edx
$LN56@plotXY:
	sar	eax, 1
	add	esi, eax

; 247  : 
; 248  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

	cmp	esi, -2147483647			; 80000001H
	je	$LN13@plotXY
	cmp	edi, -2147483647			; 80000001H
	je	$LN13@plotXY
	push	ebp
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN23@plotXY
	test	esi, esi
	jge	SHORT $LN25@plotXY
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN23@plotXY
$LN25@plotXY:
	cmp	esi, ecx
	jl	SHORT $LN23@plotXY
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
$LN23@plotXY:
	cmp	BYTE PTR [ebp+4057], 0
	push	ebx
	mov	ebx, DWORD PTR [ebp+4024]
	je	SHORT $LN52@plotXY
	test	edi, edi
	jge	SHORT $LN35@plotXY
	mov	eax, edi
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN37@plotXY
$LN35@plotXY:
	cmp	edi, ebx
	jl	SHORT $LN52@plotXY
	mov	eax, edi
	cdq
	idiv	ebx
	jmp	SHORT $LN37@plotXY
$LN52@plotXY:
	mov	edx, edi
$LN37@plotXY:
	test	esi, esi
	jl	SHORT $LN17@plotXY
	cmp	esi, ecx
	jge	SHORT $LN17@plotXY
	test	edx, edx
	jl	SHORT $LN17@plotXY
	cmp	edx, ebx
	jge	SHORT $LN17@plotXY
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	ebx
	pop	ebp
	pop	edi
	mov	eax, ecx
	pop	esi

; 249  : }

	ret	0

; 247  : 
; 248  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

$LN17@plotXY:
	pop	ebx
	pop	ebp
	pop	edi
	xor	eax, eax
	pop	esi

; 249  : }

	ret	0

; 247  : 
; 248  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

$LN13@plotXY:
	pop	edi
	xor	eax, eax
	pop	esi

; 249  : }

	ret	0
?plotXY@@YAPAVCvPlot@@HHHH@Z ENDP			; plotXY
_TEXT	ENDS
PUBLIC	?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z	; plotXYWithRangeCheck
; Function compile flags: /Ogtpy
;	COMDAT ?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
_iRange$ = 24						; size = 4
?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z PROC	; plotXYWithRangeCheck, COMDAT

; 259  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 260  : 	// I'm assuming iDX and iDY are in hex-space
; 261  : 	if (hexDistance(iDX, iDY) > iRange)
; 262  : #else
; 263  : 	int hexRange;
; 264  : 
; 265  : 	// I'm assuming iDX and iDY are in hex-space
; 266  : 	if((iDX >= 0) == (iDY >= 0))  // the signs match

	mov	edx, DWORD PTR _iDX$[esp-4]
	xor	eax, eax
	test	edx, edx
	setge	al
	xor	ecx, ecx
	push	esi
	mov	esi, DWORD PTR _iDY$[esp]
	test	esi, esi
	setge	cl
	cmp	eax, ecx

; 267  : 	{
; 268  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	mov	ecx, edx
	jne	SHORT $LN3@plotXYWith
	test	edx, edx
	jge	SHORT $LN7@plotXYWith
	neg	ecx
$LN7@plotXYWith:

; 269  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	mov	eax, esi
	test	esi, esi
	jge	SHORT $LN9@plotXYWith
	neg	eax
$LN9@plotXYWith:

; 270  : 		hexRange = iAbsDX + iAbsDY;

	add	eax, ecx

; 271  : 	}
; 272  : 	else

	jmp	SHORT $LN14@plotXYWith
$LN3@plotXYWith:

; 273  : 	{
; 274  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	test	edx, edx
	jge	SHORT $LN11@plotXYWith
	neg	ecx
$LN11@plotXYWith:

; 275  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	mov	eax, esi
	test	esi, esi
	jge	SHORT $LN13@plotXYWith
	neg	eax
$LN13@plotXYWith:

; 276  : 		hexRange = iAbsDX >= iAbsDY ? iAbsDX : iAbsDY;

	cmp	ecx, eax
	jl	SHORT $LN14@plotXYWith
	mov	eax, ecx
$LN14@plotXYWith:

; 277  : 	}
; 278  : 
; 279  : 	if(hexRange > iRange)

	cmp	eax, DWORD PTR _iRange$[esp]
	jle	SHORT $LN1@plotXYWith

; 280  : #endif
; 281  : 	{
; 282  : 		return NULL;

	xor	eax, eax
	pop	esi

; 286  : }

	ret	0
$LN1@plotXYWith:

; 283  : 	}
; 284  : 
; 285  : 	return plotXY(iX, iY, iDX, iDY);

	mov	eax, DWORD PTR _iX$[esp]
	push	esi
	push	edx
	mov	edx, DWORD PTR _iY$[esp+8]
	push	edx
	push	eax
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	add	esp, 16					; 00000010H
	pop	esi

; 286  : }

	ret	0
?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z ENDP	; plotXYWithRangeCheck
_TEXT	ENDS
PUBLIC	?Init@CvAIOperation@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ; CvAIOperation::Init
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
;	COMDAT ?Init@CvAIOperation@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
_TEXT	SEGMENT
_iID$ = 8						; size = 4
_eOwner$ = 12						; size = 4
_eEnemy$ = 16						; size = 4
_iDefaultArea$ = 20					; size = 4
___formal$ = 24						; size = 4
_pMuster$ = 28						; size = 4
?Init@CvAIOperation@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z PROC ; CvAIOperation::Init, COMDAT
; _this$ = ecx

; 48   : {

	push	esi
	mov	esi, ecx

; 49   : 	Uninit();

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+8]
	call	edx

; 50   : 	m_iID = iID;

	mov	eax, DWORD PTR _iID$[esp]

; 51   : 	m_eOwner = eOwner;

	mov	ecx, DWORD PTR _eOwner$[esp]

; 52   : 	m_eEnemy = eEnemy;

	mov	edx, DWORD PTR _eEnemy$[esp]
	mov	DWORD PTR [esi+52], eax

; 53   : 	m_iDefaultArea = iDefaultArea;

	mov	eax, DWORD PTR _iDefaultArea$[esp]
	mov	DWORD PTR [esi+72], ecx

; 54   : #ifndef AUI_WARNING_FIXES
; 55   : 	m_bShouldReplaceLossesWithReinforcements = false;
; 56   : #endif
; 57   : 
; 58   : 	SetStartCityPlot(pMuster->plot());

	mov	ecx, DWORD PTR _pMuster$[esp]
	mov	DWORD PTR [esi+76], edx
	mov	DWORD PTR [esi+64], eax
	mov	BYTE PTR [esi+80], 0
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR [esi+88], ecx
	movsx	edx, WORD PTR [eax+2]

; 59   : 
; 60   : 	// create the armies that are needed and set the state to ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE
; 61   : 	BuildListOfUnitsWeStillNeedToBuild();

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [esi+92], edx
	mov	edx, DWORD PTR [eax+92]
	mov	ecx, esi
	call	edx

; 62   : 	GrabUnitsFromTheReserves(NULL, NULL);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+112]
	push	0
	push	0
	mov	ecx, esi
	call	edx
	pop	esi

; 63   : }

	ret	24					; 00000018H
?Init@CvAIOperation@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ENDP ; CvAIOperation::Init
_TEXT	ENDS
PUBLIC	?GetFirstArmyID@CvAIOperation@@QAEHXZ		; CvAIOperation::GetFirstArmyID
; Function compile flags: /Ogtpy
;	COMDAT ?GetFirstArmyID@CvAIOperation@@QAEHXZ
_TEXT	SEGMENT
?GetFirstArmyID@CvAIOperation@@QAEHXZ PROC		; CvAIOperation::GetFirstArmyID, COMDAT
; _this$ = ecx

; 167  : 	if(!m_viArmyIDs.empty())

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, DWORD PTR [ecx+8]
	test	eax, -4					; fffffffcH
	je	SHORT $LN2@GetFirstAr

; 168  : 	{
; 169  : 		return m_viArmyIDs[0];

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [ecx]

; 174  : 	}
; 175  : }

	ret	0
$LN2@GetFirstAr:

; 170  : 	}
; 171  : 	else
; 172  : 	{
; 173  : 		return -1;

	or	eax, -1

; 174  : 	}
; 175  : }

	ret	0
?GetFirstArmyID@CvAIOperation@@QAEHXZ ENDP		; CvAIOperation::GetFirstArmyID
_TEXT	ENDS
PUBLIC	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ	; CvAIOperation::GetTargetPlot
; Function compile flags: /Ogtpy
;	COMDAT ?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ
_TEXT	SEGMENT
?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ PROC	; CvAIOperation::GetTargetPlot, COMDAT
; _this$ = ecx

; 180  : 	CvPlot* rtnValue = NULL;
; 181  : 	rtnValue =  GC.getMap().plot(m_iTargetX, m_iTargetY);

	mov	eax, DWORD PTR [ecx+104]
	push	ebx
	mov	ebx, DWORD PTR [ecx+108]
	cmp	eax, -2147483647			; 80000001H
	je	$LN5@GetTargetP
	cmp	ebx, -2147483647			; 80000001H
	je	$LN5@GetTargetP
	push	ebp
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	push	esi
	je	SHORT $LN44@GetTargetP
	test	eax, eax
	jge	SHORT $LN17@GetTargetP
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN19@GetTargetP
$LN17@GetTargetP:
	cmp	eax, ecx
	jl	SHORT $LN44@GetTargetP
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN19@GetTargetP
$LN44@GetTargetP:
	mov	esi, eax
$LN19@GetTargetP:
	cmp	BYTE PTR [ebp+4057], 0
	push	edi
	mov	edi, DWORD PTR [ebp+4024]
	je	SHORT $LN45@GetTargetP
	test	ebx, ebx
	jge	SHORT $LN27@GetTargetP
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN29@GetTargetP
$LN27@GetTargetP:
	cmp	ebx, edi
	jl	SHORT $LN45@GetTargetP
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN29@GetTargetP
$LN45@GetTargetP:
	mov	edx, ebx
$LN29@GetTargetP:
	test	esi, esi
	jl	SHORT $LN9@GetTargetP
	cmp	esi, ecx
	jge	SHORT $LN9@GetTargetP
	test	edx, edx
	jl	SHORT $LN9@GetTargetP
	cmp	edx, edi
	jge	SHORT $LN9@GetTargetP
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ecx
	pop	ebx

; 182  : 	return rtnValue;
; 183  : }

	ret	0

; 180  : 	CvPlot* rtnValue = NULL;
; 181  : 	rtnValue =  GC.getMap().plot(m_iTargetX, m_iTargetY);

$LN9@GetTargetP:
	pop	edi
	pop	esi
	pop	ebp
	xor	eax, eax
	pop	ebx

; 182  : 	return rtnValue;
; 183  : }

	ret	0

; 180  : 	CvPlot* rtnValue = NULL;
; 181  : 	rtnValue =  GC.getMap().plot(m_iTargetX, m_iTargetY);

$LN5@GetTargetP:
	xor	eax, eax
	pop	ebx

; 182  : 	return rtnValue;
; 183  : }

	ret	0
?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ENDP	; CvAIOperation::GetTargetPlot
_TEXT	ENDS
PUBLIC	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ	; CvAIOperation::GetMusterPlot
; Function compile flags: /Ogtpy
;	COMDAT ?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ
_TEXT	SEGMENT
?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ PROC	; CvAIOperation::GetMusterPlot, COMDAT
; _this$ = ecx

; 195  : 	CvPlot* rtnValue = NULL;
; 196  : 	rtnValue =  GC.getMap().plot(m_iMusterX, m_iMusterY);

	mov	eax, DWORD PTR [ecx+96]
	push	ebx
	mov	ebx, DWORD PTR [ecx+100]
	cmp	eax, -2147483647			; 80000001H
	je	$LN5@GetMusterP@2
	cmp	ebx, -2147483647			; 80000001H
	je	$LN5@GetMusterP@2
	push	ebp
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	push	esi
	je	SHORT $LN44@GetMusterP@2
	test	eax, eax
	jge	SHORT $LN17@GetMusterP@2
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN19@GetMusterP@2
$LN17@GetMusterP@2:
	cmp	eax, ecx
	jl	SHORT $LN44@GetMusterP@2
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN19@GetMusterP@2
$LN44@GetMusterP@2:
	mov	esi, eax
$LN19@GetMusterP@2:
	cmp	BYTE PTR [ebp+4057], 0
	push	edi
	mov	edi, DWORD PTR [ebp+4024]
	je	SHORT $LN45@GetMusterP@2
	test	ebx, ebx
	jge	SHORT $LN27@GetMusterP@2
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN29@GetMusterP@2
$LN27@GetMusterP@2:
	cmp	ebx, edi
	jl	SHORT $LN45@GetMusterP@2
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN29@GetMusterP@2
$LN45@GetMusterP@2:
	mov	edx, ebx
$LN29@GetMusterP@2:
	test	esi, esi
	jl	SHORT $LN9@GetMusterP@2
	cmp	esi, ecx
	jge	SHORT $LN9@GetMusterP@2
	test	edx, edx
	jl	SHORT $LN9@GetMusterP@2
	cmp	edx, edi
	jge	SHORT $LN9@GetMusterP@2
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ecx
	pop	ebx

; 197  : 	return rtnValue;
; 198  : }

	ret	0

; 195  : 	CvPlot* rtnValue = NULL;
; 196  : 	rtnValue =  GC.getMap().plot(m_iMusterX, m_iMusterY);

$LN9@GetMusterP@2:
	pop	edi
	pop	esi
	pop	ebp
	xor	eax, eax
	pop	ebx

; 197  : 	return rtnValue;
; 198  : }

	ret	0

; 195  : 	CvPlot* rtnValue = NULL;
; 196  : 	rtnValue =  GC.getMap().plot(m_iMusterX, m_iMusterY);

$LN5@GetMusterP@2:
	xor	eax, eax
	pop	ebx

; 197  : 	return rtnValue;
; 198  : }

	ret	0
?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ENDP	; CvAIOperation::GetMusterPlot
_TEXT	ENDS
PUBLIC	?GetStartCityPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetStartCityPlot
; Function compile flags: /Ogtpy
;	COMDAT ?GetStartCityPlot@CvAIOperation@@QBEPAVCvPlot@@XZ
_TEXT	SEGMENT
?GetStartCityPlot@CvAIOperation@@QBEPAVCvPlot@@XZ PROC	; CvAIOperation::GetStartCityPlot, COMDAT
; _this$ = ecx

; 210  : 	CvPlot* rtnValue = NULL;
; 211  : 	rtnValue =  GC.getMap().plot(m_iStartCityX, m_iStartCityY);

	mov	eax, DWORD PTR [ecx+88]
	push	ebx
	mov	ebx, DWORD PTR [ecx+92]
	cmp	eax, -2147483647			; 80000001H
	je	$LN5@GetStartCi
	cmp	ebx, -2147483647			; 80000001H
	je	$LN5@GetStartCi
	push	ebp
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	push	esi
	je	SHORT $LN44@GetStartCi
	test	eax, eax
	jge	SHORT $LN17@GetStartCi
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN19@GetStartCi
$LN17@GetStartCi:
	cmp	eax, ecx
	jl	SHORT $LN44@GetStartCi
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN19@GetStartCi
$LN44@GetStartCi:
	mov	esi, eax
$LN19@GetStartCi:
	cmp	BYTE PTR [ebp+4057], 0
	push	edi
	mov	edi, DWORD PTR [ebp+4024]
	je	SHORT $LN45@GetStartCi
	test	ebx, ebx
	jge	SHORT $LN27@GetStartCi
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN29@GetStartCi
$LN27@GetStartCi:
	cmp	ebx, edi
	jl	SHORT $LN45@GetStartCi
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN29@GetStartCi
$LN45@GetStartCi:
	mov	edx, ebx
$LN29@GetStartCi:
	test	esi, esi
	jl	SHORT $LN9@GetStartCi
	cmp	esi, ecx
	jge	SHORT $LN9@GetStartCi
	test	edx, edx
	jl	SHORT $LN9@GetStartCi
	cmp	edx, edi
	jge	SHORT $LN9@GetStartCi
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ecx
	pop	ebx

; 212  : 	return rtnValue;
; 213  : }

	ret	0

; 210  : 	CvPlot* rtnValue = NULL;
; 211  : 	rtnValue =  GC.getMap().plot(m_iStartCityX, m_iStartCityY);

$LN9@GetStartCi:
	pop	edi
	pop	esi
	pop	ebp
	xor	eax, eax
	pop	ebx

; 212  : 	return rtnValue;
; 213  : }

	ret	0

; 210  : 	CvPlot* rtnValue = NULL;
; 211  : 	rtnValue =  GC.getMap().plot(m_iStartCityX, m_iStartCityY);

$LN5@GetStartCi:
	xor	eax, eax
	pop	ebx

; 212  : 	return rtnValue;
; 213  : }

	ret	0
?GetStartCityPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ENDP	; CvAIOperation::GetStartCityPlot
_TEXT	ENDS
PUBLIC	?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z ; CvAIOperation::GetGatherTolerance
EXTRN	?IsAllOceanGoing@CvArmyAI@@QAE_NXZ:PROC		; CvArmyAI::IsAllOceanGoing
EXTRN	?CanUseForOperationGatheringCheckWater@CvTacticalAnalysisCell@@QAE_N_N@Z:PROC ; CvTacticalAnalysisCell::CanUseForOperationGatheringCheckWater
EXTRN	?GetNumSlotsFilled@CvArmyAI@@QBEHXZ:PROC	; CvArmyAI::GetNumSlotsFilled
EXTRN	?GetTacticalAnalysisMap@CvGame@@QAEPAVCvTacticalAnalysisMap@@XZ:PROC ; CvGame::GetTacticalAnalysisMap
; Function compile flags: /Ogtpy
;	COMDAT ?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
_TEXT	SEGMENT
_iRange$234879 = -24					; size = 4
_iValidPlotsNearby$ = -20				; size = 4
tv139 = -16						; size = 4
_pMap$ = -12						; size = 4
_iNumUnits$ = -8					; size = 4
tv270 = -4						; size = 4
_pArmy$ = 8						; size = 4
_pPlot$ = 12						; size = 4
?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z PROC ; CvAIOperation::GetGatherTolerance, COMDAT
; _this$ = ecx

; 223  : {

	sub	esp, 24					; 00000018H
	push	edi
	mov	edi, ecx

; 224  : 	CvTacticalAnalysisCell* pCell;
; 225  : 	CvTacticalAnalysisMap* pMap = GC.getGame().GetTacticalAnalysisMap();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetTacticalAnalysisMap@CvGame@@QAEPAVCvTacticalAnalysisMap@@XZ ; CvGame::GetTacticalAnalysisMap

; 226  : 	int iRtnValue = 1;
; 227  : 	int iValidPlotsNearby = 0;
; 228  : 
; 229  : 	// Find out how many units are trying to gather
; 230  : 	int iNumUnits = pArmy->GetNumSlotsFilled();

	mov	ecx, DWORD PTR _pArmy$[esp+24]
	mov	DWORD PTR _pMap$[esp+28], eax
	mov	DWORD PTR _iValidPlotsNearby$[esp+28], 0
	call	?GetNumSlotsFilled@CvArmyAI@@QBEHXZ	; CvArmyAI::GetNumSlotsFilled

; 231  : 
; 232  : 	// If not more than 1, zero tolerance is fine (we should get the unit to the gather point)
; 233  : 	if(iNumUnits < 1)

	cmp	eax, 1
	mov	DWORD PTR _iNumUnits$[esp+28], eax
	jge	SHORT $LN14@GetGatherT

; 234  : 	{
; 235  : 		iRtnValue = 0;

	xor	eax, eax
	pop	edi

; 276  : }

	add	esp, 24					; 00000018H
	ret	8
$LN14@GetGatherT:

; 236  : 	}
; 237  : 	else
; 238  : 	{
; 239  : 		int iRange = OperationalAIHelpers::GetGatherRangeForXUnits(iNumUnits);

	cmp	eax, 2
	push	ebx
	jg	SHORT $LN24@GetGatherT
	mov	ebx, 1
	mov	DWORD PTR _iRange$234879[esp+32], ebx
	jmp	SHORT $LN20@GetGatherT
$LN24@GetGatherT:
	cmp	eax, 6
	jg	SHORT $LN22@GetGatherT
	mov	DWORD PTR _iRange$234879[esp+32], 2
	mov	ebx, DWORD PTR _iRange$234879[esp+32]
	jmp	SHORT $LN20@GetGatherT
$LN22@GetGatherT:
	xor	ecx, ecx
	cmp	eax, 10					; 0000000aH
	setg	cl
	add	ecx, 3
	mov	DWORD PTR _iRange$234879[esp+32], ecx
	mov	ebx, ecx
$LN20@GetGatherT:

; 240  : 		for(int iX = -iRange; iX <= iRange; iX++)

	mov	ecx, ebx
	neg	ecx
	cmp	ecx, ebx
	mov	DWORD PTR tv270[esp+32], ecx
	jg	$LN10@GetGatherT
	mov	edx, ebx
	sub	edx, ecx
	push	ebp
	mov	ebp, DWORD PTR _pPlot$[esp+32]
	inc	edx
	push	esi
	mov	DWORD PTR tv139[esp+40], edx
	npad	4
$LL12@GetGatherT:

; 241  : 		{
; 242  : 			for(int iY = -iRange; iY <= iRange; iY++)

	cmp	ecx, ebx
	jg	$LN11@GetGatherT
	sub	ebx, ecx
	inc	ebx
	npad	5
$LL9@GetGatherT:

; 243  : 			{
; 244  : 				int iPlotIndex = GC.getMap().plotNum(pPlot->getX(), pPlot->getY());
; 245  : 				pCell = pMap->GetCell(iPlotIndex);

	movsx	esi, WORD PTR [ebp+2]
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	imul	esi, DWORD PTR [edx+4020]
	movsx	eax, WORD PTR [ebp]
	mov	ecx, DWORD PTR _pMap$[esp+40]

; 246  : 
; 247  : 				if((IsMixedLandNavalOperation() || IsAllNavalOperation()) && !pCell->CanUseForOperationGatheringCheckWater(true))

	mov	edx, DWORD PTR [edi]
	add	esi, eax
	mov	eax, DWORD PTR [edx+44]
	imul	esi, 44					; 0000002cH
	add	esi, DWORD PTR [ecx+12]
	mov	ecx, edi
	call	eax
	test	al, al
	jne	SHORT $LN5@GetGatherT
	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, edi
	call	eax
	test	al, al
	je	SHORT $LN6@GetGatherT
$LN5@GetGatherT:
	push	1
	mov	ecx, esi
	call	?CanUseForOperationGatheringCheckWater@CvTacticalAnalysisCell@@QAE_N_N@Z ; CvTacticalAnalysisCell::CanUseForOperationGatheringCheckWater
	test	al, al
	je	SHORT $LN8@GetGatherT
$LN6@GetGatherT:

; 248  : 				{
; 249  : 					continue;
; 250  : 				}
; 251  : 
; 252  : 				if((IsMixedLandNavalOperation() || IsAllNavalOperation()) && !pArmy->IsAllOceanGoing() && pCell->IsOcean())

	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, edi
	call	eax
	test	al, al
	jne	SHORT $LN3@GetGatherT
	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, edi
	call	eax
	test	al, al
	je	SHORT $LN4@GetGatherT
$LN3@GetGatherT:
	mov	ecx, DWORD PTR _pArmy$[esp+36]
	call	?IsAllOceanGoing@CvArmyAI@@QAE_NXZ	; CvArmyAI::IsAllOceanGoing
	test	al, al
	jne	SHORT $LN4@GetGatherT
	mov	ecx, DWORD PTR [esi]
	shr	ecx, 12					; 0000000cH
	test	cl, 1
	jne	SHORT $LN8@GetGatherT
$LN4@GetGatherT:

; 253  : 				{
; 254  : 					continue;
; 255  : 				}
; 256  : 
; 257  : 				iValidPlotsNearby++;

	inc	DWORD PTR _iValidPlotsNearby$[esp+40]
$LN8@GetGatherT:

; 241  : 		{
; 242  : 			for(int iY = -iRange; iY <= iRange; iY++)

	sub	ebx, 1
	jne	$LL9@GetGatherT
	mov	edx, DWORD PTR tv139[esp+40]
	mov	eax, DWORD PTR _iNumUnits$[esp+40]
	mov	ebx, DWORD PTR _iRange$234879[esp+40]
	mov	ecx, DWORD PTR tv270[esp+40]
$LN11@GetGatherT:
	sub	edx, 1
	mov	DWORD PTR tv139[esp+40], edx
	jne	$LL12@GetGatherT
	pop	esi
	pop	ebp
$LN10@GetGatherT:

; 258  : 			}
; 259  : 		}
; 260  : 
; 261  : 		// Find more valid plots than units?
; 262  : 		if(iValidPlotsNearby > iNumUnits)

	cmp	DWORD PTR _iValidPlotsNearby$[esp+32], eax

; 272  : 		}
; 273  : 	}
; 274  : 
; 275  : 	return iRtnValue;

	mov	eax, ebx
	jg	SHORT $LN48@GetGatherT

; 263  : 		{
; 264  : 			// If so, just use normal range for this many units
; 265  : 			iRtnValue = iRange;
; 266  : 		}
; 267  : 
; 268  : 		// Something constrained here, give ourselves a lot of leeway
; 269  : 		else
; 270  : 		{
; 271  : 			iRtnValue = 3;

	mov	eax, 3
$LN48@GetGatherT:
	pop	ebx
	pop	edi

; 276  : }

	add	esp, 24					; 00000018H
	ret	8
?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z ENDP ; CvAIOperation::GetGatherTolerance
_TEXT	ENDS
PUBLIC	?CheckOnTarget@CvAIOperation@@UAE_NXZ		; CvAIOperation::CheckOnTarget
EXTRN	?GetFurthestUnitDistance@CvArmyAI@@QAEHPAVCvPlot@@@Z:PROC ; CvArmyAI::GetFurthestUnitDistance
EXTRN	?GetCenterOfMass@CvArmyAI@@QAEPAVCvPlot@@W4DomainTypes@@@Z:PROC ; CvArmyAI::GetCenterOfMass
EXTRN	?GetNextUnitID@CvArmyAI@@QAEHXZ:PROC		; CvArmyAI::GetNextUnitID
EXTRN	?plot@CvUnit@@QBEPAVCvPlot@@XZ:PROC		; CvUnit::plot
EXTRN	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z:PROC	; CvPlayer::getUnit
EXTRN	?GetFirstUnitID@CvArmyAI@@QAEHXZ:PROC		; CvArmyAI::GetFirstUnitID
; Function compile flags: /Ogtpy
;	COMDAT ?CheckOnTarget@CvAIOperation@@UAE_NXZ
_TEXT	SEGMENT
_uiI$224359 = -8					; size = 4
_uiI$224340 = -8					; size = 4
_uiI$224321 = -8					; size = 4
tv434 = -4						; size = 4
tv335 = -4						; size = 4
tv226 = -4						; size = 4
?CheckOnTarget@CvAIOperation@@UAE_NXZ PROC		; CvAIOperation::CheckOnTarget, COMDAT
; _this$ = ecx

; 511  : {

	sub	esp, 8
	push	ebp
	push	esi
	mov	esi, ecx

; 512  : 	int iUnitID;
; 513  : 	CvUnit* pCivilian;
; 514  : 	CvPlot* pCivilianPlot = NULL;
; 515  : 	CvPlot* pEscortPlot;
; 516  : 
; 517  : 	if(GetFirstArmyID() == -1)

	mov	eax, DWORD PTR [esi+12]
	sub	eax, DWORD PTR [esi+8]
	xor	ebp, ebp
	test	eax, -4					; fffffffcH
	je	SHORT $LN137@CheckOnTar
	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, -1
	jne	SHORT $LN47@CheckOnTar
$LN137@CheckOnTar:
	pop	esi

; 518  : 	{
; 519  : 		return false;

	xor	al, al
	pop	ebp

; 703  : }

	add	esp, 8
	ret	0
$LN47@CheckOnTar:

; 520  : 	}
; 521  : 
; 522  : 	switch(m_eMoveType)

	mov	ecx, DWORD PTR [esi+84]
	push	ebx
	push	edi
	cmp	ecx, 3
	ja	$LN7@CheckOnTar
	jmp	DWORD PTR $LN146@CheckOnTar[ecx*4]
$LN44@CheckOnTar:

; 523  : 	{
; 524  : 		{
; 525  : 		case AI_OPERATION_MOVETYPE_SINGLE_HEX:
; 526  : 			CvArmyAI* pThisArmy = GET_PLAYER(m_eOwner).getArmyAI(m_viArmyIDs[0]);

	mov	ecx, DWORD PTR [esi+72]
	mov	edx, DWORD PTR [eax]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI
	mov	ebx, eax

; 527  : 			if(pThisArmy->GetNumSlotsFilled() >= 1)

	mov	ecx, ebx
	call	?GetNumSlotsFilled@CvArmyAI@@QBEHXZ	; CvArmyAI::GetNumSlotsFilled
	cmp	eax, 1
	jl	$LN7@CheckOnTar

; 528  : 			{
; 529  : 				iUnitID = pThisArmy->GetFirstUnitID();

	mov	ecx, ebx
	call	?GetFirstUnitID@CvArmyAI@@QAEHXZ	; CvArmyAI::GetFirstUnitID

; 530  : 				if(iUnitID != -1)

	cmp	eax, -1
	je	SHORT $LN42@CheckOnTar

; 531  : 				{
; 532  : 					pCivilian = GET_PLAYER(m_eOwner).getUnit(iUnitID);

	mov	ecx, DWORD PTR [esi+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit

; 533  : 					pCivilianPlot = pCivilian->plot();

	mov	ecx, eax
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ebp, eax
$LN42@CheckOnTar:

; 534  : 				}
; 535  : 				if(m_eCurrentState == AI_OPERATION_STATE_MOVING_TO_TARGET && pCivilianPlot == GetTargetPlot())

	mov	edi, DWORD PTR [esi+56]
	cmp	edi, 3
	jne	SHORT $LN41@CheckOnTar
	mov	ecx, esi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	cmp	ebp, eax

; 536  : 				{
; 537  : 					ArmyInPosition(pThisArmy);
; 538  : 					return true;

	je	SHORT $LN145@CheckOnTar
$LN41@CheckOnTar:

; 539  : 				}
; 540  : 				else if(m_eCurrentState == AI_OPERATION_STATE_GATHERING_FORCES)

	cmp	edi, 2
	jne	$LN7@CheckOnTar

; 541  : 				{
; 542  : 					if(pThisArmy->GetNumSlotsFilled() == 1)

	mov	ecx, ebx
	call	?GetNumSlotsFilled@CvArmyAI@@QBEHXZ	; CvArmyAI::GetNumSlotsFilled
	cmp	eax, 1

; 543  : 					{
; 544  : 						ArmyInPosition(pThisArmy);
; 545  : 						return true;

	je	SHORT $LN145@CheckOnTar

; 546  : 					}
; 547  : 					else
; 548  : 					{
; 549  : 						pEscortPlot = GET_PLAYER(m_eOwner).getUnit(pThisArmy->GetNextUnitID())->plot();

	mov	edi, DWORD PTR [esi+72]
	imul	edi, 63236				; 0000f704H
	add	edi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, ebx
	call	?GetNextUnitID@CvArmyAI@@QAEHXZ		; CvArmyAI::GetNextUnitID
	push	eax
	mov	ecx, edi
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	ecx, eax
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot

; 550  : 						if(pCivilianPlot == pEscortPlot)

	cmp	ebp, eax
	jne	$LN7@CheckOnTar
$LN145@CheckOnTar:

; 551  : 						{
; 552  : 							ArmyInPosition(pThisArmy);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+60]
	push	ebx
	mov	ecx, esi
	call	edx
	pop	edi
	pop	ebx
	pop	esi

; 553  : 							return true;

	mov	al, 1
	pop	ebp

; 703  : }

	add	esp, 8
	ret	0
$LN34@CheckOnTar:

; 554  : 						}
; 555  : 					}
; 556  : 				}
; 557  : 			}
; 558  : 			else
; 559  : 			{
; 560  : 				CvAssertMsg(m_eCurrentState == AI_OPERATION_STATE_RECRUITING_UNITS || m_eCurrentState == AI_OPERATION_STATE_ABORTED || m_eCurrentState == AI_OPERATION_STATE_SUCCESSFUL_FINISH,
; 561  : 				            "Found an escort operation with no units in it.  Show Ed and send save.");
; 562  : 			}
; 563  : 			break;
; 564  : 		}
; 565  : 
; 566  : 	case AI_OPERATION_MOVETYPE_ENEMY_TERRITORY:
; 567  : 	{
; 568  : 		// Let each army perform its own check
; 569  : 		for(unsigned int uiI = 0; uiI < m_viArmyIDs.size(); uiI++)

	mov	eax, DWORD PTR [esi+12]
	sub	eax, DWORD PTR [esi+8]
	xor	ebp, ebp
	sar	eax, 2
	mov	DWORD PTR _uiI$224321[esp+24], ebp
	test	eax, eax
	jbe	$LN7@CheckOnTar
$LL33@CheckOnTar:
	mov	ecx, DWORD PTR [esi+8]

; 570  : 		{
; 571  : 			CvArmyAI* pThisArmy = GET_PLAYER(m_eOwner).getArmyAI(m_viArmyIDs[uiI]);

	mov	edx, DWORD PTR [ecx+ebp*4]
	lea	eax, DWORD PTR [ecx+ebp*4]
	mov	ecx, DWORD PTR [esi+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI
	mov	edi, eax

; 572  : 			CvPlot* pCenterOfMass;
; 573  : 
; 574  : 			if(pThisArmy->GetNumSlotsFilled() >= 1)

	mov	ecx, edi
	call	?GetNumSlotsFilled@CvArmyAI@@QBEHXZ	; CvArmyAI::GetNumSlotsFilled
	cmp	eax, 1
	jl	$LN32@CheckOnTar

; 575  : 			{
; 576  : 				switch(m_eCurrentState)

	mov	eax, DWORD PTR [esi+56]
	sub	eax, 2
	je	$LN27@CheckOnTar
	sub	eax, 1
	jne	$LN32@CheckOnTar

; 585  : 						{
; 586  : 							ArmyInPosition(pThisArmy);
; 587  : 							return true;
; 588  : 						}
; 589  : 					}
; 590  : 					break;
; 591  : 				case AI_OPERATION_STATE_MOVING_TO_TARGET:
; 592  : 					{
; 593  : 						int iTargetTolerance = GC.getAI_OPERATIONAL_CITY_ATTACK_DEPLOY_RANGE();
; 594  : 						pCenterOfMass = pThisArmy->GetCenterOfMass(IsAllNavalOperation() || IsMixedLandNavalOperation() ? DOMAIN_SEA : DOMAIN_LAND);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+40]
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2420
	mov	ecx, esi
	call	edx
	test	al, al
	jne	SHORT $LN52@CheckOnTar
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+44]
	mov	ecx, esi
	call	edx
	test	al, al
	jne	SHORT $LN52@CheckOnTar
	mov	eax, 2
	jmp	SHORT $LN53@CheckOnTar
$LN52@CheckOnTar:
	xor	eax, eax
$LN53@CheckOnTar:
	push	eax
	mov	ecx, edi
	call	?GetCenterOfMass@CvArmyAI@@QAEPAVCvPlot@@W4DomainTypes@@@Z ; CvArmyAI::GetCenterOfMass

; 595  : 						if(pCenterOfMass &&
; 596  : 							plotDistance(pCenterOfMass->getX(), pCenterOfMass->getY(), m_iTargetX, m_iTargetY) <= iTargetTolerance &&
; 597  : 							pThisArmy->GetFurthestUnitDistance(GetTargetPlot()) <= (iTargetTolerance * 3 / 2))

	test	eax, eax
	je	$LN32@CheckOnTar
	mov	ecx, DWORD PTR [esi+108]
	mov	edx, DWORD PTR [esi+104]
	push	ecx
	movsx	ecx, WORD PTR [eax+2]
	push	edx
	movsx	edx, WORD PTR [eax]
	push	ecx
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, ebx
	jg	$LN32@CheckOnTar
	mov	ecx, esi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	push	eax
	mov	ecx, edi
	call	?GetFurthestUnitDistance@CvArmyAI@@QAEHPAVCvPlot@@@Z ; CvArmyAI::GetFurthestUnitDistance
	mov	ecx, eax
	lea	eax, DWORD PTR [ebx+ebx*2]
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	ecx, eax
	jg	$LN32@CheckOnTar
$LN132@CheckOnTar:

; 634  : 						{
; 635  : 							ArmyInPosition(pThisArmy);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+60]
	push	edi
	mov	ecx, esi
	call	edx
$LN133@CheckOnTar:
	pop	edi
	pop	ebx
	pop	esi

; 636  : 							return true;

	mov	al, 1
	pop	ebp

; 703  : }

	add	esp, 8
	ret	0
$LN27@CheckOnTar:

; 577  : 				{
; 578  : 				case AI_OPERATION_STATE_GATHERING_FORCES:
; 579  : 					{
; 580  : 						int iGatherTolerance = GetGatherTolerance(pThisArmy, GetMusterPlot());

	mov	ebx, DWORD PTR [esi]
	mov	ecx, esi
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	edx, DWORD PTR [ebx+48]
	push	eax
	push	edi
	mov	ecx, esi
	call	edx
	mov	ebp, eax

; 581  : 						pCenterOfMass = pThisArmy->GetCenterOfMass(IsAllNavalOperation() || IsMixedLandNavalOperation() ? DOMAIN_SEA : DOMAIN_LAND);

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+40]
	mov	ecx, esi
	call	edx
	test	al, al
	jne	SHORT $LN50@CheckOnTar
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+44]
	mov	ecx, esi
	call	edx
	test	al, al
	jne	SHORT $LN50@CheckOnTar
	mov	eax, 2
	jmp	SHORT $LN51@CheckOnTar
$LN50@CheckOnTar:
	xor	eax, eax
$LN51@CheckOnTar:
	push	eax
	mov	ecx, edi
	call	?GetCenterOfMass@CvArmyAI@@QAEPAVCvPlot@@W4DomainTypes@@@Z ; CvArmyAI::GetCenterOfMass
	mov	ebx, eax

; 582  : 						if(pCenterOfMass &&
; 583  : 							plotDistance(pCenterOfMass->getX(), pCenterOfMass->getY(), GetMusterPlot()->getX(), GetMusterPlot()->getY()) <= iGatherTolerance &&
; 584  : 							pThisArmy->GetFurthestUnitDistance(GetMusterPlot()) <= (iGatherTolerance * 3 / 2))

	test	ebx, ebx
	je	SHORT $LN139@CheckOnTar
	mov	ecx, esi
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	ecx, esi
	mov	DWORD PTR tv226[esp+24], eax
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	movsx	eax, WORD PTR [eax+2]
	mov	ecx, DWORD PTR tv226[esp+24]
	movsx	edx, WORD PTR [ecx]
	movsx	ecx, WORD PTR [ebx]
	push	eax
	movsx	eax, WORD PTR [ebx+2]
	push	edx
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, ebp
	jg	SHORT $LN139@CheckOnTar
	mov	ecx, esi
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	push	eax
	mov	ecx, edi
	call	?GetFurthestUnitDistance@CvArmyAI@@QAEHPAVCvPlot@@@Z ; CvArmyAI::GetFurthestUnitDistance
	mov	ecx, eax
	lea	eax, DWORD PTR [ebp+ebp*2]
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	ecx, eax
	jle	$LN132@CheckOnTar
$LN139@CheckOnTar:
	mov	ebp, DWORD PTR _uiI$224321[esp+24]
$LN32@CheckOnTar:

; 554  : 						}
; 555  : 					}
; 556  : 				}
; 557  : 			}
; 558  : 			else
; 559  : 			{
; 560  : 				CvAssertMsg(m_eCurrentState == AI_OPERATION_STATE_RECRUITING_UNITS || m_eCurrentState == AI_OPERATION_STATE_ABORTED || m_eCurrentState == AI_OPERATION_STATE_SUCCESSFUL_FINISH,
; 561  : 				            "Found an escort operation with no units in it.  Show Ed and send save.");
; 562  : 			}
; 563  : 			break;
; 564  : 		}
; 565  : 
; 566  : 	case AI_OPERATION_MOVETYPE_ENEMY_TERRITORY:
; 567  : 	{
; 568  : 		// Let each army perform its own check
; 569  : 		for(unsigned int uiI = 0; uiI < m_viArmyIDs.size(); uiI++)

	mov	edx, DWORD PTR [esi+12]
	sub	edx, DWORD PTR [esi+8]
	inc	ebp
	sar	edx, 2
	mov	DWORD PTR _uiI$224321[esp+24], ebp
	cmp	ebp, edx
	jb	$LL33@CheckOnTar
	pop	edi
	pop	ebx
	pop	esi

; 687  : 					{
; 688  : 						return true;
; 689  : 					}
; 690  : 					break;
; 691  : 				}
; 692  : 			}
; 693  : 			else
; 694  : 			{
; 695  : 				CvAssertMsg(m_eCurrentState == AI_OPERATION_STATE_RECRUITING_UNITS || m_eCurrentState == AI_OPERATION_STATE_ABORTED || m_eCurrentState == AI_OPERATION_STATE_SUCCESSFUL_FINISH,
; 696  : 				            "Found an army operation with no units in it.  Show Ed and send save.");
; 697  : 			}
; 698  : 		}
; 699  : 		break;
; 700  : 	}
; 701  : 	}
; 702  : 	return false;

	xor	al, al
	pop	ebp

; 703  : }

	add	esp, 8
	ret	0
$LN22@CheckOnTar:

; 598  : 						{
; 599  : 							ArmyInPosition(pThisArmy);
; 600  : 							return true;
; 601  : 						}
; 602  : 					}
; 603  : 					break;
; 604  : 				}
; 605  : 			}
; 606  : 			else
; 607  : 			{
; 608  : 				CvAssertMsg(m_eCurrentState == AI_OPERATION_STATE_RECRUITING_UNITS || m_eCurrentState == AI_OPERATION_STATE_ABORTED || m_eCurrentState == AI_OPERATION_STATE_SUCCESSFUL_FINISH,
; 609  : 				            "Found an army operation with no units in it.  Show Ed and send save.");
; 610  : 			}
; 611  : 		}
; 612  : 		break;
; 613  : 	}
; 614  : 
; 615  : 	case AI_OPERATION_MOVETYPE_NAVAL_ESCORT:
; 616  : 	{
; 617  : 		// Let each army perform its own check
; 618  : 		for(unsigned int uiI = 0; uiI < m_viArmyIDs.size(); uiI++)

	mov	eax, DWORD PTR [esi+12]
	sub	eax, DWORD PTR [esi+8]
	xor	ebp, ebp
	sar	eax, 2
	mov	DWORD PTR _uiI$224340[esp+24], ebp
	test	eax, eax
	jbe	$LN7@CheckOnTar
	npad	6
$LL21@CheckOnTar:
	mov	ecx, DWORD PTR [esi+8]

; 619  : 		{
; 620  : 			CvArmyAI* pThisArmy = GET_PLAYER(m_eOwner).getArmyAI(m_viArmyIDs[uiI]);

	mov	edx, DWORD PTR [ecx+ebp*4]
	lea	eax, DWORD PTR [ecx+ebp*4]
	mov	ecx, DWORD PTR [esi+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI
	mov	edi, eax

; 621  : 			CvPlot* pCenterOfMass;
; 622  : 
; 623  : 			if(pThisArmy->GetNumSlotsFilled() >= 1)

	mov	ecx, edi
	call	?GetNumSlotsFilled@CvArmyAI@@QBEHXZ	; CvArmyAI::GetNumSlotsFilled
	cmp	eax, 1
	jl	$LN20@CheckOnTar

; 624  : 			{
; 625  : 				switch(m_eCurrentState)

	mov	eax, DWORD PTR [esi+56]
	sub	eax, 2
	je	SHORT $LN15@CheckOnTar
	sub	eax, 1
	jne	$LN20@CheckOnTar

; 637  : 						}
; 638  : 					}
; 639  : 					break;
; 640  : 				case AI_OPERATION_STATE_MOVING_TO_TARGET:
; 641  : 					{
; 642  : 						int iTargetTolerance = GC.getAI_OPERATIONAL_CITY_ATTACK_DEPLOY_RANGE();

	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2420

; 643  : 						pCenterOfMass = pThisArmy->GetCenterOfMass(DOMAIN_SEA);

	push	eax
	mov	ecx, edi
	call	?GetCenterOfMass@CvArmyAI@@QAEPAVCvPlot@@W4DomainTypes@@@Z ; CvArmyAI::GetCenterOfMass

; 644  : 						if(pCenterOfMass &&
; 645  : 							plotDistance(pCenterOfMass->getX(), pCenterOfMass->getY(), m_iTargetX, m_iTargetY) <= (iTargetTolerance  * 2) &&
; 646  : 							pThisArmy->GetFurthestUnitDistance(GetTargetPlot()) <= (iTargetTolerance * 3))

	test	eax, eax
	je	$LN20@CheckOnTar
	mov	ecx, DWORD PTR [esi+108]
	mov	edx, DWORD PTR [esi+104]
	push	ecx
	movsx	ecx, WORD PTR [eax+2]
	push	edx
	movsx	edx, WORD PTR [eax]
	push	ecx
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	lea	ecx, DWORD PTR [ebx+ebx]
	add	esp, 16					; 00000010H
	cmp	eax, ecx
	jg	$LN20@CheckOnTar
	mov	ecx, esi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	push	eax
	mov	ecx, edi
	call	?GetFurthestUnitDistance@CvArmyAI@@QAEHPAVCvPlot@@@Z ; CvArmyAI::GetFurthestUnitDistance
	lea	edx, DWORD PTR [ebx+ebx*2]
	cmp	eax, edx
	jle	$LN132@CheckOnTar

; 647  : 						{
; 648  : 							ArmyInPosition(pThisArmy);
; 649  : 							return true;
; 650  : 						}
; 651  : 					}
; 652  : 					break;

	jmp	SHORT $LN20@CheckOnTar
$LN15@CheckOnTar:

; 626  : 				{
; 627  : 				case AI_OPERATION_STATE_GATHERING_FORCES:
; 628  : 					{
; 629  : 						int iGatherTolerance = GetGatherTolerance(pThisArmy, GetMusterPlot());

	mov	ebx, DWORD PTR [esi]
	mov	ecx, esi
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	push	eax
	mov	eax, DWORD PTR [ebx+48]
	push	edi
	mov	ecx, esi
	call	eax

; 630  : 						pCenterOfMass = pThisArmy->GetCenterOfMass(DOMAIN_SEA);

	push	0
	mov	ecx, edi
	mov	ebp, eax
	call	?GetCenterOfMass@CvArmyAI@@QAEPAVCvPlot@@W4DomainTypes@@@Z ; CvArmyAI::GetCenterOfMass
	mov	ebx, eax

; 631  : 						if(pCenterOfMass &&
; 632  : 							plotDistance(pCenterOfMass->getX(), pCenterOfMass->getY(), GetMusterPlot()->getX(), GetMusterPlot()->getY()) <= iGatherTolerance &&
; 633  : 							pThisArmy->GetFurthestUnitDistance(GetMusterPlot()) <= (iGatherTolerance * 3))

	test	ebx, ebx
	je	SHORT $LN138@CheckOnTar
	mov	ecx, esi
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	ecx, esi
	mov	DWORD PTR tv335[esp+24], eax
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	movsx	ecx, WORD PTR [eax+2]
	mov	edx, DWORD PTR tv335[esp+24]
	movsx	eax, WORD PTR [edx]
	movsx	edx, WORD PTR [ebx]
	push	ecx
	movsx	ecx, WORD PTR [ebx+2]
	push	eax
	push	ecx
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, ebp
	jg	SHORT $LN138@CheckOnTar
	mov	ecx, esi
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	push	eax
	mov	ecx, edi
	call	?GetFurthestUnitDistance@CvArmyAI@@QAEHPAVCvPlot@@@Z ; CvArmyAI::GetFurthestUnitDistance
	lea	ecx, DWORD PTR [ebp+ebp*2]
	cmp	eax, ecx
	jle	$LN132@CheckOnTar
$LN138@CheckOnTar:
	mov	ebp, DWORD PTR _uiI$224340[esp+24]
$LN20@CheckOnTar:

; 598  : 						{
; 599  : 							ArmyInPosition(pThisArmy);
; 600  : 							return true;
; 601  : 						}
; 602  : 					}
; 603  : 					break;
; 604  : 				}
; 605  : 			}
; 606  : 			else
; 607  : 			{
; 608  : 				CvAssertMsg(m_eCurrentState == AI_OPERATION_STATE_RECRUITING_UNITS || m_eCurrentState == AI_OPERATION_STATE_ABORTED || m_eCurrentState == AI_OPERATION_STATE_SUCCESSFUL_FINISH,
; 609  : 				            "Found an army operation with no units in it.  Show Ed and send save.");
; 610  : 			}
; 611  : 		}
; 612  : 		break;
; 613  : 	}
; 614  : 
; 615  : 	case AI_OPERATION_MOVETYPE_NAVAL_ESCORT:
; 616  : 	{
; 617  : 		// Let each army perform its own check
; 618  : 		for(unsigned int uiI = 0; uiI < m_viArmyIDs.size(); uiI++)

	mov	edx, DWORD PTR [esi+12]
	sub	edx, DWORD PTR [esi+8]
	inc	ebp
	sar	edx, 2
	mov	DWORD PTR _uiI$224340[esp+24], ebp
	cmp	ebp, edx
	jb	$LL21@CheckOnTar
	pop	edi
	pop	ebx
	pop	esi

; 687  : 					{
; 688  : 						return true;
; 689  : 					}
; 690  : 					break;
; 691  : 				}
; 692  : 			}
; 693  : 			else
; 694  : 			{
; 695  : 				CvAssertMsg(m_eCurrentState == AI_OPERATION_STATE_RECRUITING_UNITS || m_eCurrentState == AI_OPERATION_STATE_ABORTED || m_eCurrentState == AI_OPERATION_STATE_SUCCESSFUL_FINISH,
; 696  : 				            "Found an army operation with no units in it.  Show Ed and send save.");
; 697  : 			}
; 698  : 		}
; 699  : 		break;
; 700  : 	}
; 701  : 	}
; 702  : 	return false;

	xor	al, al
	pop	ebp

; 703  : }

	add	esp, 8
	ret	0
$LN10@CheckOnTar:

; 653  : 				}
; 654  : 			}
; 655  : 			else
; 656  : 			{
; 657  : 				CvAssertMsg(m_eCurrentState == AI_OPERATION_STATE_RECRUITING_UNITS || m_eCurrentState == AI_OPERATION_STATE_ABORTED || m_eCurrentState == AI_OPERATION_STATE_SUCCESSFUL_FINISH,
; 658  : 				            "Found an army operation with no units in it.  Show Ed and send save.");
; 659  : 			}
; 660  : 		}
; 661  : 		break;
; 662  : 	}
; 663  : 
; 664  : 	case AI_OPERATION_MOVETYPE_FREEFORM_NAVAL:
; 665  : 	{
; 666  : 		// Let each army perform its own check
; 667  : 		for(unsigned int uiI = 0; uiI < m_viArmyIDs.size(); uiI++)

	mov	eax, DWORD PTR [esi+12]
	sub	eax, DWORD PTR [esi+8]
	xor	ebx, ebx
	sar	eax, 2
	mov	DWORD PTR _uiI$224359[esp+24], ebx
	test	eax, eax
	jbe	$LN7@CheckOnTar
$LL9@CheckOnTar:
	mov	ecx, DWORD PTR [esi+8]

; 668  : 		{
; 669  : 			CvArmyAI* pThisArmy = GET_PLAYER(m_eOwner).getArmyAI(m_viArmyIDs[uiI]);

	mov	edx, DWORD PTR [ecx+ebx*4]
	lea	eax, DWORD PTR [ecx+ebx*4]
	mov	ecx, DWORD PTR [esi+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI

; 670  : 			CvPlot* pCenterOfMass;
; 671  : 			int iGatherTolerance = GetGatherTolerance(pThisArmy, GetMusterPlot());

	mov	ebp, DWORD PTR [esi]
	mov	ecx, esi
	mov	edi, eax
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	push	eax
	mov	eax, DWORD PTR [ebp+48]
	push	edi
	mov	ecx, esi
	call	eax

; 672  : 
; 673  : 			if(pThisArmy->GetNumSlotsFilled() >= 1)

	mov	ecx, edi
	mov	ebp, eax
	call	?GetNumSlotsFilled@CvArmyAI@@QBEHXZ	; CvArmyAI::GetNumSlotsFilled
	cmp	eax, 1
	jl	SHORT $LN8@CheckOnTar

; 674  : 			{
; 675  : 				switch(m_eCurrentState)

	mov	eax, DWORD PTR [esi+56]
	add	eax, -2					; fffffffeH
	cmp	eax, 1
	ja	SHORT $LN8@CheckOnTar

; 676  : 				{
; 677  : 				case AI_OPERATION_STATE_GATHERING_FORCES:
; 678  : 				case AI_OPERATION_STATE_MOVING_TO_TARGET:
; 679  : 
; 680  : 					// We want to recompute a new target each turn.  So call ArmyInPosition() regardless of return status
; 681  : 					ArmyInPosition(pThisArmy);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+60]
	push	edi
	mov	ecx, esi
	call	eax

; 682  : 
; 683  : 					pCenterOfMass = pThisArmy->GetCenterOfMass(DOMAIN_SEA);

	push	0
	mov	ecx, edi
	call	?GetCenterOfMass@CvArmyAI@@QAEPAVCvPlot@@W4DomainTypes@@@Z ; CvArmyAI::GetCenterOfMass
	mov	ebx, eax

; 684  : 					if(pCenterOfMass &&
; 685  : 					        plotDistance(pCenterOfMass->getX(), pCenterOfMass->getY(), GetTargetPlot()->getX(), GetTargetPlot()->getY()) <= iGatherTolerance &&
; 686  : 					        pThisArmy->GetFurthestUnitDistance(GetMusterPlot()) <= (iGatherTolerance * 3 / 2))

	test	ebx, ebx
	je	SHORT $LN140@CheckOnTar
	mov	ecx, esi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	mov	ecx, esi
	mov	DWORD PTR tv434[esp+24], eax
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	movsx	ecx, WORD PTR [eax+2]
	mov	edx, DWORD PTR tv434[esp+24]
	movsx	eax, WORD PTR [edx]
	movsx	edx, WORD PTR [ebx]
	push	ecx
	movsx	ecx, WORD PTR [ebx+2]
	push	eax
	push	ecx
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, ebp
	jg	SHORT $LN140@CheckOnTar
	mov	ecx, esi
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	push	eax
	mov	ecx, edi
	call	?GetFurthestUnitDistance@CvArmyAI@@QAEHPAVCvPlot@@@Z ; CvArmyAI::GetFurthestUnitDistance
	mov	ecx, eax
	lea	eax, DWORD PTR [ebp+ebp*2]
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	ecx, eax
	jle	$LN133@CheckOnTar
$LN140@CheckOnTar:
	mov	ebx, DWORD PTR _uiI$224359[esp+24]
$LN8@CheckOnTar:

; 653  : 				}
; 654  : 			}
; 655  : 			else
; 656  : 			{
; 657  : 				CvAssertMsg(m_eCurrentState == AI_OPERATION_STATE_RECRUITING_UNITS || m_eCurrentState == AI_OPERATION_STATE_ABORTED || m_eCurrentState == AI_OPERATION_STATE_SUCCESSFUL_FINISH,
; 658  : 				            "Found an army operation with no units in it.  Show Ed and send save.");
; 659  : 			}
; 660  : 		}
; 661  : 		break;
; 662  : 	}
; 663  : 
; 664  : 	case AI_OPERATION_MOVETYPE_FREEFORM_NAVAL:
; 665  : 	{
; 666  : 		// Let each army perform its own check
; 667  : 		for(unsigned int uiI = 0; uiI < m_viArmyIDs.size(); uiI++)

	mov	edx, DWORD PTR [esi+12]
	sub	edx, DWORD PTR [esi+8]
	inc	ebx
	sar	edx, 2
	mov	DWORD PTR _uiI$224359[esp+24], ebx
	cmp	ebx, edx
	jb	$LL9@CheckOnTar
$LN7@CheckOnTar:
	pop	edi
	pop	ebx
	pop	esi

; 687  : 					{
; 688  : 						return true;
; 689  : 					}
; 690  : 					break;
; 691  : 				}
; 692  : 			}
; 693  : 			else
; 694  : 			{
; 695  : 				CvAssertMsg(m_eCurrentState == AI_OPERATION_STATE_RECRUITING_UNITS || m_eCurrentState == AI_OPERATION_STATE_ABORTED || m_eCurrentState == AI_OPERATION_STATE_SUCCESSFUL_FINISH,
; 696  : 				            "Found an army operation with no units in it.  Show Ed and send save.");
; 697  : 			}
; 698  : 		}
; 699  : 		break;
; 700  : 	}
; 701  : 	}
; 702  : 	return false;

	xor	al, al
	pop	ebp

; 703  : }

	add	esp, 8
	ret	0
	npad	2
$LN146@CheckOnTar:
	DD	$LN44@CheckOnTar
	DD	$LN34@CheckOnTar
	DD	$LN22@CheckOnTar
	DD	$LN10@CheckOnTar
?CheckOnTarget@CvAIOperation@@UAE_NXZ ENDP		; CvAIOperation::CheckOnTarget
_TEXT	ENDS
PUBLIC	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition
EXTRN	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z:PROC ; CvArmyAI::SetArmyAIState
EXTRN	?Plot@CvArmyAI@@QBEPAVCvPlot@@XZ:PROC		; CvArmyAI::Plot
; Function compile flags: /Ogtpy
;	COMDAT ?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
_TEXT	SEGMENT
_pArmy$ = 8						; size = 4
?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z PROC ; CvAIOperation::ArmyInPosition, COMDAT
; _this$ = ecx

; 707  : {

	push	ebx
	push	esi
	mov	esi, ecx

; 708  : 	bool bStateChanged = false;
; 709  : 
; 710  : 	switch(m_eCurrentState)

	mov	eax, DWORD PTR [esi+56]
	xor	bl, bl
	sub	eax, 2
	je	SHORT $LN4@ArmyInPosi
	sub	eax, 1
	jne	SHORT $LN10@ArmyInPosi

; 718  : 	}
; 719  : 	break;
; 720  : 
; 721  : 	// If we are moving to our target, check and see if we are there
; 722  : 	case AI_OPERATION_STATE_MOVING_TO_TARGET:
; 723  : 	{
; 724  : 		if(pArmy->Plot() == GetTargetPlot())

	mov	ecx, DWORD PTR _pArmy$[esp+4]
	push	edi
	call	?Plot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::Plot
	mov	ecx, esi
	mov	edi, eax
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	cmp	edi, eax
	pop	edi
	jne	SHORT $LN10@ArmyInPosi

; 725  : 		{
; 726  : 			m_eCurrentState = AI_OPERATION_STATE_AT_TARGET;

	mov	DWORD PTR [esi+56], 4
	pop	esi

; 727  : 			bStateChanged = true;

	mov	al, 1
	pop	ebx

; 740  : }

	ret	4
$LN4@ArmyInPosi:

; 711  : 	{
; 712  : 		// If we were gathering forces, we're all set to move out
; 713  : 	case AI_OPERATION_STATE_GATHERING_FORCES:
; 714  : 	{
; 715  : 		m_eCurrentState = AI_OPERATION_STATE_MOVING_TO_TARGET;
; 716  : 		bStateChanged = true;
; 717  : 		pArmy->SetArmyAIState(ARMYAISTATE_MOVING_TO_DESTINATION);

	mov	ecx, DWORD PTR _pArmy$[esp+4]
	push	2
	mov	DWORD PTR [esi+56], 3
	mov	bl, 1
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState
$LN10@ArmyInPosi:
	pop	esi

; 728  : 		}
; 729  : 	}
; 730  : 	break;
; 731  : 
; 732  : 	case AI_OPERATION_STATE_ABORTED:
; 733  : 	case AI_OPERATION_STATE_RECRUITING_UNITS:
; 734  : 	case AI_OPERATION_STATE_AT_TARGET:
; 735  : 	case AI_OPERATION_STATE_SUCCESSFUL_FINISH:
; 736  : 		break;
; 737  : 	};
; 738  : 
; 739  : 	return bStateChanged;

	mov	al, bl
	pop	ebx

; 740  : }

	ret	4
?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ENDP ; CvAIOperation::ArmyInPosition
_TEXT	ENDS
PUBLIC	?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ ; CvAIOperation::PercentFromMusterPointToTarget
EXTRN	?GetStepDistanceBetweenPoints@CvStepPathFinder@@QAEHW4PlayerTypes@@0PAVCvPlot@@1@Z:PROC ; CvStepPathFinder::GetStepDistanceBetweenPoints
; Function compile flags: /Ogtpy
;	COMDAT ?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
_TEXT	SEGMENT
_iRtnValue$ = -8					; size = 4
_uiI$224398 = -4					; size = 4
?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ PROC ; CvAIOperation::PercentFromMusterPointToTarget, COMDAT
; _this$ = ecx

; 744  : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 745  : 	int iRtnValue = 0;
; 746  : 
; 747  : 	switch(m_eCurrentState)

	mov	eax, DWORD PTR [esi+56]
	push	edi
	mov	DWORD PTR _iRtnValue$[esp+24], 0
	cmp	eax, 5
	ja	$LN8@PercentFro
	jmp	DWORD PTR $LN32@PercentFro[eax*4]
$LN13@PercentFro:
	pop	edi
	pop	esi
	pop	ebp

; 748  : 	{
; 749  : 	case AI_OPERATION_STATE_GATHERING_FORCES:
; 750  : 	case AI_OPERATION_STATE_ABORTED:
; 751  : 	case AI_OPERATION_STATE_RECRUITING_UNITS:
; 752  : 		return 0;

	xor	eax, eax
	pop	ebx

; 806  : }

	add	esp, 8
	ret	0
$LN12@PercentFro:
	pop	edi
	pop	esi
	pop	ebp

; 753  : 
; 754  : 	case AI_OPERATION_STATE_AT_TARGET:
; 755  : 	case AI_OPERATION_STATE_SUCCESSFUL_FINISH:
; 756  : 		return 100;

	mov	eax, 100				; 00000064H
	pop	ebx

; 806  : }

	add	esp, 8
	ret	0
$LN11@PercentFro:

; 757  : 
; 758  : 	case AI_OPERATION_STATE_MOVING_TO_TARGET:
; 759  : 	{
; 760  : 		// Let each army perform its own update
; 761  : 		for(unsigned int uiI = 0; uiI < m_viArmyIDs.size(); uiI++)

	mov	ecx, DWORD PTR [esi+12]
	sub	ecx, DWORD PTR [esi+8]
	xor	eax, eax
	sar	ecx, 2
	mov	DWORD PTR _uiI$224398[esp+24], eax
	test	ecx, ecx
	jbe	$LN8@PercentFro
$LL31@PercentFro:

; 762  : 		{
; 763  : 			CvArmyAI* pArmy = GET_PLAYER(m_eOwner).getArmyAI(m_viArmyIDs[uiI]);

	mov	ecx, DWORD PTR [esi+72]
	mov	edx, DWORD PTR [esi+8]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI
	mov	edi, eax

; 764  : 
; 765  : 			if (pArmy->GetGoalPlot())

	mov	ecx, edi
	call	?GetGoalPlot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::GetGoalPlot
	test	eax, eax
	je	$LN9@PercentFro

; 766  : 			{
; 767  : 				int iDistanceMusterToTarget;
; 768  : 				int iDistanceCurrentToTarget;
; 769  : 
; 770  : 				CvPlot *pCenterOfMass = pArmy->GetCenterOfMass(IsAllNavalOperation() || IsMixedLandNavalOperation() ? DOMAIN_SEA : DOMAIN_LAND);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, esi
	call	eax
	test	al, al
	jne	SHORT $LN18@PercentFro
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, esi
	call	eax
	test	al, al
	jne	SHORT $LN18@PercentFro
	mov	eax, 2
	jmp	SHORT $LN19@PercentFro
$LN18@PercentFro:
	xor	eax, eax
$LN19@PercentFro:
	push	eax
	mov	ecx, edi
	call	?GetCenterOfMass@CvArmyAI@@QAEPAVCvPlot@@W4DomainTypes@@@Z ; CvArmyAI::GetCenterOfMass

; 771  : 
; 772  : 				// Use the step path finder to compute distance
; 773  : 				iDistanceMusterToTarget = GC.getStepFinder().GetStepDistanceBetweenPoints(m_eOwner, m_eEnemy, GetMusterPlot(), pArmy->GetGoalPlot());

	mov	ecx, edi
	mov	ebp, eax
	call	?GetGoalPlot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::GetGoalPlot
	push	eax
	mov	ecx, esi
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	ecx, DWORD PTR [esi+76]
	mov	edx, DWORD PTR [esi+72]
	push	eax
	push	ecx
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, eax
	call	?GetStepDistanceBetweenPoints@CvStepPathFinder@@QAEHW4PlayerTypes@@0PAVCvPlot@@1@Z ; CvStepPathFinder::GetStepDistanceBetweenPoints

; 774  : 				iDistanceCurrentToTarget = GC.getStepFinder().GetStepDistanceBetweenPoints(m_eOwner, m_eEnemy, pCenterOfMass, pArmy->GetGoalPlot());

	mov	ecx, edi
	mov	ebx, eax
	call	?GetGoalPlot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::GetGoalPlot
	mov	ecx, DWORD PTR [esi+72]
	push	eax
	mov	eax, DWORD PTR [esi+76]
	push	ebp
	push	eax
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, eax
	call	?GetStepDistanceBetweenPoints@CvStepPathFinder@@QAEHW4PlayerTypes@@0PAVCvPlot@@1@Z ; CvStepPathFinder::GetStepDistanceBetweenPoints

; 775  : 
; 776  : 				if(iDistanceMusterToTarget <= 0)

	test	ebx, ebx
	jle	$LN13@PercentFro

; 777  : 				{
; 778  : 					return 0;
; 779  : 				}
; 780  : 	
; 781  : 				// If within 2 of the final goal, consider ourselves there
; 782  : 				else if (iDistanceCurrentToTarget <= 2)

	cmp	eax, 2
	jle	$LN12@PercentFro

; 783  : 				{
; 784  : 					return 100;
; 785  : 				}
; 786  : 
; 787  : 				else
; 788  : 				{
; 789  : 					int iTempValue = 100 - (100 * iDistanceCurrentToTarget / iDistanceMusterToTarget);

	imul	eax, 100				; 00000064H
	cdq
	idiv	ebx
	mov	ecx, 100				; 00000064H
	sub	ecx, eax

; 790  : 					if(iTempValue > iRtnValue)

	cmp	ecx, DWORD PTR _iRtnValue$[esp+24]
	jle	SHORT $LN9@PercentFro

; 791  : 					{
; 792  : 						iRtnValue = iTempValue;

	mov	DWORD PTR _iRtnValue$[esp+24], ecx
$LN9@PercentFro:

; 757  : 
; 758  : 	case AI_OPERATION_STATE_MOVING_TO_TARGET:
; 759  : 	{
; 760  : 		// Let each army perform its own update
; 761  : 		for(unsigned int uiI = 0; uiI < m_viArmyIDs.size(); uiI++)

	mov	edx, DWORD PTR [esi+12]
	sub	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR _uiI$224398[esp+24]
	inc	eax
	sar	edx, 2
	mov	DWORD PTR _uiI$224398[esp+24], eax
	cmp	eax, edx
	jb	$LL31@PercentFro
$LN8@PercentFro:

; 793  : 					}
; 794  : 				}
; 795  : 			}
; 796  : 			else 
; 797  : 			{
; 798  : 				CvAssertMsg (false, "Operational AI army without a goal plot!  Send save to Ed");
; 799  : 			}
; 800  : 		}
; 801  : 	}
; 802  : 	break;
; 803  : 	}
; 804  : 
; 805  : 	return iRtnValue;

	mov	eax, DWORD PTR _iRtnValue$[esp+24]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 806  : }

	add	esp, 8
	ret	0
$LN32@PercentFro:
	DD	$LN13@PercentFro
	DD	$LN13@PercentFro
	DD	$LN13@PercentFro
	DD	$LN11@PercentFro
	DD	$LN12@PercentFro
	DD	$LN12@PercentFro
?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ ENDP ; CvAIOperation::PercentFromMusterPointToTarget
_TEXT	ENDS
PUBLIC	?GetOperationStartCity@CvAIOperation@@UBEPAVCvCity@@XZ ; CvAIOperation::GetOperationStartCity
EXTRN	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::nextCity
EXTRN	?getPopulation@CvCity@@QBEHXZ:PROC		; CvCity::getPopulation
EXTRN	?getArea@CvCity@@QBEHXZ:PROC			; CvCity::getArea
EXTRN	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::firstCity
EXTRN	?nextArea@CvMap@@QAEPAVCvArea@@PAH_N@Z:PROC	; CvMap::nextArea
EXTRN	?getCitiesPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z:PROC ; CvArea::getCitiesPerPlayer
EXTRN	?isWater@CvArea@@QBE_NXZ:PROC			; CvArea::isWater
EXTRN	?firstArea@CvMap@@QAEPAVCvArea@@PAH_N@Z:PROC	; CvMap::firstArea
EXTRN	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ:PROC	; CvPlayer::getCapitalCity
; Function compile flags: /Ogtpy
;	COMDAT ?GetOperationStartCity@CvAIOperation@@UBEPAVCvCity@@XZ
_TEXT	SEGMENT
_pBestArea$ = -16					; size = 4
_iLoop$ = -12						; size = 4
_iBestTotal$ = -8					; size = 4
_pBestCity$ = -4					; size = 4
?GetOperationStartCity@CvAIOperation@@UBEPAVCvCity@@XZ PROC ; CvAIOperation::GetOperationStartCity, COMDAT
; _this$ = ecx

; 883  : {

	sub	esp, 16					; 00000010H
	push	ebp
	mov	ebp, ecx

; 884  : 	if(GetStartCityPlot())

	call	?GetStartCityPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetStartCityPlot
	test	eax, eax
	je	SHORT $LN18@GetOperati

; 885  : 	{
; 886  : 		return GetStartCityPlot()->getPlotCity();

	mov	ecx, ebp
	call	?GetStartCityPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetStartCityPlot
	mov	ecx, DWORD PTR [eax+104]
	test	ecx, ecx
	jl	SHORT $LN21@GetOperati
	cmp	ecx, 64					; 00000040H
	jge	SHORT $LN21@GetOperati
	mov	eax, DWORD PTR [eax+108]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	pop	ebp

; 961  : 	}
; 962  : }

	add	esp, 16					; 00000010H
	ret	0

; 885  : 	{
; 886  : 		return GetStartCityPlot()->getPlotCity();

$LN21@GetOperati:
	xor	eax, eax
	pop	ebp

; 961  : 	}
; 962  : }

	add	esp, 16					; 00000010H
	ret	0
$LN18@GetOperati:
	push	ebx

; 887  : 	}
; 888  : 
; 889  : 	CvCity* pCapitalCity;
; 890  : 	CvArea* pLoopArea;
; 891  : 	int iLoop;
; 892  : 	int iMyCities;
; 893  : 	int iEnemyCities;
; 894  : 	int iBestTotal = 0;
; 895  : 	CvArea* pBestArea = NULL;
; 896  : 	CvCity* pBestCity = NULL;
; 897  : 
; 898  : 	CvPlayer& thisPlayer = GET_PLAYER(m_eOwner);

	mov	ebx, DWORD PTR [ebp+72]
	imul	ebx, 63236				; 0000f704H
	add	ebx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edi
	xor	edi, edi

; 899  : 
; 900  : 	// Do we still have a capital?
; 901  : 	pCapitalCity = thisPlayer.getCapitalCity();

	mov	ecx, ebx
	mov	DWORD PTR _iBestTotal$[esp+28], edi
	mov	DWORD PTR _pBestArea$[esp+28], edi
	mov	DWORD PTR _pBestCity$[esp+28], edi
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity

; 902  : 
; 903  : 	if(pCapitalCity != NULL)

	cmp	eax, edi

; 904  : 	{
; 905  : 		return pCapitalCity;

	jne	$LN41@GetOperati
	push	esi

; 906  : 	}
; 907  : 
; 908  : 	// No capital, find the area with the most combined cities between us and our enemy (and need at least 1 from each)
; 909  : 	for(pLoopArea = GC.getMap().firstArea(&iLoop); pLoopArea != NULL; pLoopArea = GC.getMap().nextArea(&iLoop))

	push	edi
	lea	ecx, DWORD PTR _iLoop$[esp+36]
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?firstArea@CvMap@@QAEPAVCvArea@@PAH_N@Z	; CvMap::firstArea
	mov	esi, eax
	cmp	esi, edi
	je	$LN7@GetOperati
	npad	3
$LL16@GetOperati:

; 910  : 	{
; 911  : 		if(pLoopArea->isWater())

	mov	ecx, esi
	call	?isWater@CvArea@@QBE_NXZ		; CvArea::isWater
	test	al, al
	jne	SHORT $LN15@GetOperati

; 912  : 		{
; 913  : 			continue;
; 914  : 		}
; 915  : 
; 916  : 		iMyCities = pLoopArea->getCitiesPerPlayer(GetOwner());

	mov	eax, DWORD PTR [ebp+72]
	push	eax
	mov	ecx, esi
	call	?getCitiesPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z ; CvArea::getCitiesPerPlayer
	mov	edi, eax

; 917  : 		if(iMyCities > 0)

	test	edi, edi
	jle	SHORT $LN15@GetOperati

; 918  : 		{
; 919  : 			if(m_eEnemy != NO_PLAYER && m_eEnemy != BARBARIAN_PLAYER)

	mov	eax, DWORD PTR [ebp+76]
	cmp	eax, -1
	je	SHORT $LN11@GetOperati
	cmp	eax, 63					; 0000003fH
	je	SHORT $LN11@GetOperati

; 920  : 			{
; 921  : 				iEnemyCities = pLoopArea->getCitiesPerPlayer(m_eEnemy);

	push	eax
	mov	ecx, esi
	call	?getCitiesPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z ; CvArea::getCitiesPerPlayer

; 922  : 				if(iEnemyCities == 0)

	test	eax, eax
	je	SHORT $LN15@GetOperati

; 923  : 				{
; 924  : 					continue;
; 925  : 				}
; 926  : 			}
; 927  : 			else

	jmp	SHORT $LN9@GetOperati
$LN11@GetOperati:

; 928  : 			{
; 929  : 				iEnemyCities = 0;

	xor	eax, eax
$LN9@GetOperati:

; 930  : 			}
; 931  : 
; 932  : 			if((iMyCities + iEnemyCities) > iBestTotal)

	add	eax, edi
	cmp	eax, DWORD PTR _iBestTotal$[esp+32]
	jle	SHORT $LN15@GetOperati

; 933  : 			{
; 934  : 				iBestTotal = iMyCities + iEnemyCities;

	mov	DWORD PTR _iBestTotal$[esp+32], eax

; 935  : 				pBestArea = pLoopArea;

	mov	DWORD PTR _pBestArea$[esp+32], esi
$LN15@GetOperati:
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	0
	lea	edx, DWORD PTR _iLoop$[esp+36]
	push	edx
	call	?nextArea@CvMap@@QAEPAVCvArea@@PAH_N@Z	; CvMap::nextArea
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL16@GetOperati

; 936  : 			}
; 937  : 		}
; 938  : 	}
; 939  : 
; 940  : 	if(pBestArea != NULL)

	cmp	DWORD PTR _pBestArea$[esp+32], eax
	je	SHORT $LN7@GetOperati

; 941  : 	{
; 942  : 		// Know which continent to use, now use our largest city there as the start city
; 943  : 		CvCity* pCity;
; 944  : 		iBestTotal = 0;

	xor	ebp, ebp

; 945  : 		for(pCity = thisPlayer.firstCity(&iLoop); pCity != NULL; pCity = thisPlayer.nextCity(&iLoop))

	push	ebp
	lea	eax, DWORD PTR _iLoop$[esp+36]
	push	eax
	mov	ecx, ebx
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN4@GetOperati
	npad	4
$LL6@GetOperati:

; 946  : 		{
; 947  : 			if(pCity->getArea() == pBestArea->GetID())

	mov	ecx, DWORD PTR _pBestArea$[esp+32]
	mov	edi, DWORD PTR [ecx+4]
	mov	ecx, esi
	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea
	cmp	eax, edi
	jne	SHORT $LN5@GetOperati

; 948  : 			{
; 949  : 				if(pCity->getPopulation() > iBestTotal)

	mov	ecx, esi
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	cmp	eax, ebp
	jle	SHORT $LN5@GetOperati

; 950  : 				{
; 951  : 					iBestTotal = pCity->getPopulation();

	mov	ecx, esi
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation
	mov	ebp, eax

; 952  : 					pBestCity = pCity;

	mov	DWORD PTR _pBestCity$[esp+32], esi
$LN5@GetOperati:
	push	0
	lea	edx, DWORD PTR _iLoop$[esp+36]
	push	edx
	mov	ecx, ebx
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL6@GetOperati
$LN4@GetOperati:

; 953  : 				}
; 954  : 			}
; 955  : 		}
; 956  : 		return pBestCity;

	mov	eax, DWORD PTR _pBestCity$[esp+32]
	pop	esi
	pop	edi
	pop	ebx
	pop	ebp

; 961  : 	}
; 962  : }

	add	esp, 16					; 00000010H
	ret	0
$LN7@GetOperati:

; 957  : 	}
; 958  : 	else
; 959  : 	{
; 960  : 		return NULL;

	xor	eax, eax
	pop	esi
$LN41@GetOperati:
	pop	edi
	pop	ebx
	pop	ebp

; 961  : 	}
; 962  : }

	add	esp, 16					; 00000010H
	ret	0
?GetOperationStartCity@CvAIOperation@@UBEPAVCvCity@@XZ ENDP ; CvAIOperation::GetOperationStartCity
_TEXT	ENDS
PUBLIC	?LogOperationStart@CvAIOperation@@QAEXXZ	; CvAIOperation::LogOperationStart
EXTRN	?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z:PROC ; CvMilitaryAI::LogMilitarySummaryMessage
EXTRN	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ:PROC ; CvPlayer::GetMilitaryAI
EXTRN	?GetID@CvArmyAI@@QAEHXZ:PROC			; CvArmyAI::GetID
EXTRN	?GetNumFormationEntries@CvArmyAI@@QBEHXZ:PROC	; CvArmyAI::GetNumFormationEntries
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z:PROC
EXTRN	?getElapsedGameTurns@CvGame@@QBEHXZ:PROC	; CvGame::getElapsedGameTurns
EXTRN	?GetInstance@FILogFileMgr@@SAAAV1@XZ:PROC	; FILogFileMgr::GetInstance
EXTRN	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationShortDescription
EXTRN	?getAILogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getAILogging
EXTRN	?getLogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getLogging
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?LogOperationStart@CvAIOperation@@QAEXXZ DD 019930522H
	DD	0fH
	DD	FLAT:__unwindtable$?LogOperationStart@CvAIOperation@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogOperationStart@CvAIOperation@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$5
	DD	04H
	DD	FLAT:__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$9
	DD	04H
	DD	FLAT:__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$10
	DD	04H
	DD	FLAT:__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$11
	DD	0bH
	DD	FLAT:__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$12
	DD	04H
	DD	FLAT:__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$13
	DD	04H
	DD	FLAT:__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$14
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
xdata$x	ENDS
;	COMDAT ?LogOperationStart@CvAIOperation@@QAEXXZ
_TEXT	SEGMENT
_pLog$224721 = -296					; size = 4
_strTemp2$224719 = -292					; size = 28
_strOutBuf$224716 = -264				; size = 28
_strPlayerName$224720 = -236				; size = 28
$T235167 = -208						; size = 28
$T235165 = -208						; size = 28
$T235161 = -208						; size = 28
_strBaseString$224717 = -180				; size = 28
_strTemp1$224718 = -152					; size = 28
$T235168 = -124						; size = 28
$T235163 = -124						; size = 28
$T235166 = -96						; size = 28
$T235162 = -96						; size = 28
$T235169 = -68						; size = 28
$T235164 = -68						; size = 28
$T235160 = -40						; size = 28
__$EHRec$ = -12						; size = 12
?LogOperationStart@CvAIOperation@@QAEXXZ PROC		; CvAIOperation::LogOperationStart, COMDAT
; _this$ = ecx

; 1224 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?LogOperationStart@CvAIOperation@@QAEXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 284				; 0000011cH
	push	esi
	mov	esi, ecx

; 1225 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN16@LogOperati
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN16@LogOperati

; 1226 : 	{
; 1227 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$224716[esp+300]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1228 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$224717[esp+300]
	mov	DWORD PTR __$EHRec$[esp+308], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1229 : 		CvString strTemp1;

	lea	ecx, DWORD PTR _strTemp1$224718[esp+300]
	mov	BYTE PTR __$EHRec$[esp+308], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1230 : 		CvString strTemp2;

	lea	ecx, DWORD PTR _strTemp2$224719[esp+300]
	mov	BYTE PTR __$EHRec$[esp+308], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1231 : 
; 1232 : 		CvString strPlayerName = GET_PLAYER(m_eOwner).getCivilizationShortDescription();

	mov	ecx, DWORD PTR [esi+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	BYTE PTR __$EHRec$[esp+308], 3
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	test	eax, eax
	jne	SHORT $LN51@LogOperati
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN51@LogOperati:
	push	ebx
	push	ebp
	push	edi
	push	eax
	lea	ecx, DWORD PTR _strPlayerName$224720[esp+316]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[esp+320], 4

; 1233 : 		FILogFile* pLog = LOGFILEMGR.GetLog(GetLogFileName(strPlayerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	edi, eax
	lea	eax, DWORD PTR _strPlayerName$224720[esp+312]
	push	eax
	lea	ecx, DWORD PTR $T235160[esp+316]
	push	ecx
	mov	ecx, esi
	call	?GetLogFileName@CvAIOperation@@IBE?AVCvString@@AAV2@@Z ; CvAIOperation::GetLogFileName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+320], 5
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [edi]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, edi
	call	eax
	lea	ecx, DWORD PTR $T235160[esp+312]
	mov	DWORD PTR _pLog$224721[esp+312], eax
	mov	BYTE PTR __$EHRec$[esp+320], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1234 : 
; 1235 : 		// Get the leading info for this line
; 1236 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	lea	ecx, DWORD PTR _strBaseString$224717[esp+316]
	push	OFFSET $SG224723
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 1237 : 		strBaseString += strPlayerName + ", " + GetOperationName() + ", ";

	mov	edx, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+132]
	add	esp, 12					; 0000000cH
	lea	eax, DWORD PTR $T235161[esp+312]
	push	eax
	mov	ecx, esi
	call	edx
	mov	edi, eax
	mov	ebx, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	push	OFFSET $SG224729
	lea	eax, DWORD PTR _strPlayerName$224720[esp+316]
	push	eax
	lea	ecx, DWORD PTR $T235162[esp+320]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+332], 6
	call	ebx
	mov	ebp, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	push	edi
	push	eax
	lea	edx, DWORD PTR $T235163[esp+332]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+344], 7
	call	ebp
	push	OFFSET $SG224728
	push	eax
	lea	eax, DWORD PTR $T235164[esp+344]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+356], 8
	call	ebx
	add	esp, 36					; 00000024H
	push	eax
	lea	ecx, DWORD PTR _strBaseString$224717[esp+316]
	mov	BYTE PTR __$EHRec$[esp+324], 9
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T235164[esp+312]
	mov	BYTE PTR __$EHRec$[esp+320], 8
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[esp+320], 7
	lea	ecx, DWORD PTR $T235163[esp+312]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T235162[esp+312]
	mov	BYTE PTR __$EHRec$[esp+320], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T235161[esp+312]
	mov	BYTE PTR __$EHRec$[esp+320], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1238 : 
; 1239 : 		for(unsigned int uiI = 0; uiI < m_viArmyIDs.size(); uiI++)

	mov	ecx, DWORD PTR [esi+12]
	sub	ecx, DWORD PTR [esi+8]
	xor	edi, edi
	sar	ecx, 2
	test	ecx, ecx
	jbe	SHORT $LN13@LogOperati
	npad	10
$LL15@LogOperati:

; 1240 : 		{
; 1241 : 			CvArmyAI* pThisArmy = GET_PLAYER(m_eOwner).getArmyAI(m_viArmyIDs[uiI]);

	mov	ecx, DWORD PTR [esi+72]
	mov	edx, DWORD PTR [esi+8]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	eax, DWORD PTR [edx+edi*4]
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI
	mov	ebp, eax

; 1242 : 			strTemp1.Format("Started, Army: %d, Units Recruited: %d, Max Formation Size: %d, ", pThisArmy->GetID(), pThisArmy->GetNumSlotsFilled(), pThisArmy->GetNumFormationEntries());

	mov	ecx, ebp
	call	?GetNumFormationEntries@CvArmyAI@@QBEHXZ ; CvArmyAI::GetNumFormationEntries
	push	eax
	mov	ecx, ebp
	call	?GetNumSlotsFilled@CvArmyAI@@QBEHXZ	; CvArmyAI::GetNumSlotsFilled
	push	eax
	mov	ecx, ebp
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	push	eax
	lea	ecx, DWORD PTR _strTemp1$224718[esp+324]
	push	OFFSET $SG224735
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	mov	edx, DWORD PTR [esi+12]
	sub	edx, DWORD PTR [esi+8]
	inc	edi
	sar	edx, 2
	add	esp, 20					; 00000014H
	cmp	edi, edx
	jb	SHORT $LL15@LogOperati

; 1238 : 
; 1239 : 		for(unsigned int uiI = 0; uiI < m_viArmyIDs.size(); uiI++)

	mov	ebp, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
$LN13@LogOperati:

; 1243 : 		}
; 1244 : 
; 1245 : 		strOutBuf = strBaseString + strTemp1;

	lea	eax, DWORD PTR _strTemp1$224718[esp+312]
	push	eax
	lea	ecx, DWORD PTR _strBaseString$224717[esp+316]
	push	ecx
	lea	edx, DWORD PTR $T235165[esp+320]
	push	edx
	call	ebp
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+320], 10		; 0000000aH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$224716[esp+316]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T235165[esp+312]
	mov	BYTE PTR __$EHRec$[esp+320], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1246 : 		switch(m_eCurrentState)

	mov	eax, DWORD PTR [esi+56]
	cmp	eax, 5
	ja	SHORT $LN91@LogOperati
	jmp	DWORD PTR $LN130@LogOperati[eax*4]
$LN10@LogOperati:

; 1247 : 		{
; 1248 : 		case AI_OPERATION_STATE_ABORTED:
; 1249 : 			strTemp2 = "Aborted";

	push	OFFSET $SG224742

; 1250 : 			break;

	jmp	SHORT $LN129@LogOperati
$LN9@LogOperati:

; 1251 : 		case AI_OPERATION_STATE_RECRUITING_UNITS:
; 1252 : 			strTemp2 = "Recruiting Units";

	push	OFFSET $SG224744

; 1253 : 			break;

	jmp	SHORT $LN129@LogOperati
$LN8@LogOperati:

; 1254 : 		case AI_OPERATION_STATE_GATHERING_FORCES:
; 1255 : 			strTemp2 = "Gathering Forces";

	push	OFFSET $SG224746

; 1256 : 			break;

	jmp	SHORT $LN129@LogOperati
$LN7@LogOperati:

; 1257 : 		case AI_OPERATION_STATE_MOVING_TO_TARGET:
; 1258 : 			strTemp2 = "Moving To Target";

	push	OFFSET $SG224748

; 1259 : 			break;

	jmp	SHORT $LN129@LogOperati
$LN6@LogOperati:

; 1260 : 		case AI_OPERATION_STATE_AT_TARGET:
; 1261 : 			strTemp2 = "At Target";

	push	OFFSET $SG224750

; 1262 : 			break;

	jmp	SHORT $LN129@LogOperati
$LN5@LogOperati:

; 1263 : 		case AI_OPERATION_STATE_SUCCESSFUL_FINISH:
; 1264 : 			strTemp2 = "Completed";

	push	OFFSET $SG224752
$LN129@LogOperati:
	lea	ecx, DWORD PTR _strTemp2$224719[esp+316]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
$LN91@LogOperati:

; 1265 : 			break;
; 1266 : 		};
; 1267 : 
; 1268 : 		strOutBuf += strTemp2;

	lea	eax, DWORD PTR _strTemp2$224719[esp+312]
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$224716[esp+316]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 1269 : 
; 1270 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$224716[esp+312]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR _pLog$224721[esp+312]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx]
	push	ecx
	call	eax

; 1271 : 
; 1272 : 		// Message to summary log?
; 1273 : 		switch (GetOperationType())

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+16]
	add	esp, 8
	mov	ecx, esi
	call	eax
	add	eax, -2					; fffffffeH
	cmp	eax, 16					; 00000010H
	ja	$LN3@LogOperati
	movzx	ecx, BYTE PTR $LN127@LogOperati[eax]
	jmp	DWORD PTR $LN131@LogOperati[ecx*4]
$LN2@LogOperati:

; 1274 : 		{
; 1275 : 		case AI_OPERATION_BASIC_CITY_ATTACK:
; 1276 : 		case AI_OPERATION_PILLAGE_ENEMY:
; 1277 : 		case AI_OPERATION_SNEAK_CITY_ATTACK:
; 1278 : 		case AI_OPERATION_SMALL_CITY_ATTACK:
; 1279 : 		case AI_OPERATION_NAVAL_BOMBARDMENT:
; 1280 : 		case AI_OPERATION_NAVAL_SUPERIORITY:
; 1281 : 		case AI_OPERATION_COLONIZE:
; 1282 : 		case AI_OPERATION_NAVAL_ATTACK:
; 1283 : 		case AI_OPERATION_NAVAL_SNEAK_ATTACK:
; 1284 : 		case AI_OPERATION_CITY_STATE_ATTACK:
; 1285 : 		case AI_OPERATION_CITY_STATE_NAVAL_ATTACK:
; 1286 : 		case AI_OPERATION_NUKE_ATTACK:
; 1287 : 		case AI_OPERATION_PURE_NAVAL_CITY_ATTACK:
; 1288 : 			
; 1289 : 			strOutBuf = GetOperationName() + ", ";

	mov	edx, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+132]
	lea	eax, DWORD PTR $T235166[esp+312]
	push	eax
	mov	ecx, esi
	call	edx
	push	OFFSET $SG224760
	push	eax
	lea	eax, DWORD PTR $T235167[esp+320]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+332], 11		; 0000000bH
	call	ebx
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+320], 12		; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$224716[esp+316]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T235167[esp+312]
	mov	BYTE PTR __$EHRec$[esp+320], 11		; 0000000bH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T235166[esp+312]
	mov	BYTE PTR __$EHRec$[esp+320], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1290 : 			strOutBuf += strTemp1 + strTemp2;

	lea	ecx, DWORD PTR _strTemp2$224719[esp+312]
	push	ecx
	lea	edx, DWORD PTR _strTemp1$224718[esp+316]
	push	edx
	lea	eax, DWORD PTR $T235168[esp+320]
	push	eax
	call	ebp
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$224716[esp+316]
	mov	BYTE PTR __$EHRec$[esp+324], 13		; 0000000dH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T235168[esp+312]
	mov	BYTE PTR __$EHRec$[esp+320], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1291 : 			if (m_eEnemy != NO_PLAYER)

	mov	eax, DWORD PTR [esi+76]
	cmp	eax, -1
	je	SHORT $LN1@LogOperati

; 1292 : 			{
; 1293 : 				strPlayerName = GET_PLAYER(m_eEnemy).getCivilizationShortDescription();

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	ecx, eax
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _strPlayerName$224720[esp+312]
	test	eax, eax
	je	SHORT $LN105@LogOperati
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN104@LogOperati
$LN105@LogOperati:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN104@LogOperati:

; 1294 : 				strOutBuf += ", vs. " + strPlayerName;

	lea	ecx, DWORD PTR _strPlayerName$224720[esp+312]
	push	ecx
	lea	edx, DWORD PTR $T235169[esp+316]
	push	OFFSET $SG224764
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$224716[esp+316]
	mov	BYTE PTR __$EHRec$[esp+324], 14		; 0000000eH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T235169[esp+312]
	mov	BYTE PTR __$EHRec$[esp+320], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@LogOperati:

; 1295 : 			}
; 1296 : 			GET_PLAYER(m_eOwner).GetMilitaryAI()->LogMilitarySummaryMessage(strOutBuf);

	mov	ecx, DWORD PTR [esi+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	eax, DWORD PTR _strOutBuf$224716[esp+312]
	push	eax
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z ; CvMilitaryAI::LogMilitarySummaryMessage
$LN3@LogOperati:

; 1297 : 		}
; 1298 : 	}

	lea	ecx, DWORD PTR _strPlayerName$224720[esp+312]
	mov	BYTE PTR __$EHRec$[esp+320], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp2$224719[esp+312]
	mov	BYTE PTR __$EHRec$[esp+320], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp1$224718[esp+312]
	mov	BYTE PTR __$EHRec$[esp+320], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strBaseString$224717[esp+312]
	mov	BYTE PTR __$EHRec$[esp+320], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strOutBuf$224716[esp+312]
	mov	DWORD PTR __$EHRec$[esp+320], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	edi
	pop	ebp
	pop	ebx
$LN16@LogOperati:

; 1299 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+300]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 296				; 00000128H
	ret	0
$LN130@LogOperati:
	DD	$LN10@LogOperati
	DD	$LN9@LogOperati
	DD	$LN8@LogOperati
	DD	$LN7@LogOperati
	DD	$LN6@LogOperati
	DD	$LN5@LogOperati
$LN131@LogOperati:
	DD	$LN2@LogOperati
	DD	$LN3@LogOperati
$LN127@LogOperati:
	DB	0
	DB	1
	DB	1
	DB	0
	DB	0
	DB	0
	DB	1
	DB	0
	DB	0
	DB	0
	DB	1
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$0:
	lea	ecx, DWORD PTR _strOutBuf$224716[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$1:
	lea	ecx, DWORD PTR _strBaseString$224717[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$2:
	lea	ecx, DWORD PTR _strTemp1$224718[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$3:
	lea	ecx, DWORD PTR _strTemp2$224719[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$4:
	lea	ecx, DWORD PTR _strPlayerName$224720[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$5:
	lea	ecx, DWORD PTR $T235160[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$6:
	lea	ecx, DWORD PTR $T235161[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$7:
	lea	ecx, DWORD PTR $T235162[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$8:
	lea	ecx, DWORD PTR $T235163[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$9:
	lea	ecx, DWORD PTR $T235164[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$10:
	lea	ecx, DWORD PTR $T235165[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$11:
	lea	ecx, DWORD PTR $T235166[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$12:
	lea	ecx, DWORD PTR $T235167[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$13:
	lea	ecx, DWORD PTR $T235168[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogOperationStart@CvAIOperation@@QAEXXZ$14:
	lea	ecx, DWORD PTR $T235169[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogOperationStart@CvAIOperation@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?LogOperationStart@CvAIOperation@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogOperationStart@CvAIOperation@@QAEXXZ ENDP		; CvAIOperation::LogOperationStart
PUBLIC	?LogOperationStatus@CvAIOperation@@QAEXXZ	; CvAIOperation::LogOperationStatus
EXTRN	?GetX@CvArmyAI@@QBEHXZ:PROC			; CvArmyAI::GetX
EXTRN	?GetY@CvArmyAI@@QBEHXZ:PROC			; CvArmyAI::GetY
EXTRN	?getName@CvUnit@@QBE?BVCvString@@XZ:PROC	; CvUnit::getName
EXTRN	?GetTurnAtNextCheckpoint@CvArmyAI@@QBEHXZ:PROC	; CvArmyAI::GetTurnAtNextCheckpoint
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?LogOperationStatus@CvAIOperation@@QAEXXZ DD 019930522H
	DD	014H
	DD	FLAT:__unwindtable$?LogOperationStatus@CvAIOperation@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogOperationStatus@CvAIOperation@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$6
	DD	05H
	DD	FLAT:__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$9
	DD	09H
	DD	FLAT:__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$10
	DD	05H
	DD	FLAT:__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$11
	DD	05H
	DD	FLAT:__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$12
	DD	05H
	DD	FLAT:__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$13
	DD	0dH
	DD	FLAT:__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$14
	DD	05H
	DD	FLAT:__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$15
	DD	0fH
	DD	FLAT:__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$16
	DD	05H
	DD	FLAT:__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$17
	DD	011H
	DD	FLAT:__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$18
	DD	05H
	DD	FLAT:__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$19
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
xdata$x	ENDS
;	COMDAT ?LogOperationStatus@CvAIOperation@@QAEXXZ
_TEXT	SEGMENT
_uiI$224841 = -356					; size = 4
_uiI$224825 = -356					; size = 4
_uiI$224792 = -356					; size = 4
tv1243 = -352						; size = 4
_iI$224798 = -348					; size = 4
_pThisUnit$224851 = -344				; size = 8
_pThisUnit$224835 = -344				; size = 8
_pThisUnit$224819 = -344				; size = 8
_szTemp2$224772 = -336					; size = 28
_strTemp$224771 = -308					; size = 28
_pLog$224775 = -280					; size = 4
_pThisUnit$224815 = -276				; size = 8
_strPlayerName$224774 = -268				; size = 28
$T235347 = -240						; size = 28
$T235343 = -240						; size = 28
$T235339 = -240						; size = 28
_strBaseString$224770 = -212				; size = 28
$T235346 = -184						; size = 28
$T235342 = -184						; size = 28
_strOutBuf$224769 = -156				; size = 28
$T235345 = -128						; size = 28
$T235341 = -128						; size = 28
_szTemp3$224773 = -100					; size = 28
$T235344 = -72						; size = 28
$T235340 = -72						; size = 28
$T235338 = -44						; size = 28
__$EHRec$ = -12						; size = 12
?LogOperationStatus@CvAIOperation@@QAEXXZ PROC		; CvAIOperation::LogOperationStatus, COMDAT
; _this$ = ecx

; 1303 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	-1
	mov	eax, DWORD PTR fs:0
	push	__ehhandler$?LogOperationStatus@CvAIOperation@@QAEXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 348				; 0000015cH
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi

; 1304 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN37@LogOperati@2
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN37@LogOperati@2

; 1305 : 	{
; 1306 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$224769[esp+376]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1307 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$224770[esp+376]
	mov	DWORD PTR __$EHRec$[esp+384], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1308 : 		CvString strTemp, szTemp2, szTemp3;

	lea	ecx, DWORD PTR _strTemp$224771[esp+376]
	mov	BYTE PTR __$EHRec$[esp+384], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _szTemp2$224772[esp+376]
	mov	BYTE PTR __$EHRec$[esp+384], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _szTemp3$224773[esp+376]
	mov	BYTE PTR __$EHRec$[esp+384], 3
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1309 : 		CvString strPlayerName;

	lea	ecx, DWORD PTR _strPlayerName$224774[esp+376]
	mov	BYTE PTR __$EHRec$[esp+384], 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1310 : 		FILogFile* pLog;
; 1311 : 
; 1312 : 		strPlayerName = GET_PLAYER(m_eOwner).getCivilizationShortDescription();

	mov	ecx, DWORD PTR [esi+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	BYTE PTR __$EHRec$[esp+384], 5
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _strPlayerName$224774[esp+376]
	test	eax, eax
	je	SHORT $LN81@LogOperati@2
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN80@LogOperati@2
$LN81@LogOperati@2:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN80@LogOperati@2:

; 1313 : 		pLog = LOGFILEMGR.GetLog(GetLogFileName(strPlayerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	edi, eax
	lea	eax, DWORD PTR _strPlayerName$224774[esp+376]
	push	eax
	lea	ecx, DWORD PTR $T235338[esp+380]
	push	ecx
	mov	ecx, esi
	call	?GetLogFileName@CvAIOperation@@IBE?AVCvString@@AAV2@@Z ; CvAIOperation::GetLogFileName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+384], 6
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [edi]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, edi
	call	eax
	lea	ecx, DWORD PTR $T235338[esp+376]
	mov	DWORD PTR _pLog$224775[esp+376], eax
	mov	BYTE PTR __$EHRec$[esp+384], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1314 : 
; 1315 : 		// Get the leading info for this line
; 1316 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	lea	ecx, DWORD PTR _strBaseString$224770[esp+380]
	push	OFFSET $SG224777
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 1317 : 		strBaseString += strPlayerName + ", " + GetOperationName() + ", ";

	mov	edx, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+132]
	add	esp, 12					; 0000000cH
	lea	eax, DWORD PTR $T235339[esp+376]
	push	eax
	mov	ecx, esi
	call	edx
	mov	edi, eax
	mov	ebp, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	push	OFFSET $SG224783
	lea	eax, DWORD PTR _strPlayerName$224774[esp+380]
	push	eax
	lea	ecx, DWORD PTR $T235340[esp+384]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+396], 7
	call	ebp
	push	edi
	push	eax
	lea	edx, DWORD PTR $T235341[esp+396]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+408], 8
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	push	OFFSET $SG224782
	push	eax
	lea	eax, DWORD PTR $T235342[esp+408]
	mov	bl, 9
	push	eax
	mov	BYTE PTR __$EHRec$[esp+420], bl
	call	ebp
	add	esp, 36					; 00000024H
	push	eax
	lea	ecx, DWORD PTR _strBaseString$224770[esp+380]
	mov	BYTE PTR __$EHRec$[esp+388], 10		; 0000000aH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T235342[esp+376]
	mov	BYTE PTR __$EHRec$[esp+384], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T235341[esp+376]
	mov	BYTE PTR __$EHRec$[esp+384], 8
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T235340[esp+376]
	mov	BYTE PTR __$EHRec$[esp+384], 7
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T235339[esp+376]
	mov	BYTE PTR __$EHRec$[esp+384], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1318 : 
; 1319 : 		switch(m_eCurrentState)

	mov	eax, DWORD PTR [esi+56]
	cmp	eax, 5
	ja	$LN35@LogOperati@2
	jmp	DWORD PTR $LN283@LogOperati@2[eax*4]
$LN34@LogOperati@2:

; 1320 : 		{
; 1321 : 		case AI_OPERATION_STATE_ABORTED:
; 1322 : 			strTemp = "Aborted";

	push	OFFSET $SG224789

; 1323 : 			break;

	jmp	$LN281@LogOperati@2
$LN33@LogOperati@2:

; 1324 : 		case AI_OPERATION_STATE_RECRUITING_UNITS:
; 1325 : 			strTemp = "";

	push	OFFSET $SG224791
	lea	ecx, DWORD PTR _strTemp$224771[esp+380]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1326 : 			for(unsigned int uiI = 0; uiI < m_viArmyIDs.size(); uiI++)

	mov	ecx, DWORD PTR [esi+12]
	sub	ecx, DWORD PTR [esi+8]
	xor	edi, edi
	sar	ecx, 2
	xor	ebp, ebp
	mov	DWORD PTR _uiI$224792[esp+376], edi
	test	ecx, ecx
	jbe	$LN35@LogOperati@2
	npad	6
$LL32@LogOperati@2:

; 1327 : 			{
; 1328 : 				CvArmyAI* pThisArmy = GET_PLAYER(m_eOwner).getArmyAI(m_viArmyIDs[uiI]);

	mov	ecx, DWORD PTR [esi+72]
	mov	edx, DWORD PTR [esi+8]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	eax, DWORD PTR [edx+edi*4]
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI
	mov	ebx, eax

; 1329 : 				szTemp2.Format("Recruiting Units, Army: %d, Muster Turn: %d, SLOT DETAIL:, ", pThisArmy->GetID(), pThisArmy->GetTurnAtNextCheckpoint());

	mov	ecx, ebx
	call	?GetTurnAtNextCheckpoint@CvArmyAI@@QBEHXZ ; CvArmyAI::GetTurnAtNextCheckpoint
	push	eax
	mov	ecx, ebx
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	push	eax
	lea	ecx, DWORD PTR _szTemp2$224772[esp+384]
	push	OFFSET $SG224797
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 1330 : 				strTemp += szTemp2;

	lea	edx, DWORD PTR _szTemp2$224772[esp+376]
	push	edx
	lea	ecx, DWORD PTR _strTemp$224771[esp+380]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 1331 : 
; 1332 : 				for(int iI = 0; iI < pThisArmy->GetNumFormationEntries(); iI++)

	mov	ecx, ebx
	mov	DWORD PTR _iI$224798[esp+376], ebp
	call	?GetNumFormationEntries@CvArmyAI@@QBEHXZ ; CvArmyAI::GetNumFormationEntries
	test	eax, eax
	jle	$LN31@LogOperati@2

; 1327 : 			{
; 1328 : 				CvArmyAI* pThisArmy = GET_PLAYER(m_eOwner).getArmyAI(m_viArmyIDs[uiI]);

	mov	DWORD PTR tv1243[esp+376], ebp
	npad	9
$LL29@LogOperati@2:

; 1333 : 				{
; 1334 : 					CvArmyFormationSlot* pSlot = pThisArmy->GetFormationSlot(iI);

	mov	edi, DWORD PTR [ebx+44]
	add	edi, DWORD PTR tv1243[esp+376]

; 1335 : 					if(pSlot->GetTurnAtCheckpoint() == ARMYSLOT_UNKNOWN_TURN_AT_CHECKPOINT)

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, -1
	jne	SHORT $LN26@LogOperati@2

; 1336 : 					{
; 1337 : 						szTemp2 = "No Info, ";

	push	OFFSET $SG224804
	lea	ecx, DWORD PTR _szTemp2$224772[esp+380]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	$LN165@LogOperati@2
$LN26@LogOperati@2:

; 1338 : 					}
; 1339 : 					else if(pSlot->GetTurnAtCheckpoint() == ARMYSLOT_NOT_INCLUDING_IN_OPERATION)

	cmp	eax, -2					; fffffffeH
	jne	SHORT $LN24@LogOperati@2

; 1340 : 					{
; 1341 : 						szTemp2 = "Skipping, ";

	push	OFFSET $SG224807
	lea	ecx, DWORD PTR _szTemp2$224772[esp+380]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	$LN165@LogOperati@2
$LN24@LogOperati@2:

; 1342 : 					}
; 1343 : 					else if(pSlot->GetUnitID() == NO_UNIT)

	mov	edx, DWORD PTR [edi]
	cmp	edx, -1
	jne	SHORT $LN22@LogOperati@2

; 1344 : 					{
; 1345 : 						szTemp3.Format("Turn %d, ", pSlot->GetTurnAtCheckpoint());

	push	eax
	lea	eax, DWORD PTR _szTemp3$224773[esp+380]
	push	OFFSET $SG224810
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 1346 : 						szTemp2 = "Training - " + szTemp3;

	lea	ecx, DWORD PTR _szTemp3$224773[esp+388]
	push	ecx
	lea	edx, DWORD PTR $T235343[esp+392]
	push	OFFSET $SG224812
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	add	esp, 24					; 00000018H
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+384], 11		; 0000000bH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _szTemp2$224772[esp+380]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T235343[esp+376]
	mov	BYTE PTR __$EHRec$[esp+384], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	jmp	$LN165@LogOperati@2
$LN22@LogOperati@2:

; 1347 : 					}
; 1348 : 					else if(pSlot->HasStartedOnOperation())
; 1349 : 					{
; 1350 : 						UnitHandle pThisUnit = GET_PLAYER(m_eOwner).getUnit(pSlot->GetUnitID());

	mov	ecx, DWORD PTR [esi+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	DWORD PTR [edi+8], 0
	push	edx
	je	SHORT $LN20@LogOperati@2
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	push	eax
	lea	ecx, DWORD PTR _pThisUnit$224815[esp+380]
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>

; 1351 : 						if(pThisUnit)

	mov	edi, DWORD PTR _pThisUnit$224815[esp+376]
	mov	BYTE PTR __$EHRec$[esp+384], 12		; 0000000cH
	test	edi, edi
	je	SHORT $LN19@LogOperati@2

; 1352 : 						{
; 1353 : 							szTemp2.Format("Gathering at (%d-%d), ", pThisUnit->getX(), pThisUnit->getY());

	mov	eax, DWORD PTR [edi+88]
	mov	ecx, DWORD PTR [edi+76]
	push	eax
	push	ecx
	lea	eax, DWORD PTR _szTemp2$224772[esp+384]
	push	OFFSET $SG224817
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H
$LN19@LogOperati@2:

; 1354 : 						}
; 1355 : 					}

	mov	BYTE PTR __$EHRec$[esp+384], 5
	test	edi, edi
	je	$LN165@LogOperati@2
	mov	ecx, edi

; 1356 : 					else

	jmp	SHORT $LN282@LogOperati@2
$LN20@LogOperati@2:

; 1357 : 					{
; 1358 : 						UnitHandle pThisUnit = GET_PLAYER(m_eOwner).getUnit(pSlot->GetUnitID());

	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	push	eax
	lea	ecx, DWORD PTR _pThisUnit$224819[esp+380]
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>

; 1359 : 						if(pThisUnit)

	mov	ebp, DWORD PTR _pThisUnit$224819[esp+376]
	mov	BYTE PTR __$EHRec$[esp+384], 13		; 0000000dH
	test	ebp, ebp
	je	SHORT $LN17@LogOperati@2

; 1360 : 						{
; 1361 : 							szTemp2.Format("%s - Turn %d, ", pThisUnit->getName().GetCString(), pSlot->GetTurnAtCheckpoint());

	lea	ecx, DWORD PTR $T235344[esp+376]
	push	ecx
	mov	ecx, ebp
	call	?getName@CvUnit@@QBE?BVCvString@@XZ	; CvUnit::getName
	mov	edi, DWORD PTR [edi+4]
	push	edi
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+388], 14		; 0000000eH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR _szTemp2$224772[esp+384]
	push	OFFSET $SG224822
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H
	lea	ecx, DWORD PTR $T235344[esp+376]
	mov	BYTE PTR __$EHRec$[esp+384], 13		; 0000000dH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN17@LogOperati@2:

; 1362 : 						}
; 1363 : 					}

	mov	BYTE PTR __$EHRec$[esp+384], 5
	test	ebp, ebp
	je	SHORT $LN165@LogOperati@2
	mov	ecx, ebp
$LN282@LogOperati@2:
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN165@LogOperati@2:

; 1364 : 					strTemp += szTemp2;

	lea	eax, DWORD PTR _szTemp2$224772[esp+376]
	push	eax
	lea	ecx, DWORD PTR _strTemp$224771[esp+380]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	edi, DWORD PTR _iI$224798[esp+376]
	add	DWORD PTR tv1243[esp+376], 12		; 0000000cH
	inc	edi
	mov	ecx, ebx
	mov	DWORD PTR _iI$224798[esp+376], edi
	call	?GetNumFormationEntries@CvArmyAI@@QBEHXZ ; CvArmyAI::GetNumFormationEntries
	cmp	edi, eax
	jl	$LL29@LogOperati@2
	mov	edi, DWORD PTR _uiI$224792[esp+376]
	xor	ebp, ebp
$LN31@LogOperati@2:
	mov	ecx, DWORD PTR [esi+12]
	sub	ecx, DWORD PTR [esi+8]
	inc	edi
	sar	ecx, 2
	mov	DWORD PTR _uiI$224792[esp+376], edi
	cmp	edi, ecx
	jb	$LL32@LogOperati@2

; 1365 : 				}
; 1366 : 			}
; 1367 : 			break;

	jmp	$LN35@LogOperati@2
$LN16@LogOperati@2:

; 1368 : 		case AI_OPERATION_STATE_GATHERING_FORCES:
; 1369 : 			strTemp = "";

	push	OFFSET $SG224824
	lea	ecx, DWORD PTR _strTemp$224771[esp+380]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1370 : 			for(unsigned int uiI = 0; uiI < m_viArmyIDs.size(); uiI++)

	mov	edx, DWORD PTR [esi+12]
	sub	edx, DWORD PTR [esi+8]
	xor	edi, edi
	sar	edx, 2
	mov	DWORD PTR _uiI$224825[esp+376], edi
	test	edx, edx
	jbe	$LN35@LogOperati@2
	npad	5
$LL15@LogOperati@2:

; 1371 : 			{
; 1372 : 				CvArmyAI* pThisArmy = GET_PLAYER(m_eOwner).getArmyAI(m_viArmyIDs[uiI]);

	mov	ecx, DWORD PTR [esi+72]
	mov	eax, DWORD PTR [esi+8]
	imul	ecx, 63236				; 0000f704H
	mov	edx, DWORD PTR [eax+edi*4]
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	eax, DWORD PTR [eax+edi*4]
	push	edx
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI
	mov	ebx, eax

; 1373 : 				szTemp2.Format("Gathering Forces, Army: %d, Gather X: %d, Gather Y: %d, ", pThisArmy->GetID(), pThisArmy->GetX(), pThisArmy->GetY());

	mov	ecx, ebx
	call	?GetY@CvArmyAI@@QBEHXZ			; CvArmyAI::GetY
	push	eax
	mov	ecx, ebx
	call	?GetX@CvArmyAI@@QBEHXZ			; CvArmyAI::GetX
	push	eax
	mov	ecx, ebx
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	push	eax
	lea	eax, DWORD PTR _szTemp2$224772[esp+388]
	push	OFFSET $SG224830
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H

; 1374 : 				strTemp += szTemp2;

	lea	ecx, DWORD PTR _szTemp2$224772[esp+376]
	push	ecx
	lea	ecx, DWORD PTR _strTemp$224771[esp+380]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 1375 : 				int iUnitID;
; 1376 : 				iUnitID = pThisArmy->GetFirstUnitID();

	mov	ecx, ebx
	call	?GetFirstUnitID@CvArmyAI@@QAEHXZ	; CvArmyAI::GetFirstUnitID
	mov	ebp, eax

; 1377 : 				while(iUnitID != ARMY_NO_UNIT)

	cmp	ebp, -1
	je	$LN14@LogOperati@2
	npad	5
$LL12@LogOperati@2:

; 1378 : 				{
; 1379 : 					// do something with each entry
; 1380 : 					UnitHandle pThisUnit = GET_PLAYER(m_eOwner).getUnit(iUnitID);

	mov	ecx, DWORD PTR [esi+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebp
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
	mov	DWORD PTR _pThisUnit$224835[esp+376], edi
	mov	BYTE PTR _pThisUnit$224835[esp+380], 0
	test	edi, edi
	je	SHORT $LN178@LogOperati@2
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN178@LogOperati@2:
	mov	BYTE PTR __$EHRec$[esp+384], 15		; 0000000fH

; 1381 : 					if(pThisUnit)

	test	edi, edi
	je	SHORT $LN10@LogOperati@2

; 1382 : 					{
; 1383 : 						szTemp2.Format("%s at (%d-%d),", pThisUnit->getName().GetCString(), pThisUnit->getX(), pThisUnit->getY());

	lea	edx, DWORD PTR $T235345[esp+376]
	push	edx
	mov	ecx, edi
	call	?getName@CvUnit@@QBE?BVCvString@@XZ	; CvUnit::getName
	mov	ecx, DWORD PTR [edi+88]
	mov	edx, DWORD PTR [edi+76]
	push	ecx
	push	edx
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+392], 16		; 00000010H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR _szTemp2$224772[esp+388]
	push	OFFSET $SG224838
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H
	lea	ecx, DWORD PTR $T235345[esp+376]
	mov	BYTE PTR __$EHRec$[esp+384], 15		; 0000000fH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1384 : 						strTemp += szTemp2;

	lea	ecx, DWORD PTR _szTemp2$224772[esp+376]
	push	ecx
	lea	ecx, DWORD PTR _strTemp$224771[esp+380]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
$LN10@LogOperati@2:

; 1385 : 					}
; 1386 : 					iUnitID = pThisArmy->GetNextUnitID();

	mov	ecx, ebx
	call	?GetNextUnitID@CvArmyAI@@QAEHXZ		; CvArmyAI::GetNextUnitID
	mov	ebp, eax

; 1387 : 				}

	mov	BYTE PTR __$EHRec$[esp+384], 5
	test	edi, edi
	je	SHORT $LN204@LogOperati@2
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN204@LogOperati@2:

; 1377 : 				while(iUnitID != ARMY_NO_UNIT)

	cmp	ebp, -1
	jne	$LL12@LogOperati@2
	mov	edi, DWORD PTR _uiI$224825[esp+376]
$LN14@LogOperati@2:

; 1370 : 			for(unsigned int uiI = 0; uiI < m_viArmyIDs.size(); uiI++)

	mov	edx, DWORD PTR [esi+12]
	sub	edx, DWORD PTR [esi+8]
	inc	edi
	sar	edx, 2
	mov	DWORD PTR _uiI$224825[esp+376], edi
	cmp	edi, edx
	jb	$LL15@LogOperati@2

; 1388 : 			}
; 1389 : 			break;

	jmp	$LN35@LogOperati@2
$LN9@LogOperati@2:

; 1390 : 		case AI_OPERATION_STATE_MOVING_TO_TARGET:
; 1391 : 			strTemp = "";

	push	OFFSET $SG224840
	lea	ecx, DWORD PTR _strTemp$224771[esp+380]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=

; 1392 : 			for(unsigned int uiI = 0; uiI < m_viArmyIDs.size(); uiI++)

	mov	eax, DWORD PTR [esi+12]
	sub	eax, DWORD PTR [esi+8]
	xor	edi, edi
	sar	eax, 2
	mov	DWORD PTR _uiI$224841[esp+376], edi
	test	eax, eax
	jbe	$LN35@LogOperati@2
	npad	2
$LL8@LogOperati@2:
	mov	ecx, DWORD PTR [esi+8]

; 1393 : 			{
; 1394 : 				CvArmyAI* pThisArmy = GET_PLAYER(m_eOwner).getArmyAI(m_viArmyIDs[uiI]);

	mov	edx, DWORD PTR [ecx+edi*4]
	lea	eax, DWORD PTR [ecx+edi*4]
	mov	ecx, DWORD PTR [esi+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI

; 1395 : 				szTemp2.Format("Moving To Target, Army: %d, At X: %d, At Y: %d, To X: %d, To Y: %d, ", pThisArmy->GetID(), pThisArmy->GetX(), pThisArmy->GetY(), m_iTargetX, m_iTargetY);

	mov	ecx, DWORD PTR [esi+104]
	mov	ebx, eax
	mov	eax, DWORD PTR [esi+108]
	push	eax
	push	ecx
	mov	ecx, ebx
	call	?GetY@CvArmyAI@@QBEHXZ			; CvArmyAI::GetY
	push	eax
	mov	ecx, ebx
	call	?GetX@CvArmyAI@@QBEHXZ			; CvArmyAI::GetX
	push	eax
	mov	ecx, ebx
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	push	eax
	lea	edx, DWORD PTR _szTemp2$224772[esp+396]
	push	OFFSET $SG224846
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 28					; 0000001cH

; 1396 : 				strTemp += szTemp2;

	lea	eax, DWORD PTR _szTemp2$224772[esp+376]
	push	eax
	lea	ecx, DWORD PTR _strTemp$224771[esp+380]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 1397 : 				int iUnitID;
; 1398 : 				iUnitID = pThisArmy->GetFirstUnitID();

	mov	ecx, ebx
	call	?GetFirstUnitID@CvArmyAI@@QAEHXZ	; CvArmyAI::GetFirstUnitID
	mov	ebp, eax

; 1399 : 				while(iUnitID != ARMY_NO_UNIT)

	cmp	ebp, -1
	je	$LN7@LogOperati@2
	npad	13
$LL5@LogOperati@2:

; 1400 : 				{
; 1401 : 					// do something with each entry
; 1402 : 					UnitHandle pThisUnit = GET_PLAYER(m_eOwner).getUnit(iUnitID);

	mov	ecx, DWORD PTR [esi+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebp
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
	mov	DWORD PTR _pThisUnit$224851[esp+376], edi
	mov	BYTE PTR _pThisUnit$224851[esp+380], 0
	test	edi, edi
	je	SHORT $LN217@LogOperati@2
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN217@LogOperati@2:
	mov	BYTE PTR __$EHRec$[esp+384], 17		; 00000011H

; 1403 : 					if(pThisUnit)

	test	edi, edi
	je	SHORT $LN3@LogOperati@2

; 1404 : 					{
; 1405 : 						szTemp2.Format("%s at (%d-%d),", pThisUnit->getName().GetCString(), pThisUnit->getX(), pThisUnit->getY());

	lea	ecx, DWORD PTR $T235346[esp+376]
	push	ecx
	mov	ecx, edi
	call	?getName@CvUnit@@QBE?BVCvString@@XZ	; CvUnit::getName
	mov	ecx, DWORD PTR [edi+88]
	mov	edx, DWORD PTR [edi+76]
	push	ecx
	push	edx
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+392], 18		; 00000012H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR _szTemp2$224772[esp+388]
	push	OFFSET $SG224854
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 20					; 00000014H
	lea	ecx, DWORD PTR $T235346[esp+376]
	mov	BYTE PTR __$EHRec$[esp+384], 17		; 00000011H
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1406 : 						strTemp += szTemp2;

	lea	eax, DWORD PTR _szTemp2$224772[esp+376]
	push	eax
	lea	ecx, DWORD PTR _strTemp$224771[esp+380]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
$LN3@LogOperati@2:

; 1407 : 					}
; 1408 : 					iUnitID = pThisArmy->GetNextUnitID();

	mov	ecx, ebx
	call	?GetNextUnitID@CvArmyAI@@QAEHXZ		; CvArmyAI::GetNextUnitID
	mov	ebp, eax

; 1409 : 				}

	mov	BYTE PTR __$EHRec$[esp+384], 5
	test	edi, edi
	je	SHORT $LN243@LogOperati@2
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN243@LogOperati@2:

; 1399 : 				while(iUnitID != ARMY_NO_UNIT)

	cmp	ebp, -1
	jne	$LL5@LogOperati@2
	mov	edi, DWORD PTR _uiI$224841[esp+376]
$LN7@LogOperati@2:

; 1392 : 			for(unsigned int uiI = 0; uiI < m_viArmyIDs.size(); uiI++)

	mov	ecx, DWORD PTR [esi+12]
	sub	ecx, DWORD PTR [esi+8]
	inc	edi
	sar	ecx, 2
	mov	DWORD PTR _uiI$224841[esp+376], edi
	cmp	edi, ecx
	jb	$LL8@LogOperati@2

; 1410 : 			}
; 1411 : 			break;

	jmp	SHORT $LN35@LogOperati@2
$LN2@LogOperati@2:

; 1412 : 		case AI_OPERATION_STATE_AT_TARGET:
; 1413 : 			strTemp = "At Target";

	push	OFFSET $SG224856

; 1414 : 			break;

	jmp	SHORT $LN281@LogOperati@2
$LN1@LogOperati@2:

; 1415 : 		case AI_OPERATION_STATE_SUCCESSFUL_FINISH:
; 1416 : 			strTemp = "Completed";

	push	OFFSET $SG224858
$LN281@LogOperati@2:
	lea	ecx, DWORD PTR _strTemp$224771[esp+380]
	call	??4CvString@@QAEAAV0@PBD@Z		; CvString::operator=
$LN35@LogOperati@2:

; 1417 : 			break;
; 1418 : 		};
; 1419 : 
; 1420 : 		strOutBuf = strBaseString + strTemp;

	lea	edx, DWORD PTR _strTemp$224771[esp+376]
	push	edx
	lea	eax, DWORD PTR _strBaseString$224770[esp+380]
	push	eax
	lea	ecx, DWORD PTR $T235347[esp+384]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+384], 19		; 00000013H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$224769[esp+380]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T235347[esp+376]
	mov	BYTE PTR __$EHRec$[esp+384], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1421 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$224769[esp+376]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR _pLog$224775[esp+376]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx]
	push	ecx
	call	eax
	add	esp, 8

; 1422 : 	}

	lea	ecx, DWORD PTR _strPlayerName$224774[esp+376]
	mov	BYTE PTR __$EHRec$[esp+384], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _szTemp3$224773[esp+376]
	mov	BYTE PTR __$EHRec$[esp+384], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _szTemp2$224772[esp+376]
	mov	BYTE PTR __$EHRec$[esp+384], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$224771[esp+376]
	mov	BYTE PTR __$EHRec$[esp+384], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strBaseString$224770[esp+376]
	mov	BYTE PTR __$EHRec$[esp+384], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strOutBuf$224769[esp+376]
	mov	DWORD PTR __$EHRec$[esp+384], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN37@LogOperati@2:

; 1423 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+376]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN283@LogOperati@2:
	DD	$LN34@LogOperati@2
	DD	$LN33@LogOperati@2
	DD	$LN16@LogOperati@2
	DD	$LN9@LogOperati@2
	DD	$LN2@LogOperati@2
	DD	$LN1@LogOperati@2
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$0:
	lea	ecx, DWORD PTR _strOutBuf$224769[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$1:
	lea	ecx, DWORD PTR _strBaseString$224770[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$2:
	lea	ecx, DWORD PTR _strTemp$224771[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$3:
	lea	ecx, DWORD PTR _szTemp2$224772[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$4:
	lea	ecx, DWORD PTR _szTemp3$224773[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$5:
	lea	ecx, DWORD PTR _strPlayerName$224774[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$6:
	lea	ecx, DWORD PTR $T235338[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$7:
	lea	ecx, DWORD PTR $T235339[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$8:
	lea	ecx, DWORD PTR $T235340[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$9:
	lea	ecx, DWORD PTR $T235341[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$10:
	lea	ecx, DWORD PTR $T235342[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$11:
	lea	ecx, DWORD PTR $T235343[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$12:
	lea	ecx, DWORD PTR _pThisUnit$224815[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$13:
	lea	ecx, DWORD PTR _pThisUnit$224819[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$14:
	lea	ecx, DWORD PTR $T235344[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$15:
	lea	ecx, DWORD PTR _pThisUnit$224835[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$16:
	lea	ecx, DWORD PTR $T235345[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$17:
	lea	ecx, DWORD PTR _pThisUnit$224851[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$18:
	lea	ecx, DWORD PTR $T235346[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationStatus@CvAIOperation@@QAEXXZ$19:
	lea	ecx, DWORD PTR $T235347[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogOperationStatus@CvAIOperation@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?LogOperationStatus@CvAIOperation@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogOperationStatus@CvAIOperation@@QAEXXZ ENDP		; CvAIOperation::LogOperationStatus
PUBLIC	?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z ; CvAIOperation::LogOperationSpecialMessage
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z$7
	DD	02H
	DD	FLAT:__unwindfunclet$?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z$8
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
xdata$x	ENDS
;	COMDAT ?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z
_TEXT	SEGMENT
_strBaseString$224866 = -236				; size = 28
_strPlayerName$224867 = -208				; size = 28
_strOutBuf$224865 = -180				; size = 28
$T235765 = -152						; size = 28
$T235761 = -152						; size = 28
$T235760 = -124						; size = 28
$T235762 = -96						; size = 28
$T235763 = -68						; size = 28
$T235764 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_strMsg$ = 8						; size = 4
?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z PROC ; CvAIOperation::LogOperationSpecialMessage, COMDAT
; _this$ = ecx

; 1426 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 224				; 000000e0H
	push	esi
	mov	esi, ecx

; 1427 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN1@LogOperati@3
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN1@LogOperati@3

; 1428 : 	{
; 1429 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$224865[esp+240]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1430 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$224866[esp+240]
	mov	DWORD PTR __$EHRec$[esp+248], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1431 : 
; 1432 : 		CvString strPlayerName = GET_PLAYER(m_eOwner).getCivilizationShortDescription();

	mov	ecx, DWORD PTR [esi+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	BYTE PTR __$EHRec$[esp+248], 1
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	test	eax, eax
	jne	SHORT $LN24@LogOperati@3
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN24@LogOperati@3:
	push	ebx
	push	ebp
	push	edi
	push	eax
	lea	ecx, DWORD PTR _strPlayerName$224867[esp+256]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	bl, 2
	mov	BYTE PTR __$EHRec$[esp+260], bl

; 1433 : 		FILogFile* pLog = LOGFILEMGR.GetLog(GetLogFileName(strPlayerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	edi, eax
	lea	eax, DWORD PTR _strPlayerName$224867[esp+252]
	push	eax
	lea	ecx, DWORD PTR $T235760[esp+256]
	push	ecx
	mov	ecx, esi
	call	?GetLogFileName@CvAIOperation@@IBE?AVCvString@@AAV2@@Z ; CvAIOperation::GetLogFileName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+260], 3
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [edi]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, edi
	call	eax
	lea	ecx, DWORD PTR $T235760[esp+252]
	mov	edi, eax
	mov	BYTE PTR __$EHRec$[esp+260], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1434 : 
; 1435 : 		// Get the leading info for this line
; 1436 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	lea	ecx, DWORD PTR _strBaseString$224866[esp+256]
	push	OFFSET $SG224870
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 1437 : 		strBaseString += strPlayerName + ", " + GetOperationName() + ", ";

	mov	edx, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+132]
	add	esp, 12					; 0000000cH
	lea	eax, DWORD PTR $T235761[esp+252]
	push	eax
	mov	ecx, esi
	call	edx
	mov	esi, eax
	mov	ebp, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	push	OFFSET $SG224876
	lea	eax, DWORD PTR _strPlayerName$224867[esp+256]
	push	eax
	lea	ecx, DWORD PTR $T235762[esp+260]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+272], 4
	call	ebp
	push	esi
	mov	esi, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	push	eax
	lea	edx, DWORD PTR $T235763[esp+272]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+284], 5
	call	esi
	push	OFFSET $SG224875
	push	eax
	lea	eax, DWORD PTR $T235764[esp+284]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+296], 6
	call	ebp
	add	esp, 36					; 00000024H
	push	eax
	lea	ecx, DWORD PTR _strBaseString$224866[esp+256]
	mov	BYTE PTR __$EHRec$[esp+264], 7
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T235764[esp+252]
	mov	BYTE PTR __$EHRec$[esp+260], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[esp+260], 5
	lea	ecx, DWORD PTR $T235763[esp+252]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T235762[esp+252]
	mov	BYTE PTR __$EHRec$[esp+260], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T235761[esp+252]
	mov	BYTE PTR __$EHRec$[esp+260], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1438 : 		strOutBuf = strBaseString + strMsg;

	mov	ecx, DWORD PTR _strMsg$[esp+248]
	push	ecx
	lea	edx, DWORD PTR _strBaseString$224866[esp+256]
	push	edx
	lea	eax, DWORD PTR $T235765[esp+260]
	push	eax
	call	esi
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+260], 8
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$224865[esp+256]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T235765[esp+252]
	mov	BYTE PTR __$EHRec$[esp+260], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1439 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$224865[esp+252]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	edi
	call	edx
	add	esp, 8

; 1440 : 	}

	lea	ecx, DWORD PTR _strPlayerName$224867[esp+252]
	mov	BYTE PTR __$EHRec$[esp+260], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strBaseString$224866[esp+252]
	mov	BYTE PTR __$EHRec$[esp+260], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strOutBuf$224865[esp+252]
	mov	DWORD PTR __$EHRec$[esp+260], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	edi
	pop	ebp
	pop	ebx
$LN1@LogOperati@3:

; 1441 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+240]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 236				; 000000ecH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z$0:
	lea	ecx, DWORD PTR _strOutBuf$224865[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z$1:
	lea	ecx, DWORD PTR _strBaseString$224866[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z$2:
	lea	ecx, DWORD PTR _strPlayerName$224867[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z$3:
	lea	ecx, DWORD PTR $T235760[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z$4:
	lea	ecx, DWORD PTR $T235761[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z$5:
	lea	ecx, DWORD PTR $T235762[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z$6:
	lea	ecx, DWORD PTR $T235763[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z$7:
	lea	ecx, DWORD PTR $T235764[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z$8:
	lea	ecx, DWORD PTR $T235765[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z ENDP ; CvAIOperation::LogOperationSpecialMessage
PUBLIC	?LogOperationEnd@CvAIOperation@@QAEXXZ		; CvAIOperation::LogOperationEnd
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?LogOperationEnd@CvAIOperation@@QAEXXZ DD 019930522H
	DD	0cH
	DD	FLAT:__unwindtable$?LogOperationEnd@CvAIOperation@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogOperationEnd@CvAIOperation@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogOperationEnd@CvAIOperation@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogOperationEnd@CvAIOperation@@QAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogOperationEnd@CvAIOperation@@QAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogOperationEnd@CvAIOperation@@QAEXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogOperationEnd@CvAIOperation@@QAEXXZ$4
	DD	03H
	DD	FLAT:__unwindfunclet$?LogOperationEnd@CvAIOperation@@QAEXXZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$?LogOperationEnd@CvAIOperation@@QAEXXZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$?LogOperationEnd@CvAIOperation@@QAEXXZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$?LogOperationEnd@CvAIOperation@@QAEXXZ$8
	DD	03H
	DD	FLAT:__unwindfunclet$?LogOperationEnd@CvAIOperation@@QAEXXZ$9
	DD	03H
	DD	FLAT:__unwindfunclet$?LogOperationEnd@CvAIOperation@@QAEXXZ$10
	DD	0aH
	DD	FLAT:__unwindfunclet$?LogOperationEnd@CvAIOperation@@QAEXXZ$11
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
xdata$x	ENDS
;	COMDAT ?LogOperationEnd@CvAIOperation@@QAEXXZ
_TEXT	SEGMENT
_strTemp$224884 = -268					; size = 28
_pLog$224886 = -240					; size = 4
_strOutBuf$224882 = -236				; size = 28
$T235849 = -208						; size = 28
$T235847 = -208						; size = 28
$T235843 = -208						; size = 28
_strBaseString$224883 = -180				; size = 28
_strPlayerName$224885 = -152				; size = 28
$T235848 = -124						; size = 28
$T235844 = -124						; size = 28
$T235845 = -96						; size = 28
$T235846 = -68						; size = 28
$T235842 = -40						; size = 28
__$EHRec$ = -12						; size = 12
?LogOperationEnd@CvAIOperation@@QAEXXZ PROC		; CvAIOperation::LogOperationEnd, COMDAT
; _this$ = ecx

; 1445 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?LogOperationEnd@CvAIOperation@@QAEXXZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 256				; 00000100H
	push	esi
	mov	esi, ecx

; 1446 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN21@LogOperati@4
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN21@LogOperati@4

; 1447 : 	{
; 1448 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$224882[esp+272]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1449 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$224883[esp+272]
	mov	DWORD PTR __$EHRec$[esp+280], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1450 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$224884[esp+272]
	mov	BYTE PTR __$EHRec$[esp+280], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1451 : 
; 1452 : 		CvString strPlayerName = GET_PLAYER(m_eOwner).getCivilizationShortDescription();

	mov	ecx, DWORD PTR [esi+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	BYTE PTR __$EHRec$[esp+280], 2
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	test	eax, eax
	jne	SHORT $LN50@LogOperati@4
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN50@LogOperati@4:
	push	ebx
	push	ebp
	push	edi
	push	eax
	lea	ecx, DWORD PTR _strPlayerName$224885[esp+288]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	bl, 3
	mov	BYTE PTR __$EHRec$[esp+292], bl

; 1453 : 		FILogFile* pLog = LOGFILEMGR.GetLog(GetLogFileName(strPlayerName), FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	mov	edi, eax
	lea	eax, DWORD PTR _strPlayerName$224885[esp+284]
	push	eax
	lea	ecx, DWORD PTR $T235842[esp+288]
	push	ecx
	mov	ecx, esi
	call	?GetLogFileName@CvAIOperation@@IBE?AVCvString@@AAV2@@Z ; CvAIOperation::GetLogFileName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+292], 4
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [edi]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, edi
	call	eax
	lea	ecx, DWORD PTR $T235842[esp+284]
	mov	DWORD PTR _pLog$224886[esp+284], eax
	mov	BYTE PTR __$EHRec$[esp+292], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1454 : 
; 1455 : 		// Get the leading info for this line
; 1456 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	lea	ecx, DWORD PTR _strBaseString$224883[esp+288]
	push	OFFSET $SG224888
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 1457 : 		strBaseString += strPlayerName + ", " + GetOperationName() + ", ";

	mov	edx, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+132]
	add	esp, 12					; 0000000cH
	lea	eax, DWORD PTR $T235843[esp+284]
	push	eax
	mov	ecx, esi
	call	edx
	mov	ebp, eax
	mov	edi, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	push	OFFSET $SG224894
	lea	eax, DWORD PTR _strPlayerName$224885[esp+288]
	push	eax
	lea	ecx, DWORD PTR $T235844[esp+292]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+304], 5
	call	edi
	push	ebp
	mov	ebp, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	push	eax
	lea	edx, DWORD PTR $T235845[esp+304]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+316], 6
	call	ebp
	push	OFFSET $SG224893
	push	eax
	lea	eax, DWORD PTR $T235846[esp+316]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+328], 7
	call	edi
	add	esp, 36					; 00000024H
	push	eax
	lea	ecx, DWORD PTR _strBaseString$224883[esp+288]
	mov	BYTE PTR __$EHRec$[esp+296], 8
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T235846[esp+284]
	mov	BYTE PTR __$EHRec$[esp+292], 7
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[esp+292], 6
	lea	ecx, DWORD PTR $T235845[esp+284]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T235844[esp+284]
	mov	BYTE PTR __$EHRec$[esp+292], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T235843[esp+284]
	mov	BYTE PTR __$EHRec$[esp+292], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1458 : 
; 1459 : 		strTemp = "Ended, ";

	push	OFFSET $SG224895
	lea	ecx, DWORD PTR _strTemp$224884[esp+288]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 1460 : 
; 1461 : 		switch(m_eAbortReason)

	mov	eax, DWORD PTR [esi+60]
	cmp	eax, 14					; 0000000eH
	ja	SHORT $LN19@LogOperati@4
	jmp	DWORD PTR $LN92@LogOperati@4[eax*4]
$LN18@LogOperati@4:

; 1462 : 		{
; 1463 : 		case AI_ABORT_SUCCESS:
; 1464 : 			strTemp += "Success";

	push	OFFSET $SG224901

; 1465 : 			break;

	jmp	SHORT $LN91@LogOperati@4
$LN17@LogOperati@4:

; 1466 : 		case AI_ABORT_NO_TARGET:
; 1467 : 			strTemp += "No target";

	push	OFFSET $SG224903

; 1468 : 			break;

	jmp	SHORT $LN91@LogOperati@4
$LN16@LogOperati@4:

; 1469 : 		case AI_ABORT_REPEAT_TARGET:
; 1470 : 			strTemp += "Repeat target";

	push	OFFSET $SG224905

; 1471 : 			break;

	jmp	SHORT $LN91@LogOperati@4
$LN15@LogOperati@4:

; 1472 : 		case AI_ABORT_LOST_TARGET:
; 1473 : 			strTemp += "Lost target";

	push	OFFSET $SG224907

; 1474 : 			break;

	jmp	SHORT $LN91@LogOperati@4
$LN14@LogOperati@4:

; 1475 : 		case AI_ABORT_TARGET_ALREADY_CAPTURED:
; 1476 : 			strTemp += "Target already captured";

	push	OFFSET $SG224909

; 1477 : 			break;

	jmp	SHORT $LN91@LogOperati@4
$LN13@LogOperati@4:

; 1478 : 		case AI_ABORT_NO_ROOM_DEPLOY:
; 1479 : 			strTemp += "No room to deploy";

	push	OFFSET $SG224911

; 1480 : 			break;

	jmp	SHORT $LN91@LogOperati@4
$LN12@LogOperati@4:

; 1481 : 		case AI_ABORT_HALF_STRENGTH:
; 1482 : 			strTemp += "Half strength";

	push	OFFSET $SG224913

; 1483 : 			break;

	jmp	SHORT $LN91@LogOperati@4
$LN11@LogOperati@4:

; 1484 : 		case AI_ABORT_NO_MUSTER:
; 1485 : 			strTemp += "No muster point";

	push	OFFSET $SG224915

; 1486 : 			break;

	jmp	SHORT $LN91@LogOperati@4
$LN10@LogOperati@4:

; 1487 : 		case AI_ABORT_LOST_CIVILIAN:
; 1488 : 			strTemp += "Lost civilian";

	push	OFFSET $SG224917

; 1489 : 			break;

	jmp	SHORT $LN91@LogOperati@4
$LN9@LogOperati@4:

; 1490 : 		case AI_ABORT_ESCORT_DIED:
; 1491 : 			strTemp += "Escort died";

	push	OFFSET $SG224919

; 1492 : 			break;

	jmp	SHORT $LN91@LogOperati@4
$LN8@LogOperati@4:

; 1493 : 		case AI_ABORT_NO_NUKES:
; 1494 : 			strTemp += "No nukes";

	push	OFFSET $SG224921

; 1495 : 			break;

	jmp	SHORT $LN91@LogOperati@4
$LN7@LogOperati@4:

; 1496 : 		case AI_ABORT_KILLED:
; 1497 : 			strTemp += "Killed";

	push	OFFSET $SG224923

; 1498 : 			break;

	jmp	SHORT $LN91@LogOperati@4
$LN6@LogOperati@4:

; 1499 : 		case AI_ABORT_WAR_STATE_CHANGE:
; 1500 : 			strTemp += "War State Change";

	push	OFFSET $SG224925

; 1501 : 			break;

	jmp	SHORT $LN91@LogOperati@4
$LN5@LogOperati@4:

; 1502 : 		case AI_ABORT_DIPLO_OPINION_CHANGE:
; 1503 : 			strTemp += "Diplo Opinion Change";

	push	OFFSET $SG224927

; 1504 : 			break;

	jmp	SHORT $LN91@LogOperati@4
$LN4@LogOperati@4:

; 1505 : 		case AI_ABORT_LOST_PATH:
; 1506 : 			strTemp += "Lost Path to Target";

	push	OFFSET $SG224929
$LN91@LogOperati@4:
	lea	ecx, DWORD PTR _strTemp$224884[esp+288]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN19@LogOperati@4:

; 1507 : 			break;
; 1508 : 		}
; 1509 : 
; 1510 : 		strOutBuf = strBaseString + strTemp;

	lea	ecx, DWORD PTR _strTemp$224884[esp+284]
	push	ecx
	lea	edx, DWORD PTR _strBaseString$224883[esp+288]
	push	edx
	lea	eax, DWORD PTR $T235847[esp+292]
	push	eax
	call	ebp
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+292], 9
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$224882[esp+288]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T235847[esp+284]
	mov	BYTE PTR __$EHRec$[esp+292], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1511 : 		pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$224882[esp+284]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR _pLog$224886[esp+284]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx]
	push	ecx
	call	eax

; 1512 : 
; 1513 : 		// Message to summary log?
; 1514 : 		switch (GetOperationType())

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+16]
	add	esp, 8
	mov	ecx, esi
	call	eax
	add	eax, -2					; fffffffeH
	cmp	eax, 16					; 00000010H
	ja	$LN2@LogOperati@4
	movzx	ecx, BYTE PTR $LN89@LogOperati@4[eax]
	jmp	DWORD PTR $LN93@LogOperati@4[ecx*4]
$LN1@LogOperati@4:

; 1515 : 		{
; 1516 : 		case AI_OPERATION_BASIC_CITY_ATTACK:
; 1517 : 		case AI_OPERATION_PILLAGE_ENEMY:
; 1518 : 		case AI_OPERATION_SNEAK_CITY_ATTACK:
; 1519 : 		case AI_OPERATION_SMALL_CITY_ATTACK:
; 1520 : 		case AI_OPERATION_NAVAL_BOMBARDMENT:
; 1521 : 		case AI_OPERATION_NAVAL_SUPERIORITY:
; 1522 : 		case AI_OPERATION_COLONIZE:
; 1523 : 		case AI_OPERATION_NAVAL_ATTACK:
; 1524 : 		case AI_OPERATION_NAVAL_SNEAK_ATTACK:
; 1525 : 		case AI_OPERATION_CITY_STATE_ATTACK:
; 1526 : 		case AI_OPERATION_CITY_STATE_NAVAL_ATTACK:
; 1527 : 		case AI_OPERATION_NUKE_ATTACK:
; 1528 : 		case AI_OPERATION_PURE_NAVAL_CITY_ATTACK:
; 1529 : 			strOutBuf = GetOperationName() + ", ";

	mov	edx, DWORD PTR [esi]
	mov	edx, DWORD PTR [edx+132]
	lea	eax, DWORD PTR $T235848[esp+284]
	push	eax
	mov	ecx, esi
	call	edx
	push	OFFSET $SG224938
	push	eax
	lea	eax, DWORD PTR $T235849[esp+292]
	push	eax
	mov	BYTE PTR __$EHRec$[esp+304], 10		; 0000000aH
	call	edi
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+292], 11		; 0000000bH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$224882[esp+288]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T235849[esp+284]
	mov	BYTE PTR __$EHRec$[esp+292], 10		; 0000000aH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T235848[esp+284]
	mov	BYTE PTR __$EHRec$[esp+292], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1530 : 			strOutBuf += strTemp;

	lea	ecx, DWORD PTR _strTemp$224884[esp+284]
	push	ecx
	lea	ecx, DWORD PTR _strOutBuf$224882[esp+288]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 1531 : 			GET_PLAYER(m_eOwner).GetMilitaryAI()->LogMilitarySummaryMessage(strOutBuf);

	mov	ecx, DWORD PTR [esi+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	edx, DWORD PTR _strOutBuf$224882[esp+284]
	push	edx
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?LogMilitarySummaryMessage@CvMilitaryAI@@QAEXABVCvString@@@Z ; CvMilitaryAI::LogMilitarySummaryMessage
$LN2@LogOperati@4:

; 1532 : 		}
; 1533 : 	}

	lea	ecx, DWORD PTR _strPlayerName$224885[esp+284]
	mov	BYTE PTR __$EHRec$[esp+292], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$224884[esp+284]
	mov	BYTE PTR __$EHRec$[esp+292], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strBaseString$224883[esp+284]
	mov	BYTE PTR __$EHRec$[esp+292], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strOutBuf$224882[esp+284]
	mov	DWORD PTR __$EHRec$[esp+292], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	edi
	pop	ebp
	pop	ebx
$LN21@LogOperati@4:

; 1534 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+272]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 268				; 0000010cH
	ret	0
	npad	2
$LN92@LogOperati@4:
	DD	$LN18@LogOperati@4
	DD	$LN17@LogOperati@4
	DD	$LN16@LogOperati@4
	DD	$LN15@LogOperati@4
	DD	$LN14@LogOperati@4
	DD	$LN13@LogOperati@4
	DD	$LN12@LogOperati@4
	DD	$LN11@LogOperati@4
	DD	$LN10@LogOperati@4
	DD	$LN9@LogOperati@4
	DD	$LN8@LogOperati@4
	DD	$LN7@LogOperati@4
	DD	$LN6@LogOperati@4
	DD	$LN5@LogOperati@4
	DD	$LN4@LogOperati@4
$LN93@LogOperati@4:
	DD	$LN1@LogOperati@4
	DD	$LN2@LogOperati@4
$LN89@LogOperati@4:
	DB	0
	DB	1
	DB	1
	DB	0
	DB	0
	DB	0
	DB	1
	DB	0
	DB	0
	DB	0
	DB	1
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogOperationEnd@CvAIOperation@@QAEXXZ$0:
	lea	ecx, DWORD PTR _strOutBuf$224882[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationEnd@CvAIOperation@@QAEXXZ$1:
	lea	ecx, DWORD PTR _strBaseString$224883[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationEnd@CvAIOperation@@QAEXXZ$2:
	lea	ecx, DWORD PTR _strTemp$224884[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationEnd@CvAIOperation@@QAEXXZ$3:
	lea	ecx, DWORD PTR _strPlayerName$224885[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationEnd@CvAIOperation@@QAEXXZ$4:
	lea	ecx, DWORD PTR $T235842[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationEnd@CvAIOperation@@QAEXXZ$5:
	lea	ecx, DWORD PTR $T235843[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationEnd@CvAIOperation@@QAEXXZ$6:
	lea	ecx, DWORD PTR $T235844[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogOperationEnd@CvAIOperation@@QAEXXZ$7:
	lea	ecx, DWORD PTR $T235845[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogOperationEnd@CvAIOperation@@QAEXXZ$8:
	lea	ecx, DWORD PTR $T235846[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogOperationEnd@CvAIOperation@@QAEXXZ$9:
	lea	ecx, DWORD PTR $T235847[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogOperationEnd@CvAIOperation@@QAEXXZ$10:
	lea	ecx, DWORD PTR $T235848[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogOperationEnd@CvAIOperation@@QAEXXZ$11:
	lea	ecx, DWORD PTR $T235849[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogOperationEnd@CvAIOperation@@QAEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?LogOperationEnd@CvAIOperation@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogOperationEnd@CvAIOperation@@QAEXXZ ENDP		; CvAIOperation::LogOperationEnd
PUBLIC	?SelectInitialMusterPoint@CvAIEnemyTerritoryOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z ; CvAIEnemyTerritoryOperation::SelectInitialMusterPoint
EXTRN	?GetPlotDanger@CvPlayer@@QBEHAAVCvPlot@@@Z:PROC	; CvPlayer::GetPlotDanger
EXTRN	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z:PROC	; CvAStar::GeneratePath
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?SelectInitialMusterPoint@CvAIEnemyTerritoryOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SelectInitialMusterPoint@CvAIEnemyTerritoryOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z$0
__ehfuncinfo$?SelectInitialMusterPoint@CvAIEnemyTerritoryOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SelectInitialMusterPoint@CvAIEnemyTerritoryOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
xdata$x	ENDS
;	COMDAT ?SelectInitialMusterPoint@CvAIEnemyTerritoryOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
_TEXT	SEGMENT
_pMusterPt$ = -56					; size = 4
_iSpacesFromTarget$ = -52				; size = 4
_iDangerousPlots$ = -48					; size = 4
_pDeployPlot$ = -44					; size = 4
_szMsg$225340 = -40					; size = 28
__$EHRec$ = -12						; size = 12
_pThisArmy$ = 8						; size = 4
?SelectInitialMusterPoint@CvAIEnemyTerritoryOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z PROC ; CvAIEnemyTerritoryOperation::SelectInitialMusterPoint, COMDAT
; _this$ = ecx

; 2010 : {

	push	-1
	push	__ehhandler$?SelectInitialMusterPoint@CvAIEnemyTerritoryOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 44					; 0000002cH
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 2011 : 	CvPlot* pMusterPt = NULL;
; 2012 : 	CvPlot* pStartCityPlot;
; 2013 : 	CvCity* pStartCity;
; 2014 : 	CvPlot* pCurrentPlot;
; 2015 : 	int iSpacesFromTarget = 0;
; 2016 : 	CvPlot* pDeployPlot = NULL;
; 2017 : 	int iDangerousPlots = 0;
; 2018 : 
; 2019 : 	pStartCity = GetOperationStartCity();

	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+52]
	xor	ebx, ebx
	mov	DWORD PTR _pMusterPt$[esp+72], ebx
	mov	DWORD PTR _iSpacesFromTarget$[esp+72], ebx
	mov	DWORD PTR _pDeployPlot$[esp+72], ebx
	mov	DWORD PTR _iDangerousPlots$[esp+72], ebx
	call	edx

; 2020 : 	if(pStartCity)

	mov	ebp, DWORD PTR _pThisArmy$[esp+68]
	cmp	eax, ebx
	je	$LN3@SelectInit@2

; 2021 : 	{
; 2022 : 		pStartCityPlot = pStartCity->plot();

	mov	ecx, eax
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	esi, eax

; 2023 : 
; 2024 : 		if(pStartCityPlot != NULL)

	cmp	esi, ebx
	je	$LN3@SelectInit@2

; 2025 : 		{
; 2026 : 			// Different areas?  If so, just muster at start city
; 2027 : 			if (pStartCityPlot->getArea() != pThisArmy->GetGoalPlot()->getArea())

	mov	ebx, DWORD PTR [esi+356]
	mov	ecx, ebp
	call	?GetGoalPlot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::GetGoalPlot
	cmp	ebx, DWORD PTR [eax+356]
	je	SHORT $LN13@SelectInit@2

; 2028 : 			{
; 2029 : 				SetMusterPlot(pStartCityPlot);

	movsx	eax, WORD PTR [esi]
	mov	DWORD PTR [edi+96], eax
	movsx	ecx, WORD PTR [esi+2]
	mov	DWORD PTR [edi+100], ecx
	pop	edi

; 2030 : 				return pStartCityPlot;

	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 2097 : 	}
; 2098 : 
; 2099 : 	return pMusterPt;
; 2100 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	mov	DWORD PTR fs:0, ecx
	add	esp, 56					; 00000038H
	ret	4
$LN13@SelectInit@2:

; 2031 : 			}
; 2032 : 
; 2033 : 			CvAStarNode* pNode;
; 2034 : 
; 2035 : 			// Generate path
; 2036 : 			GC.getStepFinder().SetData(&m_eEnemy);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	lea	ebx, DWORD PTR [edi+76]
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	cmp	BYTE PTR [eax+80], 0
	je	SHORT $LN29@SelectInit@2
	cmp	DWORD PTR [eax+44], ebx
	je	SHORT $LN29@SelectInit@2
	mov	BYTE PTR [eax+78], 1
$LN29@SelectInit@2:

; 2037 : 			if(GC.getStepFinder().GeneratePath(pStartCityPlot->getX(), pStartCityPlot->getY(), pThisArmy->GetGoalPlot()->getX(), pThisArmy->GetGoalPlot()->getY(), m_eOwner, false))

	mov	ecx, ebp
	mov	DWORD PTR [eax+44], ebx
	call	?GetGoalPlot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::GetGoalPlot
	movsx	ebx, WORD PTR [eax+2]
	mov	ecx, ebp
	call	?GetGoalPlot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::GetGoalPlot
	movsx	ecx, WORD PTR [esi+2]
	movsx	edx, WORD PTR [esi]
	mov	esi, DWORD PTR [edi+72]
	movsx	eax, WORD PTR [eax]
	push	0
	push	esi
	push	ebx
	push	eax
	push	ecx
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, eax
	call	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z	; CvAStar::GeneratePath
	test	al, al
	je	$LN83@SelectInit@2

; 2038 : 			{
; 2039 : 				pNode = GC.getStepFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ebx, DWORD PTR [eax+96]

; 2040 : 
; 2041 : 				// Starting at the end, loop until we find a plot from this owner
; 2042 : 				while(pNode != NULL)

	test	ebx, ebx
	je	$LN83@SelectInit@2
$LL11@SelectInit@2:

; 2043 : 				{
; 2044 : 					pCurrentPlot = GC.getMap().plotCheckInvalid(pNode->m_iX, pNode->m_iY);

	movsx	ecx, WORD PTR [ebx+80]
	movsx	edx, WORD PTR [ebx+82]
	cmp	ecx, -2147483647			; 80000001H
	je	SHORT $LN44@SelectInit@2
	cmp	edx, -2147483647			; 80000001H
	je	SHORT $LN44@SelectInit@2
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	eax, DWORD PTR [esi+4020]
	imul	eax, edx
	add	eax, ecx
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [esi+4068]
	mov	esi, eax
	jmp	SHORT $LN46@SelectInit@2
$LN44@SelectInit@2:
	xor	esi, esi
$LN46@SelectInit@2:

; 2045 : 
; 2046 : 					// Is this the deploy point?
; 2047 : 					if(iSpacesFromTarget == GetDeployRange())

	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx+144]
	mov	ecx, edi
	call	eax
	mov	ecx, DWORD PTR _iSpacesFromTarget$[esp+72]
	cmp	ecx, eax
	jne	SHORT $LN80@SelectInit@2

; 2048 : 					{
; 2049 : 						pDeployPlot = pCurrentPlot;

	mov	DWORD PTR _pDeployPlot$[esp+72], esi
$LN80@SelectInit@2:

; 2050 : 					}
; 2051 : 
; 2052 : 					// Check and see if this plot has the right owner
; 2053 : 					if(pCurrentPlot->getOwner() == GetOwner())

	movsx	edx, BYTE PTR [esi+4]
	mov	eax, DWORD PTR [edi+72]
	cmp	edx, eax
	je	SHORT $LN77@SelectInit@2

; 2056 : 						break;
; 2057 : 					}
; 2058 : 
; 2059 : 					else
; 2060 : 					{
; 2061 : 						// Is this a dangerous plot?
; 2062 : 						if(GET_PLAYER(m_eOwner).GetPlotDanger(*pCurrentPlot) > 0)

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	esi
	mov	ecx, eax
	call	?GetPlotDanger@CvPlayer@@QBEHAAVCvPlot@@@Z ; CvPlayer::GetPlotDanger
	test	eax, eax
	jle	SHORT $LN79@SelectInit@2

; 2063 : 						{
; 2064 : 							iDangerousPlots++;

	inc	DWORD PTR _iDangerousPlots$[esp+72]
$LN79@SelectInit@2:

; 2065 : 						}
; 2066 : 					}
; 2067 : 
; 2068 : 					// Move to the previous plot on the path
; 2069 : 					iSpacesFromTarget++;
; 2070 : 					pNode = pNode->m_pParent;

	mov	ebx, DWORD PTR [ebx+24]
	inc	DWORD PTR _iSpacesFromTarget$[esp+72]
	test	ebx, ebx
	jne	$LL11@SelectInit@2

; 2050 : 					}
; 2051 : 
; 2052 : 					// Check and see if this plot has the right owner
; 2053 : 					if(pCurrentPlot->getOwner() == GetOwner())

	mov	ecx, DWORD PTR _iSpacesFromTarget$[esp+72]
	jmp	SHORT $LN10@SelectInit@2
$LN77@SelectInit@2:

; 2054 : 					{
; 2055 : 						pMusterPt = pCurrentPlot;

	mov	DWORD PTR _pMusterPt$[esp+72], esi
$LN10@SelectInit@2:

; 2071 : 				}
; 2072 : 
; 2073 : 				// Is the path safe?  If so, let's just muster at the deploy point
; 2074 : 				if(iSpacesFromTarget > 0 && (iDangerousPlots * 100 / iSpacesFromTarget) < GC.getAI_OPERATIONAL_PERCENT_DANGER_FOR_FORWARD_MUSTER())

	test	ecx, ecx
	jle	SHORT $LN4@SelectInit@2
	mov	eax, DWORD PTR _iDangerousPlots$[esp+72]
	imul	eax, 100				; 00000064H
	cdq
	idiv	ecx
	cmp	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2432
	jge	SHORT $LN4@SelectInit@2

; 2075 : 				{
; 2076 : 					if(pDeployPlot)

	mov	eax, DWORD PTR _pDeployPlot$[esp+72]
	test	eax, eax
	je	SHORT $LN4@SelectInit@2

; 2077 : 					{
; 2078 : 						pMusterPt = pDeployPlot;

	mov	DWORD PTR _pMusterPt$[esp+72], eax
$LN4@SelectInit@2:

; 2079 : 					}
; 2080 : 				}
; 2081 : 			}
; 2082 : 		}
; 2083 : 	}
; 2084 : 
; 2085 : 	if(pMusterPt != NULL)

	cmp	DWORD PTR _pMusterPt$[esp+72], 0
	je	SHORT $LN83@SelectInit@2

; 2086 : 	{
; 2087 : 		SetMusterPlot(pMusterPt);

	mov	eax, DWORD PTR _pMusterPt$[esp+72]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR [edi+96], ecx
	movsx	edx, WORD PTR [eax+2]
	mov	DWORD PTR [edi+100], edx

; 2088 : 	}
; 2089 : 	else

	jmp	SHORT $LN1@SelectInit@2
$LN83@SelectInit@2:
	xor	ebx, ebx
$LN3@SelectInit@2:

; 2090 : 	{
; 2091 : 		if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN1@SelectInit@2
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN1@SelectInit@2

; 2092 : 		{
; 2093 : 			CvString szMsg;

	lea	ecx, DWORD PTR _szMsg$225340[esp+72]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2094 : 			szMsg.Format("No muster point found, Operation aborting, Target was, X: %d, Y: %d", pThisArmy->GetGoalPlot()->getX(), pThisArmy->GetGoalPlot()->getY());

	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+80], ebx
	call	?GetGoalPlot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::GetGoalPlot
	movsx	esi, WORD PTR [eax+2]
	mov	ecx, ebp
	call	?GetGoalPlot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::GetGoalPlot
	movsx	eax, WORD PTR [eax]
	push	esi
	push	eax
	lea	ecx, DWORD PTR _szMsg$225340[esp+80]
	push	OFFSET $SG225341
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 2095 : 			LogOperationSpecialMessage(szMsg);

	lea	edx, DWORD PTR _szMsg$225340[esp+72]
	push	edx
	mov	ecx, edi
	call	?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z ; CvAIOperation::LogOperationSpecialMessage

; 2096 : 		}

	lea	ecx, DWORD PTR _szMsg$225340[esp+72]
	mov	DWORD PTR __$EHRec$[esp+80], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@SelectInit@2:

; 2097 : 	}
; 2098 : 
; 2099 : 	return pMusterPt;
; 2100 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+72]
	mov	eax, DWORD PTR _pMusterPt$[esp+72]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 56					; 00000038H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SelectInitialMusterPoint@CvAIEnemyTerritoryOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z$0:
	lea	ecx, DWORD PTR _szMsg$225340[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?SelectInitialMusterPoint@CvAIEnemyTerritoryOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?SelectInitialMusterPoint@CvAIEnemyTerritoryOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SelectInitialMusterPoint@CvAIEnemyTerritoryOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z ENDP ; CvAIEnemyTerritoryOperation::SelectInitialMusterPoint
PUBLIC	?ArmyInPosition@CvAIOperationBasicCityAttack@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperationBasicCityAttack::ArmyInPosition
EXTRN	?AddTemporaryZone@CvTacticalAI@@QAEXVCvTemporaryZone@@@Z:PROC ; CvTacticalAI::AddTemporaryZone
EXTRN	?GetTacticalAI@CvPlayer@@QBEPAVCvTacticalAI@@XZ:PROC ; CvPlayer::GetTacticalAI
EXTRN	?getGameTurn@CvGame@@QAEHXZ:PROC		; CvGame::getGameTurn
EXTRN	?SetMusteringForAttack@CvDiplomacyAI@@QAEXW4PlayerTypes@@_N@Z:PROC ; CvDiplomacyAI::SetMusteringForAttack
EXTRN	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ:PROC ; CvPlayer::GetDiplomacyAI
; Function compile flags: /Ogtpy
;	COMDAT ?ArmyInPosition@CvAIOperationBasicCityAttack@@UAE_NPAVCvArmyAI@@@Z
_TEXT	SEGMENT
_bStateChanged$ = -21					; size = 1
_zone$225401 = -20					; size = 20
$T236153 = 8						; size = 4
_pArmy$ = 8						; size = 4
?ArmyInPosition@CvAIOperationBasicCityAttack@@UAE_NPAVCvArmyAI@@@Z PROC ; CvAIOperationBasicCityAttack::ArmyInPosition, COMDAT
; _this$ = ecx

; 2215 : {

	sub	esp, 24					; 00000018H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 2216 : 	bool bStateChanged = false;
; 2217 : 
; 2218 : 	switch(m_eCurrentState)

	mov	eax, DWORD PTR [esi+56]
	xor	ebx, ebx
	push	edi
	mov	BYTE PTR _bStateChanged$[esp+40], bl
	cmp	eax, 4
	ja	SHORT $LN46@ArmyInPosi@2
	jmp	DWORD PTR $LN47@ArmyInPosi@2[eax*4]
$LN5@ArmyInPosi@2:

; 2219 : 	{
; 2220 : 		// If we were gathering forces, let's make sure a better target hasn't presented itself
; 2221 : 	case AI_OPERATION_STATE_GATHERING_FORCES:
; 2222 : 	{
; 2223 : 		// First do base case processing
; 2224 : 		bStateChanged = CvAIOperation::ArmyInPosition(pArmy);

	mov	eax, DWORD PTR _pArmy$[esp+36]
	push	eax
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition

; 2225 : 
; 2226 : 		// Is target still under enemy control?
; 2227 : 		CvPlot* pTarget = GetTargetPlot();

	mov	ecx, esi
	mov	BYTE PTR _bStateChanged$[esp+40], al
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot

; 2228 : 		if(pTarget->getOwner() != m_eEnemy)

	movsx	ecx, BYTE PTR [eax+4]
	cmp	ecx, DWORD PTR [esi+76]
	je	SHORT $LN46@ArmyInPosi@2

; 2229 : 		{
; 2230 : 			m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	DWORD PTR [esi+56], ebx

; 2231 : 			m_eAbortReason = AI_ABORT_TARGET_ALREADY_CAPTURED;

	mov	DWORD PTR [esi+60], 4
$LN46@ArmyInPosi@2:

; 2265 : 		break;
; 2266 : 	};
; 2267 : 
; 2268 : 	return bStateChanged;

	mov	al, BYTE PTR _bStateChanged$[esp+40]

; 2269 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	4
$LN3@ArmyInPosi@2:

; 2232 : 		}
; 2233 : 	}
; 2234 : 	break;
; 2235 : 
; 2236 : 	// See if reached our target, if so give control of these units to the tactical AI
; 2237 : 	case AI_OPERATION_STATE_MOVING_TO_TARGET:
; 2238 : 	{
; 2239 : 		CvPlot *pCenterOfMass = pArmy->GetCenterOfMass(DOMAIN_LAND);

	mov	ecx, DWORD PTR _pArmy$[esp+36]
	push	2
	call	?GetCenterOfMass@CvArmyAI@@QAEPAVCvPlot@@W4DomainTypes@@@Z ; CvArmyAI::GetCenterOfMass

; 2240 : 
; 2241 : 		// Are we within tactical range of our target?
; 2242 : 		if(pCenterOfMass && plotDistance(pCenterOfMass->getX(), pCenterOfMass->getY(), m_iTargetX, m_iTargetY) <= GC.getAI_OPERATIONAL_CITY_ATTACK_DEPLOY_RANGE())

	cmp	eax, ebx
	je	SHORT $LN46@ArmyInPosi@2
	mov	edx, DWORD PTR [esi+108]
	mov	ecx, DWORD PTR [esi+104]
	push	edx
	movsx	edx, WORD PTR [eax+2]
	movsx	eax, WORD PTR [eax]
	push	ecx
	push	edx
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2420
	jg	SHORT $LN46@ArmyInPosi@2

; 2243 : 		{
; 2244 : 			// Notify Diplo AI we're in place for attack
; 2245 : 			GET_PLAYER(GetOwner()).GetDiplomacyAI()->SetMusteringForAttack(GetEnemy(), true);

	mov	ecx, DWORD PTR [esi+72]
	mov	eax, DWORD PTR [esi+76]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	1
	push	eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?SetMusteringForAttack@CvDiplomacyAI@@QAEXW4PlayerTypes@@_N@Z ; CvDiplomacyAI::SetMusteringForAttack

; 2246 : 
; 2247 : 			// Notify tactical AI to focus on this area
; 2248 : 			CvTemporaryZone zone;
; 2249 : 			zone.SetX(GetTargetPlot()->getX());

	mov	ecx, esi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	movsx	edi, WORD PTR [eax]

; 2250 : 			zone.SetY(GetTargetPlot()->getY());

	mov	ecx, esi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot

; 2251 : 			zone.SetTargetType(AI_TACTICAL_TARGET_CITY);
; 2252 : 			zone.SetLastTurn(GC.getGame().getGameTurn() + GC.getAI_TACTICAL_MAP_TEMP_ZONE_TURNS());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2452
	movsx	ebp, WORD PTR [eax+2]
	mov	DWORD PTR $T236153[esp+36], ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	ebx, 1
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn

; 2253 : 			GET_PLAYER(m_eOwner).GetTacticalAI()->AddTemporaryZone(zone);

	mov	ecx, DWORD PTR [esi+72]
	add	eax, DWORD PTR $T236153[esp+36]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR [edx], edi
	mov	DWORD PTR [edx+4], ebp
	mov	DWORD PTR [edx+8], ebx
	mov	DWORD PTR [edx+12], eax
	mov	eax, DWORD PTR _zone$225401[esp+76]
	mov	DWORD PTR [edx+16], eax
	call	?GetTacticalAI@CvPlayer@@QBEPAVCvTacticalAI@@XZ ; CvPlayer::GetTacticalAI
	mov	ecx, eax
	call	?AddTemporaryZone@CvTacticalAI@@QAEXVCvTemporaryZone@@@Z ; CvTacticalAI::AddTemporaryZone

; 2265 : 		break;
; 2266 : 	};
; 2267 : 
; 2268 : 	return bStateChanged;

	mov	al, BYTE PTR _bStateChanged$[esp+40]
	mov	DWORD PTR [esi+56], 5

; 2269 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	4
$LN1@ArmyInPosi@2:

; 2254 : 
; 2255 : 			m_eCurrentState = AI_OPERATION_STATE_SUCCESSFUL_FINISH;
; 2256 : 		}
; 2257 : 	}
; 2258 : 	break;
; 2259 : 
; 2260 : 	// In all other cases use base class version
; 2261 : 	case AI_OPERATION_STATE_ABORTED:
; 2262 : 	case AI_OPERATION_STATE_RECRUITING_UNITS:
; 2263 : 	case AI_OPERATION_STATE_AT_TARGET:
; 2264 : 		return CvAIOperation::ArmyInPosition(pArmy);

	mov	ecx, DWORD PTR _pArmy$[esp+36]
	push	ecx
	mov	ecx, esi
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition

; 2269 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	4
	npad	3
$LN47@ArmyInPosi@2:
	DD	$LN1@ArmyInPosi@2
	DD	$LN1@ArmyInPosi@2
	DD	$LN5@ArmyInPosi@2
	DD	$LN3@ArmyInPosi@2
	DD	$LN1@ArmyInPosi@2
?ArmyInPosition@CvAIOperationBasicCityAttack@@UAE_NPAVCvArmyAI@@@Z ENDP ; CvAIOperationBasicCityAttack::ArmyInPosition
_TEXT	ENDS
PUBLIC	?ArmyInPosition@CvAIOperationDestroyBarbarianCamp@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperationDestroyBarbarianCamp::ArmyInPosition
EXTRN	?GetGoalX@CvArmyAI@@QBEHXZ:PROC			; CvArmyAI::GetGoalX
EXTRN	?GetGoalY@CvArmyAI@@QBEHXZ:PROC			; CvArmyAI::GetGoalY
EXTRN	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z:PROC	; CvArmyAI::SetGoalPlot
EXTRN	?GetXPlotsFromEnd@CvStepPathFinder@@QBEPAVCvPlot@@W4PlayerTypes@@0PAV2@1H_N@Z:PROC ; CvStepPathFinder::GetXPlotsFromEnd
EXTRN	?GetArea@CvArmyAI@@QBEHXZ:PROC			; CvArmyAI::GetArea
; Function compile flags: /Ogtpy
;	COMDAT ?ArmyInPosition@CvAIOperationDestroyBarbarianCamp@@UAE_NPAVCvArmyAI@@@Z
_TEXT	SEGMENT
_bStateChanged$ = -21					; size = 1
_zone$225498 = -20					; size = 20
$T236241 = 8						; size = 4
$T236182 = 8						; size = 4
_pArmy$ = 8						; size = 4
?ArmyInPosition@CvAIOperationDestroyBarbarianCamp@@UAE_NPAVCvArmyAI@@@Z PROC ; CvAIOperationDestroyBarbarianCamp::ArmyInPosition, COMDAT
; _this$ = ecx

; 2388 : {

	sub	esp, 24					; 00000018H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 2389 : 	bool bStateChanged = false;
; 2390 : 
; 2391 : 	switch(m_eCurrentState)

	mov	eax, DWORD PTR [esi+56]
	push	edi
	mov	BYTE PTR _bStateChanged$[esp+40], 0
	cmp	eax, 4
	ja	SHORT $LN57@ArmyInPosi@3
	jmp	DWORD PTR $LN58@ArmyInPosi@3[eax*4]
$LN10@ArmyInPosi@3:

; 2392 : 	{
; 2393 : 		// If we were gathering forces, let's make sure a better target hasn't presented itself
; 2394 : 	case AI_OPERATION_STATE_GATHERING_FORCES:
; 2395 : 	{
; 2396 : 		// First do base case processing
; 2397 : 		bStateChanged = CvAIOperation::ArmyInPosition(pArmy);

	mov	ebp, DWORD PTR _pArmy$[esp+36]
	push	ebp
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition
	mov	BYTE PTR _bStateChanged$[esp+40], al

; 2398 : 
; 2399 : 		// Now revisit target
; 2400 : 		CvPlot* possibleBetterTarget;
; 2401 : 		possibleBetterTarget = FindBestTarget();

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+148]
	mov	ecx, esi
	call	edx
	mov	edi, eax

; 2402 : 
; 2403 : 		// If no target left, abort
; 2404 : 		if(possibleBetterTarget == NULL)

	test	edi, edi
	jne	SHORT $LN9@ArmyInPosi@3

; 2405 : 		{
; 2406 : 			m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	DWORD PTR [esi+56], eax

; 2407 : 			m_eAbortReason = AI_ABORT_LOST_TARGET;

	mov	DWORD PTR [esi+60], 3
$LN57@ArmyInPosi@3:

; 2457 : 		break;
; 2458 : 	};
; 2459 : 
; 2460 : 	return bStateChanged;

	mov	al, BYTE PTR _bStateChanged$[esp+40]

; 2461 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	4
$LN9@ArmyInPosi@3:

; 2408 : 		}
; 2409 : 
; 2410 : 		// If target changed, reset to this new one
; 2411 : 		else if(possibleBetterTarget != GetTargetPlot())

	mov	ecx, esi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	cmp	edi, eax
	je	SHORT $LN57@ArmyInPosi@3

; 2412 : 		{
; 2413 : 			// If we're traveling on a single continent, set our destination to be a few plots shy of the final target
; 2414 : 			if (pArmy->GetArea() == possibleBetterTarget->getArea())

	mov	ebx, DWORD PTR [edi+356]
	mov	ecx, ebp
	call	?GetArea@CvArmyAI@@QBEHXZ		; CvArmyAI::GetArea
	cmp	eax, ebx
	jne	SHORT $LN6@ArmyInPosi@3

; 2415 : 			{
; 2416 : 				CvPlot* pDeployPt = GC.getStepFinder().GetXPlotsFromEnd(GetOwner(), GetEnemy(), pArmy->Plot(), possibleBetterTarget, GC.getAI_OPERATIONAL_BARBARIAN_CAMP_DEPLOY_RANGE(), false);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2416
	mov	eax, DWORD PTR [esi+72]
	mov	ebx, DWORD PTR [esi+76]
	push	0
	push	ecx
	push	edi
	mov	ecx, ebp
	mov	DWORD PTR $T236182[esp+48], eax
	call	?Plot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::Plot
	mov	edx, DWORD PTR $T236182[esp+48]
	push	eax
	push	ebx
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, eax
	call	?GetXPlotsFromEnd@CvStepPathFinder@@QBEPAVCvPlot@@W4PlayerTypes@@0PAV2@1H_N@Z ; CvStepPathFinder::GetXPlotsFromEnd

; 2417 : 				if(pDeployPt != NULL)

	test	eax, eax
	je	SHORT $LN57@ArmyInPosi@3

; 2418 : 				{
; 2419 : 					pArmy->SetGoalPlot(pDeployPt);

	push	eax
	mov	ecx, ebp
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 2420 : 					SetTargetPlot(possibleBetterTarget);

	movsx	eax, WORD PTR [edi]
	mov	DWORD PTR [esi+104], eax
	movsx	ecx, WORD PTR [edi+2]

; 2457 : 		break;
; 2458 : 	};
; 2459 : 
; 2460 : 	return bStateChanged;

	mov	al, BYTE PTR _bStateChanged$[esp+40]
	mov	DWORD PTR [esi+108], ecx

; 2461 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	4
$LN6@ArmyInPosi@3:

; 2421 : 				}
; 2422 : 			}
; 2423 : 
; 2424 : 			// Coming in from the sea. Just head to the camp
; 2425 : 			else
; 2426 : 			{
; 2427 : 				pArmy->SetGoalPlot(possibleBetterTarget);

	push	edi
	mov	ecx, ebp
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 2428 : 				SetTargetPlot(possibleBetterTarget);

	movsx	edx, WORD PTR [edi]
	mov	DWORD PTR [esi+104], edx
	movsx	eax, WORD PTR [edi+2]
	mov	DWORD PTR [esi+108], eax

; 2457 : 		break;
; 2458 : 	};
; 2459 : 
; 2460 : 	return bStateChanged;

	mov	al, BYTE PTR _bStateChanged$[esp+40]

; 2461 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	4
$LN3@ArmyInPosi@3:

; 2429 : 			}
; 2430 : 		}
; 2431 : 	}
; 2432 : 	break;
; 2433 : 
; 2434 : 	// See if reached our target, if so give control of these units to the tactical AI
; 2435 : 	case AI_OPERATION_STATE_MOVING_TO_TARGET:
; 2436 : 	{
; 2437 : 		if (plotDistance(pArmy->GetX(), pArmy->GetY(), pArmy->GetGoalX(), pArmy->GetGoalY()) <= 1)

	mov	edi, DWORD PTR _pArmy$[esp+36]
	mov	ecx, edi
	call	?GetGoalY@CvArmyAI@@QBEHXZ		; CvArmyAI::GetGoalY
	push	eax
	mov	ecx, edi
	call	?GetGoalX@CvArmyAI@@QBEHXZ		; CvArmyAI::GetGoalX
	push	eax
	mov	ecx, edi
	call	?GetY@CvArmyAI@@QBEHXZ			; CvArmyAI::GetY
	push	eax
	mov	ecx, edi
	call	?GetX@CvArmyAI@@QBEHXZ			; CvArmyAI::GetX
	push	eax
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, 1
	jg	$LN57@ArmyInPosi@3

; 2438 : 		{
; 2439 : 			// Notify tactical AI to focus on this area
; 2440 : 			CvTemporaryZone zone;
; 2441 : 			zone.SetX(GetTargetPlot()->getX());

	mov	ecx, esi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	movsx	edi, WORD PTR [eax]

; 2442 : 			zone.SetY(GetTargetPlot()->getY());

	mov	ecx, esi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot

; 2443 : 			zone.SetTargetType(AI_TACTICAL_TARGET_BARBARIAN_CAMP);
; 2444 : 			zone.SetLastTurn(GC.getGame().getGameTurn() + GC.getAI_TACTICAL_MAP_TEMP_ZONE_TURNS());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2452
	movsx	ebp, WORD PTR [eax+2]
	mov	DWORD PTR $T236241[esp+36], ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	ebx, 2
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn

; 2445 : 			GET_PLAYER(m_eOwner).GetTacticalAI()->AddTemporaryZone(zone);

	mov	ecx, DWORD PTR [esi+72]
	add	eax, DWORD PTR $T236241[esp+36]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR [edx], edi
	mov	DWORD PTR [edx+4], ebp
	mov	DWORD PTR [edx+8], ebx
	mov	DWORD PTR [edx+12], eax
	mov	eax, DWORD PTR _zone$225498[esp+76]
	mov	DWORD PTR [edx+16], eax
	call	?GetTacticalAI@CvPlayer@@QBEPAVCvTacticalAI@@XZ ; CvPlayer::GetTacticalAI
	mov	ecx, eax
	call	?AddTemporaryZone@CvTacticalAI@@QAEXVCvTemporaryZone@@@Z ; CvTacticalAI::AddTemporaryZone

; 2457 : 		break;
; 2458 : 	};
; 2459 : 
; 2460 : 	return bStateChanged;

	mov	al, BYTE PTR _bStateChanged$[esp+40]
	mov	DWORD PTR [esi+56], 5

; 2461 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	4
$LN1@ArmyInPosi@3:

; 2446 : 
; 2447 : 			m_eCurrentState = AI_OPERATION_STATE_SUCCESSFUL_FINISH;
; 2448 : 		}
; 2449 : 	}
; 2450 : 	break;
; 2451 : 
; 2452 : 	// In all other cases use base class version
; 2453 : 	case AI_OPERATION_STATE_ABORTED:
; 2454 : 	case AI_OPERATION_STATE_RECRUITING_UNITS:
; 2455 : 	case AI_OPERATION_STATE_AT_TARGET:
; 2456 : 		return CvAIOperation::ArmyInPosition(pArmy);

	mov	ecx, DWORD PTR _pArmy$[esp+36]
	push	ecx
	mov	ecx, esi
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition

; 2461 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	4
	npad	1
$LN58@ArmyInPosi@3:
	DD	$LN1@ArmyInPosi@3
	DD	$LN1@ArmyInPosi@3
	DD	$LN10@ArmyInPosi@3
	DD	$LN3@ArmyInPosi@3
	DD	$LN1@ArmyInPosi@3
?ArmyInPosition@CvAIOperationDestroyBarbarianCamp@@UAE_NPAVCvArmyAI@@@Z ENDP ; CvAIOperationDestroyBarbarianCamp::ArmyInPosition
_TEXT	ENDS
PUBLIC	?FindBestTarget@CvAIOperationDestroyBarbarianCamp@@MAEPAVCvPlot@@XZ ; CvAIOperationDestroyBarbarianCamp::FindBestTarget
EXTRN	?getRevealedImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@W4TeamTypes@@@Z:PROC ; CvPlot::getRevealedImprovementType
EXTRN	?GetOriginalOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ:PROC ; CvUnit::GetOriginalOwner
; Function compile flags: /Ogtpy
;	COMDAT ?FindBestTarget@CvAIOperationDestroyBarbarianCamp@@MAEPAVCvPlot@@XZ
_TEXT	SEGMENT
_pBestPlot$ = -32					; size = 4
$T236272 = -28						; size = 4
tv404 = -24						; size = 4
_pStartCity$ = -20					; size = 4
_iPlotLoop$ = -16					; size = 4
_BarbPlayer$225549 = -16				; size = 4
_iLoop$225552 = -12					; size = 4
tv395 = -8						; size = 4
_eBarbCamp$ = -4					; size = 4
?FindBestTarget@CvAIOperationDestroyBarbarianCamp@@MAEPAVCvPlot@@XZ PROC ; CvAIOperationDestroyBarbarianCamp::FindBestTarget, COMDAT
; _this$ = ecx

; 2536 : {

	sub	esp, 32					; 00000020H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 2537 : #ifdef AUI_WARNING_FIXES
; 2538 : 	uint iPlotLoop;
; 2539 : #else
; 2540 : 	int iPlotLoop;
; 2541 : #endif
; 2542 : 	CvPlot* pBestPlot = NULL;
; 2543 : 	CvPlot* pPlot;
; 2544 : 	int iBestPlotDistance = MAX_INT;
; 2545 : 	int iCurPlotDistance;
; 2546 : 
; 2547 : 	m_bCivilianRescue = false;
; 2548 : 
; 2549 : 	TeamTypes eTeam = GET_PLAYER(m_eOwner).getTeam();

	mov	eax, DWORD PTR [edi+72]
	imul	eax, 63236				; 0000f704H
	mov	BYTE PTR [edi+112], 0
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [eax+ecx+44]
	xor	esi, esi
	mov	DWORD PTR _pBestPlot$[esp+48], esi
	mov	ebx, 2147483647				; 7fffffffH
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN23@FindBestTa@3
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR $T236272[esp+48], edx
	jmp	SHORT $LN24@FindBestTa@3
$LN23@FindBestTa@3:
	mov	DWORD PTR $T236272[esp+48], -1
$LN24@FindBestTa@3:

; 2550 : 	ImprovementTypes eBarbCamp = (ImprovementTypes) GC.getBARBARIAN_CAMP_IMPROVEMENT();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8548

; 2551 : 
; 2552 : 	CvCity* pStartCity;
; 2553 : 	pStartCity = GetOperationStartCity();

	mov	edx, DWORD PTR [edi]
	mov	DWORD PTR _eBarbCamp$[esp+48], eax
	mov	eax, DWORD PTR [edx+52]
	mov	ecx, edi
	call	eax
	mov	ebp, eax
	mov	DWORD PTR _pStartCity$[esp+48], ebp

; 2554 : 	if(pStartCity != NULL)

	test	ebp, ebp
	je	$LN55@FindBestTa@3

; 2555 : 	{
; 2556 : 
; 2557 : 		// look for good captured civilians of ours (settlers and workers, not missionaries) 
; 2558 : 		// these will be even more important than just a camp
; 2559 : 		// btw - the AI will cheat here - as a human I would use a combination of memory and intuition to find these, since our current AI has neither of these...
; 2560 : 		CvPlayerAI& BarbPlayer = GET_PLAYER(BARBARIAN_PLAYER);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 2561 : 
; 2562 : 		CvUnit* pLoopUnit = NULL;
; 2563 : 		int iLoop;
; 2564 : 		for (pLoopUnit = BarbPlayer.firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = BarbPlayer.nextUnit(&iLoop))

	push	0
	lea	edx, DWORD PTR _iLoop$225552[esp+52]
	add	ecx, 3983868				; 003cc9fcH
	push	edx
	mov	DWORD PTR _BarbPlayer$225549[esp+56], ecx
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LN13@FindBestTa@3

; 2575 : 				}
; 2576 : 			}
; 2577 : 		}
; 2578 : 
; 2579 : 		if (!pBestPlot)

	mov	eax, DWORD PTR _pBestPlot$[esp+48]
$LN61@FindBestTa@3:

; 2580 : 		{
; 2581 : 			// Look at map for Barbarian camps
; 2582 : 			for (iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	DWORD PTR [edx+4028], 0
	mov	DWORD PTR _iPlotLoop$[esp+48], 0
	jle	$LN4@FindBestTa@3
	mov	ebp, DWORD PTR $T236272[esp+48]
	shr	ebp, 5

; 2585 : 
; 2586 : 				if (pPlot->isRevealed(eTeam))

	mov	ecx, ebp
	shl	ecx, 5
	mov	eax, ecx
	mov	ecx, DWORD PTR $T236272[esp+48]
	sub	ecx, eax
	mov	eax, 1
	shl	eax, cl
	mov	DWORD PTR tv404[esp+48], 0
	mov	DWORD PTR tv395[esp+48], eax
	jmp	$LN6@FindBestTa@3
	npad	9
$LL58@FindBestTa@3:

; 2561 : 
; 2562 : 		CvUnit* pLoopUnit = NULL;
; 2563 : 		int iLoop;
; 2564 : 		for (pLoopUnit = BarbPlayer.firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = BarbPlayer.nextUnit(&iLoop))

	mov	ebp, DWORD PTR _pStartCity$[esp+48]
$LN13@FindBestTa@3:

; 2565 : 		{
; 2566 : 			if (pLoopUnit->GetOriginalOwner() == m_eOwner && (pLoopUnit->AI_getUnitAIType() == UNITAI_SETTLE || pLoopUnit->AI_getUnitAIType() == UNITAI_WORKER || pLoopUnit->AI_getUnitAIType() == UNITAI_ARCHAEOLOGIST))

	mov	ecx, esi
	call	?GetOriginalOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ ; CvUnit::GetOriginalOwner
	cmp	eax, DWORD PTR [edi+72]
	jne	SHORT $LN12@FindBestTa@3
	mov	ecx, esi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 1
	je	SHORT $LN9@FindBestTa@3
	mov	ecx, esi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 2
	je	SHORT $LN9@FindBestTa@3
	mov	ecx, esi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 39					; 00000027H
	jne	SHORT $LN12@FindBestTa@3
$LN9@FindBestTa@3:

; 2567 : 			{
; 2568 : 				iCurPlotDistance = GC.getStepFinder().GetStepDistanceBetweenPoints(m_eOwner, m_eEnemy, pLoopUnit->plot(), pStartCity->plot());

	mov	ecx, ebp
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, DWORD PTR [edi+72]
	push	eax
	mov	eax, DWORD PTR [edi+76]
	push	eax
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, eax
	call	?GetStepDistanceBetweenPoints@CvStepPathFinder@@QAEHW4PlayerTypes@@0PAVCvPlot@@1@Z ; CvStepPathFinder::GetStepDistanceBetweenPoints
	mov	ebp, eax

; 2569 : 				if (iCurPlotDistance < iBestPlotDistance)

	cmp	ebp, ebx
	jge	SHORT $LN12@FindBestTa@3

; 2570 : 				{
; 2571 : 					pBestPlot = pLoopUnit->plot();

	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot

; 2572 : 					iBestPlotDistance = iCurPlotDistance;
; 2573 : 					m_bCivilianRescue = true;

	mov	BYTE PTR [edi+112], 1

; 2574 : 					m_iUnitToRescue = pLoopUnit->GetID();

	mov	edx, DWORD PTR [esi+100]
	mov	DWORD PTR _pBestPlot$[esp+48], eax
	mov	ebx, ebp
	mov	DWORD PTR [edi+116], edx
$LN12@FindBestTa@3:
	mov	ecx, DWORD PTR _BarbPlayer$225549[esp+48]
	push	0
	lea	eax, DWORD PTR _iLoop$225552[esp+52]
	push	eax
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	esi, eax
	test	esi, esi
	jne	$LL58@FindBestTa@3

; 2575 : 				}
; 2576 : 			}
; 2577 : 		}
; 2578 : 
; 2579 : 		if (!pBestPlot)

	mov	eax, DWORD PTR _pBestPlot$[esp+48]
	test	eax, eax
	jne	$LN4@FindBestTa@3
	jmp	$LN61@FindBestTa@3
	npad	11
$LL59@FindBestTa@3:

; 2580 : 		{
; 2581 : 			// Look at map for Barbarian camps
; 2582 : 			for (iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)

	mov	eax, DWORD PTR tv395[esp+48]
$LN6@FindBestTa@3:

; 2583 : 			{
; 2584 : 				pPlot = GC.getMap().plotByIndexUnchecked(iPlotLoop);

	mov	esi, DWORD PTR [edx+4068]
	add	esi, DWORD PTR tv404[esp+48]

; 2585 : 
; 2586 : 				if (pPlot->isRevealed(eTeam))

	test	DWORD PTR [esi+ebp*4+8], eax
	je	SHORT $LN5@FindBestTa@3

; 2587 : 				{
; 2588 : 					if (pPlot->getRevealedImprovementType(eTeam) == eBarbCamp)

	mov	ecx, DWORD PTR $T236272[esp+48]
	push	ecx
	mov	ecx, esi
	call	?getRevealedImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@W4TeamTypes@@@Z ; CvPlot::getRevealedImprovementType
	cmp	eax, DWORD PTR _eBarbCamp$[esp+48]
	jne	SHORT $LN5@FindBestTa@3

; 2589 : 					{
; 2590 : 						// Make sure camp is in the same area as our start city
; 2591 : 						//if (pPlot->getArea() == pStartCity->getArea())
; 2592 : 						{
; 2593 : 							iCurPlotDistance = GC.getStepFinder().GetStepDistanceBetweenPoints(m_eOwner, m_eEnemy, pPlot, pStartCity->plot());

	mov	ecx, DWORD PTR _pStartCity$[esp+48]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	edx, DWORD PTR [edi+76]
	push	eax
	mov	eax, DWORD PTR [edi+72]
	push	esi
	push	edx
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, eax
	call	?GetStepDistanceBetweenPoints@CvStepPathFinder@@QAEHW4PlayerTypes@@0PAVCvPlot@@1@Z ; CvStepPathFinder::GetStepDistanceBetweenPoints

; 2594 : 
; 2595 : 							if (iCurPlotDistance < iBestPlotDistance)

	cmp	eax, ebx
	jge	SHORT $LN5@FindBestTa@3

; 2596 : 							{
; 2597 : 								pBestPlot = pPlot;

	mov	DWORD PTR _pBestPlot$[esp+48], esi

; 2598 : 								iBestPlotDistance = iCurPlotDistance;

	mov	ebx, eax
$LN5@FindBestTa@3:
	mov	eax, DWORD PTR _iPlotLoop$[esp+48]
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	DWORD PTR tv404[esp+48], 484		; 000001e4H
	inc	eax
	cmp	eax, DWORD PTR [edx+4028]
	mov	DWORD PTR _iPlotLoop$[esp+48], eax
	jl	SHORT $LL59@FindBestTa@3

; 2599 : 							}
; 2600 : 						}
; 2601 : 					}
; 2602 : 				}
; 2603 : 			}
; 2604 : 		}
; 2605 : 
; 2606 : 	}
; 2607 : 
; 2608 : 	return pBestPlot;

	mov	eax, DWORD PTR _pBestPlot$[esp+48]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2609 : }

	add	esp, 32					; 00000020H
	ret	0
$LN55@FindBestTa@3:

; 2599 : 							}
; 2600 : 						}
; 2601 : 					}
; 2602 : 				}
; 2603 : 			}
; 2604 : 		}
; 2605 : 
; 2606 : 	}
; 2607 : 
; 2608 : 	return pBestPlot;

	mov	eax, esi
$LN4@FindBestTa@3:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2609 : }

	add	esp, 32					; 00000020H
	ret	0
?FindBestTarget@CvAIOperationDestroyBarbarianCamp@@MAEPAVCvPlot@@XZ ENDP ; CvAIOperationDestroyBarbarianCamp::FindBestTarget
_TEXT	ENDS
PUBLIC	?ArmyMoved@CvAIOperationPillageEnemy@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperationPillageEnemy::ArmyMoved
; Function compile flags: /Ogtpy
;	COMDAT ?ArmyMoved@CvAIOperationPillageEnemy@@UAE_NPAVCvArmyAI@@@Z
_TEXT	SEGMENT
_pArmy$ = 8						; size = 4
?ArmyMoved@CvAIOperationPillageEnemy@@UAE_NPAVCvArmyAI@@@Z PROC ; CvAIOperationPillageEnemy::ArmyMoved, COMDAT
; _this$ = ecx

; 2655 : {

	push	esi
	mov	esi, ecx

; 2656 : 	bool bStateChanged = false;
; 2657 : 	CvPlot* pBetterTarget;
; 2658 : 
; 2659 : 	switch(m_eCurrentState)

	mov	eax, DWORD PTR [esi+56]
	cmp	eax, 4
	ja	$LN6@ArmyMoved
	jmp	DWORD PTR $LN25@ArmyMoved[eax*4]
$LN5@ArmyMoved:

; 2660 : 	{
; 2661 : 	case AI_OPERATION_STATE_MOVING_TO_TARGET:
; 2662 : 	{
; 2663 : 		// Find best pillage target
; 2664 : 		pBetterTarget = FindBestTarget();

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+148]
	push	edi
	call	edx
	mov	edi, eax

; 2665 : 
; 2666 : 		// No targets at all!  Abort
; 2667 : 		if(pBetterTarget == NULL)

	test	edi, edi
	jne	SHORT $LN4@ArmyMoved

; 2668 : 		{
; 2669 : 			m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	DWORD PTR [esi+56], eax
	pop	edi

; 2670 : 			m_eAbortReason = AI_ABORT_NO_TARGET;

	mov	DWORD PTR [esi+60], 1

; 2683 : 		}
; 2684 : 	}
; 2685 : 	break;
; 2686 : 
; 2687 : 	// In all other cases use base class version
; 2688 : 	case AI_OPERATION_STATE_AT_TARGET:
; 2689 : 	case AI_OPERATION_STATE_RECRUITING_UNITS:
; 2690 : 	case AI_OPERATION_STATE_GATHERING_FORCES:
; 2691 : 	case AI_OPERATION_STATE_ABORTED:
; 2692 : 		return CvAIOperation::ArmyMoved(pArmy);
; 2693 : 		break;
; 2694 : 	};
; 2695 : 
; 2696 : 	return bStateChanged;

	xor	al, al
	pop	esi

; 2697 : }

	ret	4
$LN4@ArmyMoved:

; 2671 : 		}
; 2672 : 
; 2673 : 		// If this is a new target, switch to it
; 2674 : 		else if(pBetterTarget != GetTargetPlot())

	mov	ecx, esi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	cmp	edi, eax
	je	SHORT $LN24@ArmyMoved

; 2675 : 		{
; 2676 : 			SetTargetPlot(pBetterTarget);

	movsx	eax, WORD PTR [edi]
	push	ebx

; 2677 : 			pArmy->SetGoalPlot(pBetterTarget);

	mov	ebx, DWORD PTR _pArmy$[esp+8]
	mov	DWORD PTR [esi+104], eax
	movsx	ecx, WORD PTR [edi+2]
	push	ebp
	mov	DWORD PTR [esi+108], ecx
	push	edi
	mov	ecx, ebx
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 2678 : 
; 2679 : 			// Reset our destination to be a few plots shy of the final target
; 2680 : 			CvPlot* pDeployPt;
; 2681 : 			pDeployPt = GC.getStepFinder().GetXPlotsFromEnd(GetOwner(), GetEnemy(), pArmy->Plot(), pBetterTarget, GC.getAI_OPERATIONAL_PILLAGE_ENEMY_DEPLOY_RANGE(), false);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2424
	mov	ebp, DWORD PTR [esi+76]
	mov	esi, DWORD PTR [esi+72]
	push	0
	push	edx
	push	edi
	mov	ecx, ebx
	call	?Plot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::Plot
	push	eax
	push	ebp
	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, eax
	call	?GetXPlotsFromEnd@CvStepPathFinder@@QBEPAVCvPlot@@W4PlayerTypes@@0PAV2@1H_N@Z ; CvStepPathFinder::GetXPlotsFromEnd

; 2682 : 			pArmy->SetGoalPlot(pDeployPt);

	push	eax
	mov	ecx, ebx
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot
	pop	ebp
	pop	ebx
$LN24@ArmyMoved:
	pop	edi
$LN6@ArmyMoved:

; 2683 : 		}
; 2684 : 	}
; 2685 : 	break;
; 2686 : 
; 2687 : 	// In all other cases use base class version
; 2688 : 	case AI_OPERATION_STATE_AT_TARGET:
; 2689 : 	case AI_OPERATION_STATE_RECRUITING_UNITS:
; 2690 : 	case AI_OPERATION_STATE_GATHERING_FORCES:
; 2691 : 	case AI_OPERATION_STATE_ABORTED:
; 2692 : 		return CvAIOperation::ArmyMoved(pArmy);
; 2693 : 		break;
; 2694 : 	};
; 2695 : 
; 2696 : 	return bStateChanged;

	xor	al, al
	pop	esi

; 2697 : }

	ret	4
	npad	2
$LN25@ArmyMoved:
	DD	$LN6@ArmyMoved
	DD	$LN6@ArmyMoved
	DD	$LN6@ArmyMoved
	DD	$LN5@ArmyMoved
	DD	$LN6@ArmyMoved
?ArmyMoved@CvAIOperationPillageEnemy@@UAE_NPAVCvArmyAI@@@Z ENDP ; CvAIOperationPillageEnemy::ArmyMoved
_TEXT	ENDS
PUBLIC	?ArmyInPosition@CvAIOperationPillageEnemy@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperationPillageEnemy::ArmyInPosition
; Function compile flags: /Ogtpy
;	COMDAT ?ArmyInPosition@CvAIOperationPillageEnemy@@UAE_NPAVCvArmyAI@@@Z
_TEXT	SEGMENT
_pArmy$ = 8						; size = 4
?ArmyInPosition@CvAIOperationPillageEnemy@@UAE_NPAVCvArmyAI@@@Z PROC ; CvAIOperationPillageEnemy::ArmyInPosition, COMDAT
; _this$ = ecx

; 2701 : {

	push	ebx
	push	esi
	mov	esi, ecx

; 2702 : 	bool bStateChanged = false;
; 2703 : 
; 2704 : 	switch(m_eCurrentState)

	mov	eax, DWORD PTR [esi+56]
	xor	bl, bl
	cmp	eax, 4
	ja	SHORT $LN4@ArmyInPosi@4
	jmp	DWORD PTR $LN8@ArmyInPosi@4[eax*4]
$LN3@ArmyInPosi@4:
	push	ebp
	push	edi

; 2705 : 	{
; 2706 : 		// See if reached our target, if so give control of these units to the tactical AI
; 2707 : 	case AI_OPERATION_STATE_MOVING_TO_TARGET:
; 2708 : 	{
; 2709 : 		if(pArmy->Plot() == pArmy->GetGoalPlot())

	mov	edi, DWORD PTR _pArmy$[esp+12]
	mov	ecx, edi
	call	?Plot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::Plot
	mov	ecx, edi
	mov	ebp, eax
	call	?GetGoalPlot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::GetGoalPlot
	pop	edi
	cmp	ebp, eax
	pop	ebp
	jne	SHORT $LN4@ArmyInPosi@4

; 2710 : 		{
; 2711 : 			m_eCurrentState = AI_OPERATION_STATE_SUCCESSFUL_FINISH;

	mov	DWORD PTR [esi+56], 5
	pop	esi

; 2722 : 		break;
; 2723 : 	};
; 2724 : 
; 2725 : 	return bStateChanged;

	mov	al, bl
	pop	ebx

; 2726 : }

	ret	4
$LN1@ArmyInPosi@4:

; 2712 : 		}
; 2713 : 	}
; 2714 : 	break;
; 2715 : 
; 2716 : 	// In all other cases use base class version
; 2717 : 	case AI_OPERATION_STATE_GATHERING_FORCES:
; 2718 : 	case AI_OPERATION_STATE_ABORTED:
; 2719 : 	case AI_OPERATION_STATE_RECRUITING_UNITS:
; 2720 : 	case AI_OPERATION_STATE_AT_TARGET:
; 2721 : 		bStateChanged = CvAIOperation::ArmyInPosition(pArmy);

	mov	eax, DWORD PTR _pArmy$[esp+4]
	push	eax
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition
	mov	bl, al
$LN4@ArmyInPosi@4:
	pop	esi

; 2722 : 		break;
; 2723 : 	};
; 2724 : 
; 2725 : 	return bStateChanged;

	mov	al, bl
	pop	ebx

; 2726 : }

	ret	4
	npad	2
$LN8@ArmyInPosi@4:
	DD	$LN1@ArmyInPosi@4
	DD	$LN1@ArmyInPosi@4
	DD	$LN1@ArmyInPosi@4
	DD	$LN3@ArmyInPosi@4
	DD	$LN1@ArmyInPosi@4
?ArmyInPosition@CvAIOperationPillageEnemy@@UAE_NPAVCvArmyAI@@@Z ENDP ; CvAIOperationPillageEnemy::ArmyInPosition
_TEXT	ENDS
PUBLIC	?FindBestTarget@CvAIOperationPillageEnemy@@MAEPAVCvPlot@@XZ ; CvAIOperationPillageEnemy::FindBestTarget
EXTRN	?countNumImprovedPlots@CvCity@@QBEHW4ImprovementTypes@@_N@Z:PROC ; CvCity::countNumImprovedPlots
; Function compile flags: /Ogtpy
;	COMDAT ?FindBestTarget@CvAIOperationPillageEnemy@@MAEPAVCvPlot@@XZ
_TEXT	SEGMENT
_iBestValue$ = -16					; size = 4
_pBestTargetCity$ = -12					; size = 4
_iLoop$ = -8						; size = 4
_kEnemyPlayer$ = -4					; size = 4
?FindBestTarget@CvAIOperationPillageEnemy@@MAEPAVCvPlot@@XZ PROC ; CvAIOperationPillageEnemy::FindBestTarget, COMDAT
; _this$ = ecx

; 2730 : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	mov	ebx, ecx

; 2731 : 	CvCity* pBestTargetCity = NULL;
; 2732 : 	int iValue;
; 2733 : 	int iBestValue;
; 2734 : 	CvCity* pLoopCity;
; 2735 : 	CvCity* pStartCity;
; 2736 : 	int iDistance;
; 2737 : 	int iLoop;
; 2738 : 
; 2739 : 	CvPlayerAI& kEnemyPlayer = GET_PLAYER(m_eEnemy);

	mov	esi, DWORD PTR [ebx+76]
	imul	esi, 63236				; 0000f704H
	add	esi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edi
	xor	edi, edi

; 2740 : 
; 2741 : 	if(!kEnemyPlayer.isAlive())

	cmp	BYTE PTR [esi+2256], 0
	mov	DWORD PTR _pBestTargetCity$[esp+28], edi
	mov	DWORD PTR _kEnemyPlayer$[esp+28], esi
	jne	SHORT $LN10@FindBestTa@4
	pop	edi
	pop	esi

; 2742 : 	{
; 2743 : 		return NULL;

	xor	eax, eax
	pop	ebx

; 2781 : 	}
; 2782 : }

	add	esp, 16					; 00000010H
	ret	0
$LN10@FindBestTa@4:

; 2744 : 	}
; 2745 : 
; 2746 : 	iBestValue = 0;
; 2747 : 	pStartCity = GetOperationStartCity();

	mov	eax, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax+52]
	push	ebp
	mov	DWORD PTR _iBestValue$[esp+32], edi
	call	edx
	mov	ebp, eax

; 2748 : 	if(pStartCity != NULL)

	cmp	ebp, edi
	je	$LN21@FindBestTa@4

; 2749 : 	{
; 2750 : 		for(pLoopCity = kEnemyPlayer.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = kEnemyPlayer.nextCity(&iLoop))

	push	edi
	lea	eax, DWORD PTR _iLoop$[esp+36]
	push	eax
	mov	ecx, esi
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	esi, eax
	cmp	esi, edi
	je	$LN21@FindBestTa@4
$LL8@FindBestTa@4:

; 2751 : 		{
; 2752 : 			// Make sure city is in the same area as our start city
; 2753 : 			if(pLoopCity->getArea() == pStartCity->getArea())

	mov	ecx, esi
	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea
	mov	ecx, ebp
	mov	edi, eax
	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea
	cmp	edi, eax
	jne	SHORT $LN7@FindBestTa@4

; 2754 : 			{
; 2755 : 				// Initial value of target is the number of improved plots
; 2756 : 				iValue = pLoopCity->countNumImprovedPlots();

	push	0
	push	-1
	mov	ecx, esi
	call	?countNumImprovedPlots@CvCity@@QBEHW4ImprovementTypes@@_N@Z ; CvCity::countNumImprovedPlots

; 2757 : 
; 2758 : 				// Adjust value based on proximity to our start location
; 2759 : 				iDistance = GC.getStepFinder().GetStepDistanceBetweenPoints(m_eOwner, m_eEnemy, pLoopCity->plot(), pStartCity->plot());

	mov	ecx, ebp
	mov	edi, eax
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	mov	ecx, esi
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	ecx, DWORD PTR [ebx+76]
	mov	edx, DWORD PTR [ebx+72]
	push	eax
	push	ecx
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, eax
	call	?GetStepDistanceBetweenPoints@CvStepPathFinder@@QAEHW4PlayerTypes@@0PAVCvPlot@@1@Z ; CvStepPathFinder::GetStepDistanceBetweenPoints
	mov	ecx, eax

; 2760 : 				if(iDistance > 0)

	test	ecx, ecx
	jle	SHORT $LN4@FindBestTa@4

; 2761 : 				{
; 2762 : 					iValue = iValue * 100 / iDistance;

	mov	eax, edi
	imul	eax, 100				; 00000064H
	cdq
	idiv	ecx
	mov	edi, eax
$LN4@FindBestTa@4:

; 2763 : 				}
; 2764 : 
; 2765 : 				if(iValue > iBestValue)

	cmp	edi, DWORD PTR _iBestValue$[esp+32]
	jle	SHORT $LN7@FindBestTa@4

; 2766 : 				{
; 2767 : 					iBestValue = iValue;

	mov	DWORD PTR _iBestValue$[esp+32], edi

; 2768 : 					pBestTargetCity = pLoopCity;

	mov	DWORD PTR _pBestTargetCity$[esp+32], esi
$LN7@FindBestTa@4:
	mov	ecx, DWORD PTR _kEnemyPlayer$[esp+32]
	push	0
	lea	eax, DWORD PTR _iLoop$[esp+36]
	push	eax
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL8@FindBestTa@4

; 2769 : 				}
; 2770 : 			}
; 2771 : 		}
; 2772 : 	}
; 2773 : 
; 2774 : 	if(pBestTargetCity == NULL)

	mov	ecx, DWORD PTR _pBestTargetCity$[esp+32]
	test	ecx, ecx
	jne	SHORT $LN2@FindBestTa@4
$LN21@FindBestTa@4:
	pop	ebp
	pop	edi
	pop	esi

; 2775 : 	{
; 2776 : 		return NULL;

	xor	eax, eax
	pop	ebx

; 2781 : 	}
; 2782 : }

	add	esp, 16					; 00000010H
	ret	0
$LN2@FindBestTa@4:

; 2777 : 	}
; 2778 : 	else
; 2779 : 	{
; 2780 : 		return pBestTargetCity->plot();

	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	pop	ebp
	pop	edi
	pop	esi
	pop	ebx

; 2781 : 	}
; 2782 : }

	add	esp, 16					; 00000010H
	ret	0
?FindBestTarget@CvAIOperationPillageEnemy@@MAEPAVCvPlot@@XZ ENDP ; CvAIOperationPillageEnemy::FindBestTarget
_TEXT	ENDS
PUBLIC	?RetargetCivilian@CvAIEscortedOperation@@QAE_NPAVCvUnit@@PAVCvArmyAI@@@Z ; CvAIEscortedOperation::RetargetCivilian
; Function compile flags: /Ogtpy
;	COMDAT ?RetargetCivilian@CvAIEscortedOperation@@QAE_NPAVCvUnit@@PAVCvArmyAI@@@Z
_TEXT	SEGMENT
_pCivilian$ = 8						; size = 4
_pArmy$ = 12						; size = 4
?RetargetCivilian@CvAIEscortedOperation@@QAE_NPAVCvUnit@@PAVCvArmyAI@@@Z PROC ; CvAIEscortedOperation::RetargetCivilian, COMDAT
; _this$ = ecx

; 2990 : {

	push	esi
	mov	esi, ecx

; 2991 : 	CvPlot* pBetterTarget;
; 2992 : 
; 2993 : 	// Find best city site (taking into account whether or not we are escorted)
; 2994 : 	pBetterTarget = FindBestTarget(pCivilian, !m_bEscorted);

	cmp	BYTE PTR [esi+112], 0
	mov	eax, DWORD PTR [esi]
	sete	cl
	movzx	edx, cl
	mov	ecx, DWORD PTR _pCivilian$[esp]
	push	edi
	push	edx
	mov	edx, DWORD PTR [eax+148]
	push	ecx
	mov	ecx, esi
	call	edx
	mov	edi, eax

; 2995 : 
; 2996 : 	// No targets at all!  Abort
; 2997 : 	if(pBetterTarget == NULL)

	test	edi, edi
	jne	SHORT $LN4@RetargetCi

; 2998 : 	{
; 2999 : 		m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	DWORD PTR [esi+56], eax
	pop	edi

; 3000 : 		m_eAbortReason = AI_ABORT_NO_TARGET;

	mov	DWORD PTR [esi+60], 1

; 3012 : 		return false;

	xor	al, al
	pop	esi

; 3019 : }

	ret	8
$LN4@RetargetCi:

; 3001 : 		return false;
; 3002 : 	}
; 3003 : 	// If this is a new target, switch to it
; 3004 : 	else if(pBetterTarget != GetTargetPlot())

	mov	ecx, esi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	cmp	edi, eax
	je	SHORT $LN2@RetargetCi

; 3005 : 	{
; 3006 : 		SetTargetPlot(pBetterTarget);

	movsx	eax, WORD PTR [edi]
	mov	DWORD PTR [esi+104], eax
	movsx	ecx, WORD PTR [edi+2]

; 3007 : 		pArmy->SetGoalPlot(pBetterTarget);

	push	edi
	mov	edi, DWORD PTR _pArmy$[esp+8]
	mov	DWORD PTR [esi+108], ecx
	mov	ecx, edi
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 3013 : 	}
; 3014 : 
; 3015 : 	pArmy->SetArmyAIState(ARMYAISTATE_MOVING_TO_DESTINATION);

	push	2
	mov	ecx, edi
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState
	pop	edi

; 3016 : 	m_eCurrentState = AI_OPERATION_STATE_MOVING_TO_TARGET;

	mov	DWORD PTR [esi+56], 3

; 3017 : 
; 3018 : 	return true;

	mov	al, 1
	pop	esi

; 3019 : }

	ret	8
$LN2@RetargetCi:

; 3008 : 	}
; 3009 : 	else
; 3010 : 	{
; 3011 : 		SetToAbort(AI_ABORT_REPEAT_TARGET);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+76]
	push	2
	mov	ecx, esi
	call	eax
	pop	edi

; 3012 : 		return false;

	xor	al, al
	pop	esi

; 3019 : }

	ret	8
?RetargetCivilian@CvAIEscortedOperation@@QAE_NPAVCvUnit@@PAVCvArmyAI@@@Z ENDP ; CvAIEscortedOperation::RetargetCivilian
_TEXT	ENDS
PUBLIC	?ArmyInPosition@CvAIOperationFoundCity@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperationFoundCity::ArmyInPosition
EXTRN	?finishMoves@CvUnit@@QAEXXZ:PROC		; CvUnit::finishMoves
EXTRN	?getTotalFoundValue@CvArea@@QBEHXZ:PROC		; CvArea::getTotalFoundValue
EXTRN	?getName@CvCity@@QBE?BVCvString@@XZ:PROC	; CvCity::getName
EXTRN	?area@CvPlot@@QBEPAVCvArea@@XZ:PROC		; CvPlot::area
EXTRN	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z:PROC ; CvUnit::PushMission
EXTRN	?getMISSION_FOUND@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_FOUND
EXTRN	?GetSettlerSiteEvaluator@CvGame@@QAEPAVCvSiteEvaluatorForSettler@@XZ:PROC ; CvGame::GetSettlerSiteEvaluator
EXTRN	?canFound@CvUnit@@QBE_NPBVCvPlot@@_N@Z:PROC	; CvUnit::canFound
EXTRN	?canMove@CvUnit@@QBE_NXZ:PROC			; CvUnit::canMove
EXTRN	?IsAdjacentOwnedByOtherTeam@CvPlot@@QBE_NW4TeamTypes@@@Z:PROC ; CvPlot::IsAdjacentOwnedByOtherTeam
EXTRN	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ:PROC	; CvUnit::getTeam
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?ArmyInPosition@CvAIOperationFoundCity@@UAE_NPAVCvArmyAI@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ArmyInPosition@CvAIOperationFoundCity@@UAE_NPAVCvArmyAI@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ArmyInPosition@CvAIOperationFoundCity@@UAE_NPAVCvArmyAI@@@Z$1
__ehfuncinfo$?ArmyInPosition@CvAIOperationFoundCity@@UAE_NPAVCvArmyAI@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ArmyInPosition@CvAIOperationFoundCity@@UAE_NPAVCvArmyAI@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
xdata$x	ENDS
;	COMDAT ?ArmyInPosition@CvAIOperationFoundCity@@UAE_NPAVCvArmyAI@@@Z
_TEXT	SEGMENT
_bStateChanged$ = -73					; size = 1
_iPlotValue$225790 = -72				; size = 4
_strMsg$ = -68						; size = 28
$T236417 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_pArea$225792 = 8					; size = 4
_pArmy$ = 8						; size = 4
?ArmyInPosition@CvAIOperationFoundCity@@UAE_NPAVCvArmyAI@@@Z PROC ; CvAIOperationFoundCity::ArmyInPosition, COMDAT
; _this$ = ecx

; 3151 : {

	push	-1
	push	__ehhandler$?ArmyInPosition@CvAIOperationFoundCity@@UAE_NPAVCvArmyAI@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi

; 3152 : 	int iUnitID = 0;
; 3153 : 	bool bStateChanged = false;
; 3154 : 	CvUnit* pSettler = 0, *pEscort = 0;
; 3155 : 	CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$[esp+92]
	mov	BYTE PTR _bStateChanged$[esp+92], 0
	xor	ebx, ebx
	xor	edi, edi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3156 : 
; 3157 : 	switch(m_eCurrentState)

	mov	eax, DWORD PTR [esi+56]
	mov	DWORD PTR __$EHRec$[esp+100], ebx
	cmp	eax, 4
	ja	$LN95@ArmyInPosi@5
	jmp	DWORD PTR $LN100@ArmyInPosi@5[eax*4]
$LN26@ArmyInPosi@5:

; 3158 : 	{
; 3159 : 		// If we were gathering forces, we have to insist that any escort is in the same plot as the settler.
; 3160 : 		// If not we'll fall through and just stay in this state.
; 3161 : 	case AI_OPERATION_STATE_GATHERING_FORCES:
; 3162 : 
; 3163 : 		// No escort, can just let base class handle it
; 3164 : 		if(!m_bEscorted)

	cmp	BYTE PTR [esi+112], 0
	jne	SHORT $LN25@ArmyInPosi@5

; 3165 : 		{
; 3166 : 			return CvAIOperation::ArmyInPosition(pArmy);

	mov	eax, DWORD PTR _pArmy$[esp+88]
	push	eax
	mov	ecx, esi
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition
	lea	ecx, DWORD PTR _strMsg$[esp+92]
	mov	bl, al
	mov	DWORD PTR __$EHRec$[esp+100], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebp
	mov	al, bl
	pop	ebx

; 3294 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+76]
	mov	DWORD PTR fs:0, ecx
	add	esp, 76					; 0000004cH
	ret	4
$LN25@ArmyInPosi@5:

; 3167 : 		}
; 3168 : 
; 3169 : 		// More complex if we are waiting for an escort
; 3170 : 		else
; 3171 : 		{
; 3172 : 			iUnitID = pArmy->GetFirstUnitID();

	mov	ebp, DWORD PTR _pArmy$[esp+88]
	mov	ecx, ebp
	call	?GetFirstUnitID@CvArmyAI@@QAEHXZ	; CvArmyAI::GetFirstUnitID

; 3173 : 			if(iUnitID != -1)

	cmp	eax, -1
	je	SHORT $LN23@ArmyInPosi@5

; 3174 : 			{
; 3175 : 				pSettler = GET_PLAYER(m_eOwner).getUnit(iUnitID);

	mov	ecx, DWORD PTR [esi+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
$LN23@ArmyInPosi@5:

; 3176 : 			}
; 3177 : 			iUnitID = pArmy->GetNextUnitID();

	mov	ecx, ebp
	call	?GetNextUnitID@CvArmyAI@@QAEHXZ		; CvArmyAI::GetNextUnitID

; 3178 : 			if(iUnitID != -1)

	cmp	eax, -1
	je	$LN22@ArmyInPosi@5

; 3179 : 			{
; 3180 : 				pEscort = GET_PLAYER(m_eOwner).getUnit(iUnitID);

	mov	ecx, DWORD PTR [esi+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit

; 3188 : 			}
; 3189 : 			if(pSettler != NULL && pEscort != NULL && pSettler->plot() == pEscort->plot())

	cmp	edi, ebx
	je	$LN95@ArmyInPosi@5
	cmp	eax, ebx
	je	$LN95@ArmyInPosi@5
	mov	ecx, eax
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, edi
	mov	ebx, eax
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	eax, ebx
	jne	$LN95@ArmyInPosi@5

; 3190 : 			{
; 3191 : 				// let's see if the target still makes sense (this is modified from RetargetCivilian)
; 3192 : 				CvPlot* pBetterTarget = FindBestTarget(pSettler, true);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+148]
	push	1
	push	edi
	mov	ecx, esi
	call	eax

; 3193 : 
; 3194 : 				// No targets at all!  Abort
; 3195 : 				if(pBetterTarget == NULL)

	test	eax, eax
	jne	SHORT $LN19@ArmyInPosi@5

; 3196 : 				{
; 3197 : 					m_eCurrentState = AI_OPERATION_STATE_ABORTED;
; 3198 : 					m_eAbortReason = AI_ABORT_NO_TARGET;
; 3199 : 					return false;

	lea	ecx, DWORD PTR _strMsg$[esp+92]
	mov	DWORD PTR [esi+56], eax
	mov	DWORD PTR [esi+60], 1
	mov	DWORD PTR __$EHRec$[esp+100], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebp
	xor	al, al
	pop	ebx

; 3294 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+76]
	mov	DWORD PTR fs:0, ecx
	add	esp, 76					; 0000004cH
	ret	4
$LN19@ArmyInPosi@5:

; 3200 : 				}
; 3201 : 				// If we have a target
; 3202 : 				else
; 3203 : 				{
; 3204 : 					SetTargetPlot(pBetterTarget);

	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR [esi+104], ecx
	movsx	edx, WORD PTR [eax+2]

; 3205 : 					pArmy->SetGoalPlot(pBetterTarget);

	push	eax
	mov	ecx, ebp
	mov	DWORD PTR [esi+108], edx
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 3206 : 				}
; 3207 : 				return CvAIOperation::ArmyInPosition(pArmy);

	push	ebp
	mov	ecx, esi
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition
	lea	ecx, DWORD PTR _strMsg$[esp+92]
	mov	bl, al
	mov	DWORD PTR __$EHRec$[esp+100], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebp
	mov	al, bl
	pop	ebx

; 3294 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+76]
	mov	DWORD PTR fs:0, ecx
	add	esp, 76					; 0000004cH
	ret	4
$LN22@ArmyInPosi@5:

; 3181 : 			}
; 3182 : 			else
; 3183 : 			{
; 3184 : 				// Escort died while gathering forces.  Abort (and return TRUE since state changed)
; 3185 : 				m_eCurrentState = AI_OPERATION_STATE_ABORTED;
; 3186 : 				m_eAbortReason = AI_ABORT_ESCORT_DIED;
; 3187 : 				return true;

	lea	ecx, DWORD PTR _strMsg$[esp+92]
	mov	DWORD PTR [esi+56], ebx
	mov	DWORD PTR [esi+60], 9
	mov	DWORD PTR __$EHRec$[esp+100], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebp
	mov	al, 1
	pop	ebx

; 3294 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+76]
	mov	DWORD PTR fs:0, ecx
	add	esp, 76					; 0000004cH
	ret	4
$LN17@ArmyInPosi@5:

; 3208 : 			}
; 3209 : 		}
; 3210 : 		break;
; 3211 : 
; 3212 : 	case AI_OPERATION_STATE_MOVING_TO_TARGET:
; 3213 : 	case AI_OPERATION_STATE_AT_TARGET:
; 3214 : 
; 3215 : 		// Call base class version and see if it thinks we're done
; 3216 : 		bStateChanged = CvAIOperation::ArmyInPosition(pArmy);

	mov	ebp, DWORD PTR _pArmy$[esp+88]
	push	ebp
	mov	ecx, esi
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition

; 3217 : 
; 3218 : 		// Now get the settler
; 3219 : 		iUnitID = pArmy->GetFirstUnitID();

	mov	ecx, ebp
	mov	BYTE PTR _bStateChanged$[esp+92], al
	call	?GetFirstUnitID@CvArmyAI@@QAEHXZ	; CvArmyAI::GetFirstUnitID

; 3220 : 		if(iUnitID != -1)

	cmp	eax, -1
	je	$LN95@ArmyInPosi@5

; 3221 : 		{
; 3222 : 			pSettler = GET_PLAYER(m_eOwner).getUnit(iUnitID);

	mov	ecx, DWORD PTR [esi+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax

; 3223 : 		}
; 3224 : 
; 3225 : 		if(pSettler != NULL)

	cmp	edi, ebx
	je	$LN95@ArmyInPosi@5

; 3226 : 		{
; 3227 : 			if((GetTargetPlot()->getOwner() != NO_PLAYER && GetTargetPlot()->getOwner() != m_eOwner) || GetTargetPlot()->IsAdjacentOwnedByOtherTeam(pSettler->getTeam()))

	mov	ecx, esi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	cmp	BYTE PTR [eax+4], -1
	je	SHORT $LN12@ArmyInPosi@5
	mov	ecx, esi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	movsx	eax, BYTE PTR [eax+4]
	cmp	eax, DWORD PTR [esi+72]
	jne	SHORT $LN13@ArmyInPosi@5
$LN12@ArmyInPosi@5:
	mov	ecx, edi
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	push	eax
	mov	ecx, esi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	mov	ecx, eax
	call	?IsAdjacentOwnedByOtherTeam@CvPlot@@QBE_NW4TeamTypes@@@Z ; CvPlot::IsAdjacentOwnedByOtherTeam
	test	al, al
	je	SHORT $LN14@ArmyInPosi@5
$LN13@ArmyInPosi@5:

; 3228 : 			{
; 3229 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN3@ArmyInPosi@5
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN3@ArmyInPosi@5

; 3230 : 				{
; 3231 : 					strMsg.Format("Now at target but can no longer settle here. Target was (X=%d Y=%d)", GetTargetPlot()->getX(), GetTargetPlot()->getY());

	mov	ecx, esi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	movsx	ebx, WORD PTR [eax+2]
	mov	ecx, esi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	movsx	eax, WORD PTR [eax]
	push	ebx
	push	eax
	lea	ecx, DWORD PTR _strMsg$[esp+100]
	push	OFFSET $SG225785
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3232 : 					LogOperationSpecialMessage(strMsg);

	lea	edx, DWORD PTR _strMsg$[esp+92]
	push	edx

; 3233 : 				}
; 3234 : 				RetargetCivilian(pSettler, pArmy);
; 3235 : 				pSettler->finishMoves();
; 3236 : 				iUnitID = pArmy->GetNextUnitID();
; 3237 : 				if(iUnitID != -1)
; 3238 : 				{
; 3239 : 					pEscort = GET_PLAYER(m_eOwner).getUnit(iUnitID);
; 3240 : 					pEscort->finishMoves();
; 3241 : 				}
; 3242 : 			}

	jmp	$LN99@ArmyInPosi@5
$LN14@ArmyInPosi@5:

; 3243 : 			// If the settler made it, we don't care about the entire army
; 3244 : 			else if(pSettler->plot() == GetTargetPlot() && pSettler->canMove() && pSettler->canFound(pSettler->plot()))

	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, esi
	mov	ebx, eax
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	cmp	ebx, eax
	jne	$LN8@ArmyInPosi@5
	mov	ecx, edi
	call	?canMove@CvUnit@@QBE_NXZ		; CvUnit::canMove
	test	al, al
	je	$LN8@ArmyInPosi@5
	push	0
	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, edi
	call	?canFound@CvUnit@@QBE_NPBVCvPlot@@_N@Z	; CvUnit::canFound
	test	al, al
	je	$LN8@ArmyInPosi@5

; 3245 : 			{
; 3246 : 				CvPlot* pCityPlot = pSettler->plot();

	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot

; 3247 : 				int iPlotValue = GC.getGame().GetSettlerSiteEvaluator()->PlotFoundValue(pCityPlot, &GET_PLAYER(m_eOwner), NO_YIELD, false);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	ebp, eax
	call	?GetSettlerSiteEvaluator@CvGame@@QAEPAVCvSiteEvaluatorForSettler@@XZ ; CvGame::GetSettlerSiteEvaluator
	mov	edx, DWORD PTR [esi+72]
	mov	ebx, DWORD PTR [eax]
	imul	edx, 63236				; 0000f704H
	add	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	push	-1
	push	edx
	mov	ecx, eax
	mov	eax, DWORD PTR [ebx+12]
	push	ebp
	call	eax

; 3248 : 
; 3249 : 				pSettler->PushMission(CvTypes::getMISSION_FOUND());

	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	mov	DWORD PTR _iPlotValue$225790[esp+124], eax
	call	?getMISSION_FOUND@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_FOUND
	push	eax
	mov	ecx, edi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3250 : 
; 3251 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN6@ArmyInPosi@5
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN6@ArmyInPosi@5

; 3252 : 				{
; 3253 : 					CvArea* pArea = pCityPlot->area();

	mov	ecx, ebp
	call	?area@CvPlot@@QBEPAVCvArea@@XZ		; CvPlot::area

; 3254 : 					CvCity* pCity = pCityPlot->getPlotCity();

	mov	ecx, ebp
	mov	DWORD PTR _pArea$225792[esp+88], eax
	call	?getPlotCity@CvPlot@@QBEPAVCvCity@@XZ	; CvPlot::getPlotCity

; 3255 : 
; 3256 : 					if (pCity != NULL)

	test	eax, eax
	je	SHORT $LN6@ArmyInPosi@5

; 3257 : 					{
; 3258 : 						strMsg.Format("City founded, At X=%d, At Y=%d, %s, %d, %d", pCityPlot->getX(), pCityPlot->getY(), pCity->getName().GetCString(), iPlotValue, pArea->getTotalFoundValue());

	lea	ecx, DWORD PTR $T236417[esp+92]
	push	ecx
	mov	ecx, eax
	call	?getName@CvCity@@QBE?BVCvString@@XZ	; CvCity::getName
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+100], 1
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	movsx	ebx, WORD PTR [ebp+2]
	mov	ecx, DWORD PTR _pArea$225792[esp+88]
	movsx	ebp, WORD PTR [ebp]
	mov	edi, eax
	call	?getTotalFoundValue@CvArea@@QBEHXZ	; CvArea::getTotalFoundValue
	mov	edx, DWORD PTR _iPlotValue$225790[esp+92]
	push	eax
	push	edx
	push	edi
	push	ebx
	push	ebp
	lea	eax, DWORD PTR _strMsg$[esp+112]
	push	OFFSET $SG225796
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 28					; 0000001cH
	lea	ecx, DWORD PTR $T236417[esp+92]
	mov	BYTE PTR __$EHRec$[esp+100], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3259 : 						LogOperationSpecialMessage(strMsg);

	lea	ecx, DWORD PTR _strMsg$[esp+92]
	push	ecx
	mov	ecx, esi
	call	?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z ; CvAIOperation::LogOperationSpecialMessage
$LN6@ArmyInPosi@5:

; 3260 : 					}
; 3261 : 				}
; 3262 : 				m_eCurrentState = AI_OPERATION_STATE_SUCCESSFUL_FINISH;

	mov	DWORD PTR [esi+56], 5
$LN95@ArmyInPosi@5:

; 3290 : 		break;
; 3291 : 	};
; 3292 : 
; 3293 : 	return bStateChanged;

	lea	ecx, DWORD PTR _strMsg$[esp+92]
	mov	DWORD PTR __$EHRec$[esp+100], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR _bStateChanged$[esp+92]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3294 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+76]
	mov	DWORD PTR fs:0, ecx
	add	esp, 76					; 0000004cH
	ret	4
$LN8@ArmyInPosi@5:

; 3263 : 			}
; 3264 : 
; 3265 : 			// If we're at our target but can no longer found a city, might be someone else beat us to this area
; 3266 : 			// So move back out, picking a new target
; 3267 : 			else if(pSettler->plot() == GetTargetPlot() && !pSettler->canFound(pSettler->plot()))

	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, esi
	mov	ebx, eax
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	cmp	ebx, eax
	jne	SHORT $LN95@ArmyInPosi@5
	push	0
	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, edi
	call	?canFound@CvUnit@@QBE_NPBVCvPlot@@_N@Z	; CvUnit::canFound
	test	al, al
	jne	SHORT $LN95@ArmyInPosi@5

; 3268 : 			{
; 3269 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN3@ArmyInPosi@5
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN3@ArmyInPosi@5

; 3270 : 				{
; 3271 : 					strMsg.Format("At target but can no longer settle here. Target was (X=%d Y=%d)", GetTargetPlot()->getX(), GetTargetPlot()->getY());

	mov	ecx, esi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	movsx	ebx, WORD PTR [eax+2]
	mov	ecx, esi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	movsx	edx, WORD PTR [eax]
	push	ebx
	push	edx
	lea	eax, DWORD PTR _strMsg$[esp+100]
	push	OFFSET $SG225800
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3272 : 					LogOperationSpecialMessage(strMsg);

	lea	ecx, DWORD PTR _strMsg$[esp+92]
	push	ecx
$LN99@ArmyInPosi@5:
	mov	ecx, esi
	call	?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z ; CvAIOperation::LogOperationSpecialMessage
$LN3@ArmyInPosi@5:

; 3273 : 				}
; 3274 : 				RetargetCivilian(pSettler, pArmy);

	push	ebp
	push	edi
	mov	ecx, esi
	call	?RetargetCivilian@CvAIEscortedOperation@@QAE_NPAVCvUnit@@PAVCvArmyAI@@@Z ; CvAIEscortedOperation::RetargetCivilian

; 3275 : 				pSettler->finishMoves();

	mov	ecx, edi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 3276 : 				iUnitID = pArmy->GetNextUnitID();

	mov	ecx, ebp
	call	?GetNextUnitID@CvArmyAI@@QAEHXZ		; CvArmyAI::GetNextUnitID

; 3277 : 				if(iUnitID != -1)

	cmp	eax, -1
	je	$LN95@ArmyInPosi@5

; 3278 : 				{
; 3279 : 					pEscort = GET_PLAYER(m_eOwner).getUnit(iUnitID);

	mov	ecx, DWORD PTR [esi+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit

; 3280 : 					pEscort->finishMoves();

	mov	ecx, eax
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 3281 : 				}
; 3282 : 			}
; 3283 : 		}
; 3284 : 		break;

	jmp	$LN95@ArmyInPosi@5
$LN1@ArmyInPosi@5:

; 3285 : 
; 3286 : 		// In all other cases use base class version
; 3287 : 	case AI_OPERATION_STATE_ABORTED:
; 3288 : 	case AI_OPERATION_STATE_RECRUITING_UNITS:
; 3289 : 		return CvAIOperation::ArmyInPosition(pArmy);

	mov	edx, DWORD PTR _pArmy$[esp+88]
	push	edx
	mov	ecx, esi
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition
	lea	ecx, DWORD PTR _strMsg$[esp+92]
	mov	bl, al
	mov	DWORD PTR __$EHRec$[esp+100], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3294 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+92]
	pop	edi
	pop	esi
	pop	ebp
	mov	al, bl
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 76					; 0000004cH
	ret	4
	npad	2
$LN100@ArmyInPosi@5:
	DD	$LN1@ArmyInPosi@5
	DD	$LN1@ArmyInPosi@5
	DD	$LN26@ArmyInPosi@5
	DD	$LN17@ArmyInPosi@5
	DD	$LN17@ArmyInPosi@5
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ArmyInPosition@CvAIOperationFoundCity@@UAE_NPAVCvArmyAI@@@Z$0:
	lea	ecx, DWORD PTR _strMsg$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ArmyInPosition@CvAIOperationFoundCity@@UAE_NPAVCvArmyAI@@@Z$1:
	lea	ecx, DWORD PTR $T236417[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ArmyInPosition@CvAIOperationFoundCity@@UAE_NPAVCvArmyAI@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ArmyInPosition@CvAIOperationFoundCity@@UAE_NPAVCvArmyAI@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ArmyInPosition@CvAIOperationFoundCity@@UAE_NPAVCvArmyAI@@@Z ENDP ; CvAIOperationFoundCity::ArmyInPosition
PUBLIC	?ArmyInPosition@CvAIOperationMerchantDelegation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperationMerchantDelegation::ArmyInPosition
EXTRN	?getMISSION_TRADE@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_TRADE
EXTRN	?getMISSION_BUY_CITY_STATE@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_BUY_CITY_STATE
EXTRN	?GreatMerchantWantsCash@CvPlayerAI@@QAE_NXZ:PROC ; CvPlayerAI::GreatMerchantWantsCash
EXTRN	?canBuyCityState@CvUnit@@QBE_NPBVCvPlot@@_N@Z:PROC ; CvUnit::canBuyCityState
EXTRN	?canTrade@CvUnit@@QBE_NPBVCvPlot@@_N@Z:PROC	; CvUnit::canTrade
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?ArmyInPosition@CvAIOperationMerchantDelegation@@UAE_NPAVCvArmyAI@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ArmyInPosition@CvAIOperationMerchantDelegation@@UAE_NPAVCvArmyAI@@@Z$0
__ehfuncinfo$?ArmyInPosition@CvAIOperationMerchantDelegation@@UAE_NPAVCvArmyAI@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ArmyInPosition@CvAIOperationMerchantDelegation@@UAE_NPAVCvArmyAI@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
xdata$x	ENDS
;	COMDAT ?ArmyInPosition@CvAIOperationMerchantDelegation@@UAE_NPAVCvArmyAI@@@Z
_TEXT	SEGMENT
_bStateChanged$ = -41					; size = 1
_strMsg$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
_pArmy$ = 8						; size = 4
?ArmyInPosition@CvAIOperationMerchantDelegation@@UAE_NPAVCvArmyAI@@@Z PROC ; CvAIOperationMerchantDelegation::ArmyInPosition, COMDAT
; _this$ = ecx

; 3490 : {

	push	-1
	push	__ehhandler$?ArmyInPosition@CvAIOperationMerchantDelegation@@UAE_NPAVCvArmyAI@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi

; 3491 : 	int iUnitID = 0;
; 3492 : 	bool bStateChanged = false;

	xor	ebx, ebx

; 3493 : 	CvUnit* pMerchant = 0, *pEscort = 0;
; 3494 : 	CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$[esp+60]
	mov	BYTE PTR _bStateChanged$[esp+60], bl
	xor	edi, edi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3495 : 
; 3496 : 	switch(m_eCurrentState)

	mov	eax, DWORD PTR [esi+56]
	mov	DWORD PTR __$EHRec$[esp+68], ebx
	cmp	eax, 4
	ja	$LN78@ArmyInPosi@6
	jmp	DWORD PTR $LN84@ArmyInPosi@6[eax*4]
$LN23@ArmyInPosi@6:

; 3497 : 	{
; 3498 : 		// If we were gathering forces, we have to insist that any escort is in the same plot as the merchant.
; 3499 : 		// If not we'll fall through and just stay in this state.
; 3500 : 	case AI_OPERATION_STATE_GATHERING_FORCES:
; 3501 : 
; 3502 : 		// No escort, can just let base class handle it
; 3503 : 		if(!m_bEscorted)

	cmp	BYTE PTR [esi+112], bl
	jne	SHORT $LN22@ArmyInPosi@6
$LN1@ArmyInPosi@6:

; 3504 : 		{
; 3505 : 			return CvAIOperation::ArmyInPosition(pArmy);

	mov	eax, DWORD PTR _pArmy$[esp+56]
	push	eax
	mov	ecx, esi
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition
	lea	ecx, DWORD PTR _strMsg$[esp+60]
	mov	bl, al
	mov	DWORD PTR __$EHRec$[esp+68], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebp
	mov	al, bl
	pop	ebx

; 3623 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	4
$LN22@ArmyInPosi@6:

; 3506 : 		}
; 3507 : 
; 3508 : 		// More complex if we are waiting for an escort
; 3509 : 		else
; 3510 : 		{
; 3511 : 			iUnitID = pArmy->GetFirstUnitID();

	mov	ebp, DWORD PTR _pArmy$[esp+56]
	mov	ecx, ebp
	call	?GetFirstUnitID@CvArmyAI@@QAEHXZ	; CvArmyAI::GetFirstUnitID

; 3512 : 			if(iUnitID != -1)

	cmp	eax, -1
	je	SHORT $LN20@ArmyInPosi@6

; 3513 : 			{
; 3514 : 				pMerchant = GET_PLAYER(m_eOwner).getUnit(iUnitID);

	mov	ecx, DWORD PTR [esi+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
$LN20@ArmyInPosi@6:

; 3515 : 			}
; 3516 : 			iUnitID = pArmy->GetNextUnitID();

	mov	ecx, ebp
	call	?GetNextUnitID@CvArmyAI@@QAEHXZ		; CvArmyAI::GetNextUnitID

; 3517 : 			if(iUnitID != -1)

	cmp	eax, -1
	je	$LN19@ArmyInPosi@6

; 3518 : 			{
; 3519 : 				pEscort = GET_PLAYER(m_eOwner).getUnit(iUnitID);

	mov	ecx, DWORD PTR [esi+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit

; 3527 : 			}
; 3528 : 			if(pMerchant != NULL && pEscort != NULL && pMerchant->plot() == pEscort->plot())

	cmp	edi, ebx
	je	$LN78@ArmyInPosi@6
	cmp	eax, ebx
	je	$LN78@ArmyInPosi@6
	mov	ecx, eax
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, edi
	mov	ebx, eax
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	eax, ebx
	jne	$LN78@ArmyInPosi@6

; 3529 : 			{
; 3530 : 				// let's see if the target still makes sense (this is modified from RetargetCivilian)
; 3531 : 				CvPlot* pBetterTarget = FindBestTarget(pMerchant, true);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+148]
	push	1
	push	edi
	mov	ecx, esi
	call	eax

; 3532 : 
; 3533 : 				// No targets at all!  Abort
; 3534 : 				if(pBetterTarget == NULL)

	test	eax, eax
	jne	SHORT $LN16@ArmyInPosi@6

; 3535 : 				{
; 3536 : 					m_eCurrentState = AI_OPERATION_STATE_ABORTED;
; 3537 : 					m_eAbortReason = AI_ABORT_NO_TARGET;
; 3538 : 					return false;

	lea	ecx, DWORD PTR _strMsg$[esp+60]
	mov	DWORD PTR [esi+56], eax
	mov	DWORD PTR [esi+60], 1
	mov	DWORD PTR __$EHRec$[esp+68], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebp
	xor	al, al
	pop	ebx

; 3623 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	4
$LN16@ArmyInPosi@6:

; 3539 : 				}
; 3540 : 				// If we have a target
; 3541 : 				else
; 3542 : 				{
; 3543 : 					SetTargetPlot(pBetterTarget);

	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR [esi+104], ecx
	movsx	edx, WORD PTR [eax+2]

; 3544 : 					pArmy->SetGoalPlot(pBetterTarget);

	push	eax
	mov	ecx, ebp
	mov	DWORD PTR [esi+108], edx
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 3545 : 				}
; 3546 : 				return CvAIOperation::ArmyInPosition(pArmy);

	push	ebp
	mov	ecx, esi
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition
	lea	ecx, DWORD PTR _strMsg$[esp+60]
	mov	bl, al
	mov	DWORD PTR __$EHRec$[esp+68], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebp
	mov	al, bl
	pop	ebx

; 3623 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	4
$LN19@ArmyInPosi@6:

; 3520 : 			}
; 3521 : 			else
; 3522 : 			{
; 3523 : 				// Escort died while gathering forces.  Abort (and return TRUE since state changed)
; 3524 : 				m_eCurrentState = AI_OPERATION_STATE_ABORTED;
; 3525 : 				m_eAbortReason = AI_ABORT_ESCORT_DIED;
; 3526 : 				return true;

	lea	ecx, DWORD PTR _strMsg$[esp+60]
	mov	DWORD PTR [esi+56], ebx
	mov	DWORD PTR [esi+60], 9
	mov	DWORD PTR __$EHRec$[esp+68], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebp
	mov	al, 1
	pop	ebx

; 3623 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	4
$LN14@ArmyInPosi@6:

; 3547 : 			}
; 3548 : 		}
; 3549 : 		break;
; 3550 : 
; 3551 : 	case AI_OPERATION_STATE_MOVING_TO_TARGET:
; 3552 : 	case AI_OPERATION_STATE_AT_TARGET:
; 3553 : 
; 3554 : 		// Call base class version and see if it thinks we're done
; 3555 : 		bStateChanged = CvAIOperation::ArmyInPosition(pArmy);

	mov	ebp, DWORD PTR _pArmy$[esp+56]
	push	ebp
	mov	ecx, esi
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition

; 3556 : 
; 3557 : 		// Now get the merchant
; 3558 : 		iUnitID = pArmy->GetFirstUnitID();

	mov	ecx, ebp
	mov	BYTE PTR _bStateChanged$[esp+60], al
	call	?GetFirstUnitID@CvArmyAI@@QAEHXZ	; CvArmyAI::GetFirstUnitID

; 3559 : 		if(iUnitID != -1)

	cmp	eax, -1
	je	$LN78@ArmyInPosi@6

; 3560 : 		{
; 3561 : 			pMerchant = GET_PLAYER(m_eOwner).getUnit(iUnitID);

	mov	ecx, DWORD PTR [esi+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax

; 3562 : 		}
; 3563 : 
; 3564 : 		if(pMerchant != NULL)

	cmp	edi, ebx
	je	$LN78@ArmyInPosi@6

; 3565 : 		{
; 3566 : 			// If the merchant made it, we don't care about the entire army
; 3567 : 			if(pMerchant->plot() == GetTargetPlot() && pMerchant->canMove() && pMerchant->canTrade(pMerchant->plot()))

	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, esi
	mov	ebx, eax
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	cmp	ebx, eax
	jne	$LN11@ArmyInPosi@6
	mov	ecx, edi
	call	?canMove@CvUnit@@QBE_NXZ		; CvUnit::canMove
	test	al, al
	je	$LN11@ArmyInPosi@6
	push	0
	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, edi
	call	?canTrade@CvUnit@@QBE_NPBVCvPlot@@_N@Z	; CvUnit::canTrade
	test	al, al
	je	$LN11@ArmyInPosi@6

; 3568 : 			{
; 3569 : 				if (pMerchant->canBuyCityState(pMerchant->plot()) && !GET_PLAYER(m_eOwner).GreatMerchantWantsCash())

	push	0
	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, edi
	call	?canBuyCityState@CvUnit@@QBE_NPBVCvPlot@@_N@Z ; CvUnit::canBuyCityState
	test	al, al
	je	SHORT $LN10@ArmyInPosi@6
	mov	ecx, DWORD PTR [esi+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GreatMerchantWantsCash@CvPlayerAI@@QAE_NXZ ; CvPlayerAI::GreatMerchantWantsCash
	test	al, al
	jne	SHORT $LN10@ArmyInPosi@6

; 3570 : 				{
; 3571 : 					pMerchant->PushMission(CvTypes::getMISSION_BUY_CITY_STATE());

	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_BUY_CITY_STATE@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_BUY_CITY_STATE
	push	eax
	mov	ecx, edi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3572 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN7@ArmyInPosi@6
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN7@ArmyInPosi@6

; 3573 : 					{
; 3574 : 						strMsg.Format("Great Merchant buying city-state, At X=%d, At Y=%d", pMerchant->plot()->getX(), pMerchant->plot()->getY());

	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	movsx	ebx, WORD PTR [eax+2]
	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	movsx	eax, WORD PTR [eax]
	push	ebx
	push	eax
	push	OFFSET $SG225921

; 3575 : 						LogOperationSpecialMessage(strMsg);
; 3576 : 					}
; 3577 : 				}
; 3578 : 				else

	jmp	SHORT $LN83@ArmyInPosi@6
$LN10@ArmyInPosi@6:

; 3579 : 				{
; 3580 : 					pMerchant->PushMission(CvTypes::getMISSION_TRADE());

	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_TRADE@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_TRADE
	push	eax
	mov	ecx, edi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3581 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN7@ArmyInPosi@6
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN7@ArmyInPosi@6

; 3582 : 					{
; 3583 : 						strMsg.Format("Great Merchant finishing trade mission, At X=%d, At Y=%d", pMerchant->plot()->getX(), pMerchant->plot()->getY());

	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	movsx	ebx, WORD PTR [eax+2]
	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	movsx	eax, WORD PTR [eax]
	push	ebx
	push	eax
	push	OFFSET $SG225924
$LN83@ArmyInPosi@6:
	lea	ecx, DWORD PTR _strMsg$[esp+72]
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3584 : 						LogOperationSpecialMessage(strMsg);

	lea	edx, DWORD PTR _strMsg$[esp+60]
	push	edx
	mov	ecx, esi
	call	?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z ; CvAIOperation::LogOperationSpecialMessage
$LN7@ArmyInPosi@6:

; 3585 : 					}
; 3586 : 				}
; 3587 : 
; 3588 : 				m_eCurrentState = AI_OPERATION_STATE_SUCCESSFUL_FINISH;

	mov	DWORD PTR [esi+56], 5
	jmp	$LN78@ArmyInPosi@6
$LN11@ArmyInPosi@6:

; 3589 : 			}
; 3590 : 
; 3591 : 			// Does it look like we should be done?
; 3592 : 			else if(pMerchant->plot() == GetTargetPlot())

	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, esi
	mov	ebx, eax
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	cmp	ebx, eax
	jne	$LN78@ArmyInPosi@6

; 3593 : 			{
; 3594 : 				// We're at our target but can no longer trade, city state was probably conquered
; 3595 : 				if(!pMerchant->canTrade(pMerchant->plot()))

	push	0
	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, edi
	call	?canTrade@CvUnit@@QBE_NPBVCvPlot@@_N@Z	; CvUnit::canTrade
	test	al, al
	jne	$LN78@ArmyInPosi@6

; 3596 : 				{
; 3597 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN3@ArmyInPosi@6
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN3@ArmyInPosi@6

; 3598 : 					{
; 3599 : 						strMsg.Format("At target but can no longer trade here. Target was (X=%d Y=%d)", GetTargetPlot()->getX(), GetTargetPlot()->getY());

	mov	ecx, esi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	movsx	ebx, WORD PTR [eax+2]
	mov	ecx, esi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	movsx	eax, WORD PTR [eax]
	push	ebx
	push	eax
	lea	ecx, DWORD PTR _strMsg$[esp+68]
	push	OFFSET $SG225929
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3600 : 						LogOperationSpecialMessage(strMsg);

	lea	edx, DWORD PTR _strMsg$[esp+60]
	push	edx
	mov	ecx, esi
	call	?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z ; CvAIOperation::LogOperationSpecialMessage
$LN3@ArmyInPosi@6:

; 3601 : 					}
; 3602 : 					RetargetCivilian(pMerchant, pArmy);

	push	ebp
	push	edi
	mov	ecx, esi
	call	?RetargetCivilian@CvAIEscortedOperation@@QAE_NPAVCvUnit@@PAVCvArmyAI@@@Z ; CvAIEscortedOperation::RetargetCivilian

; 3603 : 					pMerchant->finishMoves();

	mov	ecx, edi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 3604 : 					iUnitID = pArmy->GetNextUnitID();

	mov	ecx, ebp
	call	?GetNextUnitID@CvArmyAI@@QAEHXZ		; CvArmyAI::GetNextUnitID

; 3605 : 					if(iUnitID != -1)

	cmp	eax, -1
	je	SHORT $LN78@ArmyInPosi@6

; 3606 : 					{
; 3607 : 						pEscort = GET_PLAYER(m_eOwner).getUnit(iUnitID);

	mov	ecx, DWORD PTR [esi+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit

; 3608 : 						pEscort->finishMoves();

	mov	ecx, eax
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves
$LN78@ArmyInPosi@6:

; 3609 : 					}
; 3610 : 				}
; 3611 : 			}
; 3612 : 		}
; 3613 : 		break;
; 3614 : 
; 3615 : 		// In all other cases use base class version
; 3616 : 	case AI_OPERATION_STATE_ABORTED:
; 3617 : 	case AI_OPERATION_STATE_RECRUITING_UNITS:
; 3618 : 		return CvAIOperation::ArmyInPosition(pArmy);
; 3619 : 		break;
; 3620 : 	};
; 3621 : 
; 3622 : 	return bStateChanged;

	lea	ecx, DWORD PTR _strMsg$[esp+60]
	mov	DWORD PTR __$EHRec$[esp+68], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3623 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+60]
	mov	al, BYTE PTR _bStateChanged$[esp+60]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	4
	npad	2
$LN84@ArmyInPosi@6:
	DD	$LN1@ArmyInPosi@6
	DD	$LN1@ArmyInPosi@6
	DD	$LN23@ArmyInPosi@6
	DD	$LN14@ArmyInPosi@6
	DD	$LN14@ArmyInPosi@6
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ArmyInPosition@CvAIOperationMerchantDelegation@@UAE_NPAVCvArmyAI@@@Z$0:
	lea	ecx, DWORD PTR _strMsg$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ArmyInPosition@CvAIOperationMerchantDelegation@@UAE_NPAVCvArmyAI@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ArmyInPosition@CvAIOperationMerchantDelegation@@UAE_NPAVCvArmyAI@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ArmyInPosition@CvAIOperationMerchantDelegation@@UAE_NPAVCvArmyAI@@@Z ENDP ; CvAIOperationMerchantDelegation::ArmyInPosition
PUBLIC	?FindBestTarget@CvAIOperationMerchantDelegation@@EAEPAVCvPlot@@PAVCvUnit@@_N@Z ; CvAIOperationMerchantDelegation::FindBestTarget
EXTRN	?FindBestMerchantTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z:PROC ; CvPlayerAI::FindBestMerchantTargetPlot
; Function compile flags: /Ogtpy
;	COMDAT ?FindBestTarget@CvAIOperationMerchantDelegation@@EAEPAVCvPlot@@PAVCvUnit@@_N@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
_bOnlySafePaths$ = 12					; size = 1
?FindBestTarget@CvAIOperationMerchantDelegation@@EAEPAVCvPlot@@PAVCvUnit@@_N@Z PROC ; CvAIOperationMerchantDelegation::FindBestTarget, COMDAT
; _this$ = ecx

; 3628 : 	CvAssertMsg(pUnit, "pUnit cannot be null");
; 3629 : 	if(!pUnit)

	mov	eax, DWORD PTR _pUnit$[esp-4]
	test	eax, eax
	jne	SHORT $LN1@FindBestTa@5

; 3635 : }

	ret	8
$LN1@FindBestTa@5:

; 3630 : 	{
; 3631 : 		return NULL;
; 3632 : 	}
; 3633 : 
; 3634 : 	return GET_PLAYER(pUnit->getOwner()).FindBestMerchantTargetPlot(pUnit, !bOnlySafePaths /*m_bEscorted*/);

	mov	ecx, DWORD PTR [eax+40]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR _bOnlySafePaths$[esp-4], 0
	mov	DWORD PTR _pUnit$[esp-4], eax
	sete	dl
	movzx	edx, dl
	mov	DWORD PTR _bOnlySafePaths$[esp-4], edx
	jmp	?FindBestMerchantTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z ; CvPlayerAI::FindBestMerchantTargetPlot
?FindBestTarget@CvAIOperationMerchantDelegation@@EAEPAVCvPlot@@PAVCvUnit@@_N@Z ENDP ; CvAIOperationMerchantDelegation::FindBestTarget
_TEXT	ENDS
PUBLIC	?ArmyInPosition@CvAIOperationConcertTour@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperationConcertTour::ArmyInPosition
EXTRN	?getMISSION_ONE_SHOT_TOURISM@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_ONE_SHOT_TOURISM
EXTRN	?canBlastTourism@CvUnit@@QBE_NPBVCvPlot@@_N@Z:PROC ; CvUnit::canBlastTourism
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?ArmyInPosition@CvAIOperationConcertTour@@UAE_NPAVCvArmyAI@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ArmyInPosition@CvAIOperationConcertTour@@UAE_NPAVCvArmyAI@@@Z$0
__ehfuncinfo$?ArmyInPosition@CvAIOperationConcertTour@@UAE_NPAVCvArmyAI@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ArmyInPosition@CvAIOperationConcertTour@@UAE_NPAVCvArmyAI@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
xdata$x	ENDS
;	COMDAT ?ArmyInPosition@CvAIOperationConcertTour@@UAE_NPAVCvArmyAI@@@Z
_TEXT	SEGMENT
_bStateChanged$ = -41					; size = 1
_strMsg$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
_pArmy$ = 8						; size = 4
?ArmyInPosition@CvAIOperationConcertTour@@UAE_NPAVCvArmyAI@@@Z PROC ; CvAIOperationConcertTour::ArmyInPosition, COMDAT
; _this$ = ecx

; 3654 : {

	push	-1
	push	__ehhandler$?ArmyInPosition@CvAIOperationConcertTour@@UAE_NPAVCvArmyAI@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 32					; 00000020H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi

; 3655 : 	int iUnitID = 0;
; 3656 : 	bool bStateChanged = false;

	xor	ebx, ebx

; 3657 : 	CvUnit* pMusician = 0, *pEscort = 0;
; 3658 : 	CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$[esp+60]
	mov	BYTE PTR _bStateChanged$[esp+60], bl
	xor	edi, edi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3659 : 
; 3660 : 	switch(m_eCurrentState)

	mov	eax, DWORD PTR [esi+56]
	mov	DWORD PTR __$EHRec$[esp+68], ebx
	cmp	eax, 4
	ja	$LN69@ArmyInPosi@7
	jmp	DWORD PTR $LN74@ArmyInPosi@7[eax*4]
$LN20@ArmyInPosi@7:

; 3661 : 	{
; 3662 : 		// If we were gathering forces, we have to insist that any escort is in the same plot as the merchant.
; 3663 : 		// If not we'll fall through and just stay in this state.
; 3664 : 	case AI_OPERATION_STATE_GATHERING_FORCES:
; 3665 : 
; 3666 : 		// No escort, can just let base class handle it
; 3667 : 		if(!m_bEscorted)

	cmp	BYTE PTR [esi+112], bl
	jne	SHORT $LN19@ArmyInPosi@7
$LN1@ArmyInPosi@7:

; 3668 : 		{
; 3669 : 			return CvAIOperation::ArmyInPosition(pArmy);

	mov	eax, DWORD PTR _pArmy$[esp+56]
	push	eax
	mov	ecx, esi
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition
	lea	ecx, DWORD PTR _strMsg$[esp+60]
	mov	bl, al
	mov	DWORD PTR __$EHRec$[esp+68], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebp
	mov	al, bl
	pop	ebx

; 3775 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	4
$LN19@ArmyInPosi@7:

; 3670 : 		}
; 3671 : 
; 3672 : 		// More complex if we are waiting for an escort
; 3673 : 		else
; 3674 : 		{
; 3675 : 			iUnitID = pArmy->GetFirstUnitID();

	mov	ebp, DWORD PTR _pArmy$[esp+56]
	mov	ecx, ebp
	call	?GetFirstUnitID@CvArmyAI@@QAEHXZ	; CvArmyAI::GetFirstUnitID

; 3676 : 			if(iUnitID != -1)

	cmp	eax, -1
	je	SHORT $LN17@ArmyInPosi@7

; 3677 : 			{
; 3678 : 				pMusician = GET_PLAYER(m_eOwner).getUnit(iUnitID);

	mov	ecx, DWORD PTR [esi+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax
$LN17@ArmyInPosi@7:

; 3679 : 			}
; 3680 : 			iUnitID = pArmy->GetNextUnitID();

	mov	ecx, ebp
	call	?GetNextUnitID@CvArmyAI@@QAEHXZ		; CvArmyAI::GetNextUnitID

; 3681 : 			if(iUnitID != -1)

	cmp	eax, -1
	je	$LN16@ArmyInPosi@7

; 3682 : 			{
; 3683 : 				pEscort = GET_PLAYER(m_eOwner).getUnit(iUnitID);

	mov	ecx, DWORD PTR [esi+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit

; 3691 : 			}
; 3692 : 			if(pMusician != NULL && pEscort != NULL && pMusician->plot() == pEscort->plot())

	cmp	edi, ebx
	je	$LN69@ArmyInPosi@7
	cmp	eax, ebx
	je	$LN69@ArmyInPosi@7
	mov	ecx, eax
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, edi
	mov	ebx, eax
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	eax, ebx
	jne	$LN69@ArmyInPosi@7

; 3693 : 			{
; 3694 : 				// let's see if the target still makes sense (this is modified from RetargetCivilian)
; 3695 : 				CvPlot* pBetterTarget = FindBestTarget(pMusician, true);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+148]
	push	1
	push	edi
	mov	ecx, esi
	call	eax

; 3696 : 
; 3697 : 				// No targets at all!  Abort
; 3698 : 				if(pBetterTarget == NULL)

	test	eax, eax
	jne	SHORT $LN13@ArmyInPosi@7

; 3699 : 				{
; 3700 : 					m_eCurrentState = AI_OPERATION_STATE_ABORTED;
; 3701 : 					m_eAbortReason = AI_ABORT_NO_TARGET;
; 3702 : 					return false;

	lea	ecx, DWORD PTR _strMsg$[esp+60]
	mov	DWORD PTR [esi+56], eax
	mov	DWORD PTR [esi+60], 1
	mov	DWORD PTR __$EHRec$[esp+68], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebp
	xor	al, al
	pop	ebx

; 3775 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	4
$LN13@ArmyInPosi@7:

; 3703 : 				}
; 3704 : 				// If we have a target
; 3705 : 				else
; 3706 : 				{
; 3707 : 					SetTargetPlot(pBetterTarget);

	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR [esi+104], ecx
	movsx	edx, WORD PTR [eax+2]

; 3708 : 					pArmy->SetGoalPlot(pBetterTarget);

	push	eax
	mov	ecx, ebp
	mov	DWORD PTR [esi+108], edx
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 3709 : 				}
; 3710 : 				return CvAIOperation::ArmyInPosition(pArmy);

	push	ebp
	mov	ecx, esi
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition
	lea	ecx, DWORD PTR _strMsg$[esp+60]
	mov	bl, al
	mov	DWORD PTR __$EHRec$[esp+68], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebp
	mov	al, bl
	pop	ebx

; 3775 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	4
$LN16@ArmyInPosi@7:

; 3684 : 			}
; 3685 : 			else
; 3686 : 			{
; 3687 : 				// Escort died while gathering forces.  Abort (and return TRUE since state changed)
; 3688 : 				m_eCurrentState = AI_OPERATION_STATE_ABORTED;
; 3689 : 				m_eAbortReason = AI_ABORT_ESCORT_DIED;
; 3690 : 				return true;

	lea	ecx, DWORD PTR _strMsg$[esp+60]
	mov	DWORD PTR [esi+56], ebx
	mov	DWORD PTR [esi+60], 9
	mov	DWORD PTR __$EHRec$[esp+68], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebp
	mov	al, 1
	pop	ebx

; 3775 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	4
$LN11@ArmyInPosi@7:

; 3711 : 			}
; 3712 : 		}
; 3713 : 		break;
; 3714 : 
; 3715 : 	case AI_OPERATION_STATE_MOVING_TO_TARGET:
; 3716 : 	case AI_OPERATION_STATE_AT_TARGET:
; 3717 : 
; 3718 : 		// Call base class version and see if it thinks we're done
; 3719 : 		bStateChanged = CvAIOperation::ArmyInPosition(pArmy);

	mov	ebp, DWORD PTR _pArmy$[esp+56]
	push	ebp
	mov	ecx, esi
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition

; 3720 : 
; 3721 : 		// Now get the musician
; 3722 : 		iUnitID = pArmy->GetFirstUnitID();

	mov	ecx, ebp
	mov	BYTE PTR _bStateChanged$[esp+60], al
	call	?GetFirstUnitID@CvArmyAI@@QAEHXZ	; CvArmyAI::GetFirstUnitID

; 3723 : 		if(iUnitID != -1)

	cmp	eax, -1
	je	$LN69@ArmyInPosi@7

; 3724 : 		{
; 3725 : 			pMusician = GET_PLAYER(m_eOwner).getUnit(iUnitID);

	mov	ecx, DWORD PTR [esi+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax

; 3726 : 		}
; 3727 : 
; 3728 : 		if(pMusician != NULL)

	cmp	edi, ebx
	je	$LN69@ArmyInPosi@7

; 3729 : 		{
; 3730 : 			// If the merchant made it, we don't care about the entire army
; 3731 : 			if(pMusician->plot() == GetTargetPlot() && pMusician->canMove() && pMusician->canBlastTourism(pMusician->plot()))

	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, esi
	mov	ebx, eax
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	cmp	ebx, eax
	jne	$LN8@ArmyInPosi@7
	mov	ecx, edi
	call	?canMove@CvUnit@@QBE_NXZ		; CvUnit::canMove
	test	al, al
	je	$LN8@ArmyInPosi@7
	push	0
	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, edi
	call	?canBlastTourism@CvUnit@@QBE_NPBVCvPlot@@_N@Z ; CvUnit::canBlastTourism
	test	al, al
	je	SHORT $LN8@ArmyInPosi@7

; 3732 : 			{
; 3733 : 				pMusician->PushMission(CvTypes::getMISSION_ONE_SHOT_TOURISM());

	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_ONE_SHOT_TOURISM@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_ONE_SHOT_TOURISM
	push	eax
	mov	ecx, edi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 3734 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN7@ArmyInPosi@7
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN7@ArmyInPosi@7

; 3735 : 				{
; 3736 : 					strMsg.Format("Great Musician performing concert tour, At X=%d, At Y=%d", pMusician->plot()->getX(), pMusician->plot()->getY());

	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	movsx	ebx, WORD PTR [eax+2]
	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	movsx	eax, WORD PTR [eax]
	push	ebx
	push	eax
	lea	ecx, DWORD PTR _strMsg$[esp+68]
	push	OFFSET $SG225982
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3737 : 					LogOperationSpecialMessage(strMsg);

	lea	edx, DWORD PTR _strMsg$[esp+60]
	push	edx
	mov	ecx, esi
	call	?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z ; CvAIOperation::LogOperationSpecialMessage
$LN7@ArmyInPosi@7:

; 3738 : 				}
; 3739 : 
; 3740 : 				m_eCurrentState = AI_OPERATION_STATE_SUCCESSFUL_FINISH;

	mov	DWORD PTR [esi+56], 5
	jmp	$LN69@ArmyInPosi@7
$LN8@ArmyInPosi@7:

; 3741 : 			}
; 3742 : 
; 3743 : 			// Does it look like we should be done?
; 3744 : 			else if(pMusician->plot() == GetTargetPlot())

	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ecx, esi
	mov	ebx, eax
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	cmp	ebx, eax
	jne	$LN69@ArmyInPosi@7

; 3745 : 			{
; 3746 : 				// We're at our target but can no longer perform concert, enemy city was probably conquered
; 3747 : 				if(!pMusician->canBlastTourism(pMusician->plot()))

	push	0
	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, edi
	call	?canBlastTourism@CvUnit@@QBE_NPBVCvPlot@@_N@Z ; CvUnit::canBlastTourism
	test	al, al
	jne	$LN69@ArmyInPosi@7

; 3748 : 				{
; 3749 : 					if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN3@ArmyInPosi@7
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN3@ArmyInPosi@7

; 3750 : 					{
; 3751 : 						strMsg.Format("At target but can no longer hold concert here. Target was (X=%d Y=%d)", GetTargetPlot()->getX(), GetTargetPlot()->getY());

	mov	ecx, esi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	movsx	ebx, WORD PTR [eax+2]
	mov	ecx, esi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	movsx	eax, WORD PTR [eax]
	push	ebx
	push	eax
	lea	ecx, DWORD PTR _strMsg$[esp+68]
	push	OFFSET $SG225987
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3752 : 						LogOperationSpecialMessage(strMsg);

	lea	edx, DWORD PTR _strMsg$[esp+60]
	push	edx
	mov	ecx, esi
	call	?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z ; CvAIOperation::LogOperationSpecialMessage
$LN3@ArmyInPosi@7:

; 3753 : 					}
; 3754 : 					RetargetCivilian(pMusician, pArmy);

	push	ebp
	push	edi
	mov	ecx, esi
	call	?RetargetCivilian@CvAIEscortedOperation@@QAE_NPAVCvUnit@@PAVCvArmyAI@@@Z ; CvAIEscortedOperation::RetargetCivilian

; 3755 : 					pMusician->finishMoves();

	mov	ecx, edi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 3756 : 					iUnitID = pArmy->GetNextUnitID();

	mov	ecx, ebp
	call	?GetNextUnitID@CvArmyAI@@QAEHXZ		; CvArmyAI::GetNextUnitID

; 3757 : 					if(iUnitID != -1)

	cmp	eax, -1
	je	SHORT $LN69@ArmyInPosi@7

; 3758 : 					{
; 3759 : 						pEscort = GET_PLAYER(m_eOwner).getUnit(iUnitID);

	mov	ecx, DWORD PTR [esi+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit

; 3760 : 						pEscort->finishMoves();

	mov	ecx, eax
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves
$LN69@ArmyInPosi@7:

; 3761 : 					}
; 3762 : 				}
; 3763 : 			}
; 3764 : 		}
; 3765 : 		break;
; 3766 : 
; 3767 : 		// In all other cases use base class version
; 3768 : 	case AI_OPERATION_STATE_ABORTED:
; 3769 : 	case AI_OPERATION_STATE_RECRUITING_UNITS:
; 3770 : 		return CvAIOperation::ArmyInPosition(pArmy);
; 3771 : 		break;
; 3772 : 	};
; 3773 : 
; 3774 : 	return bStateChanged;

	lea	ecx, DWORD PTR _strMsg$[esp+60]
	mov	DWORD PTR __$EHRec$[esp+68], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3775 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+60]
	mov	al, BYTE PTR _bStateChanged$[esp+60]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 44					; 0000002cH
	ret	4
	npad	2
$LN74@ArmyInPosi@7:
	DD	$LN1@ArmyInPosi@7
	DD	$LN1@ArmyInPosi@7
	DD	$LN20@ArmyInPosi@7
	DD	$LN11@ArmyInPosi@7
	DD	$LN11@ArmyInPosi@7
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ArmyInPosition@CvAIOperationConcertTour@@UAE_NPAVCvArmyAI@@@Z$0:
	lea	ecx, DWORD PTR _strMsg$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ArmyInPosition@CvAIOperationConcertTour@@UAE_NPAVCvArmyAI@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ArmyInPosition@CvAIOperationConcertTour@@UAE_NPAVCvArmyAI@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ArmyInPosition@CvAIOperationConcertTour@@UAE_NPAVCvArmyAI@@@Z ENDP ; CvAIOperationConcertTour::ArmyInPosition
PUBLIC	?FindBestTarget@CvAIOperationConcertTour@@EAEPAVCvPlot@@PAVCvUnit@@_N@Z ; CvAIOperationConcertTour::FindBestTarget
EXTRN	?FindBestMusicianTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z:PROC ; CvPlayerAI::FindBestMusicianTargetPlot
; Function compile flags: /Ogtpy
;	COMDAT ?FindBestTarget@CvAIOperationConcertTour@@EAEPAVCvPlot@@PAVCvUnit@@_N@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
_bOnlySafePaths$ = 12					; size = 1
?FindBestTarget@CvAIOperationConcertTour@@EAEPAVCvPlot@@PAVCvUnit@@_N@Z PROC ; CvAIOperationConcertTour::FindBestTarget, COMDAT
; _this$ = ecx

; 3780 : 	CvAssertMsg(pUnit, "pUnit cannot be null");
; 3781 : 	if(!pUnit)

	mov	eax, DWORD PTR _pUnit$[esp-4]
	test	eax, eax
	jne	SHORT $LN1@FindBestTa@6

; 3787 : }

	ret	8
$LN1@FindBestTa@6:

; 3782 : 	{
; 3783 : 		return NULL;
; 3784 : 	}
; 3785 : 
; 3786 : 	return GET_PLAYER(pUnit->getOwner()).FindBestMusicianTargetPlot(pUnit, !bOnlySafePaths /*m_bEscorted*/);

	mov	ecx, DWORD PTR [eax+40]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	cmp	BYTE PTR _bOnlySafePaths$[esp-4], 0
	mov	DWORD PTR _pUnit$[esp-4], eax
	sete	dl
	movzx	edx, dl
	mov	DWORD PTR _bOnlySafePaths$[esp-4], edx
	jmp	?FindBestMusicianTargetPlot@CvPlayerAI@@QAEPAVCvPlot@@PAVCvUnit@@_N@Z ; CvPlayerAI::FindBestMusicianTargetPlot
?FindBestTarget@CvAIOperationConcertTour@@EAEPAVCvPlot@@PAVCvUnit@@_N@Z ENDP ; CvAIOperationConcertTour::FindBestTarget
_TEXT	ENDS
PUBLIC	?GetOperationStartCity@CvAINavalOperation@@UBEPAVCvCity@@XZ ; CvAINavalOperation::GetOperationStartCity
EXTRN	?isCoastal@CvCity@@QBE_NH@Z:PROC		; CvCity::isCoastal
; Function compile flags: /Ogtpy
;	COMDAT ?GetOperationStartCity@CvAINavalOperation@@UBEPAVCvCity@@XZ
_TEXT	SEGMENT
_iLoop$ = -4						; size = 4
?GetOperationStartCity@CvAINavalOperation@@UBEPAVCvCity@@XZ PROC ; CvAINavalOperation::GetOperationStartCity, COMDAT
; _this$ = ecx

; 3833 : {

	push	ecx
	push	edi
	mov	edi, ecx

; 3834 : 	if(GetStartCityPlot())

	call	?GetStartCityPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetStartCityPlot
	test	eax, eax
	je	SHORT $LN5@GetOperati@2

; 3835 : 	{
; 3836 : 		return GetStartCityPlot()->getPlotCity();

	mov	ecx, edi
	call	?GetStartCityPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetStartCityPlot
	mov	ecx, DWORD PTR [eax+104]
	test	ecx, ecx
	jl	SHORT $LN8@GetOperati@2
	cmp	ecx, 64					; 00000040H
	jge	SHORT $LN8@GetOperati@2
	mov	eax, DWORD PTR [eax+108]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	pop	edi

; 3852 : }

	pop	ecx
	ret	0

; 3835 : 	{
; 3836 : 		return GetStartCityPlot()->getPlotCity();

$LN8@GetOperati@2:
	xor	eax, eax
	pop	edi

; 3852 : }

	pop	ecx
	ret	0
$LN5@GetOperati@2:

; 3837 : 	}
; 3838 : 
; 3839 : 	int iLoop;
; 3840 : 	CvCity* pCity;
; 3841 : 
; 3842 : 	// Just find first coastal city
; 3843 : 	for(pCity = GET_PLAYER(m_eOwner).firstCity(&iLoop); pCity != NULL; pCity = GET_PLAYER(m_eOwner).nextCity(&iLoop))

	mov	ecx, DWORD PTR [edi+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	esi
	push	0
	lea	edx, DWORD PTR _iLoop$[esp+16]
	push	edx
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN2@GetOperati@2
	npad	1
$LL4@GetOperati@2:

; 3844 : 	{
; 3845 : 		if(pCity->isCoastal())

	push	-1
	mov	ecx, esi
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	test	al, al
	jne	SHORT $LN18@GetOperati@2
	mov	ecx, DWORD PTR [edi+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	0
	lea	eax, DWORD PTR _iLoop$[esp+16]
	push	eax
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL4@GetOperati@2
$LN2@GetOperati@2:
	pop	esi

; 3848 : 		}
; 3849 : 	}
; 3850 : 
; 3851 : 	return NULL;

	xor	eax, eax
	pop	edi

; 3852 : }

	pop	ecx
	ret	0
$LN18@GetOperati@2:

; 3846 : 		{
; 3847 : 			return pCity;

	mov	eax, esi
	pop	esi
	pop	edi

; 3852 : }

	pop	ecx
	ret	0
?GetOperationStartCity@CvAINavalOperation@@UBEPAVCvCity@@XZ ENDP ; CvAINavalOperation::GetOperationStartCity
_TEXT	ENDS
PUBLIC	?SelectInitialMusterPoint@CvAINavalOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z ; CvAINavalOperation::SelectInitialMusterPoint
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?SelectInitialMusterPoint@CvAINavalOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SelectInitialMusterPoint@CvAINavalOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z$0
__ehfuncinfo$?SelectInitialMusterPoint@CvAINavalOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SelectInitialMusterPoint@CvAINavalOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
xdata$x	ENDS
;	COMDAT ?SelectInitialMusterPoint@CvAINavalOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
_TEXT	SEGMENT
_bMusterPointFound$ = -53				; size = 1
_pMusterPt$ = -52					; size = 4
_iSpacesFromTarget$ = -48				; size = 4
_pStartCityPlot$ = -44					; size = 4
_szMsg$226059 = -40					; size = 28
__$EHRec$ = -12						; size = 12
_iDirectionLoop$ = 8					; size = 4
_pThisArmy$ = 8						; size = 4
?SelectInitialMusterPoint@CvAINavalOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z PROC ; CvAINavalOperation::SelectInitialMusterPoint, COMDAT
; _this$ = ecx

; 3856 : {

	push	-1
	push	__ehhandler$?SelectInitialMusterPoint@CvAINavalOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 44					; 0000002cH
	push	ebx
	push	ebp
	push	esi
	mov	ebp, ecx

; 3857 : 	CvPlot* pMusterPt = NULL;
; 3858 : 	CvPlot* pStartCityPlot;
; 3859 : 	CvCity* pStartCity;
; 3860 : 	CvPlot* pCurrentPlot;
; 3861 : 	CvPlot* pAdjacentPlot;
; 3862 : 	int iSpacesFromTarget = 0;
; 3863 : 	int iDirectionLoop;
; 3864 : 	CvAStarNode* pNode;
; 3865 : 	bool bMusterPointFound = false;
; 3866 : 
; 3867 : 	pStartCity = GetOperationStartCity();

	mov	eax, DWORD PTR [ebp]
	mov	edx, DWORD PTR [eax+52]
	push	edi
	xor	esi, esi
	xor	edi, edi
	mov	DWORD PTR _pMusterPt$[esp+72], edi
	mov	DWORD PTR _iSpacesFromTarget$[esp+72], esi
	mov	BYTE PTR _bMusterPointFound$[esp+72], 0
	call	edx

; 3868 : 	if(pStartCity)

	mov	ebx, DWORD PTR _pThisArmy$[esp+68]
	cmp	eax, esi
	je	$LN3@SelectInit@3

; 3869 : 	{
; 3870 : 		pStartCityPlot = pStartCity->plot();

	mov	ecx, eax
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	DWORD PTR _pStartCityPlot$[esp+72], eax

; 3871 : 
; 3872 : 		if(pStartCityPlot != NULL)

	cmp	eax, esi
	je	$LN3@SelectInit@3

; 3873 : 		{
; 3874 : 			// Find an adjacent water tile
; 3875 : 			for(iDirectionLoop = 0; iDirectionLoop < NUM_DIRECTION_TYPES && !bMusterPointFound; ++iDirectionLoop)

	mov	DWORD PTR _iDirectionLoop$[esp+68], esi
	jmp	SHORT $LN11@SelectInit@3
	npad	4
$LL70@SelectInit@3:
	mov	eax, DWORD PTR _pStartCityPlot$[esp+72]
$LN11@SelectInit@3:
	cmp	BYTE PTR _bMusterPointFound$[esp+72], 0
	jne	$LN9@SelectInit@3

; 3876 : 			{
; 3877 : 				pAdjacentPlot = plotDirection(pStartCityPlot->getX(), pStartCityPlot->getY(), ((DirectionTypes)iDirectionLoop));

	movsx	edx, WORD PTR [eax+2]
	mov	ecx, DWORD PTR _iDirectionLoop$[esp+68]
	movsx	eax, WORD PTR [eax]
	push	ecx
	push	edx
	push	eax
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 3878 : 				if(pAdjacentPlot != NULL && pAdjacentPlot->isWater())

	test	esi, esi
	je	$LN10@SelectInit@3
	cmp	BYTE PTR [esi+5], 3
	jne	$LN10@SelectInit@3

; 3879 : 				{
; 3880 : 					// Generate path
; 3881 : 					GC.getStepFinder().SetData(&m_eEnemy);

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	lea	edi, DWORD PTR [ebp+76]
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	cmp	BYTE PTR [eax+80], 0
	je	SHORT $LN23@SelectInit@3
	cmp	DWORD PTR [eax+44], edi
	je	SHORT $LN23@SelectInit@3
	mov	BYTE PTR [eax+78], 1
$LN23@SelectInit@3:

; 3882 : 					if(GC.getStepFinder().GeneratePath(pAdjacentPlot->getX(), pAdjacentPlot->getY(), pThisArmy->GetGoalPlot()->getX(), pThisArmy->GetGoalPlot()->getY(), m_eOwner, false))

	mov	ecx, ebx
	mov	DWORD PTR [eax+44], edi
	call	?GetGoalPlot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::GetGoalPlot
	movsx	edi, WORD PTR [eax+2]
	mov	ecx, ebx
	call	?GetGoalPlot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::GetGoalPlot
	movsx	ecx, WORD PTR [esi+2]
	movsx	edx, WORD PTR [esi]
	mov	esi, DWORD PTR [ebp+72]
	movsx	eax, WORD PTR [eax]
	push	0
	push	esi
	push	edi
	push	eax
	push	ecx
	push	edx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, eax
	call	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z	; CvAStar::GeneratePath
	test	al, al
	je	$LN69@SelectInit@3

; 3883 : 					{
; 3884 : 						pNode = GC.getStepFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	esi, DWORD PTR [eax+96]

; 3885 : 
; 3886 : 						// Starting at the end, loop until we find a plot from this owner
; 3887 : 						while(pNode != NULL)

	test	esi, esi
	je	SHORT $LN69@SelectInit@3
	npad	8
$LL6@SelectInit@3:

; 3888 : 						{
; 3889 : 							pCurrentPlot = GC.getMap().plotCheckInvalid(pNode->m_iX, pNode->m_iY);

	movsx	ecx, WORD PTR [esi+80]
	movsx	edx, WORD PTR [esi+82]
	cmp	ecx, -2147483647			; 80000001H
	je	SHORT $LN38@SelectInit@3
	cmp	edx, -2147483647			; 80000001H
	je	SHORT $LN38@SelectInit@3
	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	eax, DWORD PTR [edi+4020]
	imul	eax, edx
	add	eax, ecx
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [edi+4068]
	mov	edi, eax
	jmp	SHORT $LN40@SelectInit@3
$LN38@SelectInit@3:
	xor	edi, edi
$LN40@SelectInit@3:

; 3890 : 
; 3891 : 							// Is this the deploy point?
; 3892 : 							if(iSpacesFromTarget == GetDeployRange())

	mov	edx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [edx+144]
	mov	ecx, ebp
	call	eax
	cmp	DWORD PTR _iSpacesFromTarget$[esp+72], eax
	je	SHORT $LN64@SelectInit@3

; 3896 : 								break;
; 3897 : 							}
; 3898 : 
; 3899 : 							// Move to the previous plot on the path
; 3900 : 							iSpacesFromTarget++;
; 3901 : 							pNode = pNode->m_pParent;

	mov	esi, DWORD PTR [esi+24]
	inc	DWORD PTR _iSpacesFromTarget$[esp+72]
	test	esi, esi
	jne	SHORT $LL6@SelectInit@3

; 3890 : 
; 3891 : 							// Is this the deploy point?
; 3892 : 							if(iSpacesFromTarget == GetDeployRange())

	jmp	SHORT $LN69@SelectInit@3
$LN64@SelectInit@3:

; 3893 : 							{
; 3894 : 								pMusterPt = pCurrentPlot;

	mov	DWORD PTR _pMusterPt$[esp+72], edi

; 3895 : 								bMusterPointFound = true;

	mov	BYTE PTR _bMusterPointFound$[esp+72], 1
$LN69@SelectInit@3:

; 3890 : 
; 3891 : 							// Is this the deploy point?
; 3892 : 							if(iSpacesFromTarget == GetDeployRange())

	mov	edi, DWORD PTR _pMusterPt$[esp+72]
$LN10@SelectInit@3:

; 3873 : 		{
; 3874 : 			// Find an adjacent water tile
; 3875 : 			for(iDirectionLoop = 0; iDirectionLoop < NUM_DIRECTION_TYPES && !bMusterPointFound; ++iDirectionLoop)

	mov	eax, DWORD PTR _iDirectionLoop$[esp+68]
	inc	eax
	cmp	eax, 6
	mov	DWORD PTR _iDirectionLoop$[esp+68], eax
	jl	$LL70@SelectInit@3
$LN9@SelectInit@3:

; 3902 : 						}
; 3903 : 					}
; 3904 : 				}
; 3905 : 			}
; 3906 : 		}
; 3907 : 	}
; 3908 : 
; 3909 : 	if(pMusterPt != NULL)

	xor	esi, esi
	cmp	edi, esi
	je	SHORT $LN3@SelectInit@3

; 3910 : 	{
; 3911 : 		SetMusterPlot(pMusterPt);

	movsx	ecx, WORD PTR [edi]
	mov	DWORD PTR [ebp+96], ecx
	movsx	edx, WORD PTR [edi+2]
	mov	DWORD PTR [ebp+100], edx

; 3912 : 	}
; 3913 : 	else

	jmp	SHORT $LN68@SelectInit@3
$LN3@SelectInit@3:

; 3914 : 	{
; 3915 : 		if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN68@SelectInit@3
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN68@SelectInit@3

; 3916 : 		{
; 3917 : 			CvString szMsg;

	lea	ecx, DWORD PTR _szMsg$226059[esp+72]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 3918 : 			szMsg.Format("No muster point found, Naval operation aborting, Target was, X: %d, Y: %d", pThisArmy->GetGoalPlot()->getX(), pThisArmy->GetGoalPlot()->getY());

	mov	ecx, ebx
	mov	DWORD PTR __$EHRec$[esp+80], esi
	call	?GetGoalPlot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::GetGoalPlot
	movsx	esi, WORD PTR [eax+2]
	mov	ecx, ebx
	call	?GetGoalPlot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::GetGoalPlot
	movsx	eax, WORD PTR [eax]
	push	esi
	push	eax
	lea	ecx, DWORD PTR _szMsg$226059[esp+80]
	push	OFFSET $SG226060
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 3919 : 			LogOperationSpecialMessage(szMsg);

	lea	edx, DWORD PTR _szMsg$226059[esp+72]
	push	edx
	mov	ecx, ebp
	call	?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z ; CvAIOperation::LogOperationSpecialMessage

; 3920 : 		}

	lea	ecx, DWORD PTR _szMsg$226059[esp+72]
	mov	DWORD PTR __$EHRec$[esp+80], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN68@SelectInit@3:

; 3921 : 	}
; 3922 : 
; 3923 : 	return pMusterPt;
; 3924 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+72]
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 56					; 00000038H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SelectInitialMusterPoint@CvAINavalOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z$0:
	lea	ecx, DWORD PTR _szMsg$226059[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?SelectInitialMusterPoint@CvAINavalOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?SelectInitialMusterPoint@CvAINavalOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SelectInitialMusterPoint@CvAINavalOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z ENDP ; CvAINavalOperation::SelectInitialMusterPoint
PUBLIC	?ArmyInPosition@CvAIOperationNavalBombardment@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperationNavalBombardment::ArmyInPosition
; Function compile flags: /Ogtpy
;	COMDAT ?ArmyInPosition@CvAIOperationNavalBombardment@@UAE_NPAVCvArmyAI@@@Z
_TEXT	SEGMENT
_bStateChanged$ = -21					; size = 1
_zone$226133 = -20					; size = 20
$T236969 = 8						; size = 4
$T236923 = 8						; size = 4
_pArmy$ = 8						; size = 4
?ArmyInPosition@CvAIOperationNavalBombardment@@UAE_NPAVCvArmyAI@@@Z PROC ; CvAIOperationNavalBombardment::ArmyInPosition, COMDAT
; _this$ = ecx

; 4056 : {

	sub	esp, 24					; 00000018H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 4057 : 	bool bStateChanged = false;
; 4058 : 
; 4059 : 	switch(m_eCurrentState)

	mov	eax, DWORD PTR [esi+56]
	push	edi
	mov	BYTE PTR _bStateChanged$[esp+40], 0
	cmp	eax, 4
	ja	SHORT $LN45@ArmyInPosi@8
	jmp	DWORD PTR $LN46@ArmyInPosi@8[eax*4]
$LN8@ArmyInPosi@8:

; 4060 : 	{
; 4061 : 		// If we were gathering forces, let's make sure a better target hasn't presented itself
; 4062 : 	case AI_OPERATION_STATE_GATHERING_FORCES:
; 4063 : 	{
; 4064 : 		// First do base case processing
; 4065 : 		bStateChanged = CvAIOperation::ArmyInPosition(pArmy);

	mov	ebx, DWORD PTR _pArmy$[esp+36]
	push	ebx
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition
	mov	BYTE PTR _bStateChanged$[esp+40], al

; 4066 : 
; 4067 : 		// Now revisit target
; 4068 : 		CvPlot* possibleBetterTarget;
; 4069 : 		possibleBetterTarget = FindBestTarget();

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+148]
	mov	ecx, esi
	call	edx
	mov	edi, eax

; 4070 : 
; 4071 : 		// If no target left, abort
; 4072 : 		if(possibleBetterTarget == NULL)

	test	edi, edi
	jne	SHORT $LN7@ArmyInPosi@8

; 4073 : 		{
; 4074 : 			m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	DWORD PTR [esi+56], eax

; 4075 : 			m_eAbortReason = AI_ABORT_NO_TARGET;

	mov	DWORD PTR [esi+60], 1
$LN45@ArmyInPosi@8:

; 4115 : 		break;
; 4116 : 	};
; 4117 : 
; 4118 : 	return bStateChanged;

	mov	al, BYTE PTR _bStateChanged$[esp+40]

; 4119 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	4
$LN7@ArmyInPosi@8:

; 4076 : 		}
; 4077 : 
; 4078 : 		// If target changed, reset to this new one
; 4079 : 		else if(possibleBetterTarget != GetTargetPlot())

	mov	ecx, esi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	cmp	edi, eax
	je	SHORT $LN45@ArmyInPosi@8

; 4080 : 		{
; 4081 : 			// Reset our destination to be a few plots shy of the final target
; 4082 : 			CvPlot* pDeployPt = GC.getStepFinder().GetXPlotsFromEnd(GetOwner(), GetEnemy(), pArmy->Plot(), possibleBetterTarget, GetDeployRange(), false);

	mov	eax, DWORD PTR [esi+72]
	mov	edx, DWORD PTR [esi]
	mov	ebp, DWORD PTR [esi+76]
	mov	DWORD PTR $T236923[esp+36], eax
	mov	eax, DWORD PTR [edx+144]
	push	0
	mov	ecx, esi
	call	eax
	push	eax
	push	edi
	mov	ecx, ebx
	call	?Plot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::Plot
	mov	ecx, DWORD PTR $T236923[esp+48]
	push	eax
	push	ebp
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, eax
	call	?GetXPlotsFromEnd@CvStepPathFinder@@QBEPAVCvPlot@@W4PlayerTypes@@0PAV2@1H_N@Z ; CvStepPathFinder::GetXPlotsFromEnd

; 4083 : 			if(pDeployPt != NULL)

	test	eax, eax
	je	SHORT $LN45@ArmyInPosi@8

; 4084 : 			{
; 4085 : 				pArmy->SetGoalPlot(pDeployPt);

	push	eax
	mov	ecx, ebx
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 4086 : 				SetTargetPlot(possibleBetterTarget);

	movsx	edx, WORD PTR [edi]
	mov	DWORD PTR [esi+104], edx
	movsx	eax, WORD PTR [edi+2]
	mov	DWORD PTR [esi+108], eax

; 4115 : 		break;
; 4116 : 	};
; 4117 : 
; 4118 : 	return bStateChanged;

	mov	al, BYTE PTR _bStateChanged$[esp+40]

; 4119 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	4
$LN3@ArmyInPosi@8:

; 4087 : 			}
; 4088 : 		}
; 4089 : 	}
; 4090 : 	break;
; 4091 : 
; 4092 : 	// See if reached our target, if so give control of these units to the tactical AI
; 4093 : 	case AI_OPERATION_STATE_MOVING_TO_TARGET:
; 4094 : 	{
; 4095 : 		if(pArmy->Plot() == pArmy->GetGoalPlot())

	mov	edi, DWORD PTR _pArmy$[esp+36]
	mov	ecx, edi
	call	?Plot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::Plot
	mov	ecx, edi
	mov	ebx, eax
	call	?GetGoalPlot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::GetGoalPlot
	cmp	ebx, eax
	jne	$LN45@ArmyInPosi@8

; 4096 : 		{
; 4097 : 			// Notify tactical AI to focus on this area
; 4098 : 			CvTemporaryZone zone;
; 4099 : 			zone.SetX(GetTargetPlot()->getX());

	mov	ecx, esi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	movsx	edi, WORD PTR [eax]

; 4100 : 			zone.SetY(GetTargetPlot()->getY());

	mov	ecx, esi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot

; 4101 : 			zone.SetTargetType(AI_TACTICAL_TARGET_BOMBARDMENT_ZONE);
; 4102 : 			zone.SetLastTurn(GC.getGame().getGameTurn() + GC.getAI_TACTICAL_MAP_BOMBARDMENT_ZONE_TURNS());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2456
	movsx	ebp, WORD PTR [eax+2]
	mov	DWORD PTR $T236969[esp+36], ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	ebx, 12					; 0000000cH
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn

; 4103 : 			GET_PLAYER(m_eOwner).GetTacticalAI()->AddTemporaryZone(zone);

	mov	ecx, DWORD PTR [esi+72]
	add	eax, DWORD PTR $T236969[esp+36]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR [edx], edi
	mov	DWORD PTR [edx+4], ebp
	mov	DWORD PTR [edx+8], ebx
	mov	DWORD PTR [edx+12], eax
	mov	eax, DWORD PTR _zone$226133[esp+76]
	mov	DWORD PTR [edx+16], eax
	call	?GetTacticalAI@CvPlayer@@QBEPAVCvTacticalAI@@XZ ; CvPlayer::GetTacticalAI
	mov	ecx, eax
	call	?AddTemporaryZone@CvTacticalAI@@QAEXVCvTemporaryZone@@@Z ; CvTacticalAI::AddTemporaryZone

; 4115 : 		break;
; 4116 : 	};
; 4117 : 
; 4118 : 	return bStateChanged;

	mov	al, BYTE PTR _bStateChanged$[esp+40]
	mov	DWORD PTR [esi+56], 5

; 4119 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	4
$LN1@ArmyInPosi@8:

; 4104 : 
; 4105 : 			m_eCurrentState = AI_OPERATION_STATE_SUCCESSFUL_FINISH;
; 4106 : 		}
; 4107 : 	}
; 4108 : 	break;
; 4109 : 
; 4110 : 	// In all other cases use base class version
; 4111 : 	case AI_OPERATION_STATE_ABORTED:
; 4112 : 	case AI_OPERATION_STATE_RECRUITING_UNITS:
; 4113 : 	case AI_OPERATION_STATE_AT_TARGET:
; 4114 : 		return CvAIOperation::ArmyInPosition(pArmy);

	mov	ecx, DWORD PTR _pArmy$[esp+36]
	push	ecx
	mov	ecx, esi
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition

; 4119 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	4
$LN46@ArmyInPosi@8:
	DD	$LN1@ArmyInPosi@8
	DD	$LN1@ArmyInPosi@8
	DD	$LN8@ArmyInPosi@8
	DD	$LN3@ArmyInPosi@8
	DD	$LN1@ArmyInPosi@8
?ArmyInPosition@CvAIOperationNavalBombardment@@UAE_NPAVCvArmyAI@@@Z ENDP ; CvAIOperationNavalBombardment::ArmyInPosition
_TEXT	ENDS
PUBLIC	?FindBestTarget@CvAIOperationNavalBombardment@@MAEPAVCvPlot@@XZ ; CvAIOperationNavalBombardment::FindBestTarget
EXTRN	?GeneratePath@CvUnit@@QBE_NPBVCvPlot@@H_NPAH@Z:PROC ; CvUnit::GeneratePath
EXTRN	?isShallowWater@CvPlot@@QBE_NXZ:PROC		; CvPlot::isShallowWater
EXTRN	?getVisibleEnemyDefender@CvPlot@@QAEPAVCvUnit@@W4PlayerTypes@@@Z:PROC ; CvPlot::getVisibleEnemyDefender
EXTRN	?isCoastalLand@CvPlot@@QBE_NH@Z:PROC		; CvPlot::isCoastalLand
; Function compile flags: /Ogtpy
;	COMDAT ?FindBestTarget@CvAIOperationNavalBombardment@@MAEPAVCvPlot@@XZ
_TEXT	SEGMENT
_pInitialUnit$ = -32					; size = 4
tv401 = -28						; size = 4
_iBestTurns$ = -24					; size = 4
_pBestPlot$ = -20					; size = 4
_iPlotLoop$ = -16					; size = 4
tv373 = -12						; size = 4
_iCurrentTurns$ = -8					; size = 4
_this$ = -4						; size = 4
?FindBestTarget@CvAIOperationNavalBombardment@@MAEPAVCvPlot@@XZ PROC ; CvAIOperationNavalBombardment::FindBestTarget, COMDAT
; _this$ = ecx

; 4123 : {

	sub	esp, 32					; 00000020H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 4124 : #ifdef AUI_WARNING_FIXES
; 4125 : 	uint iPlotLoop;
; 4126 : 	int iDirectionLoop;
; 4127 : #else
; 4128 : 	int iPlotLoop, iDirectionLoop;
; 4129 : #endif
; 4130 : 	CvPlot* pBestPlot = NULL;
; 4131 : 	CvPlot* pPlot;
; 4132 : 	CvPlot* pAdjacentPlot;
; 4133 : 	int iBestTurns = MAX_INT;
; 4134 : 	int iCurrentTurns;
; 4135 : 	CvUnit* pInitialUnit;
; 4136 : 
; 4137 : 	CvPlayer& owningPlayer = GET_PLAYER(m_eOwner);

	mov	ebx, DWORD PTR [esi+72]

; 4138 : 
; 4139 : 	if(GetFirstArmyID() == -1)

	mov	eax, DWORD PTR [esi+12]
	imul	ebx, 63236				; 0000f704H
	sub	eax, DWORD PTR [esi+8]
	add	ebx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	xor	ebp, ebp
	mov	DWORD PTR _this$[esp+44], esi
	mov	DWORD PTR _pBestPlot$[esp+44], ebp
	mov	DWORD PTR _iBestTurns$[esp+44], 2147483647 ; 7fffffffH
	test	eax, -4					; fffffffcH
	je	SHORT $LN60@FindBestTa@7
	mov	eax, DWORD PTR [esi+8]
	cmp	DWORD PTR [eax], -1

; 4140 : 	{
; 4141 : 		pInitialUnit = FindInitialUnit();
; 4142 : 	}
; 4143 : 	else

	je	SHORT $LN60@FindBestTa@7

; 4144 : 	{
; 4145 : 		CvArmyAI* pThisArmy = owningPlayer.getArmyAI(m_viArmyIDs[0]);

	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, ebx
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI

; 4146 : 		int iUnitID = pThisArmy->GetFirstUnitID();

	mov	ecx, eax
	call	?GetFirstUnitID@CvArmyAI@@QAEHXZ	; CvArmyAI::GetFirstUnitID

; 4147 : 		if(iUnitID != -1)

	cmp	eax, -1
	je	SHORT $LN15@FindBestTa@7

; 4148 : 		{
; 4149 : 			pInitialUnit = owningPlayer.getUnit(iUnitID);

	push	eax
	mov	ecx, ebx
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit

; 4150 : 		}
; 4151 : 		else

	jmp	SHORT $LN62@FindBestTa@7
$LN15@FindBestTa@7:

; 4152 : 		{
; 4153 : 			pInitialUnit = FindInitialUnit();

	mov	ecx, esi
$LN60@FindBestTa@7:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+152]
	call	eax
$LN62@FindBestTa@7:
	mov	DWORD PTR _pInitialUnit$[esp+44], eax

; 4154 : 		}
; 4155 : 	}
; 4156 : 
; 4157 : 	if(pInitialUnit != NULL)

	cmp	eax, ebp
	je	$LN58@FindBestTa@7

; 4158 : 	{
; 4159 : 		// Look at map for enemy units on the coast
; 4160 : 		for(iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	DWORD PTR [ecx+4028], ebp
	mov	DWORD PTR _iPlotLoop$[esp+44], ebp
	jle	$LN58@FindBestTa@7
	mov	DWORD PTR tv401[esp+44], ebp
	push	edi
	npad	15
$LL61@FindBestTa@7:

; 4161 : 		{
; 4162 : 			pPlot = GC.getMap().plotByIndexUnchecked(iPlotLoop);

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	edi, DWORD PTR [edx+4068]
	add	edi, DWORD PTR tv401[esp+48]

; 4163 : 
; 4164 : 			if(pPlot->isRevealed(owningPlayer.getTeam()))

	mov	ecx, ebx
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	mov	edx, eax
	shr	edx, 5
	mov	ecx, edx
	shl	ecx, 5
	mov	DWORD PTR tv373[esp+48], ecx
	mov	ecx, eax
	mov	eax, DWORD PTR tv373[esp+48]
	sub	ecx, eax
	mov	eax, 1
	shl	eax, cl
	test	eax, DWORD PTR [edi+edx*4+8]
	je	SHORT $LN11@FindBestTa@7

; 4165 : 			{
; 4166 : 				if(pPlot->isCoastalLand())

	push	-1
	mov	ecx, edi
	call	?isCoastalLand@CvPlot@@QBE_NH@Z		; CvPlot::isCoastalLand
	test	al, al
	je	SHORT $LN11@FindBestTa@7

; 4167 : 				{
; 4168 : 					// Enemy defender here? (for now let's not add cities; they fire back!)
; 4169 : 					CvUnit* pUnit = pPlot->getVisibleEnemyDefender(m_eOwner);

	mov	ecx, DWORD PTR [esi+72]
	push	ecx
	mov	ecx, edi
	call	?getVisibleEnemyDefender@CvPlot@@QAEPAVCvUnit@@W4PlayerTypes@@@Z ; CvPlot::getVisibleEnemyDefender

; 4170 : 					if(pUnit)

	test	eax, eax
	je	SHORT $LN11@FindBestTa@7

; 4171 : 					{
; 4172 : 						// Find an adjacent coastal water tile
; 4173 : 						for(iDirectionLoop = 0; iDirectionLoop < NUM_DIRECTION_TYPES; ++iDirectionLoop)

	xor	ebp, ebp
$LL6@FindBestTa@7:

; 4174 : 						{
; 4175 : 							pAdjacentPlot = plotDirection(pPlot->getX(), pPlot->getY(), ((DirectionTypes)iDirectionLoop));

	movsx	edx, WORD PTR [edi+2]
	movsx	eax, WORD PTR [edi]
	push	ebp
	push	edx
	push	eax
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 4176 : 							if(pAdjacentPlot != NULL && pAdjacentPlot->isWater() && pAdjacentPlot->isShallowWater())

	test	esi, esi
	je	SHORT $LN5@FindBestTa@7
	cmp	BYTE PTR [esi+5], 3
	jne	SHORT $LN5@FindBestTa@7
	mov	ecx, esi
	call	?isShallowWater@CvPlot@@QBE_NXZ		; CvPlot::isShallowWater
	test	al, al
	je	SHORT $LN5@FindBestTa@7

; 4177 : 							{
; 4178 : 								if(pInitialUnit->GeneratePath(pAdjacentPlot, 0, false, &iCurrentTurns))

	lea	ecx, DWORD PTR _iCurrentTurns$[esp+48]
	push	ecx
	mov	ecx, DWORD PTR _pInitialUnit$[esp+52]
	push	0
	push	0
	push	esi
	call	?GeneratePath@CvUnit@@QBE_NPBVCvPlot@@H_NPAH@Z ; CvUnit::GeneratePath
	test	al, al
	je	SHORT $LN5@FindBestTa@7

; 4179 : 								{
; 4180 : 									if(iCurrentTurns < iBestTurns)

	mov	eax, DWORD PTR _iCurrentTurns$[esp+48]
	cmp	eax, DWORD PTR _iBestTurns$[esp+48]
	jge	SHORT $LN5@FindBestTa@7

; 4181 : 									{
; 4182 : 										iBestTurns = iCurrentTurns;

	mov	DWORD PTR _iBestTurns$[esp+48], eax

; 4183 : 										pBestPlot = pAdjacentPlot;

	mov	DWORD PTR _pBestPlot$[esp+48], esi
$LN5@FindBestTa@7:
	inc	ebp
	cmp	ebp, 6
	jl	SHORT $LL6@FindBestTa@7
	mov	ebp, DWORD PTR _pBestPlot$[esp+48]
	mov	esi, DWORD PTR _this$[esp+48]
$LN11@FindBestTa@7:
	mov	eax, DWORD PTR _iPlotLoop$[esp+48]
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	DWORD PTR tv401[esp+48], 484		; 000001e4H
	inc	eax
	cmp	eax, DWORD PTR [edx+4028]
	mov	DWORD PTR _iPlotLoop$[esp+48], eax
	jl	$LL61@FindBestTa@7
	pop	edi
$LN58@FindBestTa@7:
	pop	esi

; 4184 : 									}
; 4185 : 								}
; 4186 : 							}
; 4187 : 						}
; 4188 : 					}
; 4189 : 				}
; 4190 : 			}
; 4191 : 		}
; 4192 : 	}
; 4193 : 
; 4194 : 	return pBestPlot;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 4195 : }

	add	esp, 32					; 00000020H
	ret	0
?FindBestTarget@CvAIOperationNavalBombardment@@MAEPAVCvPlot@@XZ ENDP ; CvAIOperationNavalBombardment::FindBestTarget
_TEXT	ENDS
PUBLIC	?ArmyInPosition@CvAIOperationNavalSuperiority@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperationNavalSuperiority::ArmyInPosition
; Function compile flags: /Ogtpy
;	COMDAT ?ArmyInPosition@CvAIOperationNavalSuperiority@@UAE_NPAVCvArmyAI@@@Z
_TEXT	SEGMENT
_bStateChanged$ = -1					; size = 1
$T237070 = 8						; size = 4
_pArmy$ = 8						; size = 4
?ArmyInPosition@CvAIOperationNavalSuperiority@@UAE_NPAVCvArmyAI@@@Z PROC ; CvAIOperationNavalSuperiority::ArmyInPosition, COMDAT
; _this$ = ecx

; 4301 : {

	push	ecx
	push	esi
	mov	esi, ecx

; 4302 : 	bool bStateChanged = false;
; 4303 : 
; 4304 : 	switch(m_eCurrentState)

	mov	eax, DWORD PTR [esi+56]
	mov	BYTE PTR _bStateChanged$[esp+8], 0
	cmp	eax, 4
	ja	SHORT $LN21@ArmyInPosi@9
	jmp	DWORD PTR $LN24@ArmyInPosi@9[eax*4]
$LN6@ArmyInPosi@9:
	push	ebp

; 4305 : 	{
; 4306 : 		// If we were gathering forces, let's make sure a better target hasn't presented itself
; 4307 : 	case AI_OPERATION_STATE_GATHERING_FORCES:
; 4308 : 	case AI_OPERATION_STATE_MOVING_TO_TARGET:
; 4309 : 	{
; 4310 : 		// First do base case processing
; 4311 : 		bStateChanged = CvAIOperation::ArmyInPosition(pArmy);

	mov	ebp, DWORD PTR _pArmy$[esp+8]
	push	edi
	push	ebp
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition
	mov	BYTE PTR _bStateChanged$[esp+16], al

; 4312 : 
; 4313 : 		// Now revisit target
; 4314 : 		CvPlot* possibleBetterTarget;
; 4315 : 		possibleBetterTarget = FindBestTarget();

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+148]
	mov	ecx, esi
	call	edx
	mov	edi, eax

; 4316 : 
; 4317 : 		// If no target left, abort
; 4318 : 		if(possibleBetterTarget == NULL)

	test	edi, edi
	jne	SHORT $LN5@ArmyInPosi@9

; 4319 : 		{
; 4320 : 			m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	DWORD PTR [esi+56], eax

; 4321 : 			m_eAbortReason = AI_ABORT_NO_TARGET;

	mov	DWORD PTR [esi+60], 1
$LN22@ArmyInPosi@9:
	pop	edi
	pop	ebp
$LN21@ArmyInPosi@9:

; 4343 : 		break;
; 4344 : 	};
; 4345 : 
; 4346 : 	return bStateChanged;

	mov	al, BYTE PTR _bStateChanged$[esp+8]
	pop	esi

; 4347 : }

	pop	ecx
	ret	4
$LN5@ArmyInPosi@9:

; 4322 : 		}
; 4323 : 
; 4324 : 		// If target changed, reset to this new one
; 4325 : 		else if(possibleBetterTarget != GetTargetPlot())

	mov	ecx, esi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	cmp	edi, eax
	je	SHORT $LN22@ArmyInPosi@9

; 4326 : 		{
; 4327 : 			// Reset our destination to be a few plots shy of the final target
; 4328 : 			CvPlot* pDeployPt = GC.getStepFinder().GetXPlotsFromEnd(GetOwner(), GetEnemy(), pArmy->Plot(), possibleBetterTarget, GetDeployRange(), false);

	mov	eax, DWORD PTR [esi+72]
	mov	edx, DWORD PTR [esi]
	push	ebx
	mov	ebx, DWORD PTR [esi+76]
	mov	DWORD PTR $T237070[esp+16], eax
	mov	eax, DWORD PTR [edx+144]
	push	0
	mov	ecx, esi
	call	eax
	push	eax
	push	edi
	mov	ecx, ebp
	call	?Plot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::Plot
	mov	ecx, DWORD PTR $T237070[esp+28]
	push	eax
	push	ebx
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, eax
	call	?GetXPlotsFromEnd@CvStepPathFinder@@QBEPAVCvPlot@@W4PlayerTypes@@0PAV2@1H_N@Z ; CvStepPathFinder::GetXPlotsFromEnd
	pop	ebx

; 4329 : 			if(pDeployPt != NULL)

	test	eax, eax
	je	SHORT $LN22@ArmyInPosi@9

; 4330 : 			{
; 4331 : 				pArmy->SetGoalPlot(pDeployPt);

	push	eax
	mov	ecx, ebp
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 4332 : 				SetTargetPlot(possibleBetterTarget);

	movsx	edx, WORD PTR [edi]
	mov	DWORD PTR [esi+104], edx
	movsx	eax, WORD PTR [edi+2]
	pop	edi
	mov	DWORD PTR [esi+108], eax

; 4343 : 		break;
; 4344 : 	};
; 4345 : 
; 4346 : 	return bStateChanged;

	mov	al, BYTE PTR _bStateChanged$[esp+12]
	pop	ebp
	pop	esi

; 4347 : }

	pop	ecx
	ret	4
$LN1@ArmyInPosi@9:

; 4333 : 			}
; 4334 : 		}
; 4335 : 	}
; 4336 : 	break;
; 4337 : 
; 4338 : 		// In all other cases use base class version
; 4339 : 	case AI_OPERATION_STATE_ABORTED:
; 4340 : 	case AI_OPERATION_STATE_RECRUITING_UNITS:
; 4341 : 	case AI_OPERATION_STATE_AT_TARGET:
; 4342 : 		return CvAIOperation::ArmyInPosition(pArmy);

	mov	ecx, DWORD PTR _pArmy$[esp+4]
	push	ecx
	mov	ecx, esi
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition
	pop	esi

; 4347 : }

	pop	ecx
	ret	4
	npad	2
$LN24@ArmyInPosi@9:
	DD	$LN1@ArmyInPosi@9
	DD	$LN1@ArmyInPosi@9
	DD	$LN6@ArmyInPosi@9
	DD	$LN6@ArmyInPosi@9
	DD	$LN1@ArmyInPosi@9
?ArmyInPosition@CvAIOperationNavalSuperiority@@UAE_NPAVCvArmyAI@@@Z ENDP ; CvAIOperationNavalSuperiority::ArmyInPosition
_TEXT	ENDS
PUBLIC	?ArmyInPosition@CvAIOperationPureNavalCityAttack@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperationPureNavalCityAttack::ArmyInPosition
; Function compile flags: /Ogtpy
;	COMDAT ?ArmyInPosition@CvAIOperationPureNavalCityAttack@@UAE_NPAVCvArmyAI@@@Z
_TEXT	SEGMENT
_bStateChanged$ = -21					; size = 1
_zone$226603 = -20					; size = 20
$T237143 = 8						; size = 4
$T237106 = 8						; size = 4
_pArmy$ = 8						; size = 4
?ArmyInPosition@CvAIOperationPureNavalCityAttack@@UAE_NPAVCvArmyAI@@@Z PROC ; CvAIOperationPureNavalCityAttack::ArmyInPosition, COMDAT
; _this$ = ecx

; 4684 : {

	sub	esp, 24					; 00000018H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 4685 : 	bool bStateChanged = false;
; 4686 : 
; 4687 : 	switch(m_eCurrentState)

	mov	eax, DWORD PTR [esi+56]
	xor	ebx, ebx
	push	edi
	mov	BYTE PTR _bStateChanged$[esp+40], bl
	cmp	eax, 4
	ja	SHORT $LN42@ArmyInPosi@10
	jmp	DWORD PTR $LN44@ArmyInPosi@10[eax*4]
$LN5@ArmyInPosi@10:

; 4688 : 	{
; 4689 : 		// If we were gathering forces, let's make sure a better target hasn't presented itself
; 4690 : 	case AI_OPERATION_STATE_GATHERING_FORCES:
; 4691 : 		{
; 4692 : 			// First do base case processing
; 4693 : 			bStateChanged = CvAIOperation::ArmyInPosition(pArmy);

	mov	eax, DWORD PTR _pArmy$[esp+36]
	push	eax
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition

; 4694 : 
; 4695 : 			// Is target still under enemy control?
; 4696 : 			CvPlot* pTarget = GetTargetPlot();

	mov	ecx, esi
	mov	BYTE PTR _bStateChanged$[esp+40], al
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot

; 4697 : 			if(pTarget->getOwner() != m_eEnemy)

	movsx	ecx, BYTE PTR [eax+4]
	cmp	ecx, DWORD PTR [esi+76]
	je	SHORT $LN42@ArmyInPosi@10

; 4698 : 			{
; 4699 : 				m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	DWORD PTR [esi+56], ebx

; 4700 : 				m_eAbortReason = AI_ABORT_TARGET_ALREADY_CAPTURED;

	mov	DWORD PTR [esi+60], 4
$LN42@ArmyInPosi@10:

; 4728 : 		break;
; 4729 : 	};
; 4730 : 
; 4731 : 	return bStateChanged;

	mov	al, BYTE PTR _bStateChanged$[esp+40]

; 4732 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	4
$LN3@ArmyInPosi@10:

; 4701 : 			}
; 4702 : 		}
; 4703 : 		break;
; 4704 : 
; 4705 : 		// See if within 2 spaces of our target, if so give control of these units to the tactical AI
; 4706 : 	case AI_OPERATION_STATE_MOVING_TO_TARGET:
; 4707 : 		{
; 4708 : 			if (plotDistance(pArmy->Plot()->getX(), pArmy->Plot()->getY(), GetTargetPlot()->getX(), GetTargetPlot()->getY()) < 2)

	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	movsx	edi, WORD PTR [eax+2]
	mov	ecx, esi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	mov	ebp, DWORD PTR _pArmy$[esp+36]
	movsx	ebx, WORD PTR [eax]
	mov	ecx, ebp
	call	?Plot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::Plot
	movsx	edx, WORD PTR [eax+2]
	mov	ecx, ebp
	mov	DWORD PTR $T237106[esp+36], edx
	call	?Plot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::Plot
	mov	ecx, DWORD PTR $T237106[esp+36]
	movsx	edx, WORD PTR [eax]
	push	edi
	push	ebx
	push	ecx
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, 2
	jge	SHORT $LN42@ArmyInPosi@10

; 4709 : 			{
; 4710 : 				// Notify tactical AI to focus on this area
; 4711 : 				CvTemporaryZone zone;
; 4712 : 				zone.SetX(GetTargetPlot()->getX());

	mov	ecx, esi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	movsx	edi, WORD PTR [eax]

; 4713 : 				zone.SetY(GetTargetPlot()->getY());

	mov	ecx, esi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	movsx	ebp, WORD PTR [eax+2]

; 4714 : 				zone.SetTargetType(AI_TACTICAL_TARGET_CITY);
; 4715 : 				zone.SetLastTurn(GC.getGame().getGameTurn() + GC.getAI_TACTICAL_MAP_TEMP_ZONE_TURNS());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2452
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	ebx, 1
	mov	DWORD PTR $T237143[esp+36], eax
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn

; 4716 : 				GET_PLAYER(m_eOwner).GetTacticalAI()->AddTemporaryZone(zone);

	mov	ecx, DWORD PTR [esi+72]
	add	eax, DWORD PTR $T237143[esp+36]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR [edx], edi
	mov	DWORD PTR [edx+4], ebp
	mov	DWORD PTR [edx+8], ebx
	mov	DWORD PTR [edx+12], eax
	mov	eax, DWORD PTR _zone$226603[esp+76]
	mov	DWORD PTR [edx+16], eax
	call	?GetTacticalAI@CvPlayer@@QBEPAVCvTacticalAI@@XZ ; CvPlayer::GetTacticalAI
	mov	ecx, eax
	call	?AddTemporaryZone@CvTacticalAI@@QAEXVCvTemporaryZone@@@Z ; CvTacticalAI::AddTemporaryZone

; 4728 : 		break;
; 4729 : 	};
; 4730 : 
; 4731 : 	return bStateChanged;

	mov	al, BYTE PTR _bStateChanged$[esp+40]
	mov	DWORD PTR [esi+56], 5

; 4732 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	4
$LN1@ArmyInPosi@10:

; 4717 : 
; 4718 : 				m_eCurrentState = AI_OPERATION_STATE_SUCCESSFUL_FINISH;
; 4719 : 			}
; 4720 : 		}
; 4721 : 		break;
; 4722 : 
; 4723 : 		// In all other cases use base class version
; 4724 : 	case AI_OPERATION_STATE_ABORTED:
; 4725 : 	case AI_OPERATION_STATE_RECRUITING_UNITS:
; 4726 : 	case AI_OPERATION_STATE_AT_TARGET:
; 4727 : 		return CvAIOperation::ArmyInPosition(pArmy);

	mov	ecx, DWORD PTR _pArmy$[esp+36]
	push	ecx
	mov	ecx, esi
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition

; 4732 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	4
$LN44@ArmyInPosi@10:
	DD	$LN1@ArmyInPosi@10
	DD	$LN1@ArmyInPosi@10
	DD	$LN5@ArmyInPosi@10
	DD	$LN3@ArmyInPosi@10
	DD	$LN1@ArmyInPosi@10
?ArmyInPosition@CvAIOperationPureNavalCityAttack@@UAE_NPAVCvArmyAI@@@Z ENDP ; CvAIOperationPureNavalCityAttack::ArmyInPosition
_TEXT	ENDS
PUBLIC	?FindBestTarget@CvAIOperationCityCloseDefense@@AAEPAVCvPlot@@XZ ; CvAIOperationCityCloseDefense::FindBestTarget
EXTRN	?findCity@CvMap@@QAEPAVCvCity@@HHW4PlayerTypes@@W4TeamTypes@@_N21W4DirectionTypes@@PBV2@@Z:PROC ; CvMap::findCity
EXTRN	?GetMostThreatenedCity@CvMilitaryAI@@QAEPAVCvCity@@H@Z:PROC ; CvMilitaryAI::GetMostThreatenedCity
; Function compile flags: /Ogtpy
;	COMDAT ?FindBestTarget@CvAIOperationCityCloseDefense@@AAEPAVCvPlot@@XZ
_TEXT	SEGMENT
_iLoop$ = -4						; size = 4
?FindBestTarget@CvAIOperationCityCloseDefense@@AAEPAVCvPlot@@XZ PROC ; CvAIOperationCityCloseDefense::FindBestTarget, COMDAT
; _this$ = ecx

; 4847 : {

	push	ecx
	push	esi
	mov	esi, ecx

; 4848 : 	CvCity* pCity;
; 4849 : 	CvPlot* pPlot = NULL;
; 4850 : 	CvCity* pEnemyCapital;
; 4851 : 	int iLoop;
; 4852 : 
; 4853 : 	// Defend the city most under threat
; 4854 : 	pCity = GET_PLAYER(m_eOwner).GetMilitaryAI()->GetMostThreatenedCity();

	mov	ecx, DWORD PTR [esi+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edi
	xor	edi, edi
	push	edi
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?GetMostThreatenedCity@CvMilitaryAI@@QAEPAVCvCity@@H@Z ; CvMilitaryAI::GetMostThreatenedCity

; 4855 : 
; 4856 : 	// If no city is threatened just defend whichever of our cities is closest to the enemy capital
; 4857 : 	if(pCity == NULL)

	test	eax, eax
	jne	SHORT $LN22@FindBestTa@8

; 4858 : 	{
; 4859 : 		pEnemyCapital = GET_PLAYER(m_eEnemy).getCapitalCity();

	mov	ecx, DWORD PTR [esi+76]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity

; 4860 : 		if(pEnemyCapital == NULL)

	test	eax, eax
	jne	SHORT $LN2@FindBestTa@8

; 4861 : 		{
; 4862 : 			pEnemyCapital = GET_PLAYER(m_eEnemy).firstCity(&iLoop);

	mov	ecx, DWORD PTR [esi+76]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	lea	eax, DWORD PTR _iLoop$[esp+16]
	push	eax
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
$LN2@FindBestTa@8:

; 4863 : 		}
; 4864 : 		pCity = GC.getMap().findCity(pEnemyCapital->getX(), pEnemyCapital->getY(), m_eOwner, NO_TEAM, true, false, NO_TEAM, NO_DIRECTION, NULL);

	mov	ecx, DWORD PTR [eax+108]
	mov	edx, DWORD PTR [esi+72]
	mov	eax, DWORD PTR [eax+96]
	push	0
	push	-1
	push	-1
	push	0
	push	1
	push	-1
	push	edx
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	eax
	call	?findCity@CvMap@@QAEPAVCvCity@@HHW4PlayerTypes@@W4TeamTypes@@_N21W4DirectionTypes@@PBV2@@Z ; CvMap::findCity

; 4865 : 	}
; 4866 : 
; 4867 : 	if(pCity != NULL)

	test	eax, eax
	je	SHORT $LN23@FindBestTa@8
$LN22@FindBestTa@8:

; 4868 : 	{
; 4869 : 		pPlot = pCity->plot();

	mov	ecx, eax
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	pop	edi
	pop	esi

; 4873 : }

	pop	ecx
	ret	0
$LN23@FindBestTa@8:

; 4870 : 	}
; 4871 : 
; 4872 : 	return pPlot;

	mov	eax, edi
	pop	edi
	pop	esi

; 4873 : }

	pop	ecx
	ret	0
?FindBestTarget@CvAIOperationCityCloseDefense@@AAEPAVCvPlot@@XZ ENDP ; CvAIOperationCityCloseDefense::FindBestTarget
_TEXT	ENDS
PUBLIC	?FindBestTarget@CvAIOperationRapidResponse@@AAEPAVCvPlot@@XZ ; CvAIOperationRapidResponse::FindBestTarget
; Function compile flags: /Ogtpy
;	COMDAT ?FindBestTarget@CvAIOperationRapidResponse@@AAEPAVCvPlot@@XZ
_TEXT	SEGMENT
_iLoop$ = -4						; size = 4
?FindBestTarget@CvAIOperationRapidResponse@@AAEPAVCvPlot@@XZ PROC ; CvAIOperationRapidResponse::FindBestTarget, COMDAT
; _this$ = ecx

; 5045 : {

	push	ecx
	push	esi
	mov	esi, ecx

; 5046 : 	CvCity* pCity;
; 5047 : 	CvPlot* pPlot = NULL;
; 5048 : 	CvCity* pEnemyCapital;
; 5049 : 	int iLoop;
; 5050 : 
; 5051 : 	// Defend the city most under threat
; 5052 : 	pCity = GET_PLAYER(m_eOwner).GetMilitaryAI()->GetMostThreatenedCity();

	mov	ecx, DWORD PTR [esi+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edi
	xor	edi, edi
	push	edi
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?GetMostThreatenedCity@CvMilitaryAI@@QAEPAVCvCity@@H@Z ; CvMilitaryAI::GetMostThreatenedCity

; 5053 : 
; 5054 : 	// If no city is threatened just defend whichever of our cities is closest to the enemy capital
; 5055 : 	if(pCity == NULL)

	test	eax, eax
	jne	SHORT $LN22@FindBestTa@9

; 5056 : 	{
; 5057 : 		pEnemyCapital = GET_PLAYER(m_eEnemy).getCapitalCity();

	mov	ecx, DWORD PTR [esi+76]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getCapitalCity@CvPlayer@@QAEPAVCvCity@@XZ ; CvPlayer::getCapitalCity

; 5058 : 		if(pEnemyCapital == NULL)

	test	eax, eax
	jne	SHORT $LN2@FindBestTa@9

; 5059 : 		{
; 5060 : 			pEnemyCapital = GET_PLAYER(m_eEnemy).firstCity(&iLoop);

	mov	ecx, DWORD PTR [esi+76]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	lea	eax, DWORD PTR _iLoop$[esp+16]
	push	eax
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
$LN2@FindBestTa@9:

; 5061 : 		}
; 5062 : 		pCity = GC.getMap().findCity(pEnemyCapital->getX(), pEnemyCapital->getY(), m_eOwner, NO_TEAM, true, false, NO_TEAM, NO_DIRECTION, NULL);

	mov	ecx, DWORD PTR [eax+108]
	mov	edx, DWORD PTR [esi+72]
	mov	eax, DWORD PTR [eax+96]
	push	0
	push	-1
	push	-1
	push	0
	push	1
	push	-1
	push	edx
	push	ecx
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	eax
	call	?findCity@CvMap@@QAEPAVCvCity@@HHW4PlayerTypes@@W4TeamTypes@@_N21W4DirectionTypes@@PBV2@@Z ; CvMap::findCity

; 5063 : 	}
; 5064 : 
; 5065 : 	if(pCity != NULL)

	test	eax, eax
	je	SHORT $LN23@FindBestTa@9
$LN22@FindBestTa@9:

; 5066 : 	{
; 5067 : 		pPlot = pCity->plot();

	mov	ecx, eax
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	pop	edi
	pop	esi

; 5071 : }

	pop	ecx
	ret	0
$LN23@FindBestTa@9:

; 5068 : 	}
; 5069 : 
; 5070 : 	return pPlot;

	mov	eax, edi
	pop	edi
	pop	esi

; 5071 : }

	pop	ecx
	ret	0
?FindBestTarget@CvAIOperationRapidResponse@@AAEPAVCvPlot@@XZ ENDP ; CvAIOperationRapidResponse::FindBestTarget
_TEXT	ENDS
PUBLIC	?GetOperationStartCity@CvAINavalEscortedOperation@@UBEPAVCvCity@@XZ ; CvAINavalEscortedOperation::GetOperationStartCity
; Function compile flags: /Ogtpy
;	COMDAT ?GetOperationStartCity@CvAINavalEscortedOperation@@UBEPAVCvCity@@XZ
_TEXT	SEGMENT
_iLoop$ = -4						; size = 4
?GetOperationStartCity@CvAINavalEscortedOperation@@UBEPAVCvCity@@XZ PROC ; CvAINavalEscortedOperation::GetOperationStartCity, COMDAT
; _this$ = ecx

; 5156 : {

	push	ecx
	push	ebx
	mov	ebx, ecx

; 5157 : 	if(GetStartCityPlot())

	call	?GetStartCityPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetStartCityPlot
	test	eax, eax
	je	SHORT $LN6@GetOperati@3

; 5158 : 	{
; 5159 : 		return GetStartCityPlot()->getPlotCity();

	mov	ecx, ebx
	call	?GetStartCityPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetStartCityPlot
	mov	ecx, DWORD PTR [eax+104]
	test	ecx, ecx
	jl	SHORT $LN9@GetOperati@3
	cmp	ecx, 64					; 00000040H
	jge	SHORT $LN9@GetOperati@3
	mov	eax, DWORD PTR [eax+108]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	pop	ebx

; 5180 : }

	pop	ecx
	ret	0

; 5158 : 	{
; 5159 : 		return GetStartCityPlot()->getPlotCity();

$LN9@GetOperati@3:
	xor	eax, eax
	pop	ebx

; 5180 : }

	pop	ecx
	ret	0
$LN6@GetOperati@3:
	push	esi
	push	edi

; 5160 : 	}
; 5161 : 
; 5162 : 	CvPlayerAI& kOwner = GET_PLAYER(m_eOwner);

	mov	edi, DWORD PTR [ebx+72]
	imul	edi, 63236				; 0000f704H
	add	edi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 5163 : 
; 5164 : 	int iLoop = 0;
; 5165 : 	CvCity* pCity = NULL;
; 5166 : 
; 5167 : 	// Find first coastal city in same area as settler
; 5168 : 	for(pCity = kOwner.firstCity(&iLoop); pCity != NULL; pCity = kOwner.nextCity(&iLoop))

	push	0
	lea	ecx, DWORD PTR _iLoop$[esp+20]
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR _iLoop$[esp+24], 0
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN3@GetOperati@3
	npad	6
$LL5@GetOperati@3:

; 5169 : 	{
; 5170 : 		if(pCity->isCoastal())

	push	-1
	mov	ecx, esi
	call	?isCoastal@CvCity@@QBE_NH@Z		; CvCity::isCoastal
	test	al, al
	je	SHORT $LN4@GetOperati@3

; 5171 : 		{
; 5172 : 			if(pCity->getArea() == m_iInitialAreaID)

	mov	ecx, esi
	call	?getArea@CvCity@@QBEHXZ			; CvCity::getArea
	cmp	eax, DWORD PTR [ebx+116]
	je	SHORT $LN17@GetOperati@3
$LN4@GetOperati@3:

; 5163 : 
; 5164 : 	int iLoop = 0;
; 5165 : 	CvCity* pCity = NULL;
; 5166 : 
; 5167 : 	// Find first coastal city in same area as settler
; 5168 : 	for(pCity = kOwner.firstCity(&iLoop); pCity != NULL; pCity = kOwner.nextCity(&iLoop))

	push	0
	lea	edx, DWORD PTR _iLoop$[esp+20]
	push	edx
	mov	ecx, edi
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL5@GetOperati@3
$LN3@GetOperati@3:
	pop	edi
	pop	esi

; 5175 : 			}
; 5176 : 		}
; 5177 : 	}
; 5178 : 
; 5179 : 	return NULL;

	xor	eax, eax
	pop	ebx

; 5180 : }

	pop	ecx
	ret	0
$LN17@GetOperati@3:
	pop	edi

; 5173 : 			{
; 5174 : 				return pCity;

	mov	eax, esi
	pop	esi
	pop	ebx

; 5180 : }

	pop	ecx
	ret	0
?GetOperationStartCity@CvAINavalEscortedOperation@@UBEPAVCvCity@@XZ ENDP ; CvAINavalEscortedOperation::GetOperationStartCity
_TEXT	ENDS
PUBLIC	?RetargetCivilian@CvAINavalEscortedOperation@@QAE_NPAVCvUnit@@PAVCvArmyAI@@@Z ; CvAINavalEscortedOperation::RetargetCivilian
; Function compile flags: /Ogtpy
;	COMDAT ?RetargetCivilian@CvAINavalEscortedOperation@@QAE_NPAVCvUnit@@PAVCvArmyAI@@@Z
_TEXT	SEGMENT
_pCivilian$ = 8						; size = 4
_pArmy$ = 12						; size = 4
?RetargetCivilian@CvAINavalEscortedOperation@@QAE_NPAVCvUnit@@PAVCvArmyAI@@@Z PROC ; CvAINavalEscortedOperation::RetargetCivilian, COMDAT
; _this$ = ecx

; 5342 : 	CvPlot* pBetterTarget;
; 5343 : 
; 5344 : 	// Find best city site (taking into account whether or not we are escorted)
; 5345 : 	pBetterTarget = FindBestTarget(pCivilian);

	mov	eax, DWORD PTR _pCivilian$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR [esi+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edi
	push	-1
	push	1
	push	eax
	call	?GetBestSettlePlot@CvPlayer@@QBEPAVCvPlot@@PAVCvUnit@@_NH@Z ; CvPlayer::GetBestSettlePlot
	mov	edi, eax

; 5346 : 
; 5347 : 	// No targets at all!  Abort
; 5348 : 	if(pBetterTarget == NULL)

	test	edi, edi
	jne	SHORT $LN3@RetargetCi@2

; 5349 : 	{
; 5350 : 		m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	DWORD PTR [esi+56], eax
	pop	edi

; 5351 : 		m_eAbortReason = AI_ABORT_NO_TARGET;

	mov	DWORD PTR [esi+60], 1

; 5352 : 		return false;

	xor	al, al
	pop	esi

; 5366 : }

	ret	8
$LN3@RetargetCi@2:
	push	ebx

; 5353 : 	}
; 5354 : 
; 5355 : 	// If this is a new target, switch to it
; 5356 : 	else if(pBetterTarget != GetTargetPlot())

	mov	ecx, esi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	mov	ebx, DWORD PTR _pArmy$[esp+8]
	cmp	edi, eax
	je	SHORT $LN1@RetargetCi@2

; 5357 : 	{
; 5358 : 		SetTargetPlot(pBetterTarget);

	movsx	ecx, WORD PTR [edi]
	mov	DWORD PTR [esi+104], ecx
	movsx	edx, WORD PTR [edi+2]

; 5359 : 		pArmy->SetGoalPlot(pBetterTarget);

	push	edi
	mov	ecx, ebx
	mov	DWORD PTR [esi+108], edx
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot
$LN1@RetargetCi@2:

; 5360 : 	}
; 5361 : 
; 5362 : 	pArmy->SetArmyAIState(ARMYAISTATE_MOVING_TO_DESTINATION);

	push	2
	mov	ecx, ebx
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState
	pop	ebx
	pop	edi

; 5363 : 	m_eCurrentState = AI_OPERATION_STATE_MOVING_TO_TARGET;

	mov	DWORD PTR [esi+56], 3

; 5364 : 
; 5365 : 	return true;

	mov	al, 1
	pop	esi

; 5366 : }

	ret	8
?RetargetCivilian@CvAINavalEscortedOperation@@QAE_NPAVCvUnit@@PAVCvArmyAI@@@Z ENDP ; CvAINavalEscortedOperation::RetargetCivilian
_TEXT	ENDS
PUBLIC	?ArmyInPosition@CvAIOperationNavalAttack@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperationNavalAttack::ArmyInPosition
; Function compile flags: /Ogtpy
;	COMDAT ?ArmyInPosition@CvAIOperationNavalAttack@@UAE_NPAVCvArmyAI@@@Z
_TEXT	SEGMENT
_zone$226912 = -20					; size = 20
$T237338 = 8						; size = 4
_pArmy$ = 8						; size = 4
?ArmyInPosition@CvAIOperationNavalAttack@@UAE_NPAVCvArmyAI@@@Z PROC ; CvAIOperationNavalAttack::ArmyInPosition, COMDAT
; _this$ = ecx

; 5467 : {

	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 5468 : 	switch(m_eCurrentState)

	mov	eax, DWORD PTR [esi+56]
	push	edi
	cmp	eax, 4
	ja	$LN4@ArmyInPosi@11
	jmp	DWORD PTR $LN44@ArmyInPosi@11[eax*4]
$LN3@ArmyInPosi@11:

; 5469 : 	{
; 5470 : 		// See if reached our target, if so give control of these units to the tactical AI
; 5471 : 	case AI_OPERATION_STATE_MOVING_TO_TARGET:
; 5472 : 	{
; 5473 : 		CvPlot *pCenterOfMass = pArmy->GetCenterOfMass(DOMAIN_SEA);

	mov	ecx, DWORD PTR _pArmy$[esp+32]
	push	0
	call	?GetCenterOfMass@CvArmyAI@@QAEPAVCvPlot@@W4DomainTypes@@@Z ; CvArmyAI::GetCenterOfMass

; 5474 : 
; 5475 : 		// Are we within tactical range of our target? (larger than usual range for a naval attack)
; 5476 : 		if(pCenterOfMass && plotDistance(pCenterOfMass->getX(), pCenterOfMass->getY(), m_iTargetX, m_iTargetY) <= GC.getAI_OPERATIONAL_CITY_ATTACK_DEPLOY_RANGE() * 2)

	test	eax, eax
	je	$LN4@ArmyInPosi@11
	mov	ecx, DWORD PTR [esi+108]
	mov	edx, DWORD PTR [esi+104]
	push	ecx
	movsx	ecx, WORD PTR [eax+2]
	push	edx
	movsx	edx, WORD PTR [eax]
	push	ecx
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2420
	lea	edx, DWORD PTR [ecx+ecx]
	add	esp, 16					; 00000010H
	cmp	eax, edx
	jg	$LN4@ArmyInPosi@11

; 5477 : 		{
; 5478 : 			// Notify Diplo AI we're in place for attack
; 5479 : 			GET_PLAYER(GetOwner()).GetDiplomacyAI()->SetMusteringForAttack(GetEnemy(), true);

	mov	ecx, DWORD PTR [esi+72]
	mov	eax, DWORD PTR [esi+76]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	1
	push	eax
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?SetMusteringForAttack@CvDiplomacyAI@@QAEXW4PlayerTypes@@_N@Z ; CvDiplomacyAI::SetMusteringForAttack

; 5480 : 
; 5481 : 			// Notify tactical AI to focus on this area
; 5482 : 			CvTemporaryZone zone;
; 5483 : 			zone.SetX(GetTargetPlot()->getX());

	mov	ecx, esi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	movsx	edi, WORD PTR [eax]

; 5484 : 			zone.SetY(GetTargetPlot()->getY());

	mov	ecx, esi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	movsx	ebx, WORD PTR [eax+2]

; 5485 : 			zone.SetTargetType(AI_TACTICAL_TARGET_CITY);
; 5486 : 			zone.SetLastTurn(GC.getGame().getGameTurn() + GC.getAI_TACTICAL_MAP_TEMP_ZONE_TURNS());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2452
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	ebp, 1
	mov	DWORD PTR $T237338[esp+32], eax
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn

; 5487 : 			zone.SetNavalInvasion(true);
; 5488 : 			GET_PLAYER(m_eOwner).GetTacticalAI()->AddTemporaryZone(zone);

	mov	ecx, DWORD PTR [esi+72]
	add	eax, DWORD PTR $T237338[esp+32]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	sub	esp, 20					; 00000014H
	mov	edx, esp
	mov	DWORD PTR [edx], edi
	mov	DWORD PTR [edx+4], ebx
	mov	DWORD PTR [edx+8], ebp
	mov	DWORD PTR [edx+12], eax
	mov	BYTE PTR _zone$226912[esp+72], 1
	mov	eax, DWORD PTR _zone$226912[esp+72]
	mov	DWORD PTR [edx+16], eax
	call	?GetTacticalAI@CvPlayer@@QBEPAVCvTacticalAI@@XZ ; CvPlayer::GetTacticalAI
	mov	ecx, eax
	call	?AddTemporaryZone@CvTacticalAI@@QAEXVCvTemporaryZone@@@Z ; CvTacticalAI::AddTemporaryZone

; 5489 : 
; 5490 : 			m_eCurrentState = AI_OPERATION_STATE_SUCCESSFUL_FINISH;

	mov	DWORD PTR [esi+56], 5

; 5491 : 			return true;

	mov	al, 1

; 5502 : 		break;
; 5503 : 	};
; 5504 : 
; 5505 : 	return false;
; 5506 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	4
$LN1@ArmyInPosi@11:

; 5492 : 		}
; 5493 : 	}
; 5494 : 	break;
; 5495 : 
; 5496 : 	// In all other cases use base class version
; 5497 : 	case AI_OPERATION_STATE_GATHERING_FORCES:
; 5498 : 	case AI_OPERATION_STATE_ABORTED:
; 5499 : 	case AI_OPERATION_STATE_RECRUITING_UNITS:
; 5500 : 	case AI_OPERATION_STATE_AT_TARGET:
; 5501 : 		return CvAIOperation::ArmyInPosition(pArmy);

	mov	ecx, DWORD PTR _pArmy$[esp+32]
	push	ecx
	mov	ecx, esi
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition

; 5502 : 		break;
; 5503 : 	};
; 5504 : 
; 5505 : 	return false;
; 5506 : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	4
$LN4@ArmyInPosi@11:
	pop	edi
	pop	esi
	pop	ebp
	xor	al, al
	pop	ebx
	add	esp, 20					; 00000014H
	ret	4
$LN44@ArmyInPosi@11:
	DD	$LN1@ArmyInPosi@11
	DD	$LN1@ArmyInPosi@11
	DD	$LN1@ArmyInPosi@11
	DD	$LN3@ArmyInPosi@11
	DD	$LN1@ArmyInPosi@11
?ArmyInPosition@CvAIOperationNavalAttack@@UAE_NPAVCvArmyAI@@@Z ENDP ; CvAIOperationNavalAttack::ArmyInPosition
_TEXT	ENDS
PUBLIC	?GetOperationStartCity@CvAIOperationNavalAttack@@UBEPAVCvCity@@XZ ; CvAIOperationNavalAttack::GetOperationStartCity
EXTRN	?GetNearestCoastalCity@CvMilitaryAI@@QBEPAVCvCity@@W4PlayerTypes@@@Z:PROC ; CvMilitaryAI::GetNearestCoastalCity
; Function compile flags: /Ogtpy
;	COMDAT ?GetOperationStartCity@CvAIOperationNavalAttack@@UBEPAVCvCity@@XZ
_TEXT	SEGMENT
?GetOperationStartCity@CvAIOperationNavalAttack@@UBEPAVCvCity@@XZ PROC ; CvAIOperationNavalAttack::GetOperationStartCity, COMDAT
; _this$ = ecx

; 5510 : {

	push	esi
	mov	esi, ecx

; 5511 : 	if(GetStartCityPlot())

	call	?GetStartCityPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetStartCityPlot
	test	eax, eax
	je	SHORT $LN1@GetOperati@4

; 5512 : 	{
; 5513 : 		return GetStartCityPlot()->getPlotCity();

	mov	ecx, esi
	call	?GetStartCityPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetStartCityPlot
	mov	ecx, DWORD PTR [eax+104]
	test	ecx, ecx
	jl	SHORT $LN4@GetOperati@4
	cmp	ecx, 64					; 00000040H
	jge	SHORT $LN4@GetOperati@4
	mov	eax, DWORD PTR [eax+108]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	pop	esi

; 5517 : }

	ret	0

; 5512 : 	{
; 5513 : 		return GetStartCityPlot()->getPlotCity();

$LN4@GetOperati@4:
	xor	eax, eax
	pop	esi

; 5517 : }

	ret	0
$LN1@GetOperati@4:

; 5514 : 	}
; 5515 : 
; 5516 : 	return GET_PLAYER(m_eOwner).GetMilitaryAI()->GetNearestCoastalCity(m_eEnemy);

	mov	ecx, DWORD PTR [esi+72]
	mov	edx, DWORD PTR [esi+76]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?GetNearestCoastalCity@CvMilitaryAI@@QBEPAVCvCity@@W4PlayerTypes@@@Z ; CvMilitaryAI::GetNearestCoastalCity
	pop	esi

; 5517 : }

	ret	0
?GetOperationStartCity@CvAIOperationNavalAttack@@UBEPAVCvCity@@XZ ENDP ; CvAIOperationNavalAttack::GetOperationStartCity
_TEXT	ENDS
PUBLIC	?GetOperationStartCity@CvAIOperationNukeAttack@@UBEPAVCvCity@@XZ ; CvAIOperationNukeAttack::GetOperationStartCity
; Function compile flags: /Ogtpy
;	COMDAT ?GetOperationStartCity@CvAIOperationNukeAttack@@UBEPAVCvCity@@XZ
_TEXT	SEGMENT
?GetOperationStartCity@CvAIOperationNukeAttack@@UBEPAVCvCity@@XZ PROC ; CvAIOperationNukeAttack::GetOperationStartCity, COMDAT
; _this$ = ecx

; 5637 : {

	push	esi
	mov	esi, ecx

; 5638 : 	if(GetStartCityPlot())

	call	?GetStartCityPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetStartCityPlot
	test	eax, eax
	je	SHORT $LN1@GetOperati@5

; 5639 : 	{
; 5640 : 		return GetStartCityPlot()->getPlotCity();

	mov	ecx, esi
	call	?GetStartCityPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetStartCityPlot
	mov	ecx, DWORD PTR [eax+104]
	test	ecx, ecx
	jl	SHORT $LN19@GetOperati@5
	cmp	ecx, 64					; 00000040H
	jge	SHORT $LN19@GetOperati@5
	mov	eax, DWORD PTR [eax+108]
	push	eax
	jmp	SHORT $LN24@GetOperati@5
$LN1@GetOperati@5:

; 5641 : 	}
; 5642 : 
; 5643 : 	return GC.getMap().plotCheckInvalid(m_iMusterX, m_iMusterY)->getPlotCity();

	mov	ecx, DWORD PTR [esi+100]
	mov	esi, DWORD PTR [esi+96]
	cmp	esi, -2147483647			; 80000001H
	je	SHORT $LN11@GetOperati@5
	cmp	ecx, -2147483647			; 80000001H
	je	SHORT $LN11@GetOperati@5
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	eax, DWORD PTR [edx+4020]
	imul	eax, ecx
	add	eax, esi
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [edx+4068]
	jmp	SHORT $LN13@GetOperati@5
$LN11@GetOperati@5:
	xor	eax, eax
$LN13@GetOperati@5:
	mov	ecx, DWORD PTR [eax+104]
	test	ecx, ecx
	jl	SHORT $LN19@GetOperati@5
	cmp	ecx, 64					; 00000040H
	jge	SHORT $LN19@GetOperati@5
	mov	edx, DWORD PTR [eax+108]
	push	edx
$LN24@GetOperati@5:
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	pop	esi

; 5644 : }

	ret	0

; 5641 : 	}
; 5642 : 
; 5643 : 	return GC.getMap().plotCheckInvalid(m_iMusterX, m_iMusterY)->getPlotCity();

$LN19@GetOperati@5:
	xor	eax, eax
	pop	esi

; 5644 : }

	ret	0
?GetOperationStartCity@CvAIOperationNukeAttack@@UBEPAVCvCity@@XZ ENDP ; CvAIOperationNukeAttack::GetOperationStartCity
_TEXT	ENDS
PUBLIC	?ArmyInPosition@CvAIOperationNukeAttack@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperationNukeAttack::ArmyInPosition
EXTRN	?getMISSION_NUKE@CvTypes@@YA?BW4MissionTypes@@XZ:PROC ; CvTypes::getMISSION_NUKE
EXTRN	?canNukeAt@CvUnit@@QBE_NPBVCvPlot@@HH@Z:PROC	; CvUnit::canNukeAt
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?ArmyInPosition@CvAIOperationNukeAttack@@UAE_NPAVCvArmyAI@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ArmyInPosition@CvAIOperationNukeAttack@@UAE_NPAVCvArmyAI@@@Z$0
__ehfuncinfo$?ArmyInPosition@CvAIOperationNukeAttack@@UAE_NPAVCvArmyAI@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ArmyInPosition@CvAIOperationNukeAttack@@UAE_NPAVCvArmyAI@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
xdata$x	ENDS
;	COMDAT ?ArmyInPosition@CvAIOperationNukeAttack@@UAE_NPAVCvArmyAI@@@Z
_TEXT	SEGMENT
_strMsg$226994 = -40					; size = 28
__$EHRec$ = -12						; size = 12
_pArmy$ = 8						; size = 4
?ArmyInPosition@CvAIOperationNukeAttack@@UAE_NPAVCvArmyAI@@@Z PROC ; CvAIOperationNukeAttack::ArmyInPosition, COMDAT
; _this$ = ecx

; 5647 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?ArmyInPosition@CvAIOperationNukeAttack@@UAE_NPAVCvArmyAI@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	mov	ebx, ecx

; 5648 : 	CvPlot* pTargetPlot = GetTargetPlot();

	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	mov	esi, eax

; 5649 : 	if(pTargetPlot)

	test	esi, esi
	je	$LN32@ArmyInPosi@12

; 5650 : 	{
; 5651 : 		// Now get the nuke
; 5652 : 		int iUnitID = pArmy->GetFirstUnitID();

	mov	ecx, DWORD PTR _pArmy$[esp+44]
	call	?GetFirstUnitID@CvArmyAI@@QAEHXZ	; CvArmyAI::GetFirstUnitID

; 5653 : 		CvUnit* pNuke = NULL;
; 5654 : 		if(iUnitID != -1)

	cmp	eax, -1
	je	$LN32@ArmyInPosi@12

; 5655 : 		{
; 5656 : 			pNuke = GET_PLAYER(m_eOwner).getUnit(iUnitID);

	mov	ecx, DWORD PTR [ebx+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edi
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax

; 5657 : 		}
; 5658 : 
; 5659 : 		if(pNuke != NULL)

	test	edi, edi
	je	$LN31@ArmyInPosi@12

; 5660 : 		{
; 5661 : 			if(pNuke->canMove() && pNuke->canNukeAt(pNuke->plot(),pTargetPlot->getX(),pTargetPlot->getY()))

	mov	ecx, edi
	call	?canMove@CvUnit@@QBE_NXZ		; CvUnit::canMove
	test	al, al
	je	$LN31@ArmyInPosi@12
	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	eax
	push	ecx
	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	mov	ecx, edi
	call	?canNukeAt@CvUnit@@QBE_NPBVCvPlot@@HH@Z	; CvUnit::canNukeAt
	test	al, al
	je	$LN31@ArmyInPosi@12

; 5662 : 			{
; 5663 : 				pNuke->PushMission(CvTypes::getMISSION_NUKE(), pTargetPlot->getX(), pTargetPlot->getY());

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	eax
	push	ecx
	call	?getMISSION_NUKE@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_NUKE
	push	eax
	mov	ecx, edi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 5664 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN1@ArmyInPosi@12
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN1@ArmyInPosi@12

; 5665 : 				{
; 5666 : 					CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$226994[esp+52]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5667 : 					strMsg.Format("City nuked, At X=%d, At Y=%d", pTargetPlot->getX(), pTargetPlot->getY());

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _strMsg$226994[esp+60]
	push	OFFSET $SG226995
	push	edx
	mov	DWORD PTR __$EHRec$[esp+76], 0
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 5668 : 					LogOperationSpecialMessage(strMsg);

	lea	eax, DWORD PTR _strMsg$226994[esp+52]
	push	eax
	mov	ecx, ebx
	call	?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z ; CvAIOperation::LogOperationSpecialMessage

; 5669 : 				}

	lea	ecx, DWORD PTR _strMsg$226994[esp+52]
	mov	DWORD PTR __$EHRec$[esp+60], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@ArmyInPosi@12:

; 5670 : 				m_eCurrentState = AI_OPERATION_STATE_SUCCESSFUL_FINISH;

	mov	DWORD PTR [ebx+56], 5
$LN31@ArmyInPosi@12:
	pop	edi
	pop	esi

; 5671 : 			}
; 5672 : 		}
; 5673 : 	}
; 5674 : 	return true;

	mov	al, 1
	pop	ebx

; 5675 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	4
$LN32@ArmyInPosi@12:
	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	pop	esi
	mov	al, 1
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ArmyInPosition@CvAIOperationNukeAttack@@UAE_NPAVCvArmyAI@@@Z$0:
	lea	ecx, DWORD PTR _strMsg$226994[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ArmyInPosition@CvAIOperationNukeAttack@@UAE_NPAVCvArmyAI@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ArmyInPosition@CvAIOperationNukeAttack@@UAE_NPAVCvArmyAI@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ArmyInPosition@CvAIOperationNukeAttack@@UAE_NPAVCvArmyAI@@@Z ENDP ; CvAIOperationNukeAttack::ArmyInPosition
PUBLIC	?FindBestTarget@CvAIOperationNukeAttack@@MAEPAVCvPlot@@XZ ; CvAIOperationNukeAttack::FindBestTarget
EXTRN	?isCapital@CvCity@@QBE_NXZ:PROC			; CvCity::isCapital
EXTRN	?nextUnitNode@CvPlot@@QBEPBUIDInfo@@PBU2@@Z:PROC ; CvPlot::nextUnitNode
EXTRN	?getUnit@@YAPAVCvUnit@@ABUIDInfo@@@Z:PROC	; getUnit
EXTRN	?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ:PROC	; CvPlot::headUnitNode
EXTRN	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC	; CvTeam::isAtWar
EXTRN	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z:PROC ; CvPlot::getResourceType
EXTRN	?IsImprovementPillaged@CvPlot@@QBE_NXZ:PROC	; CvPlot::IsImprovementPillaged
EXTRN	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ:PROC ; CvPlot::getImprovementType
EXTRN	?getDamage@CvCity@@QBEHXZ:PROC			; CvCity::getDamage
EXTRN	?GetRange@CvUnit@@QBEHXZ:PROC			; CvUnit::GetRange
EXTRN	?canNuke@CvUnit@@QBE_NPBVCvPlot@@@Z:PROC	; CvUnit::canNuke
; Function compile flags: /Ogtpy
;	COMDAT ?FindBestTarget@CvAIOperationNukeAttack@@MAEPAVCvPlot@@XZ
_TEXT	SEGMENT
_iThisCityValue$227022 = -88				; size = 4
_pLoopUnit$ = -84					; size = 4
_iBlastRadius$ = -80					; size = 4
tv676 = -76						; size = 4
_iDX$227023 = -72					; size = 4
tv691 = -68						; size = 4
_pLoopCity$227015 = -64					; size = 4
_this$ = -60						; size = 4
_ourTeam$ = -56						; size = 4
_iDY$227027 = -52					; size = 4
_iBestCity$ = -48					; size = 4
_enemyPlayer$ = -44					; size = 4
_iCityLoop$ = -40					; size = 4
_pBestUnit$ = -36					; size = 4
_iUnitLoop$ = -32					; size = 4
_pBestCity$ = -28					; size = 4
_iUnitRange$227014 = -24				; size = 4
tv494 = -20						; size = 4
_pCityPlot$227021 = -16					; size = 4
tv514 = -12						; size = 4
tv701 = -8						; size = 4
_ownerPlayer$ = -4					; size = 4
?FindBestTarget@CvAIOperationNukeAttack@@MAEPAVCvPlot@@XZ PROC ; CvAIOperationNukeAttack::FindBestTarget, COMDAT
; _this$ = ecx

; 5678 : {

	sub	esp, 88					; 00000058H
	push	ebx
	push	ebp
	push	esi
	mov	edx, ecx

; 5679 : 	CvUnit* pLoopUnit;
; 5680 : 	CvUnit* pBestUnit = NULL;
; 5681 : 	CvCity* pBestCity = NULL;
; 5682 : 	int iBestCity = 0;
; 5683 : 	int iUnitLoop = 0;
; 5684 : 	int iCityLoop = 0;
; 5685 : 	CvPlayerAI& ownerPlayer = GET_PLAYER(m_eOwner);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edi
	mov	edi, DWORD PTR [edx+72]
	imul	edi, 63236				; 0000f704H
	xor	esi, esi
	add	edi, ecx
	mov	DWORD PTR _iUnitLoop$[esp+104], esi
	mov	DWORD PTR _iCityLoop$[esp+104], esi

; 5686 : 	TeamTypes eTeam = ownerPlayer.getTeam();

	mov	eax, DWORD PTR [edi+44]
	mov	DWORD PTR _this$[esp+104], edx
	mov	DWORD PTR _pBestUnit$[esp+104], esi
	mov	DWORD PTR _pBestCity$[esp+104], esi
	mov	DWORD PTR _iBestCity$[esp+104], esi
	mov	DWORD PTR _ownerPlayer$[esp+104], edi
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN47@FindBestTa@10
	mov	ebx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ebx, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [ebx+eax*4]
	jmp	SHORT $LN48@FindBestTa@10
$LN47@FindBestTa@10:
	or	eax, -1
$LN48@FindBestTa@10:

; 5687 : 	CvTeam& ourTeam = GET_TEAM(eTeam);
; 5688 : 	CvPlayerAI& enemyPlayer = GET_PLAYER(m_eEnemy);

	mov	ebx, DWORD PTR [edx+76]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	imul	ebx, 63236				; 0000f704H

; 5689 : 
; 5690 : 	int iBlastRadius = GC.getNUKE_BLAST_RADIUS();

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6672
	mov	DWORD PTR _ourTeam$[esp+104], eax
	add	ebx, ecx

; 5691 : 
; 5692 : 	// check all of our units to find the nukes
; 5693 : 	for(pLoopUnit = ownerPlayer.firstUnit(&iUnitLoop); pLoopUnit != NULL; pLoopUnit = ownerPlayer.nextUnit(&iUnitLoop))

	push	esi
	lea	eax, DWORD PTR _iUnitLoop$[esp+108]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR _enemyPlayer$[esp+112], ebx
	mov	DWORD PTR _iBlastRadius$[esp+112], ebp
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	DWORD PTR _pLoopUnit$[esp+104], eax
	test	eax, eax
	je	$LN1@FindBestTa@10
$LL133@FindBestTa@10:

; 5694 : 	{
; 5695 : 		if(pLoopUnit && pLoopUnit->canNuke(NULL))

	mov	ecx, DWORD PTR _pLoopUnit$[esp+104]
	test	ecx, ecx
	je	$LN37@FindBestTa@10
	push	0
	call	?canNuke@CvUnit@@QBE_NPBVCvPlot@@@Z	; CvUnit::canNuke
	test	al, al
	je	$LN37@FindBestTa@10

; 5696 : 		{
; 5697 : 			int iUnitRange = pLoopUnit->GetRange();

	mov	ecx, DWORD PTR _pLoopUnit$[esp+104]
	call	?GetRange@CvUnit@@QBEHXZ		; CvUnit::GetRange

; 5698 : 			// for all cities of this enemy
; 5699 : 			CvCity* pLoopCity;
; 5700 : 			for(pLoopCity = enemyPlayer.firstCity(&iCityLoop); pLoopCity != NULL; pLoopCity = enemyPlayer.nextCity(&iCityLoop))

	push	0
	lea	ecx, DWORD PTR _iCityLoop$[esp+108]
	push	ecx
	mov	ecx, ebx
	mov	DWORD PTR _iUnitRange$227014[esp+112], eax
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	DWORD PTR _pLoopCity$227015[esp+104], eax
	test	eax, eax
	je	$LN37@FindBestTa@10
	npad	11
$LL134@FindBestTa@10:

; 5701 : 			{
; 5702 : 				if(pLoopCity)

	mov	edi, DWORD PTR _pLoopCity$227015[esp+104]
	test	edi, edi
	je	$LN33@FindBestTa@10

; 5703 : 				{
; 5704 : 					if(plotDistance(pLoopUnit->getX(),pLoopUnit->getY(),pLoopCity->getX(),pLoopCity->getY()) <= iUnitRange)

	mov	edx, DWORD PTR [edi+108]
	mov	eax, DWORD PTR [edi+96]
	push	edx
	push	eax
	mov	eax, DWORD PTR _pLoopUnit$[esp+112]
	mov	ecx, DWORD PTR [eax+88]
	mov	edx, DWORD PTR [eax+76]
	push	ecx
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, DWORD PTR _iUnitRange$227014[esp+104]
	jg	$LN33@FindBestTa@10

; 5705 : 					{
; 5706 : 						CvPlot* pCityPlot = pLoopCity->plot();

	mov	ecx, edi
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot

; 5707 : 						int iThisCityValue = pLoopCity->getPopulation();

	mov	ecx, edi
	mov	DWORD PTR _pCityPlot$227021[esp+104], eax
	call	?getPopulation@CvCity@@QBEHXZ		; CvCity::getPopulation

; 5708 : 						iThisCityValue -= pLoopCity->getDamage() / 5; // No point nuking a city that is already trashed unless it is good city

	mov	ecx, edi
	mov	ebx, eax
	call	?getDamage@CvCity@@QBEHXZ		; CvCity::getDamage
	mov	ecx, eax
	mov	eax, -1717986919			; 99999999H
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	add	ebx, eax

; 5709 : 
; 5710 : 						// check to see if there is anything good or bad in the radius that we should account for
; 5711 : 
; 5712 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 5713 : 						int iMaxDX, iDX;
; 5714 : 						CvPlot* pLoopPlot;
; 5715 : 						for (int iDY = -iBlastRadius; iDY <= iBlastRadius; iDY++)
; 5716 : 						{
; 5717 : 							iMaxDX = iBlastRadius - MAX(0, iDY);
; 5718 : 							for (iDX = -iBlastRadius - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 5719 : 							{
; 5720 : 								// No need for range check because loops are set up properly
; 5721 : 								pLoopPlot = plotXY(pCityPlot->getX(), pCityPlot->getY(), iDX, iDY);
; 5722 : #else
; 5723 : 						for(int iDX = -iBlastRadius; iDX <= iBlastRadius; iDX++)

	mov	eax, ebp
	neg	eax
	mov	esi, eax
	cmp	esi, ebp
	mov	DWORD PTR _iThisCityValue$227022[esp+104], ebx
	mov	DWORD PTR tv701[esp+104], eax
	mov	DWORD PTR _iDX$227023[esp+104], esi
	jg	$LN27@FindBestTa@10
	mov	ecx, esi
	neg	ecx
	mov	DWORD PTR tv691[esp+104], ecx
$LL29@FindBestTa@10:

; 5724 : 						{
; 5725 : 							for(int iDY = -iBlastRadius; iDY <= iBlastRadius; iDY++)

	mov	ebx, eax
	cmp	ebx, ebp
	mov	DWORD PTR _iDY$227027[esp+104], ebx
	jg	$LN28@FindBestTa@10

; 5726 : 							{
; 5727 : 								CvPlot* pLoopPlot = plotXYWithRangeCheck(pCityPlot->getX(), pCityPlot->getY(), iDX, iDY, iBlastRadius);

	xor	edx, edx
	test	esi, esi
	setge	dl
	mov	edi, ebx
	neg	edi
	mov	DWORD PTR tv676[esp+104], edi
	mov	DWORD PTR tv494[esp+104], edx
$LL26@FindBestTa@10:
	xor	eax, eax
	test	ebx, ebx
	setge	al
	cmp	DWORD PTR tv494[esp+104], eax
	jne	SHORT $LN80@FindBestTa@10
	test	esi, esi
	jl	SHORT $LN83@FindBestTa@10
	mov	ecx, esi
$LN83@FindBestTa@10:
	mov	eax, ebx
	test	ebx, ebx
	jge	SHORT $LN86@FindBestTa@10
	mov	eax, edi
$LN86@FindBestTa@10:
	add	eax, ecx
	jmp	SHORT $LN91@FindBestTa@10
$LN80@FindBestTa@10:
	test	esi, esi
	jl	SHORT $LN87@FindBestTa@10
	mov	ecx, esi
$LN87@FindBestTa@10:
	mov	eax, ebx
	test	ebx, ebx
	jge	SHORT $LN90@FindBestTa@10
	mov	eax, edi
$LN90@FindBestTa@10:
	cmp	ecx, eax
	jl	SHORT $LN91@FindBestTa@10
	mov	eax, ecx
$LN91@FindBestTa@10:
	cmp	eax, ebp
	jg	$LN25@FindBestTa@10
	mov	eax, DWORD PTR _pCityPlot$227021[esp+104]
	movsx	ecx, WORD PTR [eax+2]
	movsx	edx, WORD PTR [eax]
	push	ebx
	push	esi
	push	ecx
	push	edx
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	mov	ebp, eax
	add	esp, 16					; 00000010H

; 5728 : #endif
; 5729 : 								if(pLoopPlot)

	test	ebp, ebp
	je	$LN140@FindBestTa@10

; 5730 : 								{
; 5731 : 									// who owns this plot?
; 5732 : 									PlayerTypes ePlotOwner = pLoopPlot->getOwner();

	movsx	edi, BYTE PTR [ebp+4]
	mov	DWORD PTR tv514[esp+104], edi

; 5733 : 									TeamTypes ePlotTeam = pLoopPlot->getTeam();

	cmp	edi, -1
	je	SHORT $LN96@FindBestTa@10
	cmp	edi, 63					; 0000003fH
	ja	SHORT $LN96@FindBestTa@10
	mov	eax, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [eax+4]
	mov	esi, DWORD PTR [ecx+edi*4]
	jmp	SHORT $LN95@FindBestTa@10
$LN96@FindBestTa@10:
	or	esi, -1
$LN95@FindBestTa@10:

; 5734 : 									// are we at war with them (or are they us)
; 5735 : 									if(ePlotOwner == m_eOwner)

	mov	edx, DWORD PTR _this$[esp+104]
	cmp	edi, DWORD PTR [edx+72]
	jne	SHORT $LN22@FindBestTa@10

; 5736 : 									{
; 5737 : 										iThisCityValue -= 1;

	dec	DWORD PTR _iThisCityValue$227022[esp+104]

; 5738 : 										if(pLoopPlot->getImprovementType() != NO_IMPROVEMENT)

	mov	ecx, ebp
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	je	SHORT $LN135@FindBestTa@10

; 5739 : 										{
; 5740 : 											if(!pLoopPlot->IsImprovementPillaged())

	mov	ecx, ebp
	call	?IsImprovementPillaged@CvPlot@@QBE_NXZ	; CvPlot::IsImprovementPillaged
	test	al, al
	jne	SHORT $LN135@FindBestTa@10

; 5741 : 											{
; 5742 : 												iThisCityValue -= 5;

	sub	DWORD PTR _iThisCityValue$227022[esp+104], 5

; 5743 : 												if(pLoopPlot->getResourceType(ePlotTeam) != NO_RESOURCE)  // we aren't nuking our own resources

	push	esi
	mov	ecx, ebp
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	cmp	eax, -1

; 5744 : 												{
; 5745 : 													iThisCityValue -= 1000;
; 5746 : 												}
; 5747 : 											}
; 5748 : 										}
; 5749 : 									}

	jmp	SHORT $LN144@FindBestTa@10
$LN22@FindBestTa@10:

; 5750 : 									else if(ePlotTeam != NO_TEAM && ourTeam.isAtWar(ePlotTeam))

	cmp	esi, -1
	je	SHORT $LN138@FindBestTa@10
	mov	ecx, DWORD PTR _ourTeam$[esp+104]
	push	esi
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	je	SHORT $LN138@FindBestTa@10

; 5751 : 									{
; 5752 : 										iThisCityValue += 1;

	inc	DWORD PTR _iThisCityValue$227022[esp+104]

; 5753 : 										if(pLoopPlot->getImprovementType() != NO_IMPROVEMENT)

	mov	ecx, ebp
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, -1
	je	SHORT $LN135@FindBestTa@10

; 5754 : 										{
; 5755 : 											if(!pLoopPlot->IsImprovementPillaged())

	mov	ecx, ebp
	call	?IsImprovementPillaged@CvPlot@@QBE_NXZ	; CvPlot::IsImprovementPillaged
	test	al, al
	jne	SHORT $LN135@FindBestTa@10

; 5756 : 											{
; 5757 : 												iThisCityValue += 2;

	add	DWORD PTR _iThisCityValue$227022[esp+104], 2

; 5758 : 												if(pLoopPlot->getResourceType(ePlotTeam) != NO_RESOURCE)  // we like nuking our their resources

	push	esi
	mov	ecx, ebp
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	cmp	eax, -1
	je	SHORT $LN135@FindBestTa@10

; 5759 : 												{
; 5760 : 													iThisCityValue += 5;

	add	DWORD PTR _iThisCityValue$227022[esp+104], 5

; 5761 : 												}
; 5762 : 											}
; 5763 : 										}
; 5764 : 									}

	jmp	SHORT $LN135@FindBestTa@10
$LN138@FindBestTa@10:

; 5765 : 									else if (ePlotOwner != NO_PLAYER) // this will trigger a war

	cmp	edi, -1
$LN144@FindBestTa@10:
	je	SHORT $LN135@FindBestTa@10

; 5766 : 									{
; 5767 : 										iThisCityValue -= 1000;

	sub	DWORD PTR _iThisCityValue$227022[esp+104], 1000 ; 000003e8H
$LN135@FindBestTa@10:

; 5768 : 									}
; 5769 : 
; 5770 : 									// will we hit any units here?
; 5771 : 
; 5772 : 									// Do we want a visibility check here?  We shouldn't know they are here.
; 5773 : 
; 5774 : 									const IDInfo* pUnitNode = pLoopPlot->headUnitNode();

	mov	ecx, ebp
	call	?headUnitNode@CvPlot@@QAEPAUIDInfo@@XZ	; CvPlot::headUnitNode
	mov	edi, eax

; 5775 : 									const CvUnit* pInnerLoopUnit;
; 5776 : 									while(pUnitNode != NULL)

	test	edi, edi
	je	SHORT $LN139@FindBestTa@10
	npad	7
$LL11@FindBestTa@10:

; 5777 : 									{
; 5778 : 										pInnerLoopUnit = ::getUnit(*pUnitNode);

	push	edi
	call	?getUnit@@YAPAVCvUnit@@ABUIDInfo@@@Z	; getUnit
	add	esp, 4

; 5779 : 										pUnitNode = pLoopPlot->nextUnitNode(pUnitNode);

	push	edi
	mov	ecx, ebp
	mov	esi, eax
	call	?nextUnitNode@CvPlot@@QBEPBUIDInfo@@PBU2@@Z ; CvPlot::nextUnitNode
	mov	edi, eax

; 5780 : 										if(pInnerLoopUnit != NULL)

	test	esi, esi
	je	SHORT $LN136@FindBestTa@10

; 5781 : 										{
; 5782 : 											PlayerTypes eUnitOwner = pInnerLoopUnit->getOwner();

	mov	ebx, DWORD PTR [esi+40]

; 5783 : 											TeamTypes eUnitTeam = pInnerLoopUnit->getTeam();

	mov	ecx, esi
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam

; 5784 : 											// are we at war with them (or are they us)
; 5785 : 											if(eUnitOwner == m_eOwner)

	mov	ecx, DWORD PTR _this$[esp+104]
	cmp	ebx, DWORD PTR [ecx+72]
	jne	SHORT $LN8@FindBestTa@10

; 5786 : 											{
; 5787 : 												iThisCityValue -= 2;

	sub	DWORD PTR _iThisCityValue$227022[esp+104], 2
	jmp	SHORT $LN136@FindBestTa@10
$LN8@FindBestTa@10:

; 5788 : 											}
; 5789 : 											else if(ourTeam.isAtWar(eUnitTeam))

	mov	ecx, DWORD PTR _ourTeam$[esp+104]
	push	eax
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	je	SHORT $LN6@FindBestTa@10

; 5790 : 											{
; 5791 : 												iThisCityValue += 2;

	add	DWORD PTR _iThisCityValue$227022[esp+104], 2
	jmp	SHORT $LN136@FindBestTa@10
$LN6@FindBestTa@10:

; 5792 : 											}
; 5793 : 											else if (ePlotOwner != NO_PLAYER) // this will trigger a war

	cmp	DWORD PTR tv514[esp+104], -1
	je	SHORT $LN136@FindBestTa@10

; 5794 : 											{
; 5795 : 												iThisCityValue -= 1000;

	sub	DWORD PTR _iThisCityValue$227022[esp+104], 1000 ; 000003e8H
$LN136@FindBestTa@10:

; 5775 : 									const CvUnit* pInnerLoopUnit;
; 5776 : 									while(pUnitNode != NULL)

	test	edi, edi
	jne	SHORT $LL11@FindBestTa@10
	mov	ebx, DWORD PTR _iDY$227027[esp+104]
$LN139@FindBestTa@10:
	mov	edi, DWORD PTR tv676[esp+104]
	mov	esi, DWORD PTR _iDX$227023[esp+104]
$LN140@FindBestTa@10:
	mov	ebp, DWORD PTR _iBlastRadius$[esp+104]
$LN25@FindBestTa@10:

; 5724 : 						{
; 5725 : 							for(int iDY = -iBlastRadius; iDY <= iBlastRadius; iDY++)

	mov	ecx, DWORD PTR tv691[esp+104]
	inc	ebx
	dec	edi
	cmp	ebx, ebp
	mov	DWORD PTR _iDY$227027[esp+104], ebx
	mov	DWORD PTR tv676[esp+104], edi
	jle	$LL26@FindBestTa@10
	mov	edi, DWORD PTR _pLoopCity$227015[esp+104]
	mov	eax, DWORD PTR tv701[esp+104]
$LN28@FindBestTa@10:
	inc	esi
	dec	ecx
	cmp	esi, ebp
	mov	DWORD PTR _iDX$227023[esp+104], esi
	mov	DWORD PTR tv691[esp+104], ecx
	jle	$LL29@FindBestTa@10

; 5709 : 
; 5710 : 						// check to see if there is anything good or bad in the radius that we should account for
; 5711 : 
; 5712 : #ifdef AUI_HEXSPACE_DX_LOOPS
; 5713 : 						int iMaxDX, iDX;
; 5714 : 						CvPlot* pLoopPlot;
; 5715 : 						for (int iDY = -iBlastRadius; iDY <= iBlastRadius; iDY++)
; 5716 : 						{
; 5717 : 							iMaxDX = iBlastRadius - MAX(0, iDY);
; 5718 : 							for (iDX = -iBlastRadius - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 5719 : 							{
; 5720 : 								// No need for range check because loops are set up properly
; 5721 : 								pLoopPlot = plotXY(pCityPlot->getX(), pCityPlot->getY(), iDX, iDY);
; 5722 : #else
; 5723 : 						for(int iDX = -iBlastRadius; iDX <= iBlastRadius; iDX++)

	mov	ebx, DWORD PTR _iThisCityValue$227022[esp+104]
$LN27@FindBestTa@10:

; 5796 : 											}
; 5797 : 										}
; 5798 : 									}
; 5799 : 								}
; 5800 : 							}
; 5801 : 						}
; 5802 : 
; 5803 : 						// if this is the capital
; 5804 : 						if(pLoopCity->isCapital())

	mov	ecx, edi
	call	?isCapital@CvCity@@QBE_NXZ		; CvCity::isCapital
	test	al, al
	je	SHORT $LN3@FindBestTa@10

; 5805 : 						{
; 5806 : 							iThisCityValue *= 2;

	lea	edx, DWORD PTR [ebx+ebx]
	mov	DWORD PTR _iThisCityValue$227022[esp+104], edx
$LN3@FindBestTa@10:

; 5807 : 						}
; 5808 : 
; 5809 : 						if(iThisCityValue > iBestCity)

	mov	eax, DWORD PTR _iThisCityValue$227022[esp+104]
	cmp	eax, DWORD PTR _iBestCity$[esp+104]

; 5810 : 						{
; 5811 : 							pBestUnit = pLoopUnit;
; 5812 : 							pBestCity = pLoopCity;
; 5813 : 							iBestCity = iThisCityValue;

	mov	ebx, DWORD PTR _enemyPlayer$[esp+104]
	jle	SHORT $LN33@FindBestTa@10
	mov	ecx, DWORD PTR _pLoopUnit$[esp+104]
	mov	DWORD PTR _pBestUnit$[esp+104], ecx
	mov	DWORD PTR _pBestCity$[esp+104], edi
	mov	DWORD PTR _iBestCity$[esp+104], eax
$LN33@FindBestTa@10:
	push	0
	lea	edx, DWORD PTR _iCityLoop$[esp+108]
	push	edx
	mov	ecx, ebx
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pLoopCity$227015[esp+104], eax
	test	eax, eax
	jne	$LL134@FindBestTa@10
	mov	esi, DWORD PTR _pBestUnit$[esp+104]
	mov	edi, DWORD PTR _ownerPlayer$[esp+104]
$LN37@FindBestTa@10:
	push	0
	lea	eax, DWORD PTR _iUnitLoop$[esp+108]
	push	eax
	mov	ecx, edi
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	DWORD PTR _pLoopUnit$[esp+104], eax
	test	eax, eax
	jne	$LL133@FindBestTa@10

; 5814 : 						}
; 5815 : 					}
; 5816 : 				}
; 5817 : 			}
; 5818 : 		}
; 5819 : 	}
; 5820 : 
; 5821 : 	if(pBestCity && pBestUnit)

	mov	ecx, DWORD PTR _pBestCity$[esp+104]
	test	ecx, ecx
	je	SHORT $LN1@FindBestTa@10
	test	esi, esi
	je	SHORT $LN1@FindBestTa@10

; 5822 : 	{
; 5823 : 		m_iMusterX = pBestUnit->getX();

	mov	edx, DWORD PTR [esi+76]
	mov	eax, DWORD PTR _this$[esp+104]
	mov	DWORD PTR [eax+96], edx

; 5824 : 		m_iMusterY = pBestUnit->getY();

	mov	edx, DWORD PTR [esi+88]
	mov	DWORD PTR [eax+100], edx

; 5825 : 		m_iBestUnitID = pBestUnit->GetID();

	mov	edx, DWORD PTR [esi+100]
	mov	DWORD PTR [eax+112], edx

; 5826 : 		return pBestCity->plot();

	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 5830 : }

	add	esp, 88					; 00000058H
	ret	0
$LN1@FindBestTa@10:
	pop	edi
	pop	esi
	pop	ebp

; 5827 : 	}
; 5828 : 
; 5829 : 	return NULL;

	xor	eax, eax
	pop	ebx

; 5830 : }

	add	esp, 88					; 00000058H
	ret	0
?FindBestTarget@CvAIOperationNukeAttack@@MAEPAVCvPlot@@XZ ENDP ; CvAIOperationNukeAttack::FindBestTarget
_TEXT	ENDS
PUBLIC	?begin@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@XZ ; std::vector<OperationSlot,std::allocator<OperationSlot> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@XZ PROC ; std::vector<OperationSlot,std::allocator<OperationSlot> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@XZ ENDP ; std::vector<OperationSlot,std::allocator<OperationSlot> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@XZ ; std::vector<OperationSlot,std::allocator<OperationSlot> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@XZ PROC ; std::vector<OperationSlot,std::allocator<OperationSlot> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@XZ ENDP ; std::vector<OperationSlot,std::allocator<OperationSlot> >::end
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvAStarNode *,200,1,297,0>::~FStaticVector<CvAStarNode *,200,1,297,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvAStarNode *,200,1,297,0>::~FStaticVector<CvAStarNode *,200,1,297,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec:

; 619  : 	};

	ret	0
??1?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvAStarNode *,200,1,297,0>::~FStaticVector<CvAStarNode *,200,1,297,0>
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvOperationSearchUnit,128,1,297,0>::~FStaticVector<CvOperationSearchUnit,128,1,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<CvOperationSearchUnit,128,1,297,0>::~FStaticVector<CvOperationSearchUnit,128,1,297,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec@2:

; 619  : 	};

	ret	0
??1?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<CvOperationSearchUnit,128,1,297,0>::~FStaticVector<CvOperationSearchUnit,128,1,297,0>
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@@Z PROC ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@@Z ENDP ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Make_iter
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAE_NI@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAE_NI@Z PROC ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 357913941				; 15555555H
	jbe	SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@KAXXZ ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Xlen
$LN16@Buy:
$LN2@Buy:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@UOperationSlot@@@std@@YAPAUOperationSlot@@IPAU1@@Z ; std::_Allocate<OperationSlot>

; 1111 : 			_Mylast = _Myfirst;
; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	ecx, DWORD PTR [edi+edi*2]
	add	esp, 8
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	edi
	mov	DWORD PTR [esi+12], edx

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy:
?_Buy@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Buy
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvAStarNode *,200,1,297,0>::GrowSize
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?GrowSize@?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<CvAStarNode *,200,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN30@GrowSize
	mov	DWORD PTR [esi+8], 1
$LN30@GrowSize:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize
	npad	6
$LL8@GrowSize:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN31@GrowSize

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize
$LN31@GrowSize:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 200				; 000000c8H
	jbe	SHORT $LN15@GrowSize
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [ebp*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN14@GrowSize
$LN15@GrowSize:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 200			; 000000c8H
$LN14@GrowSize:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN33@GrowSize
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN33@GrowSize:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+812], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvAStarNode *,200,1,297,0>::GrowSize
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvOperationSearchUnit,128,1,297,0>::GrowSize
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSize@?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<CvOperationSearchUnit,128,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN30@GrowSize@2
	mov	DWORD PTR [esi+8], 1
$LN30@GrowSize@2:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize@2
	npad	6
$LL8@GrowSize@2:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN31@GrowSize@2

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize@2

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize@2
$LN31@GrowSize@2:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize@2:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 128				; 00000080H
	jbe	SHORT $LN15@GrowSize@2
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [ebp*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN14@GrowSize@2
$LN15@GrowSize@2:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 128			; 00000080H
$LN14@GrowSize@2:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN33@GrowSize@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN33@GrowSize@2:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+1036], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvOperationSearchUnit,128,1,297,0>::GrowSize
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAE@XZ ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::~FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAE@XZ PROC ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::~FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec@3
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec@3:

; 619  : 	};

	ret	0
??1?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAE@XZ ENDP ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::~FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<OperationSlot,std::allocator<OperationSlot> >::operator+
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??H?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<OperationSlot,std::allocator<OperationSlot> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<OperationSlot,std::allocator<OperationSlot> >::operator+
_TEXT	ENDS
PUBLIC	??Z?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<OperationSlot,std::allocator<OperationSlot> >::operator-=
; Function compile flags: /Ogtpy
;	COMDAT ??Z?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Z?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<OperationSlot,std::allocator<OperationSlot> >::operator-=, COMDAT
; _this$ = ecx

; 386  : 		{	// decrement by integer

	mov	eax, ecx

; 387  : 		return (*this += -_Off);

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	sub	edx, ecx
	neg	edx
	add	edx, edx
	add	edx, edx
	add	DWORD PTR [eax], edx

; 388  : 		}

	ret	4
??Z?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<OperationSlot,std::allocator<OperationSlot> >::operator-=
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::GrowSize
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEXI@Z PROC ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	ebx
	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	mov	ebx, 1
	jne	SHORT $LN33@GrowSize@3
	mov	DWORD PTR [esi+8], ebx
$LN33@GrowSize@3:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+8]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize@3
	npad	4
$LL8@GrowSize@3:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN34@GrowSize@3

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize@3

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize@3
$LN34@GrowSize@3:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize@3:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, ebx
	jbe	SHORT $LN16@GrowSize@3
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [ebp*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN15@GrowSize@3
$LN16@GrowSize@3:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], ebx
$LN15@GrowSize@3:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN36@GrowSize@3
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN36@GrowSize@3:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+20], bl
	pop	esi
	pop	ebx

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::GrowSize
_TEXT	ENDS
PUBLIC	?GrowSizeToFit@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::GrowSizeToFit
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSizeToFit@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSizeToFit@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEXI@Z PROC ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::GrowSizeToFit, COMDAT
; _this$ = ecx

; 776  : 	{

	push	esi
	push	edi

; 777  : 		if( uiFit <= m_uiCurrMaxSize )

	mov	edi, DWORD PTR _uiFit$[esp+4]
	mov	esi, ecx
	cmp	edi, DWORD PTR [esi+8]
	jbe	SHORT $LN7@GrowSizeTo
	push	ebp

; 778  : 			return;
; 779  : 
; 780  : 		m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edi

; 781  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	cmp	edi, 1
	jbe	SHORT $LN13@GrowSizeTo
	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	lea	eax, DWORD PTR [edi*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	ebp, eax
	mov	DWORD PTR [esi+8], edi
	jmp	SHORT $LN12@GrowSizeTo
$LN13@GrowSizeTo:
	lea	ebp, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 1
$LN12@GrowSizeTo:

; 782  : 		if( bPODType ){
; 783  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	ebp
	call	_memcpy

; 784  : 		}else{
; 785  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 786  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 787  : 		}
; 788  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [esi+12]
	add	esp, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN20@GrowSizeTo
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN20@GrowSizeTo:

; 789  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], ebp

; 790  : 
; 791  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+20], 1
	pop	ebp
$LN7@GrowSizeTo:
	pop	edi
	pop	esi

; 792  : 	};

	ret	4
?GrowSizeToFit@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEXI@Z ENDP ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::GrowSizeToFit
_TEXT	ENDS
PUBLIC	??$find@V?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@UOperationSlot@@@std@@YA?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@0@V10@0ABUOperationSlot@@@Z ; std::find<std::_Vector_iterator<OperationSlot,std::allocator<OperationSlot> >,OperationSlot>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$find@V?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@UOperationSlot@@@std@@YA?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@0@V10@0ABUOperationSlot@@@Z
_TEXT	SEGMENT
$T238024 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
??$find@V?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@UOperationSlot@@@std@@YA?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@0@V10@0ABUOperationSlot@@@Z PROC ; std::find<std::_Vector_iterator<OperationSlot,std::allocator<OperationSlot> >,OperationSlot>, COMDAT

; 73   : 	{	// find first matching _Val

	push	ecx

; 74   : 	_ASSIGN_FROM_BASE(_First,

	mov	eax, DWORD PTR __Val$[esp]
	mov	ecx, DWORD PTR __Last$[esp]
	mov	edx, DWORD PTR __First$[esp]
	push	eax
	push	ecx
	push	edx
	lea	eax, DWORD PTR $T238024[esp+16]
	push	eax
	call	??$_Find@V?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@UOperationSlot@@@std@@YA?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@0@V10@0ABUOperationSlot@@@Z ; std::_Find<std::_Vector_iterator<OperationSlot,std::allocator<OperationSlot> >,OperationSlot>

; 75   : 		_Find(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val));
; 76   : 	return (_First);

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+16]
	mov	DWORD PTR [eax], ecx

; 77   : 	}

	add	esp, 20					; 00000014H
	ret	0
??$find@V?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@UOperationSlot@@@std@@YA?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@0@V10@0ABUOperationSlot@@@Z ENDP ; std::find<std::_Vector_iterator<OperationSlot,std::allocator<OperationSlot> >,OperationSlot>
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAUOperationSlot@@PAU1@@stdext@@YAPAUOperationSlot@@PAU1@00@Z ; stdext::_Unchecked_move_backward<OperationSlot *,OperationSlot *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Unchecked_move_backward@PAUOperationSlot@@PAU1@@stdext@@YAPAUOperationSlot@@PAU1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAUOperationSlot@@PAU1@@stdext@@YAPAUOperationSlot@@PAU1@00@Z PROC ; stdext::_Unchecked_move_backward<OperationSlot *,OperationSlot *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN11@Unchecked_
	push	esi
$LL12@Unchecked_:
	mov	esi, DWORD PTR [ecx-12]
	sub	ecx, 12					; 0000000cH
	sub	eax, 12					; 0000000cH
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	cmp	ecx, edx
	jne	SHORT $LL12@Unchecked_
	pop	esi
$LN11@Unchecked_:

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAUOperationSlot@@PAU1@@stdext@@YAPAUOperationSlot@@PAU1@00@Z ENDP ; stdext::_Unchecked_move_backward<OperationSlot *,OperationSlot *>
_TEXT	ENDS
PUBLIC	??$for_each@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CBUOperationSlot@@$$CBV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBUOperationSlot@@$$CBV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@0@0U1@@Z ; std::for_each<std::_Vector_const_iterator<OperationSlot,std::allocator<OperationSlot> >,SerializeFromSequenceContainer<OperationSlot const ,std::vector<OperationSlot,std::allocator<OperationSlot> > const > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CBUOperationSlot@@$$CBV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBUOperationSlot@@$$CBV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@0@0U1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Func$ = 20						; size = 8
??$for_each@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CBUOperationSlot@@$$CBV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBUOperationSlot@@$$CBV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@0@0U1@@Z PROC ; std::for_each<std::_Vector_const_iterator<OperationSlot,std::allocator<OperationSlot> >,SerializeFromSequenceContainer<OperationSlot const ,std::vector<OperationSlot,std::allocator<OperationSlot> > const > >, COMDAT

; 23   : 	{	// perform function for each element

	push	ebp

; 24   : 	_DEBUG_RANGE(_First, _Last);
; 25   : 	_DEBUG_POINTER(_Func);
; 26   : 	_CHECKED_BASE_TYPE(_InIt) _ChkFirst(_CHECKED_BASE(_First));
; 27   : 	_CHECKED_BASE_TYPE(_InIt) _ChkLast(_CHECKED_BASE(_Last));

	mov	ebp, DWORD PTR __Last$[esp]
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]

; 28   : 	for (; _ChkFirst != _ChkLast; ++_ChkFirst)

	cmp	esi, ebp
	je	SHORT $LN1@for_each@2
	push	ebx
	push	edi
$LL6@for_each@2:

; 29   : 		_Func(*_ChkFirst);

	mov	ecx, DWORD PTR __Func$[esp+12]
	push	esi
	mov	edi, ecx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	lea	ebx, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [ebx-4]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	push	ebx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	esi, 12					; 0000000cH
	cmp	esi, ebp
	jne	SHORT $LL6@for_each@2
	pop	edi
	pop	ebx
$LN1@for_each@2:

; 30   : 	return (_Func);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	ecx, DWORD PTR __Func$[esp+4]
	mov	edx, DWORD PTR __Func$[esp+8]
	pop	esi
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	pop	ebp

; 31   : 	}

	ret	0
??$for_each@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CBUOperationSlot@@$$CBV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBUOperationSlot@@$$CBV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@0@0U1@@Z ENDP ; std::for_each<std::_Vector_const_iterator<OperationSlot,std::allocator<OperationSlot> >,SerializeFromSequenceContainer<OperationSlot const ,std::vector<OperationSlot,std::allocator<OperationSlot> > const > >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UOperationSlot@@@std@@@std@@YAXPAUOperationSlot@@0AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<OperationSlot> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UOperationSlot@@@std@@@std@@YAXPAUOperationSlot@@0AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UOperationSlot@@@std@@@std@@YAXPAUOperationSlot@@0AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<OperationSlot> >, COMDAT

; 233  : 	for (; _First != _Last; ++_First)
; 234  : 		_Al.destroy(_First);
; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@UOperationSlot@@@std@@@std@@YAXPAUOperationSlot@@0AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<OperationSlot> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAUOperationSlot@@IU1@V?$allocator@UOperationSlot@@@std@@@std@@YAXPAUOperationSlot@@IABU1@AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<OperationSlot *,unsigned int,OperationSlot,std::allocator<OperationSlot> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAUOperationSlot@@IU1@V?$allocator@UOperationSlot@@@std@@@std@@YAXPAUOperationSlot@@IABU1@AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAUOperationSlot@@IU1@V?$allocator@UOperationSlot@@@std@@@std@@YAXPAUOperationSlot@@IABU1@AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<OperationSlot *,unsigned int,OperationSlot,std::allocator<OperationSlot> >, COMDAT

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;
; 401  : 
; 402  : 	_TRY_BEGIN
; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	mov	ecx, DWORD PTR __Count$[esp-4]
	test	ecx, ecx
	jbe	SHORT $LN4@Uninit_fil
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR __First$[esp-4]
	push	esi
$LL6@Uninit_fil:

; 404  : 		_Al.construct(_First, _Val);

	test	eax, eax
	je	SHORT $LN5@Uninit_fil
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], esi
$LN5@Uninit_fil:
	dec	ecx
	add	eax, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LL6@Uninit_fil
	pop	esi
$LN4@Uninit_fil:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)
; 407  : 		_Al.destroy(_Next);
; 408  : 	_RERAISE;
; 409  : 	_CATCH_END
; 410  : 	}

	ret	0
??$_Uninit_fill_n@PAUOperationSlot@@IU1@V?$allocator@UOperationSlot@@@std@@@std@@YAXPAUOperationSlot@@IABU1@AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<OperationSlot *,unsigned int,OperationSlot,std::allocator<OperationSlot> >
_TEXT	ENDS
PUBLIC	?_Maxlen@?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAEHXZ ; std::_Temp_iterator<CvOperationSearchUnit>::_Maxlen
; Function compile flags: /Ogtpy
;	COMDAT ?_Maxlen@?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAEHXZ
_TEXT	SEGMENT
__Pair$228473 = -8					; size = 8
?_Maxlen@?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAEHXZ PROC ; std::_Temp_iterator<CvOperationSearchUnit>::_Maxlen, COMDAT
; _this$ = ecx

; 607  : 		{	// return size of buffer

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 608  : 		if (_Pbuf->_Begin == 0 && 0 < _Pbuf->_Size)

	mov	eax, DWORD PTR [esi+16]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN4@Maxlen
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	jle	SHORT $LN5@Maxlen

; 609  : 			{	// allocate buffer on first size query
; 610  : 			pair<_Pty, _PDFT> _Pair =
; 611  : 				std::get_temporary_buffer<_Ty>(_Pbuf->_Size);

	push	eax
	lea	eax, DWORD PTR __Pair$228473[esp+16]
	push	eax
	call	??$get_temporary_buffer@VCvOperationSearchUnit@@@std@@YA?AU?$pair@PAVCvOperationSearchUnit@@H@0@H@Z ; std::get_temporary_buffer<CvOperationSearchUnit>

; 612  : 
; 613  : 			_Pbuf->_Begin = _Pair.first;

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR __Pair$228473[esp+20]
	mov	DWORD PTR [ecx], eax

; 614  : 			_Pbuf->_Current = _Pair.first;

	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [edx+4], eax

; 615  : 			_Pbuf->_Hiwater = _Pair.first;

	mov	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR [ecx+8], eax

; 616  : 			_Pbuf->_Size = _Pair.second;

	mov	edx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR __Pair$228473[esp+24]
	mov	DWORD PTR [edx+12], eax

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [ecx+12]
	add	esp, 8
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
$LN4@Maxlen:

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	edx, eax
	mov	eax, DWORD PTR [edx+12]
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
$LN5@Maxlen:

; 617  : 			}
; 618  : 		return (_Pbuf->_Size);

	mov	eax, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [eax+12]
	pop	esi

; 619  : 		}

	add	esp, 8
	ret	0
?_Maxlen@?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAEHXZ ENDP ; std::_Temp_iterator<CvOperationSearchUnit>::_Maxlen
_TEXT	ENDS
PUBLIC	??$_Median@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z ; std::_Median<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Median@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z
_TEXT	SEGMENT
tv200 = 8						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
tv203 = 16						; size = 4
__Last$ = 16						; size = 4
??$_Median@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z PROC ; std::_Median<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>, COMDAT

; 3010 : 	if (40 < _Last - _First)

	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
	mov	esi, DWORD PTR __Last$[esp]
	mov	eax, esi
	sub	eax, ecx
	sar	eax, 3
	cmp	eax, 40					; 00000028H
	jle	SHORT $LN2@Median

; 3011 : 		{	// median of nine
; 3012 : 		size_t _Step = (_Last - _First + 1) / 8;

	inc	eax
	cdq
	push	ebx
	and	edx, 7
	add	eax, edx
	push	ebp
	push	edi
	sar	eax, 3

; 3013 : 		std::_Med3(_First, _First + _Step, _First + 2 * _Step);

	mov	edi, eax
	shl	edi, 4
	lea	ebx, DWORD PTR [eax*8]
	lea	edx, DWORD PTR [edi+ecx]
	lea	eax, DWORD PTR [ebx+ecx]
	push	edx
	push	eax
	push	ecx
	mov	DWORD PTR tv200[esp+24], eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z ; std::_Med3<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>

; 3014 : 		std::_Med3(_Mid - _Step, _Mid, _Mid + _Step);

	mov	ebp, DWORD PTR __Mid$[esp+24]
	lea	eax, DWORD PTR [ebx+ebp]
	push	eax
	mov	ecx, ebp
	sub	ecx, ebx
	push	ebp
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z ; std::_Med3<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>

; 3015 : 		std::_Med3(_Last - 2 * _Step, _Last - _Step, _Last);

	mov	eax, esi
	sub	eax, ebx
	push	esi
	push	eax
	sub	esi, edi
	push	esi
	mov	DWORD PTR tv203[esp+48], eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z ; std::_Med3<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>

; 3016 : 		std::_Med3(_First + _Step, _Mid, _Last - _Step);

	mov	edx, DWORD PTR tv203[esp+48]
	mov	eax, DWORD PTR tv200[esp+48]
	push	edx
	push	ebp
	push	eax
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z ; std::_Med3<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
	add	esp, 48					; 00000030H
	pop	edi
	pop	ebp
	pop	ebx
	pop	esi

; 3020 : 	}

	ret	0
$LN2@Median:

; 3017 : 		}
; 3018 : 	else
; 3019 : 		std::_Med3(_First, _Mid, _Last);

	mov	edx, DWORD PTR __Mid$[esp]
	push	esi
	push	edx
	push	ecx
	call	??$_Med3@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z ; std::_Med3<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
	add	esp, 12					; 0000000cH
	pop	esi

; 3020 : 	}

	ret	0
??$_Median@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z ENDP ; std::_Median<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0PAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0PAH0@Z PROC ; std::_Make_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>, COMDAT

; 2164 : 	{	// make nontrivial [_First, _Last) into a heap, using operator<

	push	ebx

; 2165 : 	_Diff _Bottom = _Last - _First;

	mov	ebx, DWORD PTR __Last$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	sub	ebx, edi
	sar	ebx, 3

; 2166 : 
; 2167 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

	mov	eax, ebx
	cdq
	sub	eax, edx
	mov	esi, eax
	sar	esi, 1
	test	esi, esi
	jle	SHORT $LN1@Make_heap
	npad	3
$LL2@Make_heap:

; 2168 : 		{	// reheap top half, bottom to top
; 2169 : 		--_Hole;
; 2170 : 		std::_Adjust_heap(_First, _Hole, _Bottom,
; 2171 : 			_Ty(*(_First + _Hole)));

	mov	ecx, DWORD PTR [edi+esi*8-8]
	sub	esp, 8
	mov	eax, esp
	dec	esi
	push	ebx
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR [edi+esi*8+4]
	push	esi
	push	edi
	mov	DWORD PTR [eax+4], edx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
	add	esp, 20					; 00000014H
	test	esi, esi
	jg	SHORT $LL2@Make_heap
$LN1@Make_heap:

; 2172 : 		}
; 2173 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0PAH0@Z ENDP ; std::_Make_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z PROC ; std::_Insertion_sort1<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement>, COMDAT

; 2967 : 	{	// insertion sort [_First, _Last), using operator<

	push	ebp

; 2968 : 	if (_First != _Last)

	mov	ebp, DWORD PTR __Last$[esp]
	push	edi
	mov	edi, DWORD PTR __First$[esp+4]
	cmp	edi, ebp
	je	SHORT $LN6@Insertion_

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	lea	edx, DWORD PTR [edi+8]
	cmp	edx, ebp
	je	SHORT $LN6@Insertion_
	push	ebx
	push	esi
$LL7@Insertion_:

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;
; 2972 : 			_Ty _Val = *_Next;

	mov	esi, DWORD PTR [edx+4]

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	cmp	esi, DWORD PTR [edi+4]
	mov	ebx, DWORD PTR [edx]
	mov	ecx, edx
	jle	SHORT $LN5@Insertion_

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	eax, edx
	cmp	edi, edx
	je	SHORT $LN21@Insertion_
	npad	7
$LL22@Insertion_:
	mov	ecx, DWORD PTR [eax-8]
	sub	eax, 8
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+12], ecx
	cmp	eax, edi
	jne	SHORT $LL22@Insertion_
$LN21@Insertion_:

; 2977 : 				*_First = _Val;

	mov	DWORD PTR [edi], ebx
	mov	DWORD PTR [edi+4], esi

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_
$LN5@Insertion_:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	cmp	esi, DWORD PTR [edx-4]
	lea	eax, DWORD PTR [edx-8]
	jle	SHORT $LN1@Insertion_
$LL3@Insertion_:

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	ecx, eax
	sub	eax, 8
	cmp	esi, DWORD PTR [eax+4]
	jg	SHORT $LL3@Insertion_

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	mov	ebp, DWORD PTR __Last$[esp+12]
$LN1@Insertion_:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	DWORD PTR [ecx], ebx
	mov	DWORD PTR [ecx+4], esi
$LN4@Insertion_:
	add	edx, 8
	cmp	edx, ebp
	jne	SHORT $LL7@Insertion_
	pop	esi
	pop	ebx
$LN6@Insertion_:
	pop	edi
	pop	ebp

; 2986 : 				}
; 2987 : 			}
; 2988 : 	}

	ret	0
??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z ENDP ; std::_Insertion_sort1<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@@stdext@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@std@@@Z ; stdext::unchecked_uninitialized_copy<OperationSlot *,OperationSlot *,std::allocator<OperationSlot> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@@stdext@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@std@@@Z
_TEXT	SEGMENT
$T238244 = -4						; size = 1
__Cat$238249 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@@stdext@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<OperationSlot *,OperationSlot *,std::allocator<OperationSlot> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T238244[esp+4], 0
	mov	eax, DWORD PTR $T238244[esp+4]
	mov	ecx, DWORD PTR __Cat$238249[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@@std@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<OperationSlot *,OperationSlot *,std::allocator<OperationSlot> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@@stdext@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<OperationSlot *,OperationSlot *,std::allocator<OperationSlot> >
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@PAVCvOperationSearchUnit@@V1@@std@@YAXPAVCvOperationSearchUnit@@00@Z ; std::_Insertion_sort1<CvOperationSearchUnit *,CvOperationSearchUnit>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Insertion_sort1@PAVCvOperationSearchUnit@@V1@@std@@YAXPAVCvOperationSearchUnit@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@PAVCvOperationSearchUnit@@V1@@std@@YAXPAVCvOperationSearchUnit@@00@Z PROC ; std::_Insertion_sort1<CvOperationSearchUnit *,CvOperationSearchUnit>, COMDAT

; 2967 : 	{	// insertion sort [_First, _Last), using operator<

	push	ebp

; 2968 : 	if (_First != _Last)

	mov	ebp, DWORD PTR __Last$[esp]
	push	edi
	mov	edi, DWORD PTR __First$[esp+4]
	cmp	edi, ebp
	je	SHORT $LN6@Insertion_@2

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	lea	edx, DWORD PTR [edi+8]
	cmp	edx, ebp
	je	SHORT $LN6@Insertion_@2
	push	ebx
	push	esi
$LL7@Insertion_@2:

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;
; 2972 : 			_Ty _Val = *_Next;

	mov	esi, DWORD PTR [edx]

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	cmp	esi, DWORD PTR [edi]
	mov	ebx, DWORD PTR [edx+4]
	mov	ecx, edx
	jge	SHORT $LN5@Insertion_@2

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	eax, edx
	cmp	edi, edx
	je	SHORT $LN23@Insertion_@2
	npad	8
$LL24@Insertion_@2:
	mov	ecx, DWORD PTR [eax-8]
	sub	eax, 8
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+12], ecx
	cmp	eax, edi
	jne	SHORT $LL24@Insertion_@2
$LN23@Insertion_@2:

; 2977 : 				*_First = _Val;

	mov	DWORD PTR [edi], esi
	mov	DWORD PTR [edi+4], ebx

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_@2
$LN5@Insertion_@2:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	cmp	esi, DWORD PTR [edx-8]
	lea	eax, DWORD PTR [edx-8]
	jge	SHORT $LN1@Insertion_@2
$LL3@Insertion_@2:

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	ecx, eax
	sub	eax, 8
	cmp	esi, DWORD PTR [eax]
	jl	SHORT $LL3@Insertion_@2

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	mov	ebp, DWORD PTR __Last$[esp+12]
$LN1@Insertion_@2:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [ecx+4], ebx
$LN4@Insertion_@2:
	add	edx, 8
	cmp	edx, ebp
	jne	SHORT $LL7@Insertion_@2
	pop	esi
	pop	ebx
$LN6@Insertion_@2:
	pop	edi
	pop	ebp

; 2986 : 				}
; 2987 : 			}
; 2988 : 	}

	ret	0
??$_Insertion_sort1@PAVCvOperationSearchUnit@@V1@@std@@YAXPAVCvOperationSearchUnit@@00@Z ENDP ; std::_Insertion_sort1<CvOperationSearchUnit *,CvOperationSearchUnit>
_TEXT	ENDS
PUBLIC	??$_Unchecked_merge_backward@PAVCvOperationSearchUnit@@PAV1@PAV1@@stdext@@YAPAVCvOperationSearchUnit@@PAV1@0000@Z ; stdext::_Unchecked_merge_backward<CvOperationSearchUnit *,CvOperationSearchUnit *,CvOperationSearchUnit *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_merge_backward@PAVCvOperationSearchUnit@@PAV1@PAV1@@stdext@@YAPAVCvOperationSearchUnit@@PAV1@0000@Z
_TEXT	SEGMENT
$T238328 = -4						; size = 1
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
??$_Unchecked_merge_backward@PAVCvOperationSearchUnit@@PAV1@PAV1@@stdext@@YAPAVCvOperationSearchUnit@@PAV1@0000@Z PROC ; stdext::_Unchecked_merge_backward<CvOperationSearchUnit *,CvOperationSearchUnit *,CvOperationSearchUnit *>, COMDAT

; 5202 : 	{

	push	ecx

; 5203 : 		return _STD _Merge_backward(_First1, _Last1, _First2, _Last2, _Dest, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Dest$[esp]
	mov	edx, DWORD PTR __Last2$[esp]
	mov	BYTE PTR $T238328[esp+4], 0
	mov	eax, DWORD PTR $T238328[esp+4]
	push	eax
	mov	eax, DWORD PTR __First2$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last1$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First1$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Merge_backward@PAVCvOperationSearchUnit@@PAV1@PAV1@@std@@YAPAVCvOperationSearchUnit@@PAV1@0000U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<CvOperationSearchUnit *,CvOperationSearchUnit *,CvOperationSearchUnit *>

; 5204 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_merge_backward@PAVCvOperationSearchUnit@@PAV1@PAV1@@stdext@@YAPAVCvOperationSearchUnit@@PAV1@0000@Z ENDP ; stdext::_Unchecked_merge_backward<CvOperationSearchUnit *,CvOperationSearchUnit *,CvOperationSearchUnit *>
_TEXT	ENDS
PUBLIC	??$lower_bound@PAVCvOperationSearchUnit@@V1@@std@@YAPAVCvOperationSearchUnit@@PAV1@0ABV1@@Z ; std::lower_bound<CvOperationSearchUnit *,CvOperationSearchUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??$lower_bound@PAVCvOperationSearchUnit@@V1@@std@@YAPAVCvOperationSearchUnit@@PAV1@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$lower_bound@PAVCvOperationSearchUnit@@V1@@std@@YAPAVCvOperationSearchUnit@@PAV1@0ABV1@@Z PROC ; std::lower_bound<CvOperationSearchUnit *,CvOperationSearchUnit>, COMDAT

; 2276 : 	_ASSIGN_FROM_BASE(_First,

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Lower_bound@PAVCvOperationSearchUnit@@V1@H@std@@YAPAVCvOperationSearchUnit@@PAV1@0ABV1@PAH@Z ; std::_Lower_bound<CvOperationSearchUnit *,CvOperationSearchUnit,int>
	add	esp, 16					; 00000010H

; 2277 : 		_Lower_bound(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val, _Dist_type(_First)));
; 2278 : 	return _First;
; 2279 : 	}

	ret	0
??$lower_bound@PAVCvOperationSearchUnit@@V1@@std@@YAPAVCvOperationSearchUnit@@PAV1@0ABV1@@Z ENDP ; std::lower_bound<CvOperationSearchUnit *,CvOperationSearchUnit>
_TEXT	ENDS
PUBLIC	??$upper_bound@PAVCvOperationSearchUnit@@V1@@std@@YAPAVCvOperationSearchUnit@@PAV1@0ABV1@@Z ; std::upper_bound<CvOperationSearchUnit *,CvOperationSearchUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??$upper_bound@PAVCvOperationSearchUnit@@V1@@std@@YAPAVCvOperationSearchUnit@@PAV1@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$upper_bound@PAVCvOperationSearchUnit@@V1@@std@@YAPAVCvOperationSearchUnit@@PAV1@0ABV1@@Z PROC ; std::upper_bound<CvOperationSearchUnit *,CvOperationSearchUnit>, COMDAT

; 2347 : 	_ASSIGN_FROM_BASE(_First,

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	push	edx
	call	??$_Upper_bound@PAVCvOperationSearchUnit@@V1@H@std@@YAPAVCvOperationSearchUnit@@PAV1@0ABV1@PAH@Z ; std::_Upper_bound<CvOperationSearchUnit *,CvOperationSearchUnit,int>
	add	esp, 16					; 00000010H

; 2348 : 		_Upper_bound(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val, _Dist_type(_First)));
; 2349 : 	return _First;
; 2350 : 	}

	ret	0
??$upper_bound@PAVCvOperationSearchUnit@@V1@@std@@YAPAVCvOperationSearchUnit@@PAV1@0ABV1@@Z ENDP ; std::upper_bound<CvOperationSearchUnit *,CvOperationSearchUnit>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@0@PAVCvOperationSearchUnit@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit>,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_opt@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@0@PAVCvOperationSearchUnit@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T238346 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
___formal$ = 48						; size = 1
??$_Copy_opt@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@0@PAVCvOperationSearchUnit@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit>,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ecx

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp]
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR __Last$[esp+12]
	xor	ebx, ebx
	mov	DWORD PTR $T238346[esp+16], ebx
	cmp	ecx, edi
	je	SHORT $LN1@Copy_opt@4
	lea	esi, DWORD PTR [ebx+8]
	npad	7
$LL3@Copy_opt@4:

; 2472 : 		*_Dest = *_First;

	mov	edx, DWORD PTR __Dest$[esp+28]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $LN14@Copy_opt@4
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR __Dest$[esp+28]
	add	DWORD PTR [eax+4], esi
	jmp	SHORT $LN2@Copy_opt@4
$LN14@Copy_opt@4:
	cmp	eax, ebx
	je	SHORT $LN19@Copy_opt@4
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR __Dest$[esp+28]
$LN19@Copy_opt@4:
	add	DWORD PTR [edx+4], esi
	mov	eax, DWORD PTR __Dest$[esp+28]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+8], edx
$LN2@Copy_opt@4:
	add	ecx, esi
	cmp	ecx, edi
	jne	SHORT $LL3@Copy_opt@4
$LN1@Copy_opt@4:

; 2473 : 	return (_Dest);

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+12]
	mov	eax, DWORD PTR __Dest$[esp+28]
	mov	DWORD PTR [esi+16], eax
	mov	eax, DWORD PTR __Dest$[esp+12]
	mov	DWORD PTR [esi], ebx
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi+8], ebx
	mov	DWORD PTR [esi+12], ebx
	cmp	eax, ebx
	je	SHORT $LN41@Copy_opt@4
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN41@Copy_opt@4:
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx

; 2474 : 	}

	pop	ecx
	ret	0
??$_Copy_opt@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@0@PAVCvOperationSearchUnit@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit>,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Merge@PAVCvOperationSearchUnit@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvOperationSearchUnit@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvOperationSearchUnit *,CvOperationSearchUnit *,CvOperationSearchUnit *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Merge@PAVCvOperationSearchUnit@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvOperationSearchUnit@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Merge@PAVCvOperationSearchUnit@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvOperationSearchUnit@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<CvOperationSearchUnit *,CvOperationSearchUnit *,CvOperationSearchUnit *,std::random_access_iterator_tag>, COMDAT

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	eax, DWORD PTR __First1$[esp-4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	ecx, DWORD PTR __First2$[esp-4]
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Last1$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Last2$[esp+8]
	cmp	eax, esi
	je	SHORT $LN20@Merge
	npad	5
$LL5@Merge:
	cmp	ecx, edi
	je	SHORT $LN3@Merge

; 2514 : 		if (_DEBUG_LT(*_First2, *_First1))

	mov	ebx, DWORD PTR [ecx]
	cmp	ebx, DWORD PTR [eax]
	jge	SHORT $LN2@Merge

; 2515 : 			*_Dest = *_First2, ++_First2;

	mov	DWORD PTR [edx], ebx
	mov	ebx, DWORD PTR [ecx+4]
	add	ecx, 8

; 2516 : 		else

	jmp	SHORT $LN44@Merge
$LN2@Merge:

; 2517 : 			*_Dest = *_First1, ++_First1;

	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ebx
	mov	ebx, DWORD PTR [eax+4]
	add	eax, 8
$LN44@Merge:
	mov	DWORD PTR [edx+4], ebx
	add	edx, 8
	cmp	eax, esi
	jne	SHORT $LL5@Merge
$LN3@Merge:

; 2518 : 
; 2519 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	cmp	eax, esi
	je	SHORT $LN20@Merge
	npad	4
$LL22@Merge:
	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ebx
	mov	ebx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ebx
	add	eax, 8
	add	edx, 8
	cmp	eax, esi
	jne	SHORT $LL22@Merge
$LN20@Merge:

; 2520 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	mov	eax, edx
	cmp	ecx, edi
	je	SHORT $LN31@Merge
	npad	6
$LL33@Merge:
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	add	ecx, 8
	add	eax, 8
	cmp	ecx, edi
	jne	SHORT $LL33@Merge
$LN31@Merge:
	pop	edi
	pop	esi
	pop	ebx

; 2521 : 	}

	ret	0
??$_Merge@PAVCvOperationSearchUnit@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvOperationSearchUnit@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<CvOperationSearchUnit *,CvOperationSearchUnit *,CvOperationSearchUnit *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$rotate@PAVCvOperationSearchUnit@@@std@@YAXPAVCvOperationSearchUnit@@00@Z ; std::rotate<CvOperationSearchUnit *>
; Function compile flags: /Ogtpy
;	COMDAT ??$rotate@PAVCvOperationSearchUnit@@@std@@YAXPAVCvOperationSearchUnit@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$rotate@PAVCvOperationSearchUnit@@@std@@YAXPAVCvOperationSearchUnit@@00@Z PROC ; std::rotate<CvOperationSearchUnit *>, COMDAT

; 1719 : 	if (_First != _Mid && _Mid != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Mid$[esp-4]
	cmp	edx, eax
	je	SHORT $LN6@rotate
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN6@rotate

; 1720 : 		_Rotate(_CHECKED_BASE(_First), _CHECKED_BASE(_Mid), _CHECKED_BASE(_Last), _Iter_cat(_First));

	push	0
	push	0
	push	ecx
	push	eax
	push	edx
	call	??$_Rotate@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@00PAH0@Z ; std::_Rotate<CvOperationSearchUnit *,int,CvOperationSearchUnit>
	add	esp, 20					; 00000014H
$LN6@rotate:

; 1721 : 	}

	ret	0
??$rotate@PAVCvOperationSearchUnit@@@std@@YAXPAVCvOperationSearchUnit@@00@Z ENDP ; std::rotate<CvOperationSearchUnit *>
_TEXT	ENDS
PUBLIC	??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z ; std::_Pop_heap_0<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z PROC ; std::_Pop_heap_0<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement>, COMDAT

; 2088 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2089 : 		_Ty(*(_Last - 1)), _Dist_type(_First));

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR [eax-8]
	push	edi
	mov	edi, DWORD PTR [eax-4]
	mov	DWORD PTR [eax-8], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax-4], edx
	sub	eax, ecx
	sub	esp, 8
	mov	edx, esp
	sub	eax, 8
	sar	eax, 3
	push	eax
	push	0
	push	ecx
	mov	DWORD PTR [edx], esi
	mov	DWORD PTR [edx+4], edi
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
	add	esp, 20					; 00000014H

; 2090 : 	}

	pop	edi
	pop	esi
	ret	0
??$_Pop_heap_0@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z ENDP ; std::_Pop_heap_0<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z PROC	; std::vector<int,std::allocator<int> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@2
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@2:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@2

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
$LN16@Buy@2:
$LN2@Buy@2:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@2:
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ENDP	; std::vector<int,std::allocator<int> >::_Buy
_TEXT	ENDS
PUBLIC	?begin@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::begin, COMDAT
; _this$ = ecx

; 556  : 		return (_TREE_ITERATOR(_Lmost()));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 557  : 		}

	ret	4
?begin@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::begin
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z PROC ; std::vector<int,std::allocator<int> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Buynode
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z
_TEXT	SEGMENT
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1409 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	20					; 00000014H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 1410 : 		_TRY_BEGIN
; 1411 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

	test	eax, eax
	je	SHORT $LN4@Buynode
	mov	ecx, DWORD PTR __Larg$[esp-4]
	mov	edx, DWORD PTR __Parg$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __Rarg$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx]
	mov	dl, BYTE PTR __Carg$[esp-4]
	mov	DWORD PTR [eax+12], ecx
	mov	BYTE PTR [eax+16], dl
	mov	BYTE PTR [eax+17], 0
$LN4@Buynode:

; 1412 : 		_CATCH_ALL
; 1413 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1414 : 		_RERAISE;
; 1415 : 		_CATCH_END
; 1416 : 		return (_Wherenode);
; 1417 : 		}

	ret	20					; 00000014H
?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Buynode
_TEXT	ENDS
PUBLIC	??Fconst_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::operator--
; Function compile flags: /Ogtpy
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fconst_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::operator--, COMDAT
; _this$ = ecx

; 286  : 			{	// predecrement

	push	esi
	mov	esi, ecx

; 287  : 			_Dec();

	call	?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::_Dec

; 288  : 			return (*this);

	mov	eax, esi
	pop	esi

; 289  : 			}

	ret	0
??Fconst_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::operator--
_TEXT	ENDS
PUBLIC	?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::end
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z ; std::vector<int,std::allocator<int> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z PROC ; std::vector<int,std::allocator<int> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z ENDP ; std::vector<int,std::allocator<int> >::_Make_iter
_TEXT	ENDS
PUBLIC	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$vector@HV?$allocator@H@std@@@std@@@Z ; operator<<<int>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$?6H@@YAAAVFDataStream@@AAV0@ABV?$vector@HV?$allocator@H@std@@@std@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
$T238727 = 12						; size = 4
_readFrom$ = 12						; size = 4
??$?6H@@YAAAVFDataStream@@AAV0@ABV?$vector@HV?$allocator@H@std@@@std@@@Z PROC ; operator<<<int>, COMDAT

; 198  : {

	push	ebx

; 199  : 	std::for_each(readFrom.begin(), readFrom.end(), SerializeFromSequenceContainer<const ElementType, const std::vector<ElementType> >(saveTo, readFrom));

	mov	ebx, DWORD PTR _saveTo$[esp]
	push	esi
	mov	esi, DWORD PTR _readFrom$[esp+4]
	mov	eax, DWORD PTR [esi+8]
	sub	eax, DWORD PTR [esi+4]
	push	edi
	lea	ecx, DWORD PTR $T238727[esp+8]
	sar	eax, 2
	push	ecx
	mov	ecx, ebx
	mov	DWORD PTR $T238727[esp+12], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	mov	edi, DWORD PTR [esi+8]
	mov	esi, DWORD PTR [esi+4]
	cmp	esi, edi
	je	SHORT $LN36@operator@5
	npad	2
$LL22@operator@5:
	push	esi
	mov	ecx, ebx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	esi, 4
	cmp	esi, edi
	jne	SHORT $LL22@operator@5
$LN36@operator@5:
	pop	edi
	pop	esi

; 200  : 	return saveTo;

	mov	eax, ebx
	pop	ebx

; 201  : }

	ret	0
??$?6H@@YAAAVFDataStream@@AAV0@ABV?$vector@HV?$allocator@H@std@@@std@@@Z ENDP ; operator<<<int>
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<int,std::allocator<int> >::operator+
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator+
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z PROC ; stdext::_Unchecked_move_backward<int *,int *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN14@Unchecked_@2
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_@2:
	mov	eax, esi
	pop	esi

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ENDP ; stdext::_Unchecked_move_backward<int *,int *>
_TEXT	ENDS
PUBLIC	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z	; stdext::unchecked_fill_n<int *,unsigned int,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z PROC	; stdext::unchecked_fill_n<int *,unsigned int,int>, COMDAT

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN7@unchecked_@7
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL9@unchecked_@7:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL9@unchecked_@7
	pop	esi
$LN7@unchecked_@7:

; 3722 : 	}

	ret	0
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ENDP	; stdext::unchecked_fill_n<int *,unsigned int,int>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>, COMDAT

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN10@Uninit_mov
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@Uninit_mov:
	pop	edi
	mov	eax, esi
	pop	esi

; 208  : 	}

	ret	0
??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z ; CvAIOperation::Kill
EXTRN	?deleteAIOperation@CvPlayer@@QAEXH@Z:PROC	; CvPlayer::deleteAIOperation
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
;	COMDAT ?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
_TEXT	SEGMENT
_eReason$ = 8						; size = 4
?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z PROC ; CvAIOperation::Kill, COMDAT
; _this$ = ecx

; 842  : {

	push	ebx
	push	esi
	mov	esi, ecx

; 843  : 	int iID = m_iID;
; 844  : 	PlayerTypes eOwner = GetOwner();
; 845  : 
; 846  : 	if (m_eAbortReason == NO_ABORT_REASON)

	cmp	DWORD PTR [esi+60], -1
	mov	ebx, DWORD PTR [esi+72]
	push	edi
	mov	edi, DWORD PTR [esi+52]
	jne	SHORT $LN1@Kill

; 847  : 	{
; 848  : 		m_eAbortReason = eReason;

	mov	eax, DWORD PTR _eReason$[esp+8]
	mov	DWORD PTR [esi+60], eax
$LN1@Kill:

; 849  : 	}
; 850  : 
; 851  : 	LogOperationEnd();

	call	?LogOperationEnd@CvAIOperation@@QAEXXZ	; CvAIOperation::LogOperationEnd

; 852  : 	Uninit();

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, esi
	call	eax

; 853  : 	GET_PLAYER(eOwner).deleteAIOperation(iID);

	mov	ecx, ebx
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edi
	call	?deleteAIOperation@CvPlayer@@QAEXH@Z	; CvPlayer::deleteAIOperation
	pop	edi
	pop	esi
	pop	ebx

; 854  : }

	ret	4
?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z ENDP ; CvAIOperation::Kill
_TEXT	ENDS
PUBLIC	?DoTurn@CvAIOperation@@UAEXXZ			; CvAIOperation::DoTurn
; Function compile flags: /Ogtpy
;	COMDAT ?DoTurn@CvAIOperation@@UAEXXZ
_TEXT	SEGMENT
?DoTurn@CvAIOperation@@UAEXXZ PROC			; CvAIOperation::DoTurn, COMDAT
; _this$ = ecx

; 859  : 	LogOperationStatus();

	jmp	?LogOperationStatus@CvAIOperation@@QAEXXZ ; CvAIOperation::LogOperationStatus
?DoTurn@CvAIOperation@@UAEXXZ ENDP			; CvAIOperation::DoTurn
_TEXT	ENDS
PUBLIC	?RetargetDefensiveArmy@CvAIOperationRapidResponse@@AAE_NPAVCvArmyAI@@@Z ; CvAIOperationRapidResponse::RetargetDefensiveArmy
; Function compile flags: /Ogtpy
;	COMDAT ?RetargetDefensiveArmy@CvAIOperationRapidResponse@@AAE_NPAVCvArmyAI@@@Z
_TEXT	SEGMENT
_pArmy$ = 8						; size = 4
?RetargetDefensiveArmy@CvAIOperationRapidResponse@@AAE_NPAVCvArmyAI@@@Z PROC ; CvAIOperationRapidResponse::RetargetDefensiveArmy, COMDAT
; _this$ = ecx

; 5016 : {

	push	esi
	push	edi
	mov	esi, ecx

; 5017 : 	CvPlot* pBetterTarget;
; 5018 : 
; 5019 : 	// Find most threatened city
; 5020 : 	pBetterTarget = FindBestTarget();

	call	?FindBestTarget@CvAIOperationRapidResponse@@AAEPAVCvPlot@@XZ ; CvAIOperationRapidResponse::FindBestTarget
	mov	edi, eax

; 5021 : 
; 5022 : 	// No targets at all!  Abort
; 5023 : 	if(pBetterTarget == NULL)

	test	edi, edi
	jne	SHORT $LN3@RetargetDe

; 5024 : 	{
; 5025 : 		m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	DWORD PTR [esi+56], eax
	pop	edi

; 5026 : 		m_eAbortReason = AI_ABORT_NO_TARGET;

	mov	DWORD PTR [esi+60], 1

; 5027 : 		return false;

	xor	al, al
	pop	esi

; 5041 : }

	ret	4
$LN3@RetargetDe:
	push	ebx

; 5028 : 	}
; 5029 : 
; 5030 : 	// If this is a new target, switch to it
; 5031 : 	else if(pBetterTarget != GetTargetPlot())

	mov	ecx, esi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	mov	ebx, DWORD PTR _pArmy$[esp+8]
	cmp	edi, eax
	je	SHORT $LN1@RetargetDe

; 5032 : 	{
; 5033 : 		SetTargetPlot(pBetterTarget);

	movsx	eax, WORD PTR [edi]
	mov	DWORD PTR [esi+104], eax
	movsx	ecx, WORD PTR [edi+2]
	mov	DWORD PTR [esi+108], ecx

; 5034 : 		pArmy->SetGoalPlot(pBetterTarget);

	push	edi
	mov	ecx, ebx
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot
$LN1@RetargetDe:

; 5035 : 	}
; 5036 : 
; 5037 : 	pArmy->SetArmyAIState(ARMYAISTATE_MOVING_TO_DESTINATION);

	push	2
	mov	ecx, ebx
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState
	pop	ebx
	pop	edi

; 5038 : 	m_eCurrentState = AI_OPERATION_STATE_MOVING_TO_TARGET;

	mov	DWORD PTR [esi+56], 3

; 5039 : 
; 5040 : 	return true;

	mov	al, 1
	pop	esi

; 5041 : }

	ret	4
?RetargetDefensiveArmy@CvAIOperationRapidResponse@@AAE_NPAVCvArmyAI@@@Z ENDP ; CvAIOperationRapidResponse::RetargetDefensiveArmy
_TEXT	ENDS
PUBLIC	?ArmyInPosition@CvAINavalEscortedOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAINavalEscortedOperation::ArmyInPosition
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?ArmyInPosition@CvAINavalEscortedOperation@@UAE_NPAVCvArmyAI@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ArmyInPosition@CvAINavalEscortedOperation@@UAE_NPAVCvArmyAI@@@Z$0
__ehfuncinfo$?ArmyInPosition@CvAINavalEscortedOperation@@UAE_NPAVCvArmyAI@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ArmyInPosition@CvAINavalEscortedOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
xdata$x	ENDS
;	COMDAT ?ArmyInPosition@CvAINavalEscortedOperation@@UAE_NPAVCvArmyAI@@@Z
_TEXT	SEGMENT
_bStateChanged$ = -45					; size = 1
_pTargetPlotOwner$226826 = -44				; size = 4
_strMsg$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
_pArmy$ = 8						; size = 4
?ArmyInPosition@CvAINavalEscortedOperation@@UAE_NPAVCvArmyAI@@@Z PROC ; CvAINavalEscortedOperation::ArmyInPosition, COMDAT
; _this$ = ecx

; 5245 : {

	push	-1
	push	__ehhandler$?ArmyInPosition@CvAINavalEscortedOperation@@UAE_NPAVCvArmyAI@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	mov	esi, ecx

; 5246 : 	int iUnitID = 0;
; 5247 : 	bool bStateChanged = false;
; 5248 : 	CvUnit* pSettler = 0, *pEscort = 0;
; 5249 : 	CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$[esp+56]
	mov	BYTE PTR _bStateChanged$[esp+56], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5250 : 
; 5251 : 	switch(m_eCurrentState)

	mov	eax, DWORD PTR [esi+56]
	mov	DWORD PTR __$EHRec$[esp+64], 0
	cmp	eax, 4
	ja	$LN51@ArmyInPosi@13
	jmp	DWORD PTR $LN59@ArmyInPosi@13[eax*4]
$LN16@ArmyInPosi@13:
	push	edi

; 5252 : 	{
; 5253 : 	case AI_OPERATION_STATE_MOVING_TO_TARGET:
; 5254 : 	case AI_OPERATION_STATE_AT_TARGET:
; 5255 : 
; 5256 : 		// Call base class version and see if it thinks we're done
; 5257 : 		bStateChanged = CvAIOperation::ArmyInPosition(pArmy);

	mov	edi, DWORD PTR _pArmy$[esp+56]
	push	edi
	mov	ecx, esi
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition

; 5258 : 
; 5259 : 		// Now get the settler
; 5260 : 		iUnitID = pArmy->GetFirstUnitID();

	mov	ecx, edi
	mov	BYTE PTR _bStateChanged$[esp+60], al
	call	?GetFirstUnitID@CvArmyAI@@QAEHXZ	; CvArmyAI::GetFirstUnitID

; 5261 : 		if(iUnitID != -1)

	cmp	eax, -1
	je	$LN56@ArmyInPosi@13

; 5262 : 		{
; 5263 : 			pSettler = GET_PLAYER(m_eOwner).getUnit(iUnitID);

	mov	ecx, DWORD PTR [esi+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax

; 5264 : 		}
; 5265 : 
; 5266 : 		if(pSettler != NULL)

	test	edi, edi
	je	$LN56@ArmyInPosi@13
	push	ebp

; 5267 : 		{
; 5268 : 			CvPlot* pTargetPlot = GetTargetPlot();

	mov	ecx, esi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	mov	ebp, eax

; 5269 : 			const PlayerTypes pTargetPlotOwner = pTargetPlot->getOwner();

	movsx	eax, BYTE PTR [ebp+4]

; 5270 : 
; 5271 : 			CvPlot* pSettlerPlot = pSettler->plot();

	mov	ecx, edi
	mov	DWORD PTR _pTargetPlotOwner$226826[esp+64], eax
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ebx, eax

; 5272 : 
; 5273 : 			if((pTargetPlotOwner != NO_PLAYER && pTargetPlotOwner != m_eOwner) || pTargetPlot->IsAdjacentOwnedByOtherTeam(pSettler->getTeam()))

	mov	eax, DWORD PTR _pTargetPlotOwner$226826[esp+64]
	cmp	eax, -1
	je	SHORT $LN11@ArmyInPosi@13
	cmp	eax, DWORD PTR [esi+72]
	jne	SHORT $LN12@ArmyInPosi@13
$LN11@ArmyInPosi@13:
	mov	ecx, edi
	call	?getTeam@CvUnit@@QBE?AW4TeamTypes@@XZ	; CvUnit::getTeam
	push	eax
	mov	ecx, ebp
	call	?IsAdjacentOwnedByOtherTeam@CvPlot@@QBE_NW4TeamTypes@@@Z ; CvPlot::IsAdjacentOwnedByOtherTeam
	test	al, al
	je	SHORT $LN13@ArmyInPosi@13
$LN12@ArmyInPosi@13:

; 5274 : 			{
; 5275 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN3@ArmyInPosi@13
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN3@ArmyInPosi@13

; 5276 : 				{
; 5277 : 					strMsg.Format("Not at target but can no longer settle here. Target was (X=%d Y=%d)", pTargetPlot->getX(), pTargetPlot->getY());

	movsx	ecx, WORD PTR [ebp+2]
	movsx	edx, WORD PTR [ebp]
	push	ecx
	push	edx
	lea	eax, DWORD PTR _strMsg$[esp+72]
	push	OFFSET $SG226832
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 5278 : 					LogOperationSpecialMessage(strMsg);

	lea	ecx, DWORD PTR _strMsg$[esp+64]
	push	ecx

; 5279 : 				}
; 5280 : 				RetargetCivilian(pSettler, pArmy);
; 5281 : 				pSettler->finishMoves();
; 5282 : 				iUnitID = pArmy->GetNextUnitID();
; 5283 : 				if(iUnitID != -1)
; 5284 : 				{
; 5285 : 					pEscort = GET_PLAYER(m_eOwner).getUnit(iUnitID);
; 5286 : 					pEscort->finishMoves();
; 5287 : 				}
; 5288 : 			}

	jmp	$LN58@ArmyInPosi@13
$LN13@ArmyInPosi@13:

; 5289 : 			// If the settler made it, we don't care about the entire army
; 5290 : 			else if(pSettlerPlot == pTargetPlot && pSettler->canMove() && pSettler->canFound(pSettlerPlot))

	cmp	ebx, ebp
	jne	$LN7@ArmyInPosi@13
	mov	ecx, edi
	call	?canMove@CvUnit@@QBE_NXZ		; CvUnit::canMove
	test	al, al
	je	$LN7@ArmyInPosi@13
	push	0
	push	ebx
	mov	ecx, edi
	call	?canFound@CvUnit@@QBE_NPBVCvPlot@@_N@Z	; CvUnit::canFound
	test	al, al
	je	$LN7@ArmyInPosi@13

; 5291 : 			{
; 5292 : 				pSettler->PushMission(CvTypes::getMISSION_FOUND());

	push	0
	push	0
	push	-1
	push	0
	push	0
	push	0
	push	-1
	push	-1
	call	?getMISSION_FOUND@CvTypes@@YA?BW4MissionTypes@@XZ ; CvTypes::getMISSION_FOUND
	push	eax
	mov	ecx, edi
	call	?PushMission@CvUnit@@QAEXW4MissionTypes@@HHH_N1W4MissionAITypes@@PAVCvPlot@@PAV1@@Z ; CvUnit::PushMission

; 5293 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN6@ArmyInPosi@13
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN6@ArmyInPosi@13

; 5294 : 				{
; 5295 : 					strMsg.Format("City founded, At X=%d, At Y=%d", pSettlerPlot->getX(), pSettlerPlot->getY());

	movsx	edx, WORD PTR [ebx+2]
	movsx	eax, WORD PTR [ebx]
	push	edx
	push	eax
	lea	ecx, DWORD PTR _strMsg$[esp+72]
	push	OFFSET $SG226837
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 5296 : 					LogOperationSpecialMessage(strMsg);

	lea	edx, DWORD PTR _strMsg$[esp+64]
	push	edx
	mov	ecx, esi
	call	?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z ; CvAIOperation::LogOperationSpecialMessage
$LN6@ArmyInPosi@13:

; 5297 : 				}
; 5298 : 				m_eCurrentState = AI_OPERATION_STATE_SUCCESSFUL_FINISH;

	mov	DWORD PTR [esi+56], 5
$LN57@ArmyInPosi@13:
	pop	ebp
$LN56@ArmyInPosi@13:
	pop	edi
$LN51@ArmyInPosi@13:

; 5327 : 		break;
; 5328 : 	};
; 5329 : 
; 5330 : 	return bStateChanged;

	lea	ecx, DWORD PTR _strMsg$[esp+56]
	mov	DWORD PTR __$EHRec$[esp+64], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR _bStateChanged$[esp+56]
	pop	esi
	pop	ebx

; 5331 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	mov	DWORD PTR fs:0, ecx
	add	esp, 48					; 00000030H
	ret	4
$LN7@ArmyInPosi@13:

; 5299 : 			}
; 5300 : 
; 5301 : 			// If we're at our target but can no longer found a city, might be someone else beat us to this area
; 5302 : 			// So move back out, picking a new target
; 5303 : 			else if(pSettlerPlot == GetTargetPlot() && !pSettler->canFound(pSettlerPlot))

	mov	ecx, esi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	cmp	ebx, eax
	jne	SHORT $LN57@ArmyInPosi@13
	push	0
	push	ebx
	mov	ecx, edi
	call	?canFound@CvUnit@@QBE_NPBVCvPlot@@_N@Z	; CvUnit::canFound
	test	al, al
	jne	SHORT $LN57@ArmyInPosi@13

; 5304 : 			{
; 5305 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN3@ArmyInPosi@13
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN3@ArmyInPosi@13

; 5306 : 				{
; 5307 : 					strMsg.Format("At target but can no longer settle here. Target was (X=%d Y=%d)", pTargetPlot->getX(), pTargetPlot->getY());

	movsx	eax, WORD PTR [ebp+2]
	movsx	ecx, WORD PTR [ebp]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _strMsg$[esp+72]
	push	OFFSET $SG226841
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 5308 : 					LogOperationSpecialMessage(strMsg);

	lea	eax, DWORD PTR _strMsg$[esp+64]
	push	eax
$LN58@ArmyInPosi@13:
	mov	ecx, esi
	call	?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z ; CvAIOperation::LogOperationSpecialMessage
$LN3@ArmyInPosi@13:

; 5309 : 				}
; 5310 : 				RetargetCivilian(pSettler, pArmy);

	mov	ebx, DWORD PTR _pArmy$[esp+60]
	push	ebx
	push	edi
	mov	ecx, esi
	call	?RetargetCivilian@CvAINavalEscortedOperation@@QAE_NPAVCvUnit@@PAVCvArmyAI@@@Z ; CvAINavalEscortedOperation::RetargetCivilian

; 5311 : 				pSettler->finishMoves();

	mov	ecx, edi
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 5312 : 				iUnitID = pArmy->GetNextUnitID();

	mov	ecx, ebx
	call	?GetNextUnitID@CvArmyAI@@QAEHXZ		; CvArmyAI::GetNextUnitID

; 5313 : 				if(iUnitID != -1)

	cmp	eax, -1
	je	$LN57@ArmyInPosi@13

; 5314 : 				{
; 5315 : 					pEscort = GET_PLAYER(m_eOwner).getUnit(iUnitID);

	mov	ecx, DWORD PTR [esi+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit

; 5316 : 					pEscort->finishMoves();

	mov	ecx, eax
	call	?finishMoves@CvUnit@@QAEXXZ		; CvUnit::finishMoves

; 5317 : 				}
; 5318 : 			}
; 5319 : 		}
; 5320 : 		break;

	jmp	$LN57@ArmyInPosi@13
$LN1@ArmyInPosi@13:

; 5321 : 
; 5322 : 		// In all other cases use base class version
; 5323 : 	case AI_OPERATION_STATE_GATHERING_FORCES:
; 5324 : 	case AI_OPERATION_STATE_ABORTED:
; 5325 : 	case AI_OPERATION_STATE_RECRUITING_UNITS:
; 5326 : 		return CvAIOperation::ArmyInPosition(pArmy);

	mov	ecx, DWORD PTR _pArmy$[esp+52]
	push	ecx
	mov	ecx, esi
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition
	lea	ecx, DWORD PTR _strMsg$[esp+56]
	mov	bl, al
	mov	DWORD PTR __$EHRec$[esp+64], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 5331 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	pop	esi
	mov	al, bl
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 48					; 00000030H
	ret	4
	npad	2
$LN59@ArmyInPosi@13:
	DD	$LN1@ArmyInPosi@13
	DD	$LN1@ArmyInPosi@13
	DD	$LN1@ArmyInPosi@13
	DD	$LN16@ArmyInPosi@13
	DD	$LN16@ArmyInPosi@13
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ArmyInPosition@CvAINavalEscortedOperation@@UAE_NPAVCvArmyAI@@@Z$0:
	lea	ecx, DWORD PTR _strMsg$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?ArmyInPosition@CvAINavalEscortedOperation@@UAE_NPAVCvArmyAI@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ArmyInPosition@CvAINavalEscortedOperation@@UAE_NPAVCvArmyAI@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ArmyInPosition@CvAINavalEscortedOperation@@UAE_NPAVCvArmyAI@@@Z ENDP ; CvAINavalEscortedOperation::ArmyInPosition
PUBLIC	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z ; std::vector<int,std::allocator<int> >::erase
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z PROC ; std::vector<int,std::allocator<int> >::erase, COMDAT
; _this$ = ecx

; 1018 : 		_STDEXT unchecked_copy(_VEC_ITER_BASE(_Where) + 1, _Mylast,
; 1019 : 			_VEC_ITER_BASE(_Where));

	mov	edx, DWORD PTR __Where$[esp-4]
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [edx+4]
	sub	eax, ecx
	sar	eax, 2
	test	eax, eax
	jle	SHORT $LN9@erase
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	edx
	call	DWORD PTR __imp__memmove_s
	mov	edx, DWORD PTR __Where$[esp+16]
	add	esp, 16					; 00000010H
$LN9@erase:

; 1020 : 		_Destroy(_Mylast - 1, _Mylast);
; 1021 : 		--_Mylast;
; 1022 : 		return (_Make_iter(_Where));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	add	DWORD PTR [esi+8], -4			; fffffffcH
	mov	DWORD PTR [eax], edx
	pop	esi

; 1023 : 		}

	ret	8
?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z ENDP ; std::vector<int,std::allocator<int> >::erase
_TEXT	ENDS
PUBLIC	??0?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ ; std::vector<OperationSlot,std::allocator<OperationSlot> >::vector<OperationSlot,std::allocator<OperationSlot> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ PROC ; std::vector<OperationSlot,std::allocator<OperationSlot> >::vector<OperationSlot,std::allocator<OperationSlot> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ ENDP ; std::vector<OperationSlot,std::allocator<OperationSlot> >::vector<OperationSlot,std::allocator<OperationSlot> >
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@QAEIABQAVCvAStarNode@@@Z ; FStaticVector<CvAStarNode *,200,1,297,0>::push_back
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?push_back@?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@QAEIABQAVCvAStarNode@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@QAEIABQAVCvAStarNode@@@Z PROC ; FStaticVector<CvAStarNode *,200,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+812], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvAStarNode *,200,1,297,0>::GrowSize
$LN1@push_back:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $LN4@push_back
	mov	edx, DWORD PTR _element$[esp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
$LN4@push_back:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@QAEIABQAVCvAStarNode@@@Z ENDP ; FStaticVector<CvAStarNode *,200,1,297,0>::push_back
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAEIABVCvOperationSearchUnit@@@Z ; FStaticVector<CvOperationSearchUnit,128,1,297,0>::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAEIABVCvOperationSearchUnit@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAEIABVCvOperationSearchUnit@@@Z PROC ; FStaticVector<CvOperationSearchUnit,128,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+1036], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back@2

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<CvOperationSearchUnit,128,1,297,0>::GrowSize
$LN1@push_back@2:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN4@push_back@2
	mov	ecx, DWORD PTR _element$[esp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN4@push_back@2:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAEIABVCvOperationSearchUnit@@@Z ENDP ; FStaticVector<CvOperationSearchUnit,128,1,297,0>::push_back
_TEXT	ENDS
PUBLIC	??0?$CvWeightedVector@PAVCvPlot@@$00$00@@QAE@XZ	; CvWeightedVector<CvPlot *,1,1>::CvWeightedVector<CvPlot *,1,1>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ??0?$CvWeightedVector@PAVCvPlot@@$00$00@@QAE@XZ
_TEXT	SEGMENT
??0?$CvWeightedVector@PAVCvPlot@@$00$00@@QAE@XZ PROC	; CvWeightedVector<CvPlot *,1,1>::CvWeightedVector<CvPlot *,1,1>, COMDAT
; _this$ = ecx

; 52   : 	CvWeightedVector(void)

	mov	eax, ecx
	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 1
	mov	DWORD PTR [eax], ecx

; 53   : 	{
; 54   : 	};

	ret	0
??0?$CvWeightedVector@PAVCvPlot@@$00$00@@QAE@XZ ENDP	; CvWeightedVector<CvPlot *,1,1>::CvWeightedVector<CvPlot *,1,1>
_TEXT	ENDS
PUBLIC	??1?$CvWeightedVector@PAVCvPlot@@$00$00@@QAE@XZ	; CvWeightedVector<CvPlot *,1,1>::~CvWeightedVector<CvPlot *,1,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$CvWeightedVector@PAVCvPlot@@$00$00@@QAE@XZ
_TEXT	SEGMENT
??1?$CvWeightedVector@PAVCvPlot@@$00$00@@QAE@XZ PROC	; CvWeightedVector<CvPlot *,1,1>::~CvWeightedVector<CvPlot *,1,1>, COMDAT
; _this$ = ecx

; 59   : 	};

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN6@CvWeighted
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN6@CvWeighted:
	ret	0
??1?$CvWeightedVector@PAVCvPlot@@$00$00@@QAE@XZ ENDP	; CvWeightedVector<CvPlot *,1,1>::~CvWeightedVector<CvPlot *,1,1>
_TEXT	ENDS
PUBLIC	??G?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<OperationSlot,std::allocator<OperationSlot> >::operator-
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??G?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??G?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<OperationSlot,std::allocator<OperationSlot> >::operator-, COMDAT
; _this$ = ecx

; 392  : 		_Myt _Tmp = *this;
; 393  : 		return (_Tmp -= _Off);

	mov	eax, DWORD PTR __Off$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*2]
	add	eax, eax
	add	eax, eax
	sub	ecx, eax
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 394  : 		}

	ret	8
??G?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<OperationSlot,std::allocator<OperationSlot> >::operator-
_TEXT	ENDS
PUBLIC	?reserve@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAEXI@Z ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::reserve
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?reserve@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAEXI@Z
_TEXT	SEGMENT
_uiResSize$ = 8						; size = 4
?reserve@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAEXI@Z PROC ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::reserve, COMDAT
; _this$ = ecx

; 658  : 		GrowSizeToFit(uiResSize);

	jmp	?GrowSizeToFit@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::GrowSizeToFit
?reserve@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAEXI@Z ENDP ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::reserve
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@Z ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@Z PROC ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+20], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back@3

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::GrowSize
$LN1@push_back@3:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN4@push_back@3
	mov	ecx, DWORD PTR _element$[esp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN4@push_back@3:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@QAEIABUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@Z ENDP ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::push_back
_TEXT	ENDS
PUBLIC	??$?6UOperationSlot@@@@YAAAVFDataStream@@AAV0@ABV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@Z ; operator<<<OperationSlot>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$?6UOperationSlot@@@@YAAAVFDataStream@@AAV0@ABV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@Z
_TEXT	SEGMENT
$T239310 = -8						; size = 8
$T239322 = 8						; size = 4
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??$?6UOperationSlot@@@@YAAAVFDataStream@@AAV0@ABV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@Z PROC ; operator<<<OperationSlot>, COMDAT

; 198  : {

	sub	esp, 8
	push	esi

; 199  : 	std::for_each(readFrom.begin(), readFrom.end(), SerializeFromSequenceContainer<const ElementType, const std::vector<ElementType> >(saveTo, readFrom));

	mov	esi, DWORD PTR _readFrom$[esp+8]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, DWORD PTR [esi+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	push	edi
	mov	edi, DWORD PTR _saveTo$[esp+12]
	shr	eax, 31					; 0000001fH
	lea	ecx, DWORD PTR $T239322[esp+12]
	add	eax, edx
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR $T239322[esp+16], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+4]
	push	esi
	push	edi
	push	eax
	push	ecx
	lea	edx, DWORD PTR $T239310[esp+32]
	push	edx
	call	??$for_each@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@U?$SerializeFromSequenceContainer@$$CBUOperationSlot@@$$CBV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@@@std@@YA?AU?$SerializeFromSequenceContainer@$$CBUOperationSlot@@$$CBV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@0@0U1@@Z ; std::for_each<std::_Vector_const_iterator<OperationSlot,std::allocator<OperationSlot> >,SerializeFromSequenceContainer<OperationSlot const ,std::vector<OperationSlot,std::allocator<OperationSlot> > const > >
	add	esp, 20					; 00000014H

; 200  : 	return saveTo;

	mov	eax, edi
	pop	edi
	pop	esi

; 201  : }

	add	esp, 8
	ret	0
??$?6UOperationSlot@@@@YAAAVFDataStream@@AAV0@ABV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@Z ENDP ; operator<<<OperationSlot>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UOperationSlot@@@std@@@std@@YAXPAUOperationSlot@@0AAV?$allocator@UOperationSlot@@@0@@Z ; std::_Destroy_range<std::allocator<OperationSlot> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UOperationSlot@@@std@@@std@@YAXPAUOperationSlot@@0AAV?$allocator@UOperationSlot@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UOperationSlot@@@std@@@std@@YAXPAUOperationSlot@@0AAV?$allocator@UOperationSlot@@@0@@Z PROC ; std::_Destroy_range<std::allocator<OperationSlot> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@UOperationSlot@@@std@@@std@@YAXPAUOperationSlot@@0AAV?$allocator@UOperationSlot@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<OperationSlot> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAUOperationSlot@@IU1@V?$allocator@UOperationSlot@@@std@@@stdext@@YAXPAUOperationSlot@@IABU1@AAV?$allocator@UOperationSlot@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<OperationSlot *,unsigned int,OperationSlot,std::allocator<OperationSlot> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAUOperationSlot@@IU1@V?$allocator@UOperationSlot@@@std@@@stdext@@YAXPAUOperationSlot@@IABU1@AAV?$allocator@UOperationSlot@@@std@@@Z
_TEXT	SEGMENT
$T239356 = -4						; size = 1
__Cat$239360 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAUOperationSlot@@IU1@V?$allocator@UOperationSlot@@@std@@@stdext@@YAXPAUOperationSlot@@IABU1@AAV?$allocator@UOperationSlot@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<OperationSlot *,unsigned int,OperationSlot,std::allocator<OperationSlot> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T239356[esp+4], 0
	mov	eax, DWORD PTR $T239356[esp+4]
	mov	ecx, DWORD PTR __Cat$239360[esp+4]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_fill_n@PAUOperationSlot@@IU1@V?$allocator@UOperationSlot@@@std@@@std@@YAXPAUOperationSlot@@IABU1@AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<OperationSlot *,unsigned int,OperationSlot,std::allocator<OperationSlot> >

; 943  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_fill_n@PAUOperationSlot@@IU1@V?$allocator@UOperationSlot@@@std@@@stdext@@YAXPAUOperationSlot@@IABU1@AAV?$allocator@UOperationSlot@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<OperationSlot *,unsigned int,OperationSlot,std::allocator<OperationSlot> >
_TEXT	ENDS
PUBLIC	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z
_TEXT	SEGMENT
__Tmp$239469 = -24					; size = 8
__Tmp$239398 = -16					; size = 8
__Tmp$239424 = -8					; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z PROC ; std::_Unguarded_partition<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>, COMDAT

; 3024 : 	{	// partition [_First, _Last), using operator<

	sub	esp, 24					; 00000018H
	push	ebx

; 3025 : 	_RanIt _Mid = _First + (_Last - _First) / 2;	// sort median to _Mid

	mov	ebx, DWORD PTR __First$[esp+24]
	push	ebp
	mov	ebp, DWORD PTR __Last$[esp+28]
	mov	eax, ebp
	sub	eax, ebx
	sar	eax, 3
	cdq
	push	esi
	sub	eax, edx
	push	edi
	sar	eax, 1
	lea	edi, DWORD PTR [ebx+eax*8]

; 3026 : 	std::_Median(_First, _Mid, _Last - 1);

	lea	eax, DWORD PTR [ebp-8]
	push	eax
	push	edi
	push	ebx
	call	??$_Median@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z ; std::_Median<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
	add	esp, 12					; 0000000cH

; 3027 : 	_RanIt _Pfirst = _Mid;

	mov	ecx, edi

; 3028 : 	_RanIt _Plast = _Pfirst + 1;

	lea	esi, DWORD PTR [edi+8]

; 3029 : 
; 3030 : 	while (_First < _Pfirst
; 3031 : 		&& !_DEBUG_LT(*(_Pfirst - 1), *_Pfirst)
; 3032 : 		&& !(*_Pfirst < *(_Pfirst - 1)))

	cmp	ebx, edi
	jae	SHORT $LN99@Unguarded_
$LL27@Unguarded_:
	mov	eax, DWORD PTR [ecx-4]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, eax
	jl	SHORT $LN99@Unguarded_
	jg	SHORT $LN99@Unguarded_

; 3033 : 		--_Pfirst;

	sub	ecx, 8
	cmp	ebx, ecx
	jb	SHORT $LL27@Unguarded_
$LN99@Unguarded_:

; 3034 : 	while (_Plast < _Last
; 3035 : 		&& !_DEBUG_LT(*_Plast, *_Pfirst)
; 3036 : 		&& !(*_Pfirst < *_Plast))

	cmp	esi, ebp
	jae	SHORT $LN24@Unguarded_
	mov	edx, DWORD PTR [ecx+4]
	npad	1
$LL25@Unguarded_:
	mov	eax, DWORD PTR [esi+4]
	cmp	edx, eax
	jl	SHORT $LN24@Unguarded_
	jg	SHORT $LN24@Unguarded_

; 3037 : 		++_Plast;

	add	esi, 8
	cmp	esi, ebp
	jb	SHORT $LL25@Unguarded_
$LN24@Unguarded_:

; 3038 : 
; 3039 : 	_RanIt _Gfirst = _Plast;

	mov	eax, esi

; 3040 : 	_RanIt _Glast = _Pfirst;

	mov	ebx, ecx
$LL23@Unguarded_:

; 3041 : 
; 3042 : 	for (; ; )
; 3043 : 		{	// partition
; 3044 : 		for (; _Gfirst < _Last; ++_Gfirst)

	cmp	eax, DWORD PTR __Last$[esp+36]
	jae	SHORT $LN103@Unguarded_
	npad	6
$LL21@Unguarded_:

; 3045 : 			if (_DEBUG_LT(*_Pfirst, *_Gfirst))

	mov	edx, DWORD PTR [eax+4]
	mov	edi, DWORD PTR [ecx+4]
	cmp	edx, edi
	jl	SHORT $LN20@Unguarded_

; 3046 : 				;
; 3047 : 			else if (*_Gfirst < *_Pfirst)

	jg	SHORT $LN103@Unguarded_

; 3048 : 				break;
; 3049 : 			else
; 3050 : 				std::iter_swap(_Plast++, _Gfirst);

	mov	edx, esi
	add	esi, 8
	cmp	edx, eax
	je	SHORT $LN20@Unguarded_
	mov	ebp, DWORD PTR [edx+4]
	mov	edi, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$239398[esp+44], ebp
	mov	ebp, DWORD PTR [eax]
	mov	DWORD PTR [edx], ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ebp
	mov	edx, DWORD PTR __Tmp$239398[esp+44]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edx
$LN20@Unguarded_:
	add	eax, 8
	cmp	eax, DWORD PTR __Last$[esp+36]
	jb	SHORT $LL21@Unguarded_
$LN103@Unguarded_:

; 3051 : 		for (; _First < _Glast; --_Glast)

	cmp	ebx, DWORD PTR __First$[esp+36]
	jbe	SHORT $LN115@Unguarded_
	lea	edx, DWORD PTR [ebx-8]
$LL14@Unguarded_:

; 3052 : 			if (_DEBUG_LT(*(_Glast - 1), *_Pfirst))

	mov	edi, DWORD PTR [edx+4]
	mov	ebp, DWORD PTR [ecx+4]
	cmp	ebp, edi
	jl	SHORT $LN13@Unguarded_

; 3053 : 				;
; 3054 : 			else if (*_Pfirst < *(_Glast - 1))

	jg	SHORT $LN111@Unguarded_

; 3055 : 				break;
; 3056 : 			else
; 3057 : 				std::iter_swap(--_Pfirst, _Glast - 1);

	sub	ecx, 8
	cmp	ecx, edx
	je	SHORT $LN13@Unguarded_
	mov	ebp, DWORD PTR [ecx+4]
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$239424[esp+44], ebp
	mov	ebp, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR __Tmp$239424[esp+44]
	mov	DWORD PTR [edx+4], edi
$LN13@Unguarded_:
	sub	ebx, 8
	sub	edx, 8
	cmp	DWORD PTR __First$[esp+36], ebx
	jb	SHORT $LL14@Unguarded_
$LN111@Unguarded_:

; 3058 : 		if (_Glast == _First && _Gfirst == _Last)

	cmp	ebx, DWORD PTR __First$[esp+36]
$LN115@Unguarded_:
	jne	SHORT $LN6@Unguarded_
	cmp	eax, DWORD PTR __Last$[esp+36]
	je	$LN105@Unguarded_

; 3060 : 
; 3061 : 		if (_Glast == _First)
; 3062 : 			{	// no room at bottom, rotate pivot upward
; 3063 : 			if (_Plast != _Gfirst)

	cmp	esi, eax
	je	SHORT $LN64@Unguarded_

; 3064 : 				std::iter_swap(_Pfirst, _Plast);

	cmp	ecx, esi
	je	SHORT $LN64@Unguarded_
	mov	ebp, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [esi+4], edi
$LN64@Unguarded_:

; 3065 : 			++_Plast;
; 3066 : 			std::iter_swap(_Pfirst++, _Gfirst++);

	mov	edx, eax
	mov	edi, ecx
	add	esi, 8
	add	ecx, 8
	add	eax, 8
	cmp	edi, edx
	je	$LL23@Unguarded_
	mov	ebp, DWORD PTR [edi]
	mov	DWORD PTR __Tmp$239469[esp+40], ebp
	mov	ebp, DWORD PTR [edi+4]
	mov	DWORD PTR __Tmp$239469[esp+44], ebp
	mov	ebp, DWORD PTR [edx]
	mov	DWORD PTR [edi], ebp
	mov	ebp, DWORD PTR [edx+4]
	mov	DWORD PTR [edi+4], ebp
	mov	edi, DWORD PTR __Tmp$239469[esp+40]
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR __Tmp$239469[esp+44]
	mov	DWORD PTR [edx+4], edi
	jmp	$LL23@Unguarded_
$LN6@Unguarded_:

; 3067 : 			}
; 3068 : 		else if (_Gfirst == _Last)
; 3069 : 			{	// no room at top, rotate pivot downward
; 3070 : 			if (--_Glast != --_Pfirst)

	sub	ebx, 8
	cmp	eax, DWORD PTR __Last$[esp+36]
	jne	SHORT $LN3@Unguarded_
	sub	ecx, 8
	cmp	ebx, ecx
	je	SHORT $LN78@Unguarded_

; 3071 : 				std::iter_swap(_Glast, _Pfirst);

	mov	ebp, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ebx]
	mov	edi, DWORD PTR [ebx+4]
	mov	DWORD PTR [ebx], ebp
	mov	ebp, DWORD PTR [ecx+4]
	mov	DWORD PTR [ebx+4], ebp
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], edi
$LN78@Unguarded_:

; 3072 : 			std::iter_swap(_Pfirst, --_Plast);

	sub	esi, 8
	cmp	ecx, esi
	je	$LL23@Unguarded_
	mov	ebp, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], ebp
	mov	ebp, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [esi+4], edi

; 3073 : 			}
; 3074 : 		else

	jmp	$LL23@Unguarded_
$LN3@Unguarded_:

; 3075 : 			std::iter_swap(_Gfirst++, --_Glast);

	cmp	eax, ebx
	je	SHORT $LN92@Unguarded_
	mov	ebp, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR [eax], ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR [eax+4], ebp
	mov	DWORD PTR [ebx], edx
	mov	DWORD PTR [ebx+4], edi
$LN92@Unguarded_:
	add	eax, 8

; 3076 : 		}

	jmp	$LL23@Unguarded_
$LN105@Unguarded_:

; 3059 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+36]
	pop	edi
	mov	DWORD PTR [eax+4], esi
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 3077 : 	}

	add	esp, 24					; 00000018H
	ret	0
??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ENDP ; std::_Unguarded_partition<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ; std::make_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z PROC ; std::make_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>, COMDAT

; 2178 : 	_DEBUG_RANGE(_First, _Last);
; 2179 : 	if (1 < _Last - _First)

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, eax
	sub	edx, ecx
	and	edx, -8					; fffffff8H
	cmp	edx, 8
	jle	SHORT $LN1@make_heap

; 2180 : 		_Make_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last),
; 2181 : 			_Dist_type(_First), _Val_type(_First));

	push	0
	push	0
	push	eax
	push	ecx
	call	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
	add	esp, 16					; 00000010H
$LN1@make_heap:

; 2182 : 	}

	ret	0
??$make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ENDP ; std::make_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ; std::_Insertion_sort<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z PROC ; std::_Insertion_sort<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>, COMDAT

; 2993 : 	std::_Insertion_sort1(_First, _Last, _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
	add	esp, 12					; 0000000cH

; 2994 : 	}

	ret	0
??$_Insertion_sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ENDP ; std::_Insertion_sort<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@U_Undefined_move_tag@3@@std@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<OperationSlot *,OperationSlot *,std::allocator<OperationSlot>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@U_Undefined_move_tag@3@@std@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T239582 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$239585 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@U_Undefined_move_tag@3@@std@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<OperationSlot *,OperationSlot *,std::allocator<OperationSlot>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$239585[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T239582[esp+4], 0
	mov	eax, DWORD PTR $T239582[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@@std@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<OperationSlot *,OperationSlot *,std::allocator<OperationSlot> >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@U_Undefined_move_tag@3@@std@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<OperationSlot *,OperationSlot *,std::allocator<OperationSlot>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@PAVCvOperationSearchUnit@@@std@@YAXPAVCvOperationSearchUnit@@0@Z ; std::_Insertion_sort<CvOperationSearchUnit *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Insertion_sort@PAVCvOperationSearchUnit@@@std@@YAXPAVCvOperationSearchUnit@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Insertion_sort@PAVCvOperationSearchUnit@@@std@@YAXPAVCvOperationSearchUnit@@0@Z PROC ; std::_Insertion_sort<CvOperationSearchUnit *>, COMDAT

; 2993 : 	std::_Insertion_sort1(_First, _Last, _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	call	??$_Insertion_sort1@PAVCvOperationSearchUnit@@V1@@std@@YAXPAVCvOperationSearchUnit@@00@Z ; std::_Insertion_sort1<CvOperationSearchUnit *,CvOperationSearchUnit>
	add	esp, 12					; 0000000cH

; 2994 : 	}

	ret	0
??$_Insertion_sort@PAVCvOperationSearchUnit@@@std@@YAXPAVCvOperationSearchUnit@@0@Z ENDP ; std::_Insertion_sort<CvOperationSearchUnit *>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@0V12@@Z ; stdext::unchecked_copy<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@0V12@@Z
_TEXT	SEGMENT
$T239598 = -4						; size = 1
$T239605 = -4						; size = 4
$T239601 = -4						; size = 4
__Cat$239609 = 8					; size = 1
$T239600 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 20
??$unchecked_copy@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@0V12@@Z PROC ; stdext::unchecked_copy<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit> >, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ecx
	push	ebx
	xor	ebx, ebx
	mov	DWORD PTR $T239605[esp+8], ebx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$239609[esp+4]
	mov	edx, DWORD PTR $T239600[esp+4]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	BYTE PTR $T239598[esp+12], bl
	mov	eax, DWORD PTR $T239598[esp+12]
	push	eax
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last$[esp+20]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+56]
	mov	DWORD PTR $T239601[esp+44], esp
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR __First$[esp+40]
	push	edx
	push	eax
	push	esi
	call	??$_Copy_opt@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@0@PAVCvOperationSearchUnit@@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit>,std::forward_iterator_tag>
	mov	eax, DWORD PTR __Dest$[esp+52]
	add	esp, 44					; 0000002cH
	cmp	eax, ebx
	je	SHORT $LN27@unchecked_@8
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN27@unchecked_@8:
	mov	eax, esi

; 3607 : 	}

	pop	esi
	pop	ebx
	pop	ecx
	ret	0
??$unchecked_copy@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@0V12@@Z ENDP ; stdext::unchecked_copy<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit> >
_TEXT	ENDS
PUBLIC	??$unchecked_merge@PAVCvOperationSearchUnit@@PAV1@PAV1@@stdext@@YAPAVCvOperationSearchUnit@@PAV1@0000@Z ; stdext::unchecked_merge<CvOperationSearchUnit *,CvOperationSearchUnit *,CvOperationSearchUnit *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$unchecked_merge@PAVCvOperationSearchUnit@@PAV1@PAV1@@stdext@@YAPAVCvOperationSearchUnit@@PAV1@0000@Z
_TEXT	SEGMENT
$T239649 = -4						; size = 1
$T239650 = -4						; size = 1
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
__Dest$ = 24						; size = 4
??$unchecked_merge@PAVCvOperationSearchUnit@@PAV1@PAV1@@stdext@@YAPAVCvOperationSearchUnit@@PAV1@0000@Z PROC ; stdext::unchecked_merge<CvOperationSearchUnit *,CvOperationSearchUnit *,CvOperationSearchUnit *>, COMDAT

; 5114 : 	{	// copy merging ranges, both using operator<

	push	ecx

; 5115 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest,
; 5116 : 			_STD _Iter_random(_First1, _First2, _Dest), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Dest$[esp]
	mov	BYTE PTR $T239649[esp+4], 0
	mov	eax, DWORD PTR $T239649[esp+4]
	mov	ecx, DWORD PTR $T239650[esp+4]
	push	eax
	mov	eax, DWORD PTR __Last2$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __First2$[esp+8]
	push	edx
	mov	edx, DWORD PTR __Last1$[esp+12]
	push	eax
	mov	eax, DWORD PTR __First1$[esp+16]
	push	ecx
	push	edx
	push	eax
	call	??$_Merge@PAVCvOperationSearchUnit@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvOperationSearchUnit@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvOperationSearchUnit *,CvOperationSearchUnit *,CvOperationSearchUnit *,std::random_access_iterator_tag>

; 5117 : 	}

	add	esp, 32					; 00000020H
	ret	0
??$unchecked_merge@PAVCvOperationSearchUnit@@PAV1@PAV1@@stdext@@YAPAVCvOperationSearchUnit@@PAV1@0000@Z ENDP ; stdext::unchecked_merge<CvOperationSearchUnit *,CvOperationSearchUnit *,CvOperationSearchUnit *>
_TEXT	ENDS
PUBLIC	??$_Buffered_rotate@PAVCvOperationSearchUnit@@HV1@@std@@YAPAVCvOperationSearchUnit@@PAV1@00HHAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z ; std::_Buffered_rotate<CvOperationSearchUnit *,int,CvOperationSearchUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Buffered_rotate@PAVCvOperationSearchUnit@@HV1@@std@@YAPAVCvOperationSearchUnit@@PAV1@00HHAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z
_TEXT	SEGMENT
$T239661 = -20						; size = 20
$T239659 = -20						; size = 20
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
$T239660 = 20						; size = 4
$T239658 = 20						; size = 4
__Count1$ = 20						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
??$_Buffered_rotate@PAVCvOperationSearchUnit@@HV1@@std@@YAPAVCvOperationSearchUnit@@PAV1@00HHAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z PROC ; std::_Buffered_rotate<CvOperationSearchUnit *,int,CvOperationSearchUnit>, COMDAT

; 2683 : 	{	// rotate [_First, _Last) using temp buffer

	sub	esp, 20					; 00000014H
	push	ebx

; 2684 : 	if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	mov	ebx, DWORD PTR __Count2$[esp+20]
	push	ebp
	push	esi
	mov	esi, DWORD PTR __Tempbuf$[esp+28]
	push	edi
	mov	edi, DWORD PTR __Count1$[esp+32]
	cmp	edi, ebx
	jg	$LN4@Buffered_r
	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAEHXZ ; std::_Temp_iterator<CvOperationSearchUnit>::_Maxlen
	cmp	edi, eax
	jg	$LN4@Buffered_r

; 2685 : 		{	// buffer left partition, then copy parts
; 2686 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	ebx, DWORD PTR __Mid$[esp+32]
	mov	ebp, DWORD PTR __First$[esp+32]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	edi, edi
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], edi
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR $T239658[esp+52], esp
	push	ebx
	mov	DWORD PTR [eax+16], edx
	lea	eax, DWORD PTR $T239659[esp+60]
	push	ebp
	push	eax
	call	??$unchecked_copy@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@0V12@@Z ; stdext::unchecked_copy<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit> >
	mov	eax, DWORD PTR $T239659[esp+68]
	add	esp, 32					; 00000020H
	cmp	eax, edi
	je	SHORT $LN25@Buffered_r
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN25@Buffered_r:

; 2687 : 		_STDEXT unchecked_copy(_Mid, _Last, _First);

	mov	edx, DWORD PTR __Last$[esp+32]
	mov	eax, ebx
	cmp	ebx, edx
	je	SHORT $LN33@Buffered_r
	mov	ecx, ebp
	sub	ecx, ebx
$LL35@Buffered_r:
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [ecx+eax], edi
	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+eax+4], edi
	add	eax, 8
	cmp	eax, edx
	jne	SHORT $LL35@Buffered_r
$LN33@Buffered_r:

; 2688 : 		return (_STDEXT unchecked_copy_backward(_Tempbuf._First(), _Tempbuf._Last(),
; 2689 : 			_Last));

	mov	esi, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [esi+4]
	mov	esi, DWORD PTR [esi]
	push	edx
	push	eax
	push	esi
	call	??$unchecked_copy_backward@PAVCvOperationSearchUnit@@PAV1@@stdext@@YAPAVCvOperationSearchUnit@@PAV1@00@Z ; stdext::unchecked_copy_backward<CvOperationSearchUnit *,CvOperationSearchUnit *>
	add	esp, 12					; 0000000cH

; 2701 : 		return (_First);
; 2702 : 		}
; 2703 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
$LN4@Buffered_r:

; 2690 : 		}
; 2691 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAEHXZ ; std::_Temp_iterator<CvOperationSearchUnit>::_Maxlen
	cmp	ebx, eax
	jg	$LN2@Buffered_r

; 2692 : 		{	// buffer right partition, then copy parts
; 2693 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	ebp, DWORD PTR __Last$[esp+32]
	mov	ebx, DWORD PTR __Mid$[esp+32]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	edi, edi
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], edi
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR $T239660[esp+52], esp
	push	ebp
	mov	DWORD PTR [eax+16], edx
	lea	eax, DWORD PTR $T239661[esp+60]
	push	ebx
	push	eax
	call	??$unchecked_copy@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@0V12@@Z ; stdext::unchecked_copy<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit> >
	mov	eax, DWORD PTR $T239661[esp+68]
	add	esp, 32					; 00000020H
	cmp	eax, edi
	je	SHORT $LN56@Buffered_r
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN56@Buffered_r:

; 2694 : 		_STDEXT unchecked_copy_backward(_First, _Mid, _Last);

	mov	edi, DWORD PTR __First$[esp+32]
	mov	eax, ebx
	cmp	edi, ebx
	je	SHORT $LN64@Buffered_r
	mov	ecx, ebp
	sub	ecx, ebx
	npad	5
$LL65@Buffered_r:
	mov	edx, DWORD PTR [eax-8]
	sub	eax, 8
	mov	DWORD PTR [ecx+eax], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+eax+4], edx
	cmp	eax, edi
	jne	SHORT $LL65@Buffered_r
$LN64@Buffered_r:

; 2695 : 		return (_STDEXT unchecked_copy(_Tempbuf._First(), _Tempbuf._Last(), _First));

	mov	esi, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	mov	eax, edi
	cmp	ecx, edx
	je	SHORT $LN1@Buffered_r
$LL80@Buffered_r:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	add	ecx, 8
	add	eax, 8
	cmp	ecx, edx
	jne	SHORT $LL80@Buffered_r

; 2701 : 		return (_First);
; 2702 : 		}
; 2703 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
$LN2@Buffered_r:

; 2696 : 		}
; 2697 : 	else
; 2698 : 		{	// buffer too small, rotate in place
; 2699 : 		std::rotate(_First, _Mid, _Last);

	mov	esi, DWORD PTR __First$[esp+32]
	mov	eax, DWORD PTR __Mid$[esp+32]
	cmp	esi, eax
	je	SHORT $LN88@Buffered_r
	mov	ecx, DWORD PTR __Last$[esp+32]
	cmp	eax, ecx
	je	SHORT $LN88@Buffered_r
	xor	edi, edi
	push	edi
	push	edi
	push	ecx
	push	eax
	push	esi
	call	??$_Rotate@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@00PAH0@Z ; std::_Rotate<CvOperationSearchUnit *,int,CvOperationSearchUnit>
	add	esp, 20					; 00000014H
$LN88@Buffered_r:

; 2700 : 		std::advance(_First, _Count2);

	lea	eax, DWORD PTR [esi+ebx*8]
$LN1@Buffered_r:

; 2701 : 		return (_First);
; 2702 : 		}
; 2703 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
??$_Buffered_rotate@PAVCvOperationSearchUnit@@HV1@@std@@YAPAVCvOperationSearchUnit@@PAV1@00HHAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z ENDP ; std::_Buffered_rotate<CvOperationSearchUnit *,int,CvOperationSearchUnit>
_TEXT	ENDS
PUBLIC	??$pop_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ; std::pop_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$pop_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$pop_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z PROC ; std::pop_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>, COMDAT

; 2095 : 	_DEBUG_RANGE(_First, _Last);
; 2096 : 	_DEBUG_HEAP(_First, _Last);
; 2097 : 	if (1 < _Last - _First)

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	ebx
	mov	edx, eax
	push	esi
	sub	edx, ecx
	mov	esi, edx
	and	esi, -8					; fffffff8H
	cmp	esi, 8
	push	edi
	jle	SHORT $LN12@pop_heap

; 2098 : 		_Pop_heap_0(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val_type(_First));

	mov	ebx, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax-8]
	mov	edi, DWORD PTR [eax-4]
	mov	DWORD PTR [eax-8], ebx
	mov	ebx, DWORD PTR [ecx+4]
	sub	esp, 8
	mov	DWORD PTR [eax-4], ebx
	mov	eax, esp
	add	edx, -8					; fffffff8H
	sar	edx, 3
	push	edx
	push	0
	push	ecx
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], edi
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
	add	esp, 20					; 00000014H
$LN12@pop_heap:

; 2099 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$pop_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ENDP ; std::pop_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAVCvOperationSearchUnit@@PAV1@H@std@@YAXPAVCvOperationSearchUnit@@00HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvOperationSearchUnit *,CvOperationSearchUnit *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Chunked_merge@PAVCvOperationSearchUnit@@PAV1@H@std@@YAXPAVCvOperationSearchUnit@@00HHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
$T240010 = 20						; size = 1
__Chunk$ = 20						; size = 4
$T240086 = 24						; size = 1
$T240087 = 24						; size = 1
$T240011 = 24						; size = 1
__Count$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Chunked_merge@PAVCvOperationSearchUnit@@PAV1@H@std@@YAXPAVCvOperationSearchUnit@@00HHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<CvOperationSearchUnit *,CvOperationSearchUnit *,int>, COMDAT

; 3289 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	edx, DWORD PTR __Count$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Chunk$[esp+8]
	lea	ebp, DWORD PTR [edi+edi]
	cmp	ebp, edx
	jg	SHORT $LN3@Chunked_me
	push	ebx
	npad	5
$LL50@Chunked_me:

; 3290 : 		{	// copy merging pairs of adjacent chunks
; 3291 : 		_BidIt _Mid1 = _First;
; 3292 : 		std::advance(_Mid1, _Chunk);
; 3293 : 		_BidIt _Mid2 = _Mid1;
; 3294 : 		std::advance(_Mid2, _Chunk);
; 3295 : 
; 3296 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest);

	mov	BYTE PTR $T240010[esp+12], 0
	mov	ebx, DWORD PTR $T240010[esp+12]
	push	ebx
	mov	ebx, DWORD PTR $T240011[esp+16]
	push	ebx
	lea	edx, DWORD PTR [ecx+edi*8]
	push	eax
	lea	esi, DWORD PTR [edx+edi*8]
	push	esi
	push	edx
	push	edx
	push	ecx
	call	??$_Merge@PAVCvOperationSearchUnit@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvOperationSearchUnit@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvOperationSearchUnit *,CvOperationSearchUnit *,CvOperationSearchUnit *,std::random_access_iterator_tag>
	mov	edx, DWORD PTR __Count$[esp+40]
	sub	edx, ebp
	add	esp, 28					; 0000001cH
	cmp	edx, ebp

; 3297 : 		_First = _Mid2;

	mov	ecx, esi
	mov	DWORD PTR __Count$[esp+12], edx
	jge	SHORT $LL50@Chunked_me
	pop	ebx
$LN3@Chunked_me:

; 3298 : 		}
; 3299 : 
; 3300 : 	if (_Count <= _Chunk)

	cmp	edx, edi
	jg	SHORT $LN2@Chunked_me

; 3301 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	mov	edx, DWORD PTR __Last$[esp+8]
	cmp	ecx, edx
	je	SHORT $LN41@Chunked_me
	sub	eax, ecx
$LL32@Chunked_me:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax+ecx], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+ecx+4], esi
	add	ecx, 8
	cmp	ecx, edx
	jne	SHORT $LL32@Chunked_me
	pop	edi
	pop	esi
	pop	ebp

; 3308 : 		}
; 3309 : 	}

	ret	0
$LN2@Chunked_me:

; 3302 : 	else
; 3303 : 		{	// copy merging whole and partial last chunk
; 3304 : 		_BidIt _Mid = _First;
; 3305 : 		std::advance(_Mid, _Chunk);
; 3306 : 
; 3307 : 		_STDEXT unchecked_merge(_First, _Mid, _Mid, _Last, _Dest);

	mov	BYTE PTR $T240086[esp+8], 0
	mov	edx, DWORD PTR $T240086[esp+8]
	push	edx
	mov	edx, DWORD PTR $T240087[esp+12]
	push	edx
	push	eax
	mov	eax, DWORD PTR __Last$[esp+20]
	push	eax
	lea	edi, DWORD PTR [ecx+edi*8]
	push	edi
	push	edi
	push	ecx
	call	??$_Merge@PAVCvOperationSearchUnit@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvOperationSearchUnit@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvOperationSearchUnit *,CvOperationSearchUnit *,CvOperationSearchUnit *,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
$LN41@Chunked_me:
	pop	edi
	pop	esi
	pop	ebp

; 3308 : 		}
; 3309 : 	}

	ret	0
??$_Chunked_merge@PAVCvOperationSearchUnit@@PAV1@H@std@@YAXPAVCvOperationSearchUnit@@00HHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<CvOperationSearchUnit *,CvOperationSearchUnit *,int>
_TEXT	ENDS
PUBLIC	??$_Merge@PAVCvOperationSearchUnit@@PAV1@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@0@PAVCvOperationSearchUnit@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvOperationSearchUnit *,CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit>,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Merge@PAVCvOperationSearchUnit@@PAV1@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@0@PAVCvOperationSearchUnit@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T240113 = -24						; size = 4
$T240106 = -20						; size = 20
___$ReturnUdt$ = 8					; size = 4
$T240107 = 12						; size = 4
$T240105 = 12						; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
___formal$ = 48						; size = 1
___formal$ = 52						; size = 1
??$_Merge@PAVCvOperationSearchUnit@@PAV1@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@0@PAVCvOperationSearchUnit@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Merge<CvOperationSearchUnit *,CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit>,std::forward_iterator_tag>, COMDAT

; 2509 : 	{	// copy merging ranges, both using operator<

	sub	esp, 24					; 00000018H

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	mov	ecx, DWORD PTR __First1$[esp+20]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR __Last1$[esp+28]
	push	esi
	mov	esi, DWORD PTR __First2$[esp+32]
	xor	ebx, ebx
	push	edi
	mov	DWORD PTR $T240113[esp+40], ebx
	cmp	ecx, ebp
	je	$LN3@Merge@2
	lea	edi, DWORD PTR [ebx+8]
$LL4@Merge@2:
	cmp	esi, DWORD PTR __Last2$[esp+36]
	je	$LN3@Merge@2

; 2514 : 		if (_DEBUG_LT(*_First2, *_First1))

	mov	eax, DWORD PTR [esi]

; 2515 : 			*_Dest = *_First2, ++_First2;

	mov	edx, DWORD PTR __Dest$[esp+52]
	cmp	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+4]
	jge	SHORT $LN2@Merge@2
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $LN25@Merge@2
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR __Dest$[esp+52]
	add	DWORD PTR [eax+4], edi
	add	esi, edi

; 2516 : 		else

	jmp	SHORT $LN1@Merge@2

; 2515 : 			*_Dest = *_First2, ++_First2;

$LN25@Merge@2:
	cmp	eax, ebx
	je	SHORT $LN30@Merge@2
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR __Dest$[esp+52]
$LN30@Merge@2:
	add	DWORD PTR [edx+4], edi
	mov	eax, DWORD PTR __Dest$[esp+52]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+8], edx
	add	esi, edi

; 2516 : 		else

	jmp	SHORT $LN1@Merge@2
$LN2@Merge@2:

; 2517 : 			*_Dest = *_First1, ++_First1;

	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $LN37@Merge@2
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR __Dest$[esp+52]
	add	DWORD PTR [eax+4], edi
	jmp	SHORT $LN36@Merge@2
$LN37@Merge@2:
	cmp	eax, ebx
	je	SHORT $LN42@Merge@2
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR __Dest$[esp+52]
$LN42@Merge@2:
	add	DWORD PTR [edx+4], edi
	mov	eax, DWORD PTR __Dest$[esp+52]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+8], edx
$LN36@Merge@2:
	add	ecx, edi
$LN1@Merge@2:

; 2510 : 	_DEBUG_ORDER(_First1, _Last1);
; 2511 : 	_DEBUG_ORDER(_First2, _Last2);
; 2512 : 	_DEBUG_POINTER(_Dest);
; 2513 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_Dest)

	cmp	ecx, ebp
	jne	$LL4@Merge@2
$LN3@Merge@2:

; 2518 : 
; 2519 : 	_Dest = _STDEXT unchecked_copy(_First1, _Last1, _Dest);	// copy any tail

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR __Dest$[esp+72]
	mov	DWORD PTR $T240105[esp+56], esp
	push	ebp
	mov	DWORD PTR [eax+16], edx
	push	ecx
	lea	eax, DWORD PTR $T240106[esp+68]
	push	eax
	call	??$unchecked_copy@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@0V12@@Z ; stdext::unchecked_copy<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit> >
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR $T240106[esp+72]
	add	esp, 32					; 00000020H
	mov	DWORD PTR __Dest$[esp+52], ecx
	cmp	eax, ebx
	je	SHORT $LN60@Merge@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN60@Merge@2:

; 2520 : 	return (_STDEXT unchecked_copy(_First2, _Last2, _Dest));

	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR __Dest$[esp+72]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Last2$[esp+56]
	mov	DWORD PTR $T240107[esp+56], esp
	push	eax
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+64]
	push	esi
	call	??$unchecked_copy@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@0V12@@Z ; stdext::unchecked_copy<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit> >
	mov	eax, DWORD PTR __Dest$[esp+68]
	add	esp, 32					; 00000020H
	cmp	eax, ebx
	je	SHORT $LN81@Merge@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN81@Merge@2:

; 2521 : 	}

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 24					; 00000018H
	ret	0
??$_Merge@PAVCvOperationSearchUnit@@PAV1@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@0@PAVCvOperationSearchUnit@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Merge<CvOperationSearchUnit *,CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit>,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ PROC	; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
_TEXT	ENDS
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Insert
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z$2
__ehfuncinfo$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z
_TEXT	SEGMENT
$T240378 = -80						; size = 28
$T240377 = -52						; size = 40
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Insert, COMDAT
; _this$ = ecx

; 1187 : 		{	// add node with value next to _Wherenode, to left if _Addnode

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H
	push	edi
	mov	edi, ecx

; 1188 : 		if (max_size() - 1 <= _Mysize)

	cmp	DWORD PTR [edi+8], 1073741822		; 3ffffffeH
	jb	SHORT $LN17@Insert

; 1189 : 			_THROW(length_error, "map/set<T> too long");

	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T240378[esp+88]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T240377[esp+84]
	mov	DWORD PTR __$EHRec$[esp+92], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T240378[esp+84]
	push	eax
	lea	ecx, DWORD PTR $T240377[esp+100]
	mov	BYTE PTR __$EHRec$[esp+96], 1
	mov	DWORD PTR $T240377[esp+88], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T240377[esp+88]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+100], 0
	mov	DWORD PTR $T240377[esp+92], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN228@Insert:
$LN17@Insert:

; 1190 : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1191 : 			_Val, _Red);

	mov	edx, DWORD PTR __Val$[esp+80]
	mov	eax, DWORD PTR [edi+4]
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR __Wherenode$[esp+92]
	push	0
	push	edx
	push	eax
	push	esi
	push	eax
	call	?_Buynode@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@PAU342@00ABQAVFAutoVariableBase@@D@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Buynode
	mov	ebp, eax

; 1192 : 
; 1193 : 		++_Mysize;
; 1194 : 		if (_Wherenode == _Myhead)

	mov	eax, DWORD PTR [edi+4]
	mov	ebx, 1
	add	DWORD PTR [edi+8], ebx
	cmp	esi, eax
	jne	SHORT $LN16@Insert

; 1195 : 			{	// first node in tree, just set head values
; 1196 : 			_Root() = _Newnode;

	mov	DWORD PTR [eax+4], ebp

; 1197 : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [eax], ebp
	mov	ecx, DWORD PTR [edi+4]
	mov	DWORD PTR [ecx+8], ebp
	jmp	SHORT $LN11@Insert
$LN16@Insert:

; 1198 : 			}
; 1199 : 		else if (_Addleft)

	cmp	BYTE PTR __Addleft$[esp+92], 0
	je	SHORT $LN14@Insert

; 1200 : 			{	// add to left of _Wherenode
; 1201 : 			_Left(_Wherenode) = _Newnode;

	mov	DWORD PTR [esi], ebp

; 1202 : 			if (_Wherenode == _Lmost())

	mov	eax, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [eax]
	jne	SHORT $LN11@Insert

; 1203 : 				_Lmost() = _Newnode;

	mov	DWORD PTR [eax], ebp

; 1204 : 			}
; 1205 : 		else

	jmp	SHORT $LN11@Insert
$LN14@Insert:

; 1206 : 			{	// add to right of _Wherenode
; 1207 : 			_Right(_Wherenode) = _Newnode;

	mov	DWORD PTR [esi+8], ebp

; 1208 : 			if (_Wherenode == _Rmost())

	mov	eax, DWORD PTR [edi+4]
	cmp	esi, DWORD PTR [eax+8]
	jne	SHORT $LN11@Insert

; 1209 : 				_Rmost() = _Newnode;

	mov	DWORD PTR [eax+8], ebp
$LN11@Insert:

; 1210 : 			}
; 1211 : 
; 1212 : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

	mov	edx, DWORD PTR [ebp+4]
	cmp	BYTE PTR [edx+16], 0
	lea	eax, DWORD PTR [ebp+4]
	mov	esi, ebp
	jne	$LN9@Insert
	npad	5
$LL10@Insert:

; 1213 : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [edx]
	jne	SHORT $LN8@Insert

; 1214 : 				{	// fixup red-red in left subtree
; 1215 : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR [edx+8]

; 1216 : 				if (_Color(_Wherenode) == _Red)

	cmp	BYTE PTR [edx+16], 0
	jne	SHORT $LN7@Insert

; 1217 : 					{	// parent has two red children, blacken both
; 1218 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	BYTE PTR [ecx+16], bl

; 1219 : 					_Color(_Wherenode) = _Black;

	mov	BYTE PTR [edx+16], bl

; 1220 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	mov	BYTE PTR [ecx+16], 0

; 1221 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [edx+4]

; 1222 : 					}
; 1223 : 				else

	jmp	$LN171@Insert
$LN7@Insert:

; 1224 : 					{	// parent has red and black children
; 1225 : 					if (_Pnode == _Right(_Parent(_Pnode)))

	cmp	esi, DWORD PTR [ecx+8]
	jne	SHORT $LN5@Insert

; 1226 : 						{	// rotate right child to left
; 1227 : 						_Pnode = _Parent(_Pnode);

	mov	esi, ecx

; 1228 : 						_Lrotate(_Pnode);

	push	esi
	mov	ecx, edi
	call	?_Lrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Lrotate
$LN5@Insert:

; 1229 : 						}
; 1230 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+16], bl

; 1231 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+16], 0

; 1232 : 					_Rrotate(_Parent(_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, edi
	call	?_Rrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Rrotate

; 1233 : 					}
; 1234 : 				}
; 1235 : 			else

	jmp	SHORT $LN171@Insert
$LN8@Insert:

; 1236 : 				{	// fixup red-red in right subtree
; 1237 : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR [edx]

; 1238 : 				if (_Color(_Wherenode) == _Red)

	cmp	BYTE PTR [edx+16], 0
	jne	SHORT $LN3@Insert

; 1239 : 					{	// parent has two red children, blacken both
; 1240 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	BYTE PTR [ecx+16], bl

; 1241 : 					_Color(_Wherenode) = _Black;

	mov	BYTE PTR [edx+16], bl

; 1242 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+4]
	mov	BYTE PTR [ecx+16], 0

; 1243 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [edx+4]

; 1244 : 					}
; 1245 : 				else

	jmp	SHORT $LN171@Insert
$LN3@Insert:

; 1246 : 					{	// parent has red and black children
; 1247 : 					if (_Pnode == _Left(_Parent(_Pnode)))

	cmp	esi, DWORD PTR [ecx]
	jne	SHORT $LN1@Insert

; 1248 : 						{	// rotate left child to right
; 1249 : 						_Pnode = _Parent(_Pnode);

	mov	esi, ecx

; 1250 : 						_Rrotate(_Pnode);

	push	esi
	mov	ecx, edi
	call	?_Rrotate@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Rrotate
$LN1@Insert:

; 1251 : 						}
; 1252 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+16], bl

; 1253 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx+16], 0

; 1254 : 					_Lrotate(_Parent(_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+17], 0
	jne	SHORT $LN170@Insert
	mov	DWORD PTR [edx+4], eax
$LN170@Insert:
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [edi+4]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN169@Insert
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN166@Insert
$LN169@Insert:
	mov	edx, DWORD PTR [eax+4]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN167@Insert
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN166@Insert
$LN167@Insert:
	mov	DWORD PTR [edx+8], ecx
$LN166@Insert:
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [eax+4], ecx
$LN171@Insert:
	mov	ecx, DWORD PTR [esi+4]
	cmp	BYTE PTR [ecx+16], 0
	lea	eax, DWORD PTR [esi+4]
	je	$LL10@Insert
$LN9@Insert:

; 1255 : 					}
; 1256 : 				}
; 1257 : 
; 1258 : 		_Color(_Root()) = _Black;	// root is always black

	mov	edx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edx+4]

; 1259 : 		return (_TREE_ITERATOR(_Newnode));
; 1260 : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+96]
	mov	BYTE PTR [eax+16], bl
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+92]
	pop	esi
	mov	DWORD PTR [eax], ebp
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR fs:0, ecx
	add	esp, 80					; 00000050H
	ret	16					; 00000010H
$LN227@Insert:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z$0:
	lea	ecx, DWORD PTR $T240378[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z$2:
	lea	ecx, DWORD PTR $T240377[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Insert
PUBLIC	??Fiterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::iterator::operator--
; Function compile flags: /Ogtpy
;	COMDAT ??Fiterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fiterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::iterator::operator--, COMDAT
; _this$ = ecx

; 487  : 			{	// predecrement

	push	esi
	mov	esi, ecx

; 488  : 			--(*(const_iterator *)this);

	call	?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::_Dec

; 489  : 			return (*this);

	mov	eax, esi
	pop	esi

; 490  : 			}

	ret	0
??Fiterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::iterator::operator--
_TEXT	ENDS
PUBLIC	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z PROC ; std::vector<int,std::allocator<int> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase@2

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase@2
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase@2:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase@2:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ENDP ; std::vector<int,std::allocator<int> >::erase
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >, COMDAT

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN9@Uninit_fil@2
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL11@Uninit_fil@2:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL11@Uninit_fil@2
	pop	esi
$LN9@Uninit_fil@2:

; 420  : 	}

	ret	0
??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >, COMDAT

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN14@Unchecked_@3
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_@3:
	pop	edi
	mov	eax, esi
	pop	esi

; 865  : 	}

	ret	0
??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?DeleteArmyAI@CvAIOperation@@QAE_NH@Z		; CvAIOperation::DeleteArmyAI
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
;	COMDAT ?DeleteArmyAI@CvAIOperation@@QAE_NH@Z
_TEXT	SEGMENT
_iID$ = 8						; size = 4
?DeleteArmyAI@CvAIOperation@@QAE_NH@Z PROC		; CvAIOperation::DeleteArmyAI, COMDAT
; _this$ = ecx

; 966  : {

	push	esi
	mov	esi, ecx

; 967  : 	std::vector<int>::iterator iter;
; 968  : 	for(iter = m_viArmyIDs.begin(); iter != m_viArmyIDs.end(); ++iter)

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+12]
	cmp	eax, ecx
	je	SHORT $LN2@DeleteArmy
	mov	edx, DWORD PTR _iID$[esp]
$LL19@DeleteArmy:

; 969  : 	{
; 970  : 		if(*iter == iID)

	cmp	DWORD PTR [eax], edx
	je	SHORT $LN53@DeleteArmy
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL19@DeleteArmy
$LN2@DeleteArmy:

; 974  : 		}
; 975  : 	}
; 976  : 	return false;

	xor	al, al
	pop	esi

; 977  : }

	ret	4
$LN53@DeleteArmy:

; 971  : 		{
; 972  : 			m_viArmyIDs.erase(iter);

	lea	edx, DWORD PTR [eax+4]
	sub	ecx, edx
	sar	ecx, 2
	test	ecx, ecx
	jle	SHORT $LN43@DeleteArmy
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	ecx
	push	eax
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN43@DeleteArmy:
	add	DWORD PTR [esi+12], -4			; fffffffcH

; 973  : 			return true;

	mov	al, 1
	pop	esi

; 977  : }

	ret	4
?DeleteArmyAI@CvAIOperation@@QAE_NH@Z ENDP		; CvAIOperation::DeleteArmyAI
_TEXT	ENDS
PUBLIC	?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z ; CvAIOperation::ComputeCenterOfMassForTurn
EXTRN	?GetMovementRate@CvArmyAI@@QAEHXZ:PROC		; CvArmyAI::GetMovementRate
EXTRN	?StepDestValid@@YAHHHPBXPAVCvAStar@@@Z:PROC	; StepDestValid
EXTRN	?StepValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; StepValid
EXTRN	?StepValidAnyArea@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z:PROC ; StepValidAnyArea
EXTRN	?GetCoastalPlotAdjacentToTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAV2@PAVCvArmyAI@@@Z:PROC ; CvMilitaryAI::GetCoastalPlotAdjacentToTarget
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z$0
__ehfuncinfo$?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
xdata$x	ENDS
;	COMDAT ?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
_TEXT	SEGMENT
$T241133 = -840						; size = 4
_pNode1$224533 = -840					; size = 4
_pRtnValue$ = -840					; size = 4
$T241134 = -836						; size = 4
$T241132 = -836						; size = 4
_pLastTurnArmyPlot$224532 = -836			; size = 4
_iLastNodeIndex$224535 = -832				; size = 4
_pNode2$224534 = -832					; size = 4
_m_NodesOnPath$224606 = -828				; size = 816
__$EHRec$ = -12						; size = 12
_pArmy$ = 8						; size = 4
_ppClosestCurrentCOMonPath$ = 12			; size = 4
?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z PROC ; CvAIOperation::ComputeCenterOfMassForTurn, COMDAT
; _this$ = ecx

; 1025 : {

	push	-1
	push	__ehhandler$?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 828				; 0000033cH
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 1026 : 	CvPlot* pRtnValue = NULL;
; 1027 : 	CvPlayer &kPlayer = GET_PLAYER(m_eOwner);

	mov	ebp, DWORD PTR [esi+72]

; 1028 : 
; 1029 : 	switch(m_eCurrentState)

	mov	eax, DWORD PTR [esi+56]
	imul	ebp, 63236				; 0000f704H
	add	ebp, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	xor	ecx, ecx
	cmp	eax, ecx
	push	edi
	mov	DWORD PTR _pRtnValue$[esp+856], ecx
	jle	$LN182@ComputeCen
	cmp	eax, 2
	jle	$LN8@ComputeCen
	cmp	eax, 3
	jne	$LN182@ComputeCen

; 1040 : 		break;
; 1041 : 
; 1042 : 	case AI_OPERATION_STATE_MOVING_TO_TARGET:
; 1043 : 		{
; 1044 : 			CvPlot* pCenterOfMass = 0;
; 1045 : 			CvPlot* pLastTurnArmyPlot = 0;
; 1046 : 			CvAStarNode* pNode1 = 0;
; 1047 : 			CvAStarNode* pNode2 = 0;
; 1048 : 			int iLastNodeIndex = 0;
; 1049 : 			FStaticVector<CvAStarNode*, SAFE_ESTIMATE_MAX_PATH_LEN, true, c_eCiv5GameplayDLL, 0> m_NodesOnPath;

	lea	eax, DWORD PTR _m_NodesOnPath$224606[esp+868]
	mov	DWORD PTR _m_NodesOnPath$224606[esp+864], 200 ; 000000c8H
	mov	DWORD PTR _m_NodesOnPath$224606[esp+856], eax

; 1050 : 
; 1051 : 			m_NodesOnPath.clear();
; 1052 : 
; 1053 : 			// Is goal a city and we're a naval operation?  If so, go just offshore.
; 1054 : 			CvPlot *pGoalPlot = pArmy->GetGoalPlot();

	mov	ebx, DWORD PTR _pArmy$[esp+852]
	mov	DWORD PTR __$EHRec$[esp+864], ecx
	mov	DWORD PTR _m_NodesOnPath$224606[esp+860], ecx
	mov	ecx, ebx
	call	?GetGoalPlot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::GetGoalPlot
	mov	edi, eax

; 1055 : 			if (!pGoalPlot->isWater() && IsAllNavalOperation())

	cmp	BYTE PTR [edi+5], 3
	je	SHORT $LN6@ComputeCen
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, esi
	call	eax
	test	al, al
	je	SHORT $LN6@ComputeCen

; 1056 : 			{
; 1057 : 				pGoalPlot = kPlayer.GetMilitaryAI()->GetCoastalPlotAdjacentToTarget(pGoalPlot, pArmy);

	push	ebx
	push	edi
	mov	ecx, ebp
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?GetCoastalPlotAdjacentToTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAV2@PAVCvArmyAI@@@Z ; CvMilitaryAI::GetCoastalPlotAdjacentToTarget
	mov	edi, eax
$LN6@ComputeCen:

; 1058 : 			}
; 1059 : 
; 1060 : 			pLastTurnArmyPlot = pArmy->Plot();

	mov	ecx, ebx
	call	?Plot@CvArmyAI@@QBEPAVCvPlot@@XZ	; CvArmyAI::Plot

; 1061 : 			pCenterOfMass = pArmy->GetCenterOfMass(IsAllNavalOperation() || IsMixedLandNavalOperation() ? DOMAIN_SEA : DOMAIN_LAND);

	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR _pLastTurnArmyPlot$224532[esp+856], eax
	mov	eax, DWORD PTR [edx+40]
	mov	ecx, esi
	call	eax
	test	al, al
	jne	SHORT $LN14@ComputeCen
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, esi
	call	eax
	test	al, al
	jne	SHORT $LN14@ComputeCen
	mov	eax, 2
	jmp	SHORT $LN15@ComputeCen
$LN14@ComputeCen:
	xor	eax, eax
$LN15@ComputeCen:
	push	eax
	mov	ecx, ebx
	call	?GetCenterOfMass@CvArmyAI@@QAEPAVCvPlot@@W4DomainTypes@@@Z ; CvArmyAI::GetCenterOfMass

; 1062 : 			if (pLastTurnArmyPlot && pCenterOfMass && pGoalPlot)

	cmp	DWORD PTR _pLastTurnArmyPlot$224532[esp+856], 0
	mov	ebp, eax
	je	$LN181@ComputeCen
	test	ebp, ebp
	je	$LN181@ComputeCen
	test	edi, edi
	je	$LN181@ComputeCen

; 1063 : 			{
; 1064 : 				// Push center of mass forward a number of hexes equal to average movement
; 1065 : #ifdef AUI_WARNING_FIXES
; 1066 : 				CvStepPathFinder& kStepFinder = GC.getStepFinder();
; 1067 : 				kStepFinder.SetData(&m_eEnemy);
; 1068 : 				kStepFinder.SetDestValidFunc(NULL); // remove the area check
; 1069 : 				kStepFinder.SetValidFunc(StepValidAnyArea); // remove the area check
; 1070 : 				bool bFound = kStepFinder.GeneratePath(pCenterOfMass->getX(), pCenterOfMass->getY(), pGoalPlot->getX(), pGoalPlot->getY(), m_eOwner, false);
; 1071 : 				kStepFinder.SetValidFunc(StepValid); // remove the area check
; 1072 : 				kStepFinder.SetDestValidFunc(StepDestValid); // restore the area check
; 1073 : 				if (bFound)
; 1074 : 				{
; 1075 : 					pNode1 = kStepFinder.GetLastNode();
; 1076 : #else
; 1077 : 				GC.getStepFinder().SetData(&m_eEnemy);

	lea	ecx, DWORD PTR [esi+76]
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, eax
	call	?SetData@CvAStar@@QAEXPBX@Z		; CvAStar::SetData

; 1078 : 				GC.getStepFinder().SetDestValidFunc(NULL); // remove the area check

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder

; 1079 : 				GC.getStepFinder().SetValidFunc(StepValidAnyArea); // remove the area check

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [eax+4], 0
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	DWORD PTR [eax+16], OFFSET ?StepValidAnyArea@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; StepValidAnyArea

; 1080 : 				bool bFound = GC.getStepFinder().GeneratePath(pCenterOfMass->getX(), pCenterOfMass->getY(), pGoalPlot->getX(), pGoalPlot->getY(), m_eOwner, false);

	movsx	eax, WORD PTR [edi+2]
	movsx	ecx, WORD PTR [edi]
	mov	esi, DWORD PTR [esi+72]
	movsx	edx, WORD PTR [ebp+2]
	movsx	edi, WORD PTR [ebp]
	push	0
	push	esi
	push	eax
	push	ecx
	push	edx
	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, eax
	call	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z	; CvAStar::GeneratePath

; 1081 : 				GC.getStepFinder().SetValidFunc(StepValid); // remove the area check

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	bl, al
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder

; 1082 : 				GC.getStepFinder().SetDestValidFunc(StepDestValid); // restore the area check

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR [eax+16], OFFSET ?StepValid@@YAHPAVCvAStarNode@@0HPBXPAVCvAStar@@@Z ; StepValid
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	DWORD PTR [eax+4], OFFSET ?StepDestValid@@YAHHHPBXPAVCvAStar@@@Z ; StepDestValid

; 1083 : 				if (bFound)

	test	bl, bl
	je	$LN4@ComputeCen

; 1084 : 				{
; 1085 : 					pNode1 = GC.getStepFinder().GetLastNode();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	esi, DWORD PTR [eax+96]

; 1086 : #endif
; 1087 : 
; 1088 : 					// Starting at the end, loop through the entire path
; 1089 : 					while (pNode1)

	xor	edi, edi
	mov	DWORD PTR _pNode1$224533[esp+856], esi
	cmp	esi, edi
	je	SHORT $LN2@ComputeCen
	npad	6
$LL3@ComputeCen:

; 1090 : 					{
; 1091 : 						m_NodesOnPath.push_back(pNode1);

	lea	edx, DWORD PTR _pNode1$224533[esp+856]
	push	edx
	lea	ecx, DWORD PTR _m_NodesOnPath$224606[esp+860]
	call	?push_back@?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@QAEIABQAVCvAStarNode@@@Z ; FStaticVector<CvAStarNode *,200,1,297,0>::push_back

; 1092 : 						pNode1 = pNode1->m_pParent;

	mov	esi, DWORD PTR [esi+24]
	mov	DWORD PTR _pNode1$224533[esp+856], esi
	cmp	esi, edi
	jne	SHORT $LL3@ComputeCen
$LN2@ComputeCen:

; 1093 : 					}
; 1094 : 
; 1095 : 					iLastNodeIndex = m_NodesOnPath.size() - 1;

	mov	esi, DWORD PTR _m_NodesOnPath$224606[esp+860]

; 1096 : 
; 1097 : 					// Move back up path from best node a number of spaces equal to army's movement rate + 1
; 1098 : 					int iJumpAhead = pArmy->GetMovementRate() + 1;

	mov	ecx, DWORD PTR _pArmy$[esp+852]
	dec	esi
	mov	DWORD PTR _iLastNodeIndex$224535[esp+856], esi
	call	?GetMovementRate@CvArmyAI@@QAEHXZ	; CvArmyAI::GetMovementRate
	inc	eax

; 1099 : 					int iNode1Index = max(0, iLastNodeIndex - iJumpAhead);

	mov	ecx, esi
	sub	ecx, eax
	cmp	ecx, edi
	mov	DWORD PTR $T241132[esp+856], ecx
	mov	DWORD PTR $T241133[esp+856], edi
	lea	eax, DWORD PTR $T241132[esp+856]
	jg	SHORT $LN60@ComputeCen
	lea	eax, DWORD PTR $T241133[esp+856]
$LN60@ComputeCen:
	mov	eax, DWORD PTR [eax]

; 1100 : 					int iNode2Index = min(iNode1Index + 2, iLastNodeIndex);

	lea	ecx, DWORD PTR [eax+2]
	mov	DWORD PTR $T241134[esp+856], ecx
	cmp	esi, ecx
	lea	ecx, DWORD PTR _iLastNodeIndex$224535[esp+856]
	jl	SHORT $LN64@ComputeCen
	lea	ecx, DWORD PTR $T241134[esp+856]
$LN64@ComputeCen:

; 1101 : 					pNode1 = m_NodesOnPath[iNode1Index];

	mov	edx, DWORD PTR _m_NodesOnPath$224606[esp+856]
	mov	eax, DWORD PTR [edx+eax*4]

; 1102 : 					pNode2 = m_NodesOnPath[iNode2Index];
; 1103 : 					
; 1104 : 					pRtnValue = GC.getMap().plot(pNode1->m_iX, pNode1->m_iY);

	movsx	esi, WORD PTR [eax+82]
	mov	ecx, DWORD PTR [ecx]
	movsx	eax, WORD PTR [eax+80]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _pNode2$224534[esp+856], ecx
	cmp	eax, -2147483647			; 80000001H
	je	$LN71@ComputeCen
	cmp	esi, -2147483647			; 80000001H
	je	$LN71@ComputeCen
	mov	dl, BYTE PTR [ebp+4056]
	mov	ecx, DWORD PTR [ebp+4020]
	test	dl, dl
	je	SHORT $LN81@ComputeCen
	cmp	eax, edi
	jge	SHORT $LN83@ComputeCen
	cdq
	idiv	ecx
	mov	edi, edx
	add	edi, ecx
	jmp	SHORT $LN85@ComputeCen
$LN83@ComputeCen:
	cmp	eax, ecx
	jl	SHORT $LN81@ComputeCen
	cdq
	idiv	ecx
	mov	edi, edx
	jmp	SHORT $LN85@ComputeCen
$LN81@ComputeCen:
	mov	edi, eax
$LN85@ComputeCen:
	mov	al, BYTE PTR [ebp+4057]
	mov	ebx, DWORD PTR [ebp+4024]
	test	al, al
	je	SHORT $LN183@ComputeCen
	test	esi, esi
	jge	SHORT $LN93@ComputeCen
	mov	eax, esi
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN95@ComputeCen
$LN93@ComputeCen:
	cmp	esi, ebx
	jl	SHORT $LN183@ComputeCen
	mov	eax, esi
	cdq
	idiv	ebx
	jmp	SHORT $LN95@ComputeCen
$LN183@ComputeCen:
	mov	edx, esi
$LN95@ComputeCen:
	test	edi, edi
	jl	SHORT $LN75@ComputeCen
	cmp	edi, ecx
	jge	SHORT $LN75@ComputeCen
	test	edx, edx
	jl	SHORT $LN75@ComputeCen
	cmp	edx, ebx
	jge	SHORT $LN75@ComputeCen
	imul	ecx, edx
	add	ecx, edi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	mov	DWORD PTR _pRtnValue$[esp+856], ecx
	jmp	SHORT $LN73@ComputeCen
$LN75@ComputeCen:
	mov	DWORD PTR _pRtnValue$[esp+856], 0
	jmp	SHORT $LN73@ComputeCen
$LN71@ComputeCen:
	mov	DWORD PTR _pRtnValue$[esp+856], edi
$LN73@ComputeCen:

; 1105 : 					*ppClosestCurrentCOMonPath = GC.getMap().plot(pNode2->m_iX, pNode2->m_iY);

	mov	eax, DWORD PTR _pNode2$224534[esp+856]
	movsx	ebx, WORD PTR [eax+82]
	movsx	eax, WORD PTR [eax+80]
	cmp	eax, -2147483647			; 80000001H
	je	SHORT $LN111@ComputeCen
	cmp	ebx, -2147483647			; 80000001H
	je	SHORT $LN111@ComputeCen
	mov	dl, BYTE PTR [ebp+4056]
	mov	ecx, DWORD PTR [ebp+4020]
	test	dl, dl
	je	SHORT $LN121@ComputeCen
	test	eax, eax
	jge	SHORT $LN123@ComputeCen
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN125@ComputeCen
$LN123@ComputeCen:
	cmp	eax, ecx
	jl	SHORT $LN121@ComputeCen
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN125@ComputeCen
$LN121@ComputeCen:
	mov	esi, eax
$LN125@ComputeCen:
	mov	al, BYTE PTR [ebp+4057]
	mov	edi, DWORD PTR [ebp+4024]
	test	al, al
	je	SHORT $LN184@ComputeCen
	test	ebx, ebx
	jge	SHORT $LN133@ComputeCen
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN135@ComputeCen
$LN133@ComputeCen:
	cmp	ebx, edi
	jl	SHORT $LN184@ComputeCen
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN135@ComputeCen
$LN184@ComputeCen:
	mov	edx, ebx
$LN135@ComputeCen:
	test	esi, esi
	jl	SHORT $LN111@ComputeCen
	cmp	esi, ecx
	jge	SHORT $LN111@ComputeCen
	test	edx, edx
	jl	SHORT $LN111@ComputeCen
	cmp	edx, edi
	jge	SHORT $LN111@ComputeCen
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	jmp	SHORT $LN113@ComputeCen
$LN111@ComputeCen:
	xor	ecx, ecx
$LN113@ComputeCen:
	mov	edx, DWORD PTR _ppClosestCurrentCOMonPath$[esp+852]
	mov	DWORD PTR [edx], ecx
$LN181@ComputeCen:

; 1111 : 				}
; 1112 : 			}
; 1113 : 		}

	mov	eax, DWORD PTR _m_NodesOnPath$224606[esp+856]
	lea	edx, DWORD PTR _m_NodesOnPath$224606[esp+868]
	mov	DWORD PTR __$EHRec$[esp+864], -1
	cmp	eax, edx
	je	SHORT $LN182@ComputeCen
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4

; 1114 : 		break;

	jmp	SHORT $LN182@ComputeCen
$LN4@ComputeCen:

; 1106 : 				}
; 1107 : 				else
; 1108 : 				{
; 1109 : 					// Can't plot a path, probably due to change of control of hexes.  Will probably abort the operation
; 1110 : 					return NULL;

	mov	eax, DWORD PTR _m_NodesOnPath$224606[esp+856]
	lea	ecx, DWORD PTR _m_NodesOnPath$224606[esp+868]
	mov	DWORD PTR __$EHRec$[esp+864], -1
	cmp	eax, ecx
	je	SHORT $LN151@ComputeCen
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN151@ComputeCen:
	xor	eax, eax
	jmp	SHORT $LN12@ComputeCen
$LN8@ComputeCen:

; 1030 : 	{
; 1031 : 	case AI_OPERATION_STATE_ABORTED:
; 1032 : 	case AI_OPERATION_STATE_AT_TARGET:
; 1033 : 	case AI_OPERATION_STATE_SUCCESSFUL_FINISH:
; 1034 : 		break;
; 1035 : 
; 1036 : 	case AI_OPERATION_STATE_RECRUITING_UNITS:
; 1037 : 	case AI_OPERATION_STATE_GATHERING_FORCES:
; 1038 : 		// Just use the muster point if we're still recruiting/gathering
; 1039 : 		pRtnValue = GetMusterPlot();

	mov	ecx, esi
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	DWORD PTR _pRtnValue$[esp+856], eax
$LN182@ComputeCen:

; 1115 : 	}
; 1116 : 	return pRtnValue;

	mov	eax, DWORD PTR _pRtnValue$[esp+856]
$LN12@ComputeCen:

; 1117 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+856]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 840				; 00000348H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z$0:
	lea	ecx, DWORD PTR _m_NodesOnPath$224606[ebp]
	jmp	??1?$FStaticVector@PAVCvAStarNode@@$0MI@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvAStarNode *,200,1,297,0>::~FStaticVector<CvAStarNode *,200,1,297,0>
__ehhandler$?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z ENDP ; CvAIOperation::ComputeCenterOfMassForTurn
PUBLIC	?Write@CvAIOperation@@UBEXAAVFDataStream@@@Z	; CvAIOperation::Write
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z:PROC ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ?Write@CvAIOperation@@UBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
$T241587 = 8						; size = 4
_v$241571 = 8						; size = 4
_kStream$ = 8						; size = 4
?Write@CvAIOperation@@UBEXAAVFDataStream@@@Z PROC	; CvAIOperation::Write, COMDAT
; _this$ = ecx

; 1196 : {

	push	ecx
	push	esi
	push	edi

; 1197 : 	// Current version number
; 1198 : 	uint uiVersion = 1;
; 1199 : 	kStream << uiVersion;

	mov	edi, DWORD PTR _kStream$[esp+8]
	lea	eax, DWORD PTR _uiVersion$[esp+12]
	mov	esi, ecx
	push	eax
	mov	ecx, edi
	mov	DWORD PTR _uiVersion$[esp+16], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 1200 : 
; 1201 : 	kStream << m_iID;

	lea	ecx, DWORD PTR [esi+52]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1202 : 	kStream << m_eOwner;

	lea	edx, DWORD PTR [esi+72]
	push	edx
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<

; 1203 : 	kStream << m_eEnemy;

	lea	eax, DWORD PTR [esi+76]
	push	eax
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<

; 1204 : 	kStream << m_eCurrentState;

	mov	ecx, DWORD PTR [esi+56]
	add	esp, 16					; 00000010H
	lea	edx, DWORD PTR _v$241571[esp+8]
	mov	DWORD PTR _v$241571[esp+8], ecx
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1205 : 	kStream << m_iDefaultArea;

	lea	eax, DWORD PTR [esi+64]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1206 : 	kStream << m_bShouldReplaceLossesWithReinforcements;

	lea	ecx, DWORD PTR [esi+80]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 1207 : 	kStream << m_eMoveType;

	mov	edx, DWORD PTR [esi+84]
	lea	eax, DWORD PTR $T241587[esp+8]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR $T241587[esp+12], edx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1208 : 	kStream << m_iTargetX;

	lea	ecx, DWORD PTR [esi+104]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1209 : 	kStream << m_iTargetY;

	lea	edx, DWORD PTR [esi+108]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1210 : 	kStream << m_iMusterX;

	lea	eax, DWORD PTR [esi+96]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1211 : 	kStream << m_iMusterY;

	lea	ecx, DWORD PTR [esi+100]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1212 : 	kStream << m_iStartCityX;

	lea	edx, DWORD PTR [esi+88]
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1213 : 	kStream << m_iStartCityY;

	lea	eax, DWORD PTR [esi+92]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1214 : 	kStream << m_iLastTurnMoved;

	lea	ecx, DWORD PTR [esi+68]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1215 : 	kStream << m_viArmyIDs;

	lea	edx, DWORD PTR [esi+4]
	push	edx
	push	edi
	call	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$vector@HV?$allocator@H@std@@@std@@@Z ; operator<<<int>

; 1216 : 	kStream << m_viListOfUnitsWeStillNeedToBuild;

	lea	eax, DWORD PTR [esi+20]
	push	eax
	push	edi
	call	??$?6UOperationSlot@@@@YAAAVFDataStream@@AAV0@ABV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@Z ; operator<<<OperationSlot>

; 1217 : 	kStream << m_viListOfUnitsCitiesHaveCommittedToBuild;

	add	esi, 36					; 00000024H
	push	esi
	push	edi
	call	??$?6UOperationSlot@@@@YAAAVFDataStream@@AAV0@ABV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@Z ; operator<<<OperationSlot>
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi

; 1218 : }

	pop	ecx
	ret	4
?Write@CvAIOperation@@UBEXAAVFDataStream@@@Z ENDP	; CvAIOperation::Write
_TEXT	ENDS
PUBLIC	?Write@CvAIOperationBasicCityAttack@@UBEXAAVFDataStream@@@Z ; CvAIOperationBasicCityAttack::Write
; Function compile flags: /Ogtpy
;	COMDAT ?Write@CvAIOperationBasicCityAttack@@UBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = 8						; size = 4
_kStream$ = 8						; size = 4
?Write@CvAIOperationBasicCityAttack@@UBEXAAVFDataStream@@@Z PROC ; CvAIOperationBasicCityAttack::Write, COMDAT
; _this$ = ecx

; 2199 : {

	push	esi

; 2200 : 	// write the base class' entries
; 2201 : 	CvAIOperation::Write(kStream);

	mov	esi, DWORD PTR _kStream$[esp]
	push	esi
	call	?Write@CvAIOperation@@UBEXAAVFDataStream@@@Z ; CvAIOperation::Write

; 2202 : 
; 2203 : 	// Current version number
; 2204 : 	uint uiVersion = 1;
; 2205 : 	kStream << uiVersion;

	lea	eax, DWORD PTR _uiVersion$[esp]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _uiVersion$[esp+4], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	pop	esi

; 2206 : }

	ret	4
?Write@CvAIOperationBasicCityAttack@@UBEXAAVFDataStream@@@Z ENDP ; CvAIOperationBasicCityAttack::Write
_TEXT	ENDS
PUBLIC	?Write@CvAIOperationDestroyBarbarianCamp@@UBEXAAVFDataStream@@@Z ; CvAIOperationDestroyBarbarianCamp::Write
; Function compile flags: /Ogtpy
;	COMDAT ?Write@CvAIOperationDestroyBarbarianCamp@@UBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = 8						; size = 4
_kStream$ = 8						; size = 4
?Write@CvAIOperationDestroyBarbarianCamp@@UBEXAAVFDataStream@@@Z PROC ; CvAIOperationDestroyBarbarianCamp::Write, COMDAT
; _this$ = ecx

; 2375 : {

	push	esi
	push	edi

; 2376 : 	// write the base class' entries
; 2377 : 	CvAIOperation::Write(kStream);

	mov	edi, DWORD PTR _kStream$[esp+4]
	push	edi
	mov	esi, ecx
	call	?Write@CvAIOperation@@UBEXAAVFDataStream@@@Z ; CvAIOperation::Write

; 2378 : 
; 2379 : 	// Current version number
; 2380 : 	uint uiVersion = 1;
; 2381 : 	kStream << uiVersion;

	lea	eax, DWORD PTR _uiVersion$[esp+4]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR _uiVersion$[esp+8], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 2382 : 	kStream << m_bCivilianRescue;

	lea	ecx, DWORD PTR [esi+112]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 2383 : 	kStream << m_iUnitToRescue;

	add	esi, 116				; 00000074H
	push	esi
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	pop	edi
	pop	esi

; 2384 : }

	ret	4
?Write@CvAIOperationDestroyBarbarianCamp@@UBEXAAVFDataStream@@@Z ENDP ; CvAIOperationDestroyBarbarianCamp::Write
_TEXT	ENDS
PUBLIC	?Write@CvAIOperationPillageEnemy@@UBEXAAVFDataStream@@@Z ; CvAIOperationPillageEnemy::Write
; Function compile flags: /Ogtpy
;	COMDAT ?Write@CvAIOperationPillageEnemy@@UBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = 8						; size = 4
_kStream$ = 8						; size = 4
?Write@CvAIOperationPillageEnemy@@UBEXAAVFDataStream@@@Z PROC ; CvAIOperationPillageEnemy::Write, COMDAT
; _this$ = ecx

; 2644 : {

	push	esi

; 2645 : 	// write the base class' entries
; 2646 : 	CvAIOperation::Write(kStream);

	mov	esi, DWORD PTR _kStream$[esp]
	push	esi
	call	?Write@CvAIOperation@@UBEXAAVFDataStream@@@Z ; CvAIOperation::Write

; 2647 : 
; 2648 : 	// Current version number
; 2649 : 	uint uiVersion = 1;
; 2650 : 	kStream << uiVersion;

	lea	eax, DWORD PTR _uiVersion$[esp]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _uiVersion$[esp+4], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	pop	esi

; 2651 : }

	ret	4
?Write@CvAIOperationPillageEnemy@@UBEXAAVFDataStream@@@Z ENDP ; CvAIOperationPillageEnemy::Write
_TEXT	ENDS
PUBLIC	?Write@CvAIEscortedOperation@@UBEXAAVFDataStream@@@Z ; CvAIEscortedOperation::Write
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4UnitAITypes@@@Z:PROC ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ?Write@CvAIEscortedOperation@@UBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = 8						; size = 4
_kStream$ = 8						; size = 4
?Write@CvAIEscortedOperation@@UBEXAAVFDataStream@@@Z PROC ; CvAIEscortedOperation::Write, COMDAT
; _this$ = ecx

; 2937 : {

	push	esi
	push	edi

; 2938 : 	// write the base class' entries
; 2939 : 	CvAIOperation::Write(kStream);

	mov	edi, DWORD PTR _kStream$[esp+4]
	push	edi
	mov	esi, ecx
	call	?Write@CvAIOperation@@UBEXAAVFDataStream@@@Z ; CvAIOperation::Write

; 2940 : 
; 2941 : 	// Version number to maintain backwards compatibility
; 2942 : 	uint uiVersion = 1;
; 2943 : 	kStream << uiVersion;

	lea	eax, DWORD PTR _uiVersion$[esp+4]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR _uiVersion$[esp+8], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 2944 : 
; 2945 : 	kStream << m_bEscorted;

	lea	ecx, DWORD PTR [esi+112]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 2946 : 	kStream << m_eCivilianType;

	lea	edx, DWORD PTR [esi+116]
	push	edx
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4UnitAITypes@@@Z ; operator<<
	add	esp, 8

; 2947 : 	kStream << m_iTargetArea;

	add	esi, 120				; 00000078H
	push	esi
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	pop	edi
	pop	esi

; 2948 : }

	ret	4
?Write@CvAIEscortedOperation@@UBEXAAVFDataStream@@@Z ENDP ; CvAIEscortedOperation::Write
_TEXT	ENDS
PUBLIC	?Write@CvAINavalOperation@@UBEXAAVFDataStream@@@Z ; CvAINavalOperation::Write
; Function compile flags: /Ogtpy
;	COMDAT ?Write@CvAINavalOperation@@UBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = 8						; size = 4
_kStream$ = 8						; size = 4
?Write@CvAINavalOperation@@UBEXAAVFDataStream@@@Z PROC	; CvAINavalOperation::Write, COMDAT
; _this$ = ecx

; 3816 : {

	push	esi

; 3817 : 	// write the base class' entries
; 3818 : 	CvAIOperation::Write(kStream);

	mov	esi, DWORD PTR _kStream$[esp]
	push	esi
	call	?Write@CvAIOperation@@UBEXAAVFDataStream@@@Z ; CvAIOperation::Write

; 3819 : 
; 3820 : 	// Current version number
; 3821 : 	uint uiVersion = 1;
; 3822 : 	kStream << uiVersion;

	lea	eax, DWORD PTR _uiVersion$[esp]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _uiVersion$[esp+4], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	pop	esi

; 3823 : }

	ret	4
?Write@CvAINavalOperation@@UBEXAAVFDataStream@@@Z ENDP	; CvAINavalOperation::Write
_TEXT	ENDS
PUBLIC	?Write@CvAIOperationNavalBombardment@@UBEXAAVFDataStream@@@Z ; CvAIOperationNavalBombardment::Write
; Function compile flags: /Ogtpy
;	COMDAT ?Write@CvAIOperationNavalBombardment@@UBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
_uiVersion$241662 = 8					; size = 4
_kStream$ = 8						; size = 4
?Write@CvAIOperationNavalBombardment@@UBEXAAVFDataStream@@@Z PROC ; CvAIOperationNavalBombardment::Write, COMDAT
; _this$ = ecx

; 4045 : {

	push	ecx
	push	esi

; 4046 : 	// write the base class' entries
; 4047 : 	CvAINavalOperation::Write(kStream);

	mov	esi, DWORD PTR _kStream$[esp+4]
	push	esi
	call	?Write@CvAIOperation@@UBEXAAVFDataStream@@@Z ; CvAIOperation::Write
	lea	eax, DWORD PTR _uiVersion$241662[esp+4]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _uiVersion$241662[esp+8], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 4048 : 
; 4049 : 	// Current version number
; 4050 : 	uint uiVersion = 1;
; 4051 : 	kStream << uiVersion;

	lea	ecx, DWORD PTR _uiVersion$[esp+8]
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR _uiVersion$[esp+12], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	pop	esi

; 4052 : }

	pop	ecx
	ret	4
?Write@CvAIOperationNavalBombardment@@UBEXAAVFDataStream@@@Z ENDP ; CvAIOperationNavalBombardment::Write
_TEXT	ENDS
PUBLIC	?Write@CvAIOperationNavalSuperiority@@UBEXAAVFDataStream@@@Z ; CvAIOperationNavalSuperiority::Write
; Function compile flags: /Ogtpy
;	COMDAT ?Write@CvAIOperationNavalSuperiority@@UBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
_uiVersion$241680 = 8					; size = 4
_kStream$ = 8						; size = 4
?Write@CvAIOperationNavalSuperiority@@UBEXAAVFDataStream@@@Z PROC ; CvAIOperationNavalSuperiority::Write, COMDAT
; _this$ = ecx

; 4290 : {

	push	ecx
	push	esi

; 4291 : 	// write the base class' entries
; 4292 : 	CvAINavalOperation::Write(kStream);

	mov	esi, DWORD PTR _kStream$[esp+4]
	push	esi
	call	?Write@CvAIOperation@@UBEXAAVFDataStream@@@Z ; CvAIOperation::Write
	lea	eax, DWORD PTR _uiVersion$241680[esp+4]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _uiVersion$241680[esp+8], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 4293 : 
; 4294 : 	// Current version number
; 4295 : 	uint uiVersion = 1;
; 4296 : 	kStream << uiVersion;

	lea	ecx, DWORD PTR _uiVersion$[esp+8]
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR _uiVersion$[esp+12], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	pop	esi

; 4297 : }

	pop	ecx
	ret	4
?Write@CvAIOperationNavalSuperiority@@UBEXAAVFDataStream@@@Z ENDP ; CvAIOperationNavalSuperiority::Write
_TEXT	ENDS
PUBLIC	?Write@CvAIOperationPureNavalCityAttack@@UBEXAAVFDataStream@@@Z ; CvAIOperationPureNavalCityAttack::Write
; Function compile flags: /Ogtpy
;	COMDAT ?Write@CvAIOperationPureNavalCityAttack@@UBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
_uiVersion$241695 = 8					; size = 4
_kStream$ = 8						; size = 4
?Write@CvAIOperationPureNavalCityAttack@@UBEXAAVFDataStream@@@Z PROC ; CvAIOperationPureNavalCityAttack::Write, COMDAT
; _this$ = ecx

; 4667 : {

	push	ecx
	push	esi

; 4668 : 	// write the base class' entries
; 4669 : 	CvAINavalOperation::Write(kStream);

	mov	esi, DWORD PTR _kStream$[esp+4]
	push	esi
	call	?Write@CvAIOperation@@UBEXAAVFDataStream@@@Z ; CvAIOperation::Write
	lea	eax, DWORD PTR _uiVersion$241695[esp+4]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _uiVersion$241695[esp+8], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 4670 : 
; 4671 : 	// Current version number
; 4672 : 	uint uiVersion = 1;
; 4673 : 	kStream << uiVersion;

	lea	ecx, DWORD PTR _uiVersion$[esp+8]
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR _uiVersion$[esp+12], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	pop	esi

; 4674 : }

	pop	ecx
	ret	4
?Write@CvAIOperationPureNavalCityAttack@@UBEXAAVFDataStream@@@Z ENDP ; CvAIOperationPureNavalCityAttack::Write
_TEXT	ENDS
PUBLIC	?Write@CvAIOperationCityCloseDefense@@UBEXAAVFDataStream@@@Z ; CvAIOperationCityCloseDefense::Write
; Function compile flags: /Ogtpy
;	COMDAT ?Write@CvAIOperationCityCloseDefense@@UBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = 8						; size = 4
_kStream$ = 8						; size = 4
?Write@CvAIOperationCityCloseDefense@@UBEXAAVFDataStream@@@Z PROC ; CvAIOperationCityCloseDefense::Write, COMDAT
; _this$ = ecx

; 4836 : {

	push	esi

; 4837 : 	// write the base class' entries
; 4838 : 	CvAIOperation::Write(kStream);

	mov	esi, DWORD PTR _kStream$[esp]
	push	esi
	call	?Write@CvAIOperation@@UBEXAAVFDataStream@@@Z ; CvAIOperation::Write

; 4839 : 
; 4840 : 	// Current version number
; 4841 : 	uint uiVersion = 1;
; 4842 : 	kStream << uiVersion;

	lea	eax, DWORD PTR _uiVersion$[esp]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _uiVersion$[esp+4], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	pop	esi

; 4843 : }

	ret	4
?Write@CvAIOperationCityCloseDefense@@UBEXAAVFDataStream@@@Z ENDP ; CvAIOperationCityCloseDefense::Write
_TEXT	ENDS
PUBLIC	?Write@CvAIOperationRapidResponse@@UBEXAAVFDataStream@@@Z ; CvAIOperationRapidResponse::Write
; Function compile flags: /Ogtpy
;	COMDAT ?Write@CvAIOperationRapidResponse@@UBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = 8						; size = 4
_kStream$ = 8						; size = 4
?Write@CvAIOperationRapidResponse@@UBEXAAVFDataStream@@@Z PROC ; CvAIOperationRapidResponse::Write, COMDAT
; _this$ = ecx

; 4950 : {

	push	esi

; 4951 : 	// write the base class' entries
; 4952 : 	CvAIOperation::Write(kStream);

	mov	esi, DWORD PTR _kStream$[esp]
	push	esi
	call	?Write@CvAIOperation@@UBEXAAVFDataStream@@@Z ; CvAIOperation::Write

; 4953 : 
; 4954 : 	// Current version number
; 4955 : 	uint uiVersion = 1;
; 4956 : 	kStream << uiVersion;

	lea	eax, DWORD PTR _uiVersion$[esp]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _uiVersion$[esp+4], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	pop	esi

; 4957 : }

	ret	4
?Write@CvAIOperationRapidResponse@@UBEXAAVFDataStream@@@Z ENDP ; CvAIOperationRapidResponse::Write
_TEXT	ENDS
PUBLIC	?ArmyInPosition@CvAIOperationRapidResponse@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperationRapidResponse::ArmyInPosition
; Function compile flags: /Ogtpy
;	COMDAT ?ArmyInPosition@CvAIOperationRapidResponse@@UAE_NPAVCvArmyAI@@@Z
_TEXT	SEGMENT
_pArmy$ = 8						; size = 4
?ArmyInPosition@CvAIOperationRapidResponse@@UAE_NPAVCvArmyAI@@@Z PROC ; CvAIOperationRapidResponse::ArmyInPosition, COMDAT
; _this$ = ecx

; 4962 : 	bool bStateChanged = false;
; 4963 : 
; 4964 : 	switch(m_eCurrentState)

	mov	eax, DWORD PTR [ecx+56]
	push	ebx
	xor	bl, bl
	cmp	eax, 4
	ja	SHORT $LN3@ArmyInPosi@14
	jmp	DWORD PTR $LN7@ArmyInPosi@14[eax*4]
$LN2@ArmyInPosi@14:

; 4965 : 	{
; 4966 : 		// See if reached our target
; 4967 : 	case AI_OPERATION_STATE_MOVING_TO_TARGET:
; 4968 : 	{
; 4969 : 		// For now never end, even at target
; 4970 : 		bStateChanged = false;
; 4971 : 
; 4972 : 		// ... but we might want to move to a greater threat
; 4973 : 		RetargetDefensiveArmy(pArmy);

	mov	eax, DWORD PTR _pArmy$[esp]
	push	eax
	xor	bl, bl
	call	?RetargetDefensiveArmy@CvAIOperationRapidResponse@@AAE_NPAVCvArmyAI@@@Z ; CvAIOperationRapidResponse::RetargetDefensiveArmy

; 4983 : 		break;
; 4984 : 	};
; 4985 : 
; 4986 : 	return bStateChanged;

	mov	al, bl
	pop	ebx

; 4987 : }

	ret	4
$LN1@ArmyInPosi@14:

; 4974 : 	}
; 4975 : 	break;
; 4976 : 
; 4977 : 	// In all other cases use base class version
; 4978 : 	case AI_OPERATION_STATE_GATHERING_FORCES:
; 4979 : 	case AI_OPERATION_STATE_ABORTED:
; 4980 : 	case AI_OPERATION_STATE_RECRUITING_UNITS:
; 4981 : 	case AI_OPERATION_STATE_AT_TARGET:
; 4982 : 		bStateChanged = CvAIOperation::ArmyInPosition(pArmy);

	mov	edx, DWORD PTR _pArmy$[esp]
	push	edx
	call	?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperation::ArmyInPosition
	mov	bl, al
$LN3@ArmyInPosi@14:

; 4983 : 		break;
; 4984 : 	};
; 4985 : 
; 4986 : 	return bStateChanged;

	mov	al, bl
	pop	ebx

; 4987 : }

	ret	4
	npad	2
$LN7@ArmyInPosi@14:
	DD	$LN1@ArmyInPosi@14
	DD	$LN1@ArmyInPosi@14
	DD	$LN1@ArmyInPosi@14
	DD	$LN2@ArmyInPosi@14
	DD	$LN1@ArmyInPosi@14
?ArmyInPosition@CvAIOperationRapidResponse@@UAE_NPAVCvArmyAI@@@Z ENDP ; CvAIOperationRapidResponse::ArmyInPosition
_TEXT	ENDS
PUBLIC	?ArmyMoved@CvAIOperationRapidResponse@@UAE_NPAVCvArmyAI@@@Z ; CvAIOperationRapidResponse::ArmyMoved
; Function compile flags: /Ogtpy
;	COMDAT ?ArmyMoved@CvAIOperationRapidResponse@@UAE_NPAVCvArmyAI@@@Z
_TEXT	SEGMENT
_pArmy$ = 8						; size = 4
?ArmyMoved@CvAIOperationRapidResponse@@UAE_NPAVCvArmyAI@@@Z PROC ; CvAIOperationRapidResponse::ArmyMoved, COMDAT
; _this$ = ecx

; 4992 : 	bool bStateChanged = false;
; 4993 : 
; 4994 : 	switch(m_eCurrentState)

	mov	eax, DWORD PTR [ecx+56]
	cmp	eax, 4
	ja	SHORT $LN3@ArmyMoved@2
	jmp	DWORD PTR $LN9@ArmyMoved@2[eax*4]
$LN2@ArmyMoved@2:

; 4995 : 	{
; 4996 : 	case AI_OPERATION_STATE_MOVING_TO_TARGET:
; 4997 : 	{
; 4998 : 		RetargetDefensiveArmy(pArmy);

	mov	eax, DWORD PTR _pArmy$[esp-4]
	push	eax
	call	?RetargetDefensiveArmy@CvAIOperationRapidResponse@@AAE_NPAVCvArmyAI@@@Z ; CvAIOperationRapidResponse::RetargetDefensiveArmy
$LN3@ArmyMoved@2:

; 4999 : 	}
; 5000 : 	break;
; 5001 : 
; 5002 : 	// In all other cases use base class version
; 5003 : 	case AI_OPERATION_STATE_AT_TARGET:
; 5004 : 	case AI_OPERATION_STATE_RECRUITING_UNITS:
; 5005 : 	case AI_OPERATION_STATE_GATHERING_FORCES:
; 5006 : 	case AI_OPERATION_STATE_ABORTED:
; 5007 : 		return CvAIOperation::ArmyMoved(pArmy);
; 5008 : 		break;
; 5009 : 	};
; 5010 : 
; 5011 : 	return bStateChanged;

	xor	al, al

; 5012 : }

	ret	4
	npad	2
$LN9@ArmyMoved@2:
	DD	$LN3@ArmyMoved@2
	DD	$LN3@ArmyMoved@2
	DD	$LN3@ArmyMoved@2
	DD	$LN2@ArmyMoved@2
	DD	$LN3@ArmyMoved@2
?ArmyMoved@CvAIOperationRapidResponse@@UAE_NPAVCvArmyAI@@@Z ENDP ; CvAIOperationRapidResponse::ArmyMoved
_TEXT	ENDS
PUBLIC	?Write@CvAINavalEscortedOperation@@UBEXAAVFDataStream@@@Z ; CvAINavalEscortedOperation::Write
; Function compile flags: /Ogtpy
;	COMDAT ?Write@CvAINavalEscortedOperation@@UBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = 8						; size = 4
_kStream$ = 8						; size = 4
?Write@CvAINavalEscortedOperation@@UBEXAAVFDataStream@@@Z PROC ; CvAINavalEscortedOperation::Write, COMDAT
; _this$ = ecx

; 5232 : {

	push	esi
	push	edi

; 5233 : 	// write the base class' entries
; 5234 : 	CvAIOperation::Write(kStream);

	mov	edi, DWORD PTR _kStream$[esp+4]
	push	edi
	mov	esi, ecx
	call	?Write@CvAIOperation@@UBEXAAVFDataStream@@@Z ; CvAIOperation::Write

; 5235 : 
; 5236 : 	// Current version number
; 5237 : 	uint uiVersion = 1;
; 5238 : 	kStream << uiVersion;

	lea	eax, DWORD PTR _uiVersion$[esp+4]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR _uiVersion$[esp+8], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 5239 : 
; 5240 : 	kStream << m_eCivilianType;

	add	esi, 112				; 00000070H
	push	esi
	push	edi
	call	??6@YAAAVFDataStream@@AAV0@ABW4UnitAITypes@@@Z ; operator<<
	add	esp, 8
	pop	edi
	pop	esi

; 5241 : }

	ret	4
?Write@CvAINavalEscortedOperation@@UBEXAAVFDataStream@@@Z ENDP ; CvAINavalEscortedOperation::Write
_TEXT	ENDS
PUBLIC	?Write@CvAIOperationNavalAttack@@UBEXAAVFDataStream@@@Z ; CvAIOperationNavalAttack::Write
; Function compile flags: /Ogtpy
;	COMDAT ?Write@CvAIOperationNavalAttack@@UBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
_uiVersion$241739 = 8					; size = 4
_kStream$ = 8						; size = 4
?Write@CvAIOperationNavalAttack@@UBEXAAVFDataStream@@@Z PROC ; CvAIOperationNavalAttack::Write, COMDAT
; _this$ = ecx

; 5456 : {

	push	ecx
	push	esi

; 5457 : 	// write the base class' entries
; 5458 : 	CvAINavalEscortedOperation::Write(kStream);

	mov	esi, DWORD PTR _kStream$[esp+4]
	push	edi
	push	esi
	mov	edi, ecx
	call	?Write@CvAIOperation@@UBEXAAVFDataStream@@@Z ; CvAIOperation::Write
	lea	eax, DWORD PTR _uiVersion$241739[esp+8]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _uiVersion$241739[esp+12], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	add	edi, 112				; 00000070H
	push	edi
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4UnitAITypes@@@Z ; operator<<
	add	esp, 8

; 5459 : 
; 5460 : 	// Current version number
; 5461 : 	uint uiVersion = 1;
; 5462 : 	kStream << uiVersion;

	lea	ecx, DWORD PTR _uiVersion$[esp+12]
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR _uiVersion$[esp+16], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	pop	edi
	pop	esi

; 5463 : }

	pop	ecx
	ret	4
?Write@CvAIOperationNavalAttack@@UBEXAAVFDataStream@@@Z ENDP ; CvAIOperationNavalAttack::Write
_TEXT	ENDS
PUBLIC	?Write@CvAIOperationNukeAttack@@UBEXAAVFDataStream@@@Z ; CvAIOperationNukeAttack::Write
; Function compile flags: /Ogtpy
;	COMDAT ?Write@CvAIOperationNukeAttack@@UBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = 8						; size = 4
_kStream$ = 8						; size = 4
?Write@CvAIOperationNukeAttack@@UBEXAAVFDataStream@@@Z PROC ; CvAIOperationNukeAttack::Write, COMDAT
; _this$ = ecx

; 5625 : {

	push	esi
	push	edi

; 5626 : 	// write the base class' entries
; 5627 : 	CvAIOperation::Write(kStream);

	mov	edi, DWORD PTR _kStream$[esp+4]
	push	edi
	mov	esi, ecx
	call	?Write@CvAIOperation@@UBEXAAVFDataStream@@@Z ; CvAIOperation::Write

; 5628 : 
; 5629 : 	// Current version number
; 5630 : 	uint uiVersion = 1;
; 5631 : 	kStream << uiVersion;

	lea	eax, DWORD PTR _uiVersion$[esp+4]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR _uiVersion$[esp+8], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 5632 : 
; 5633 : 	kStream << m_iBestUnitID;

	add	esi, 112				; 00000070H
	push	esi
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	pop	edi
	pop	esi

; 5634 : }

	ret	4
?Write@CvAIOperationNukeAttack@@UBEXAAVFDataStream@@@Z ENDP ; CvAIOperationNukeAttack::Write
_TEXT	ENDS
PUBLIC	?back@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEAAUOperationSlot@@XZ ; std::vector<OperationSlot,std::allocator<OperationSlot> >::back
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?back@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEAAUOperationSlot@@XZ
_TEXT	SEGMENT
?back@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEAAUOperationSlot@@XZ PROC ; std::vector<OperationSlot,std::allocator<OperationSlot> >::back, COMDAT
; _this$ = ecx

; 800  : 		return (*(end() - 1));

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, 12					; 0000000cH

; 801  : 		}

	ret	0
?back@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEAAUOperationSlot@@XZ ENDP ; std::vector<OperationSlot,std::allocator<OperationSlot> >::back
_TEXT	ENDS
PUBLIC	?push_back@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAEIABQAVCvPlot@@H@Z ; CvWeightedVector<CvPlot *,1,1>::push_back
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?push_back@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAEIABQAVCvPlot@@H@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
_iWeight$ = 12						; size = 4
?push_back@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAEIABQAVCvPlot@@H@Z PROC ; CvWeightedVector<CvPlot *,1,1>::push_back, COMDAT
; _this$ = ecx

; 104  : //		FAssertMsg(iWeight >= 0, "Weight should not be negative.");
; 105  : 
; 106  : 		WeightedElement weightedElem;
; 107  : 		weightedElem.m_Element = element;

	mov	eax, DWORD PTR _element$[esp-4]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [eax]

; 108  : 		weightedElem.m_iWeight = iWeight;
; 109  : 
; 110  : 		return m_pItems.push_back(weightedElem);

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+20], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN5@push_back@4
	push	eax
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::GrowSize
$LN5@push_back@4:
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [edx+ecx*8]
	test	eax, eax
	je	SHORT $LN8@push_back@4
	mov	ecx, DWORD PTR _iWeight$[esp+4]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], ecx
$LN8@push_back@4:
	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	pop	edi
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 111  : 	};

	ret	8
?push_back@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAEIABQAVCvPlot@@H@Z ENDP ; CvWeightedVector<CvPlot *,1,1>::push_back
_TEXT	ENDS
PUBLIC	?reserve@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAEXI@Z ; CvWeightedVector<CvPlot *,1,1>::reserve
; Function compile flags: /Ogtpy
;	COMDAT ?reserve@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAEXI@Z
_TEXT	SEGMENT
_uiNewSize$ = 8						; size = 4
?reserve@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAEXI@Z PROC ; CvWeightedVector<CvPlot *,1,1>::reserve, COMDAT
; _this$ = ecx

; 128  : 		m_pItems.reserve(uiNewSize);

	jmp	?GrowSizeToFit@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::GrowSizeToFit
?reserve@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAEXI@Z ENDP ; CvWeightedVector<CvPlot *,1,1>::reserve
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXPAUOperationSlot@@0@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXPAUOperationSlot@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXPAUOperationSlot@@0@Z PROC ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXPAUOperationSlot@@0@Z ENDP ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXXZ ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXXZ PROC ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@2

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@2:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXXZ ENDP ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEPAUOperationSlot@@PAU3@IABU3@@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Ufill
; Function compile flags: /Ogtpy
;	COMDAT ?_Ufill@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEPAUOperationSlot@@PAU3@IABU3@@Z
_TEXT	SEGMENT
$T241864 = -4						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$241868 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEPAUOperationSlot@@PAU3@IABU3@@Z PROC ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	edx, DWORD PTR __Cat$241868[esp]
	push	esi
	mov	esi, DWORD PTR __Count$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+8]
	mov	BYTE PTR $T241864[esp+12], 0
	mov	eax, DWORD PTR $T241864[esp+12]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+12]
	push	edx
	push	ecx
	push	eax
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAUOperationSlot@@IU1@V?$allocator@UOperationSlot@@@std@@@std@@YAXPAUOperationSlot@@IABU1@AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<OperationSlot *,unsigned int,OperationSlot,std::allocator<OperationSlot> >

; 1255 : 		return (_Ptr + _Count);

	lea	ecx, DWORD PTR [esi+esi*2]
	add	esp, 24					; 00000018H
	lea	eax, DWORD PTR [edi+ecx*4]
	pop	edi
	pop	esi

; 1256 : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Ufill@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEPAUOperationSlot@@PAU3@IABU3@@Z ENDP ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Ufill
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@@stdext@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<OperationSlot *,OperationSlot *,std::allocator<OperationSlot> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@@stdext@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@std@@@Z
_TEXT	SEGMENT
$T241900 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$241904 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@@stdext@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<OperationSlot *,OperationSlot *,std::allocator<OperationSlot> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$241904[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T241900[esp+4], 0
	mov	eax, DWORD PTR $T241900[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@@std@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<OperationSlot *,OperationSlot *,std::allocator<OperationSlot> >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@@stdext@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<OperationSlot *,OperationSlot *,std::allocator<OperationSlot> >
_TEXT	ENDS
PUBLIC	??$_Buffered_merge@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@00HHAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z ; std::_Buffered_merge<CvOperationSearchUnit *,int,CvOperationSearchUnit>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Buffered_merge@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@00HHAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z
_TEXT	SEGMENT
__Firstn$228613 = -32					; size = 4
__Lastn$228614 = -28					; size = 4
__Midn$228633 = -24					; size = 4
$T241914 = -20						; size = 20
$T241912 = -20						; size = 20
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
tv368 = 20						; size = 4
$T242044 = 20						; size = 1
$T241993 = 20						; size = 1
$T241994 = 20						; size = 1
$T241913 = 20						; size = 4
$T241911 = 20						; size = 4
__Count1$ = 20						; size = 4
__Count2$ = 24						; size = 4
__Tempbuf$ = 28						; size = 4
??$_Buffered_merge@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@00HHAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z PROC ; std::_Buffered_merge<CvOperationSearchUnit *,int,CvOperationSearchUnit>, COMDAT

; 2760 : 	if (_Count1 + _Count2 == 2)

	mov	eax, DWORD PTR __Count1$[esp-4]
	sub	esp, 32					; 00000020H
	push	ebx
	mov	ebx, DWORD PTR __First$[esp+32]
	push	ebp
	mov	ebp, DWORD PTR __Mid$[esp+36]
	push	esi
	push	edi
	mov	edi, DWORD PTR __Count2$[esp+44]
	add	eax, edi
	cmp	eax, 2
	je	$LN110@Buffered_m
	jmp	SHORT $LN105@Buffered_m
$LL117@Buffered_m:
	mov	edi, DWORD PTR __Count2$[esp+44]
$LN105@Buffered_m:

; 2764 : 		}
; 2765 : 	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())

	cmp	DWORD PTR __Count1$[esp+44], edi
	mov	esi, DWORD PTR __Tempbuf$[esp+44]
	jg	SHORT $LN6@Buffered_m
	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAEHXZ ; std::_Temp_iterator<CvOperationSearchUnit>::_Maxlen
	cmp	DWORD PTR __Count1$[esp+44], eax
	jle	$LN111@Buffered_m
$LN6@Buffered_m:

; 2769 : 		}
; 2770 : 	else if (_Count2 <= _Tempbuf._Maxlen())

	mov	ecx, esi
	call	?_Maxlen@?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAEHXZ ; std::_Temp_iterator<CvOperationSearchUnit>::_Maxlen
	cmp	edi, eax
	jle	$LN112@Buffered_m

; 2775 : 		}
; 2776 : 	else
; 2777 : 		{	// buffer too small, divide and conquer
; 2778 : 		_BidIt _Firstn, _Lastn;
; 2779 : 		_Diff _Count1n, _Count2n;
; 2780 : 
; 2781 : 		if (_Count2 < _Count1)

	mov	eax, DWORD PTR __Count1$[esp+44]
	cmp	edi, eax

; 2782 : 			{	// left larger, cut it in half and partition right to match
; 2783 : 			_Count1n = _Count1 / 2, _Count2n = 0;
; 2784 : 			_Firstn = _First;
; 2785 : 			std::advance(_Firstn, _Count1n);
; 2786 : 			_Lastn = std::lower_bound(_Mid, _Last, *_Firstn);

	push	0
	jge	SHORT $LN2@Buffered_m
	mov	ecx, DWORD PTR __Last$[esp+48]
	cdq
	sub	eax, edx
	mov	edi, eax
	sar	edi, 1
	lea	eax, DWORD PTR [ebx+edi*8]
	push	eax
	push	ecx
	push	ebp
	mov	DWORD PTR __Firstn$228613[esp+64], eax
	call	??$_Lower_bound@PAVCvOperationSearchUnit@@V1@H@std@@YAPAVCvOperationSearchUnit@@PAV1@0ABV1@PAH@Z ; std::_Lower_bound<CvOperationSearchUnit *,CvOperationSearchUnit,int>

; 2787 : 			_Distance(_Mid, _Lastn, _Count2n);

	mov	esi, eax
	sub	esi, ebp
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Lastn$228614[esp+48], eax
	sar	esi, 3

; 2788 : 			}
; 2789 : 		else

	jmp	SHORT $LN103@Buffered_m
$LN2@Buffered_m:

; 2790 : 			{	// right larger, cut it in half and partition left to match
; 2791 : 			_Count1n = 0, _Count2n = _Count2 / 2;

	mov	eax, edi
	cdq
	sub	eax, edx
	mov	esi, eax
	sar	esi, 1

; 2792 : 			_Lastn = _Mid;
; 2793 : 			std::advance(_Lastn, _Count2n);

	lea	eax, DWORD PTR [ebp+esi*8]

; 2794 : 			_Firstn = std::upper_bound(_First, _Mid, *_Lastn);

	push	eax
	push	ebp
	push	ebx
	mov	DWORD PTR __Lastn$228614[esp+64], eax
	call	??$_Upper_bound@PAVCvOperationSearchUnit@@V1@H@std@@YAPAVCvOperationSearchUnit@@PAV1@0ABV1@PAH@Z ; std::_Upper_bound<CvOperationSearchUnit *,CvOperationSearchUnit,int>

; 2795 : 			_Distance(_First, _Firstn, _Count1n);

	mov	edi, eax
	sub	edi, ebx
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Firstn$228613[esp+48], eax
	mov	eax, DWORD PTR __Lastn$228614[esp+48]
	sar	edi, 3
$LN103@Buffered_m:

; 2796 : 			}
; 2797 : 
; 2798 : 		_BidIt _Midn = _Buffered_rotate(_Firstn, _Mid, _Lastn,
; 2799 : 			_Count1 - _Count1n, _Count2n, _Tempbuf);	// rearrange middle

	mov	edx, DWORD PTR __Tempbuf$[esp+44]
	mov	ecx, DWORD PTR __Count1$[esp+44]
	push	edx
	push	esi
	sub	ecx, edi
	push	ecx
	push	eax
	mov	eax, DWORD PTR __Firstn$228613[esp+64]
	push	ebp
	push	eax
	mov	DWORD PTR tv368[esp+68], ecx
	call	??$_Buffered_rotate@PAVCvOperationSearchUnit@@HV1@@std@@YAPAVCvOperationSearchUnit@@PAV1@00HHAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z ; std::_Buffered_rotate<CvOperationSearchUnit *,int,CvOperationSearchUnit>

; 2800 : 		_Buffered_merge(_First, _Firstn, _Midn,
; 2801 : 			_Count1n, _Count2n, _Tempbuf);	// merge each new part

	mov	ecx, DWORD PTR __Tempbuf$[esp+68]
	mov	edx, DWORD PTR __Firstn$228613[esp+72]
	push	ecx
	push	esi
	push	edi
	push	eax
	push	edx
	push	ebx
	mov	DWORD PTR __Midn$228633[esp+96], eax
	call	??$_Buffered_merge@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@00HHAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z ; std::_Buffered_merge<CvOperationSearchUnit *,int,CvOperationSearchUnit>

; 2802 : 		_Buffered_merge(_Midn, _Lastn, _Last,
; 2803 : 			_Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf);

	mov	eax, DWORD PTR __Count2$[esp+92]
	mov	ecx, DWORD PTR tv368[esp+92]
	mov	ebp, DWORD PTR __Lastn$228614[esp+96]
	mov	ebx, DWORD PTR __Midn$228633[esp+96]
	sub	eax, esi
	mov	DWORD PTR __Count1$[esp+92], ecx
	add	ecx, eax
	add	esp, 48					; 00000030H
	mov	DWORD PTR __Count2$[esp+44], eax
	cmp	ecx, 2
	jne	$LL117@Buffered_m
$LN110@Buffered_m:

; 2761 : 		{	// order two one-element partitions
; 2762 : 		if (_DEBUG_LT(*_Mid, *_First))

	mov	eax, DWORD PTR [ebp]
	cmp	eax, DWORD PTR [ebx]
	jge	$LN3@Buffered_m

; 2763 : 			std::iter_swap(_First, _Mid);

	cmp	ebx, ebp
	je	$LN3@Buffered_m
	mov	edx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR [ebx], edx
	mov	edx, DWORD PTR [ebp+4]
	mov	DWORD PTR [ebx+4], edx
	mov	DWORD PTR [ebp], eax
	mov	DWORD PTR [ebp+4], ecx

; 2804 : 		}
; 2805 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 32					; 00000020H
	ret	0
$LN111@Buffered_m:

; 2766 : 		{	// buffer left partition, then merge
; 2767 : 		_STDEXT unchecked_copy(_First, _Mid, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	edi, edi
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [eax+4], edi
	mov	DWORD PTR [eax+8], edi
	mov	DWORD PTR [eax+12], edi
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR $T241911[esp+64], esp
	push	ebp
	mov	DWORD PTR [eax+16], edx
	lea	eax, DWORD PTR $T241912[esp+72]
	push	ebx
	push	eax
	call	??$unchecked_copy@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@0V12@@Z ; stdext::unchecked_copy<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit> >
	mov	eax, DWORD PTR $T241912[esp+80]
	add	esp, 32					; 00000020H
	cmp	eax, edi
	je	SHORT $LN41@Buffered_m
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN41@Buffered_m:

; 2768 : 		_STDEXT unchecked_merge(_Tempbuf._First(), _Tempbuf._Last(), _Mid, _Last, _First);

	mov	eax, DWORD PTR __Last$[esp+44]
	mov	esi, DWORD PTR [esi+16]
	mov	BYTE PTR $T241993[esp+44], 0
	mov	ecx, DWORD PTR $T241993[esp+44]
	mov	edx, DWORD PTR $T241994[esp+44]
	push	ecx
	mov	ecx, DWORD PTR [esi+4]
	push	edx
	mov	edx, DWORD PTR [esi]
	push	ebx
	push	eax
	push	ebp
	push	ecx
	push	edx
	call	??$_Merge@PAVCvOperationSearchUnit@@PAV1@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvOperationSearchUnit@@PAV1@0000Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvOperationSearchUnit *,CvOperationSearchUnit *,CvOperationSearchUnit *,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH

; 2804 : 		}
; 2805 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 32					; 00000020H
	ret	0
$LN112@Buffered_m:

; 2771 : 		{	// buffer right partition, then merge
; 2772 : 		_STDEXT unchecked_copy(_Mid, _Last, _Tempbuf._Init());

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [eax]
	mov	edi, DWORD PTR __Last$[esp+44]
	mov	DWORD PTR [eax+4], ecx
	sub	esp, 20					; 00000014H
	mov	eax, esp
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR $T241913[esp+64], esp
	push	edi
	mov	DWORD PTR [eax+16], edx
	lea	eax, DWORD PTR $T241914[esp+72]
	push	ebp
	push	eax
	call	??$unchecked_copy@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@0V12@@Z ; stdext::unchecked_copy<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit> >
	mov	eax, DWORD PTR $T241914[esp+80]
	add	esp, 32					; 00000020H
	test	eax, eax
	je	SHORT $LN65@Buffered_m
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN65@Buffered_m:

; 2773 : 		_STDEXT _Unchecked_merge_backward(_First, _Mid,
; 2774 : 			_Tempbuf._First(), _Tempbuf._Last(), _Last);

	mov	esi, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi]
	mov	BYTE PTR $T242044[esp+44], 0
	mov	ecx, DWORD PTR $T242044[esp+44]
	push	ecx
	push	edi
	push	edx
	push	eax
	push	ebp
	push	ebx
	call	??$_Merge_backward@PAVCvOperationSearchUnit@@PAV1@PAV1@@std@@YAPAVCvOperationSearchUnit@@PAV1@0000U_Range_checked_iterator_tag@0@@Z ; std::_Merge_backward<CvOperationSearchUnit *,CvOperationSearchUnit *,CvOperationSearchUnit *>
	add	esp, 24					; 00000018H
$LN3@Buffered_m:

; 2804 : 		}
; 2805 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 32					; 00000020H
	ret	0
??$_Buffered_merge@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@00HHAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z ENDP ; std::_Buffered_merge<CvOperationSearchUnit *,int,CvOperationSearchUnit>
_TEXT	ENDS
PUBLIC	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ; std::_Sort_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z PROC ; std::_Sort_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>, COMDAT

; 2215 : 	_DEBUG_RANGE(_First, _Last);
; 2216 : 	_DEBUG_HEAP(_First, _Last);
; 2217 : 	for (; 1 < _Last - _First; --_Last)

	mov	ecx, DWORD PTR __Last$[esp-4]
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+8]
	mov	eax, ecx
	sub	eax, edi
	sar	eax, 3
	cmp	eax, 1
	jle	SHORT $LN1@Sort_heap
	mov	ebx, 8
	sub	ebx, edi

; 2218 : 		std::pop_heap(_First, _Last);

	cmp	eax, 1
	lea	esi, DWORD PTR [ecx-8]
	jle	SHORT $LN2@Sort_heap
$LN24@Sort_heap:
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR [edi+4]
	sub	esp, 8
	mov	DWORD PTR [esi+4], eax
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	lea	ecx, DWORD PTR [ebx+esi-8]
	sar	ecx, 3
	push	ecx
	push	0
	push	edi
	mov	DWORD PTR [eax+4], edx
	call	??$_Adjust_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HHU12@@Z ; std::_Adjust_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
	add	esp, 20					; 00000014H
$LN2@Sort_heap:
	sub	esi, 8
	lea	eax, DWORD PTR [ebx+esi]
	sar	eax, 3
	cmp	eax, 1
	jg	SHORT $LN24@Sort_heap
$LN1@Sort_heap:

; 2219 : 	}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ENDP ; std::_Sort_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_chunked_merge@PAVCvOperationSearchUnit@@PAV1@H@stdext@@YAXPAVCvOperationSearchUnit@@00HH@Z ; stdext::_Unchecked_chunked_merge<CvOperationSearchUnit *,CvOperationSearchUnit *,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_chunked_merge@PAVCvOperationSearchUnit@@PAV1@H@stdext@@YAXPAVCvOperationSearchUnit@@00HH@Z
_TEXT	SEGMENT
$T242213 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Chunk$ = 20						; size = 4
__Count$ = 24						; size = 4
??$_Unchecked_chunked_merge@PAVCvOperationSearchUnit@@PAV1@H@stdext@@YAXPAVCvOperationSearchUnit@@00HH@Z PROC ; stdext::_Unchecked_chunked_merge<CvOperationSearchUnit *,CvOperationSearchUnit *,int>, COMDAT

; 5252 : 	{

	push	ecx

; 5253 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Count$[esp]
	mov	edx, DWORD PTR __Chunk$[esp]
	mov	BYTE PTR $T242213[esp+4], 0
	mov	eax, DWORD PTR $T242213[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Chunked_merge@PAVCvOperationSearchUnit@@PAV1@H@std@@YAXPAVCvOperationSearchUnit@@00HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvOperationSearchUnit *,CvOperationSearchUnit *,int>

; 5254 : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_chunked_merge@PAVCvOperationSearchUnit@@PAV1@H@stdext@@YAXPAVCvOperationSearchUnit@@00HH@Z ENDP ; stdext::_Unchecked_chunked_merge<CvOperationSearchUnit *,CvOperationSearchUnit *,int>
_TEXT	ENDS
PUBLIC	??$unchecked_merge@PAVCvOperationSearchUnit@@PAV1@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@000V12@@Z ; stdext::unchecked_merge<CvOperationSearchUnit *,CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_merge@PAVCvOperationSearchUnit@@PAV1@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@000V12@@Z
_TEXT	SEGMENT
$T242217 = -4						; size = 1
$T242223 = -4						; size = 4
$T242219 = -4						; size = 4
$T242218 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
__Last2$ = 24						; size = 4
__Dest$ = 28						; size = 20
??$unchecked_merge@PAVCvOperationSearchUnit@@PAV1@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@000V12@@Z PROC ; stdext::unchecked_merge<CvOperationSearchUnit *,CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit> >, COMDAT

; 5114 : 	{	// copy merging ranges, both using operator<

	push	ecx
	push	ebx
	xor	ebx, ebx
	mov	DWORD PTR $T242223[esp+8], ebx

; 5115 : 		return _STD _Merge(_CHECKED_BASE(_First1), _CHECKED_BASE(_Last1), _CHECKED_BASE(_First2), _CHECKED_BASE(_Last2), _Dest,
; 5116 : 			_STD _Iter_random(_First1, _First2, _Dest), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR $T242218[esp+4]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+8]
	mov	BYTE PTR $T242217[esp+12], bl
	mov	eax, DWORD PTR $T242217[esp+12]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR __First2$[esp+16]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	edx, DWORD PTR __Dest$[esp+52]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR __Last2$[esp+36]
	mov	edx, DWORD PTR __Last1$[esp+36]
	mov	DWORD PTR $T242219[esp+40], esp
	push	eax
	mov	eax, DWORD PTR __First1$[esp+40]
	push	ecx
	push	edx
	push	eax
	push	esi
	call	??$_Merge@PAVCvOperationSearchUnit@@PAV1@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@Uforward_iterator_tag@3@@std@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@0@PAVCvOperationSearchUnit@@000V10@Uforward_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Merge<CvOperationSearchUnit *,CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit>,std::forward_iterator_tag>
	mov	eax, DWORD PTR __Dest$[esp+56]
	add	esp, 48					; 00000030H
	cmp	eax, ebx
	je	SHORT $LN25@unchecked_@9
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN25@unchecked_@9:
	mov	eax, esi

; 5117 : 	}

	pop	esi
	pop	ebx
	pop	ecx
	ret	0
??$unchecked_merge@PAVCvOperationSearchUnit@@PAV1@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@000V12@@Z ENDP ; stdext::unchecked_merge<CvOperationSearchUnit *,CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit> >
_TEXT	ENDS
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z
_TEXT	SEGMENT
__Addleft$ = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
$T242285 = 12						; size = 4
$T242283 = 12						; size = 4
__Where$199291 = 12					; size = 4
__Val$ = 12						; size = 4
?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z PROC ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::insert, COMDAT
; _this$ = ecx

; 630  : 		{	// try to insert node with value _Val

	push	ecx
	push	ebp

; 631  : 		_Nodeptr _Trynode = _Root();
; 632  : 		_Nodeptr _Wherenode = _Myhead;
; 633  : 		bool _Addleft = true;	// add to left of head if tree empty
; 634  : 		while (!_Isnil(_Trynode))

	mov	ebp, DWORD PTR __Val$[esp+4]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax+17], 0
	mov	cl, 1
	mov	BYTE PTR __Addleft$[esp+16], cl
	jne	SHORT $LN9@insert
	mov	edx, DWORD PTR [ebp]
	npad	1
$LL10@insert:

; 635  : 			{	// look for leaf to insert before (_Addleft) or after
; 636  : 			_Wherenode = _Trynode;
; 637  : 			_Addleft = _DEBUG_LT_PRED(this->comp,

	cmp	edx, DWORD PTR [eax+12]
	mov	esi, eax
	setb	cl
	mov	BYTE PTR __Addleft$[esp+16], cl

; 638  : 				this->_Kfn(_Val), _Key(_Trynode));
; 639  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

	test	cl, cl
	je	SHORT $LN13@insert
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN14@insert
$LN13@insert:
	mov	eax, DWORD PTR [eax+8]
$LN14@insert:

; 631  : 		_Nodeptr _Trynode = _Root();
; 632  : 		_Nodeptr _Wherenode = _Myhead;
; 633  : 		bool _Addleft = true;	// add to left of head if tree empty
; 634  : 		while (!_Isnil(_Trynode))

	cmp	BYTE PTR [eax+17], 0
	je	SHORT $LL10@insert
$LN9@insert:

; 640  : 			}
; 641  : 
; 642  : 		if (this->_Multi)
; 643  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));
; 644  : 		else
; 645  : 			{	// insert only if unique
; 646  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);

	mov	edx, esi
	mov	DWORD PTR __Where$199291[esp+12], edx

; 647  : 			if (!_Addleft)

	test	cl, cl
	je	SHORT $LN57@insert

; 648  : 				;	// need to test if insert after is okay
; 649  : 			else if (_Where == begin())

	mov	eax, DWORD PTR [edi+4]

; 650  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

	lea	ecx, DWORD PTR $T242283[esp+12]
	cmp	esi, DWORD PTR [eax]
	jne	SHORT $LN4@insert
	push	ebp
	push	esi
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Insert
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	edi
	pop	esi
	mov	BYTE PTR [eax+4], 1

; 657  : 			else
; 658  : 				return (_Pairib(_Where, false));

	mov	DWORD PTR [eax], edx
	pop	ebp

; 659  : 			}
; 660  : 		}

	pop	ecx
	ret	8
$LN4@insert:

; 651  : 			else
; 652  : 				--_Where;	// need to test if insert before is okay

	call	?_Dec@const_iterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::const_iterator::_Dec
	mov	edx, DWORD PTR __Where$199291[esp+12]
$LN57@insert:

; 653  : 
; 654  : 			if (_DEBUG_LT_PRED(this->comp,

	mov	eax, DWORD PTR [edx+12]
	cmp	eax, DWORD PTR [ebp]
	jae	SHORT $LN2@insert

; 655  : 				_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 656  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	ecx, DWORD PTR __Addleft$[esp+16]
	push	ebp
	push	esi
	push	ecx
	lea	edx, DWORD PTR $T242285[esp+24]
	push	edx
	mov	ecx, edi
	call	?_Insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::_Insert
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], ecx
	mov	BYTE PTR [eax+4], 1
	pop	ebp

; 659  : 			}
; 660  : 		}

	pop	ecx
	ret	8
$LN2@insert:

; 657  : 			else
; 658  : 				return (_Pairib(_Where, false));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	pop	edi
	pop	esi
	mov	BYTE PTR [eax+4], 0
	mov	DWORD PTR [eax], edx
	pop	ebp

; 659  : 			}
; 660  : 		}

	pop	ecx
	ret	8
?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z ENDP ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::insert
_TEXT	ENDS
PUBLIC	?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ; std::vector<int,std::allocator<int> >::clear
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ PROC	; std::vector<int,std::allocator<int> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ENDP	; std::vector<int,std::allocator<int> >::clear
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >, COMDAT

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN13@unchecked_@10
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL15@unchecked_@10:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL15@unchecked_@10
	pop	esi
$LN13@unchecked_@10:

; 943  : 	}

	ret	0
??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z PROC ; std::vector<int,std::allocator<int> >::_Umove<int *>, COMDAT
; _this$ = ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN16@Umove
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN16@Umove:
	pop	edi
	mov	eax, esi
	pop	esi

; 1149 : 		}

	ret	12					; 0000000cH
??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ENDP ; std::vector<int,std::allocator<int> >::_Umove<int *>
_TEXT	ENDS
PUBLIC	?Reset@CvAIOperation@@UAEXXZ			; CvAIOperation::Reset
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
;	COMDAT ?Reset@CvAIOperation@@UAEXXZ
_TEXT	SEGMENT
?Reset@CvAIOperation@@UAEXXZ PROC			; CvAIOperation::Reset, COMDAT
; _this$ = ecx

; 96   : 	m_iID = 0;
; 97   : 	m_eOwner = NO_PLAYER;

	or	eax, -1
	push	ebx
	xor	ebx, ebx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi+52], ebx
	mov	DWORD PTR [esi+72], eax

; 98   : 	m_eEnemy = NO_PLAYER;

	mov	DWORD PTR [esi+76], eax

; 99   : 	m_iDefaultArea = FFreeList::INVALID_INDEX;

	mov	DWORD PTR [esi+64], eax

; 100  : 	m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	DWORD PTR [esi+56], ebx

; 101  : 	m_eAbortReason = NO_ABORT_REASON;

	mov	DWORD PTR [esi+60], eax

; 102  : 	m_iTargetX = 0;

	mov	DWORD PTR [esi+104], ebx

; 103  : 	m_iTargetY = 0;

	mov	DWORD PTR [esi+108], ebx

; 104  : 	m_iMusterX = 0;

	mov	DWORD PTR [esi+96], ebx

; 105  : 	m_iMusterY = 0;

	mov	DWORD PTR [esi+100], ebx

; 106  : 	m_iStartCityX = -1;

	mov	DWORD PTR [esi+88], eax

; 107  : 	m_iStartCityY = -1;

	mov	DWORD PTR [esi+92], eax

; 108  : 	m_eMoveType = INVALID_AI_OPERATION_MOVE_TYPE;

	mov	DWORD PTR [esi+84], eax

; 109  : #ifdef AUI_WARNING_FIXES
; 110  : 	m_bShouldReplaceLossesWithReinforcements = false;
; 111  : #endif
; 112  : 	m_iLastTurnMoved = -1;

	mov	DWORD PTR [esi+68], eax

; 113  : 	m_viArmyIDs.clear();

	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [esi+8]
	cmp	edx, ecx
	je	SHORT $LN17@Reset
	mov	eax, ecx
	sub	eax, ecx
	push	ebp
	sar	eax, 2
	cmp	eax, ebx
	push	edi
	lea	edi, DWORD PTR [eax*4]
	lea	ebp, DWORD PTR [edi+edx]
	jle	SHORT $LN42@Reset
	push	edi
	push	ecx
	push	edi
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN42@Reset:
	pop	edi
	mov	DWORD PTR [esi+12], ebp
	pop	ebp
$LN17@Reset:
	pop	esi
	pop	ebx

; 114  : }

	ret	0
?Reset@CvAIOperation@@UAEXXZ ENDP			; CvAIOperation::Reset
_TEXT	ENDS
PUBLIC	?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z ; CvAIOperation::PeekAtNextUnitToBuild
; Function compile flags: /Ogtpy
;	COMDAT ?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_iAreaID$ = 12						; size = 4
?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z PROC ; CvAIOperation::PeekAtNextUnitToBuild, COMDAT
; _this$ = ecx

; 377  : 	OperationSlot thisSlot;

	or	eax, -1
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax

; 378  : 	if(iAreaID == m_iDefaultArea && !m_viListOfUnitsWeStillNeedToBuild.empty())

	mov	eax, DWORD PTR _iAreaID$[esp]
	cmp	eax, DWORD PTR [ecx+64]
	jne	SHORT $LN31@PeekAtNext
	mov	edx, DWORD PTR [ecx+28]
	sub	edx, DWORD PTR [ecx+24]
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	je	SHORT $LN31@PeekAtNext

; 379  : 	{
; 380  : 		thisSlot = m_viListOfUnitsWeStillNeedToBuild.back();

	mov	eax, DWORD PTR [ecx+28]
	mov	ecx, DWORD PTR [eax-12]
	mov	edx, DWORD PTR [eax-8]
	sub	eax, 12					; 0000000cH
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [esi+4], edx
	mov	DWORD PTR [esi+8], eax
$LN31@PeekAtNext:

; 381  : 	}
; 382  : 	return thisSlot;

	mov	eax, esi
	pop	esi

; 383  : }

	ret	8
?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z ENDP ; CvAIOperation::PeekAtNextUnitToBuild
_TEXT	ENDS
PUBLIC	??1?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ ; std::vector<OperationSlot,std::allocator<OperationSlot> >::~vector<OperationSlot,std::allocator<OperationSlot> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??1?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ PROC ; std::vector<OperationSlot,std::allocator<OperationSlot> >::~vector<OperationSlot,std::allocator<OperationSlot> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@2:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ ENDP ; std::vector<OperationSlot,std::allocator<OperationSlot> >::~vector<OperationSlot,std::allocator<OperationSlot> >
_TEXT	ENDS
PUBLIC	?pop_back@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXXZ ; std::vector<OperationSlot,std::allocator<OperationSlot> >::pop_back
; Function compile flags: /Ogtpy
;	COMDAT ?pop_back@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXXZ PROC ; std::vector<OperationSlot,std::allocator<OperationSlot> >::pop_back, COMDAT
; _this$ = ecx

; 841  : 		{	// erase element at end

	push	esi

; 842  : 		if (!empty())

	mov	esi, DWORD PTR [ecx+8]
	mov	edx, esi
	sub	edx, DWORD PTR [ecx+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	je	SHORT $LN1@pop_back

; 843  : 			{	// erase last element
; 844  : 			_Destroy(_Mylast - 1, _Mylast);
; 845  : 			--_Mylast;

	add	esi, -12				; fffffff4H
	mov	DWORD PTR [ecx+8], esi
$LN1@pop_back:
	pop	esi

; 846  : 			}
; 847  : 		}

	ret	0
?pop_back@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXXZ ENDP ; std::vector<OperationSlot,std::allocator<OperationSlot> >::pop_back
_TEXT	ENDS
PUBLIC	?erase@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@@Z PROC ; std::vector<OperationSlot,std::allocator<OperationSlot> >::erase, COMDAT
; _this$ = ecx

; 1018 : 		_STDEXT unchecked_copy(_VEC_ITER_BASE(_Where) + 1, _Mylast,
; 1019 : 			_VEC_ITER_BASE(_Where));

	mov	edx, DWORD PTR __Where$[esp-4]
	push	esi
	mov	esi, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [edx+12]
	cmp	eax, esi
	je	SHORT $LN9@erase@3
	push	edi
$LL11@erase@3:
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], edi
	mov	edi, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], edi
	add	eax, 12					; 0000000cH
	add	edx, 12					; 0000000cH
	cmp	eax, esi
	jne	SHORT $LL11@erase@3
	mov	edx, DWORD PTR __Where$[esp+4]
	pop	edi
$LN9@erase@3:

; 1020 : 		_Destroy(_Mylast - 1, _Mylast);
; 1021 : 		--_Mylast;
; 1022 : 		return (_Make_iter(_Where));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp]
	add	DWORD PTR [ecx+8], -12			; fffffff4H
	mov	DWORD PTR [eax], edx
	pop	esi

; 1023 : 		}

	ret	8
?erase@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@@Z ENDP ; std::vector<OperationSlot,std::allocator<OperationSlot> >::erase
_TEXT	ENDS
PUBLIC	?erase@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@0@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@0@Z PROC ; std::vector<OperationSlot,std::allocator<OperationSlot> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);
; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __Last_arg$[esp-4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First_arg$[esp]
	mov	DWORD PTR [eax], esi
	cmp	esi, edx
	je	SHORT $LN1@erase@4
	push	edi

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edi, DWORD PTR [ecx+8]
	cmp	edx, edi
	je	SHORT $LN26@erase@4
	push	ebx
	npad	4
$LL28@erase@4:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [esi], ebx
	mov	ebx, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], ebx
	mov	ebx, DWORD PTR [edx+8]
	mov	DWORD PTR [esi+8], ebx
	add	edx, 12					; 0000000cH
	add	esi, 12					; 0000000cH
	cmp	edx, edi
	jne	SHORT $LL28@erase@4
	pop	ebx
$LN26@erase@4:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [ecx+8], esi
	pop	edi
$LN1@erase@4:
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);
; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@0@Z ENDP ; std::vector<OperationSlot,std::allocator<OperationSlot> >::erase
_TEXT	ENDS
PUBLIC	??$_Umove@PAUOperationSlot@@@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEPAUOperationSlot@@PAU2@00@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Umove<OperationSlot *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Umove@PAUOperationSlot@@@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEPAUOperationSlot@@PAU2@00@Z
_TEXT	SEGMENT
$T243253 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$243257 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAUOperationSlot@@@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEPAUOperationSlot@@PAU2@00@Z PROC ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Umove<OperationSlot *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$243257[esp]
	mov	BYTE PTR $T243253[esp+4], 0
	mov	eax, DWORD PTR $T243253[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@@std@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<OperationSlot *,OperationSlot *,std::allocator<OperationSlot> >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@PAUOperationSlot@@@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEPAUOperationSlot@@PAU2@00@Z ENDP ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Umove<OperationSlot *>
_TEXT	ENDS
PUBLIC	??$sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ; std::sort_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z PROC ; std::sort_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>, COMDAT

; 2224 : 	_DEBUG_HEAP(_First, _Last);
; 2225 : 	_Sort_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last));

	jmp	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ; std::_Sort_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
??$sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ENDP ; std::sort_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Chunked_merge@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@H@std@@YAXPAVCvOperationSearchUnit@@0V?$_Temp_iterator@VCvOperationSearchUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit>,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Chunked_merge@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@H@std@@YAXPAVCvOperationSearchUnit@@0V?$_Temp_iterator@VCvOperationSearchUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T243272 = -20						; size = 20
$T243270 = -20						; size = 20
$T243268 = -20						; size = 20
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
$T243267 = 36						; size = 4
__Chunk$ = 36						; size = 4
$T243269 = 40						; size = 4
__Count$ = 40						; size = 4
___formal$ = 44						; size = 1
??$_Chunked_merge@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@H@std@@YAXPAVCvOperationSearchUnit@@0V?$_Temp_iterator@VCvOperationSearchUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Chunked_merge<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit>,int>, COMDAT

; 3289 : 	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)

	mov	ecx, DWORD PTR __Count$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Chunk$[esp+32]
	lea	eax, DWORD PTR [edi+edi]
	xor	ebx, ebx
	cmp	eax, ecx
	jg	SHORT $LN3@Chunked_me@2
	npad	4
$LL5@Chunked_me@2:

; 3290 : 		{	// copy merging pairs of adjacent chunks
; 3291 : 		_BidIt _Mid1 = _First;
; 3292 : 		std::advance(_Mid1, _Chunk);
; 3293 : 		_BidIt _Mid2 = _Mid1;
; 3294 : 		std::advance(_Mid2, _Chunk);
; 3295 : 
; 3296 : 		_Dest = _STDEXT unchecked_merge(_First, _Mid1, _Mid1, _Mid2, _Dest);

	sub	esp, 20					; 00000014H
	mov	eax, esp
	lea	ecx, DWORD PTR [edx+edi*8]
	mov	DWORD PTR $T243267[esp+52], esp
	lea	esi, DWORD PTR [ecx+edi*8]
	push	esi
	push	ecx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ebp, DWORD PTR __Dest$[esp+76]
	push	ecx
	mov	DWORD PTR [eax+16], ebp
	push	edx
	lea	eax, DWORD PTR $T243268[esp+72]
	push	eax
	call	??$unchecked_merge@PAVCvOperationSearchUnit@@PAV1@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@000V12@@Z ; stdext::unchecked_merge<CvOperationSearchUnit *,CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit> >
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR $T243268[esp+76]
	add	esp, 40					; 00000028H
	mov	DWORD PTR __Dest$[esp+48], ecx
	cmp	eax, ebx
	je	SHORT $LN41@Chunked_me@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN41@Chunked_me@2:
	mov	ecx, DWORD PTR __Count$[esp+32]
	lea	eax, DWORD PTR [edi+edi]
	sub	ecx, eax
	cmp	ecx, eax

; 3297 : 		_First = _Mid2;

	mov	edx, esi
	mov	DWORD PTR __Count$[esp+32], ecx
	jge	SHORT $LL5@Chunked_me@2
$LN3@Chunked_me@2:

; 3298 : 		}
; 3299 : 
; 3300 : 	if (_Count <= _Chunk)
; 3301 : 		_STDEXT unchecked_copy(_First, _Last, _Dest);	// copy partial last chunk

	sub	esp, 20					; 00000014H
	cmp	ecx, edi
	mov	eax, esp
	mov	DWORD PTR $T243269[esp+52], esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	jg	SHORT $LN2@Chunked_me@2
	mov	ecx, DWORD PTR __Dest$[esp+68]
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR __Last$[esp+52]
	push	eax
	push	edx
	lea	ecx, DWORD PTR $T243270[esp+64]
	push	ecx
	call	??$unchecked_copy@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@0V12@@Z ; stdext::unchecked_copy<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit> >
	add	esp, 32					; 00000020H

; 3302 : 	else

	jmp	SHORT $LN99@Chunked_me@2
$LN2@Chunked_me@2:

; 3303 : 		{	// copy merging whole and partial last chunk
; 3304 : 		_BidIt _Mid = _First;
; 3305 : 		std::advance(_Mid, _Chunk);
; 3306 : 
; 3307 : 		_STDEXT unchecked_merge(_First, _Mid, _Mid, _Last, _Dest);

	mov	esi, DWORD PTR __Dest$[esp+68]
	mov	DWORD PTR [eax+16], esi
	mov	eax, DWORD PTR __Last$[esp+52]
	push	eax
	lea	ecx, DWORD PTR [edx+edi*8]
	push	ecx
	push	ecx
	push	edx
	lea	ecx, DWORD PTR $T243272[esp+72]
	push	ecx
	call	??$unchecked_merge@PAVCvOperationSearchUnit@@PAV1@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@@stdext@@YA?AV?$_Temp_iterator@VCvOperationSearchUnit@@@std@@PAVCvOperationSearchUnit@@000V12@@Z ; stdext::unchecked_merge<CvOperationSearchUnit *,CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit> >
	add	esp, 40					; 00000028H
$LN99@Chunked_me@2:
	mov	eax, DWORD PTR $T243272[esp+36]
	cmp	eax, ebx
	je	SHORT $LN75@Chunked_me@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN75@Chunked_me@2:

; 3308 : 		}
; 3309 : 	}

	mov	eax, DWORD PTR __Dest$[esp+32]
	cmp	eax, ebx
	je	SHORT $LN85@Chunked_me@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN85@Chunked_me@2:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 20					; 00000014H
	ret	0
??$_Chunked_merge@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@H@std@@YAXPAVCvOperationSearchUnit@@0V?$_Temp_iterator@VCvOperationSearchUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Chunked_merge<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit>,int>
_TEXT	ENDS
PUBLIC	?touch@FAutoArchive@@QAEXAAVFAutoVariableBase@@@Z ; FAutoArchive::touch
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautoarchive.h
;	COMDAT ?touch@FAutoArchive@@QAEXAAVFAutoVariableBase@@@Z
_TEXT	SEGMENT
$T243455 = -8						; size = 8
$T243454 = 8						; size = 4
_dirtyVariable$ = 8					; size = 4
?touch@FAutoArchive@@QAEXAAVFAutoVariableBase@@@Z PROC	; FAutoArchive::touch, COMDAT
; _this$ = ecx

; 55   : 	{

	sub	esp, 8

; 56   : #ifdef FAUTOARCHIVE_DEBUG
; 57   : 		debugHelp(dirtyVariable);
; 58   : #endif//FAUTOARCHIVE_DEBUG
; 59   : 		m_deltas.insert(&dirtyVariable);

	mov	eax, DWORD PTR _dirtyVariable$[esp+4]
	lea	edx, DWORD PTR $T243454[esp+4]
	mov	DWORD PTR $T243454[esp+4], eax
	push	edx
	lea	eax, DWORD PTR $T243455[esp+12]
	push	eax
	add	ecx, 20					; 00000014H
	call	?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::insert

; 60   : 	}

	add	esp, 8
	ret	4
?touch@FAutoArchive@@QAEXAAVFAutoVariableBase@@@Z ENDP	; FAutoArchive::touch
_TEXT	ENDS
PUBLIC	?set@?$FAutoVariable@HVCvUnit@@@@QAEXABH@Z	; FAutoVariable<int,CvUnit>::set
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ?set@?$FAutoVariable@HVCvUnit@@@@QAEXABH@Z
_TEXT	SEGMENT
$T243465 = -8						; size = 8
$T243464 = 8						; size = 4
_source$ = 8						; size = 4
?set@?$FAutoVariable@HVCvUnit@@@@QAEXABH@Z PROC		; FAutoVariable<int,CvUnit>::set, COMDAT
; _this$ = ecx

; 225  : {

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 226  : 	if(m_value != source)

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR _source$[esp+12]
	cmp	eax, DWORD PTR [edi]
	je	SHORT $LN1@set

; 227  : 	{
; 228  : 		m_owner.touch(*this);

	lea	ecx, DWORD PTR $T243464[esp+12]
	push	ecx
	mov	ecx, DWORD PTR [esi+8]
	lea	edx, DWORD PTR $T243465[esp+20]
	push	edx
	add	ecx, 20					; 00000014H
	mov	DWORD PTR $T243464[esp+20], esi
	call	?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::insert

; 229  : 		m_value = source;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi+4], eax
$LN1@set:
	pop	edi
	pop	esi

; 230  : 	}
; 231  : }

	add	esp, 8
	ret	4
?set@?$FAutoVariable@HVCvUnit@@@@QAEXABH@Z ENDP		; FAutoVariable<int,CvUnit>::set
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z PROC ; std::vector<int,std::allocator<int> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	esi

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	esi, DWORD PTR __Count$[esp]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	mov	eax, esi
	mov	ecx, edi
	test	esi, esi
	jbe	SHORT $LN22@Ufill
	mov	edx, DWORD PTR __Val$[esp+4]
	push	ebx
$LL17@Ufill:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebx
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL17@Ufill
	pop	ebx
$LN22@Ufill:

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*4]
	pop	edi
	pop	esi

; 1256 : 		}

	ret	12					; 0000000cH
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
; Function compile flags: /Ogtpy
;	COMDAT ?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
_TEXT	SEGMENT
__Capacity$ = -4					; size = 4
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Tmp$215407 = 16					; size = 4
__Tmp$215397 = 16					; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z PROC ; std::vector<int,std::allocator<int> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ecx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	test	edx, edx
	jne	SHORT $LN29@Insert_n
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n
$LN29@Insert_n:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 2
	mov	ecx, eax
$LN30@Insert_n:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[esp+8]
	test	edi, edi
	je	$LN1@Insert_n
	push	ebx

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	eax, ebx
	sub	eax, edx
	sar	eax, 2
	mov	edx, 1073741823				; 3fffffffH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
$LN64@Insert_n:
$LN12@Insert_n:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	push	ebp
	cmp	ecx, edx
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 1073741823				; 3fffffffH
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR __Capacity$[esp+20], 0
	mov	ecx, DWORD PTR __Capacity$[esp+20]
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[esp+20], ecx
$LN18@Insert_n:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[esp+20], edx
	mov	ecx, edx
$LN9@Insert_n:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebx, DWORD PTR __Where$[esp+24]
	sub	ebx, DWORD PTR [esi+4]
	add	esp, 8
	mov	ebp, eax

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Val$[esp+16]
	push	eax
	sar	ebx, 2
	push	edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	mov	ecx, esi
	call	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Where$[esp+16]
	mov	eax, DWORD PTR [esi+4]
	push	ebp
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR __Where$[esp+16]
	add	ebx, edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);
; 1191 : 			_RERAISE;
; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 2
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN57@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN57@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[esp+20]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [ebp+edi*4]
	lea	eax, DWORD PTR [ebp+edx*4]

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], ebp
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], ecx
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	eax, DWORD PTR __Where$[esp+16]

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[esp+16]
	mov	edx, ebx
	sub	edx, eax
	sar	edx, 2
	cmp	edx, edi
	mov	edx, DWORD PTR [ecx]

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	ebp, DWORD PTR [edi*4]
	mov	DWORD PTR __Tmp$215397[esp+16], edx
	jae	SHORT $LN3@Insert_n
	lea	ecx, DWORD PTR [eax+ebp]
	push	ecx
	push	ebx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$215397[esp+16]
	sar	ecx, 2
	push	edx
	sub	edi, ecx
	push	edi
	push	eax
	mov	ecx, esi
	call	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	add	DWORD PTR [esi+8], ebp
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	eax, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$215397[esp+16]
	push	edx
	sub	esi, ebp
	push	esi
	push	eax
	call	??$fill@PAHH@std@@YAXPAH0ABH@Z		; std::fill<int *,int>
	add	esp, 12					; 0000000cH
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN3@Insert_n:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence
; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	push	ebx
	mov	edi, ebx
	push	ebx
	sub	edi, ebp
	push	edi
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	push	ebx
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Where$[esp+20]
	push	edi
	push	eax
	call	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[esp+28]
	lea	ecx, DWORD PTR __Tmp$215407[esp+28]
	push	ecx
	add	ebp, eax
	push	ebp
	push	eax
	call	??$fill@PAHH@std@@YAXPAH0ABH@Z		; std::fill<int *,int>
	add	esp, 24					; 00000018H
	pop	ebp
	pop	ebx
$LN1@Insert_n:
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN63@Insert_n:
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Insert_n
_TEXT	ENDS
PUBLIC	??_7CvAIOperation@@6B@				; CvAIOperation::`vftable'
PUBLIC	??0CvAIOperation@@QAE@XZ			; CvAIOperation::CvAIOperation
PUBLIC	??_R4CvAIOperation@@6B@				; CvAIOperation::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvAIOperation@@@8			; CvAIOperation `RTTI Type Descriptor'
PUBLIC	??_R3CvAIOperation@@8				; CvAIOperation::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvAIOperation@@8				; CvAIOperation::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvAIOperation@@8			; CvAIOperation::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?Uninit@CvAIOperation@@UAEXXZ			; CvAIOperation::Uninit
PUBLIC	?GetOperationType@CvAIOperation@@UBEHXZ		; CvAIOperation::GetOperationType
PUBLIC	?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ ; CvAIOperation::CanTacticalAIInterruptOperation
PUBLIC	?NeedToCheckPathToTarget@CvAIOperation@@UBE_NXZ	; CvAIOperation::NeedToCheckPathToTarget
PUBLIC	?GetFormation@CvAIOperation@@UBE?AW4MultiunitFormationTypes@@XZ ; CvAIOperation::GetFormation
PUBLIC	?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ ; CvAIOperation::GetMoveType
PUBLIC	?IsAllNavalOperation@CvAIOperation@@UBE_NXZ	; CvAIOperation::IsAllNavalOperation
PUBLIC	?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ ; CvAIOperation::IsMixedLandNavalOperation
PUBLIC	?ShouldAbort@CvAIOperation@@UAE_NXZ		; CvAIOperation::ShouldAbort
PUBLIC	?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ ; CvAIOperation::BuildListOfUnitsWeStillNeedToBuild
PUBLIC	?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z ; CvAIOperation::CommitToBuildNextUnit
PUBLIC	?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z ; CvAIOperation::UncommitToBuild
PUBLIC	?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z ; CvAIOperation::FinishedBuilding
PUBLIC	?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z ; CvAIOperation::GrabUnitsFromTheReserves
PUBLIC	?UnitWasRemoved@CvAIOperation@@UAEXHH@Z		; CvAIOperation::UnitWasRemoved
PUBLIC	?Read@CvAIOperation@@UAEXAAVFDataStream@@@Z	; CvAIOperation::Read
PUBLIC	?GetOperationName@CvAIOperation@@MBE?AVCvString@@XZ ; CvAIOperation::GetOperationName
PUBLIC	?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z ; CvAIOperation::FindBestFitReserveUnit
EXTRN	??_ECvAIOperation@@UAEPAXI@Z:PROC		; CvAIOperation::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvAIOperation@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R1A@?0A@EA@CvAIOperation@@8 DD FLAT:??_R0?AVCvAIOperation@@@8 ; CvAIOperation::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvAIOperation@@8
rdata$r	ENDS
;	COMDAT ??_R2CvAIOperation@@8
rdata$r	SEGMENT
??_R2CvAIOperation@@8 DD FLAT:??_R1A@?0A@EA@CvAIOperation@@8 ; CvAIOperation::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CvAIOperation@@8
rdata$r	SEGMENT
??_R3CvAIOperation@@8 DD 00H				; CvAIOperation::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CvAIOperation@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvAIOperation@@@8
_DATA	SEGMENT
??_R0?AVCvAIOperation@@@8 DD FLAT:??_7type_info@@6B@	; CvAIOperation `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvAIOperation@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvAIOperation@@6B@
rdata$r	SEGMENT
??_R4CvAIOperation@@6B@ DD 00H				; CvAIOperation::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvAIOperation@@@8
	DD	FLAT:??_R3CvAIOperation@@8
rdata$r	ENDS
;	COMDAT ??_7CvAIOperation@@6B@
CONST	SEGMENT
??_7CvAIOperation@@6B@ DD FLAT:??_R4CvAIOperation@@6B@	; CvAIOperation::`vftable'
	DD	FLAT:??_ECvAIOperation@@UAEPAXI@Z
	DD	FLAT:?Init@CvAIOperation@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAIOperation@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAIOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAIOperation@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAIOperation@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperation@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAIOperation@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAIOperation@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAIOperation@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAIOperation@@MBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAIOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CvAIOperation@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvAIOperation@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvAIOperation@@QAE@XZ$1
__ehfuncinfo$??0CvAIOperation@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0CvAIOperation@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
xdata$x	ENDS
;	COMDAT ??0CvAIOperation@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvAIOperation@@QAE@XZ PROC				; CvAIOperation::CvAIOperation, COMDAT
; _this$ = ecx

; 36   : {

	push	-1
	push	__ehhandler$??0CvAIOperation@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	xor	eax, eax
	mov	DWORD PTR [esi], OFFSET ??_7CvAIOperation@@6B@
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+24], eax
	mov	DWORD PTR [esi+28], eax
	mov	DWORD PTR [esi+32], eax
	mov	DWORD PTR [esi+40], eax
	mov	DWORD PTR [esi+44], eax
	mov	DWORD PTR [esi+48], eax
	mov	DWORD PTR [esi+72], -1

; 37   : 	Reset();

	call	?Reset@CvAIOperation@@UAEXXZ		; CvAIOperation::Reset

; 38   : }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvAIOperation@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??0CvAIOperation@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	jmp	??1?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ ; std::vector<OperationSlot,std::allocator<OperationSlot> >::~vector<OperationSlot,std::allocator<OperationSlot> >
__ehhandler$??0CvAIOperation@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvAIOperation@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvAIOperation@@QAE@XZ ENDP				; CvAIOperation::CvAIOperation
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
;	COMDAT ?GetOperationType@CvAIOperation@@UBEHXZ
_TEXT	SEGMENT
?GetOperationType@CvAIOperation@@UBEHXZ PROC		; CvAIOperation::GetOperationType, COMDAT
; _this$ = ecx

; 152  : 		return INVALID_AI_OPERATION;

	or	eax, -1

; 153  : 	}

	ret	0
?GetOperationType@CvAIOperation@@UBEHXZ ENDP		; CvAIOperation::GetOperationType
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ
_TEXT	SEGMENT
?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ PROC ; CvAIOperation::CanTacticalAIInterruptOperation, COMDAT
; _this$ = ecx

; 156  : 		return false;

	xor	al, al

; 157  : 	}

	ret	0
?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ ENDP ; CvAIOperation::CanTacticalAIInterruptOperation
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?NeedToCheckPathToTarget@CvAIOperation@@UBE_NXZ
_TEXT	SEGMENT
?NeedToCheckPathToTarget@CvAIOperation@@UBE_NXZ PROC	; CvAIOperation::NeedToCheckPathToTarget, COMDAT
; _this$ = ecx

; 160  : 		return true;

	mov	al, 1

; 161  : 	}

	ret	0
?NeedToCheckPathToTarget@CvAIOperation@@UBE_NXZ ENDP	; CvAIOperation::NeedToCheckPathToTarget
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetFormation@CvAIOperation@@UBE?AW4MultiunitFormationTypes@@XZ
_TEXT	SEGMENT
?GetFormation@CvAIOperation@@UBE?AW4MultiunitFormationTypes@@XZ PROC ; CvAIOperation::GetFormation, COMDAT
; _this$ = ecx

; 165  : 		return NO_MUFORMATION;

	or	eax, -1

; 166  : 	}

	ret	0
?GetFormation@CvAIOperation@@UBE?AW4MultiunitFormationTypes@@XZ ENDP ; CvAIOperation::GetFormation
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
_TEXT	SEGMENT
?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ PROC ; CvAIOperation::GetMoveType, COMDAT
; _this$ = ecx

; 169  : 		return m_eMoveType;

	mov	eax, DWORD PTR [ecx+84]

; 170  : 	}

	ret	0
?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ ENDP ; CvAIOperation::GetMoveType
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?IsAllNavalOperation@CvAIOperation@@UBE_NXZ
_TEXT	SEGMENT
?IsAllNavalOperation@CvAIOperation@@UBE_NXZ PROC	; CvAIOperation::IsAllNavalOperation, COMDAT
; _this$ = ecx

; 198  : 		return false;

	xor	al, al

; 199  : 	};

	ret	0
?IsAllNavalOperation@CvAIOperation@@UBE_NXZ ENDP	; CvAIOperation::IsAllNavalOperation
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ
_TEXT	SEGMENT
?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ PROC	; CvAIOperation::IsMixedLandNavalOperation, COMDAT
; _this$ = ecx

; 202  : 		return false;

	xor	al, al

; 203  : 	};

	ret	0
?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ ENDP	; CvAIOperation::IsMixedLandNavalOperation
_TEXT	ENDS
PUBLIC	??_C@_0BF@FEMMFCLK@INVALID_AI_OPERATION?$AA@	; `string'
;	COMDAT ??_C@_0BF@FEMMFCLK@INVALID_AI_OPERATION?$AA@
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BF@FEMMFCLK@INVALID_AI_OPERATION?$AA@ DB 'INVALID_AI_OPERATION', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
CONST	ENDS
;	COMDAT ?GetOperationName@CvAIOperation@@MBE?AVCvString@@XZ
_TEXT	SEGMENT
$T244108 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetOperationName@CvAIOperation@@MBE?AVCvString@@XZ PROC ; CvAIOperation::GetOperationName, COMDAT
; _this$ = ecx

; 267  : 	{

	push	ecx
	push	esi

; 268  : 		return CvString("INVALID_AI_OPERATION");

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	push	OFFSET ??_C@_0BF@FEMMFCLK@INVALID_AI_OPERATION?$AA@
	mov	ecx, esi
	mov	DWORD PTR $T244108[esp+12], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi

; 269  : 	}

	pop	ecx
	ret	4
?GetOperationName@CvAIOperation@@MBE?AVCvString@@XZ ENDP ; CvAIOperation::GetOperationName
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
_TEXT	ENDS
;	COMDAT ?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
_TEXT	SEGMENT
$T244162 = -4						; size = 4
$T244125 = -4						; size = 4
_thisOperationSlot$ = 8					; size = 12
?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z PROC ; CvAIOperation::FinishedBuilding, COMDAT
; _this$ = ecx

; 433  : {

	push	ecx
	push	esi
	push	edi
	mov	esi, ecx

; 434  : 	// find the operation in the list of committed units
; 435  : 	std::vector<OperationSlot>::iterator iter = find(m_viListOfUnitsCitiesHaveCommittedToBuild.begin(),m_viListOfUnitsCitiesHaveCommittedToBuild.end(),thisOperationSlot);

	mov	edi, DWORD PTR [esi+44]
	mov	eax, DWORD PTR [esi+40]
	lea	ecx, DWORD PTR _thisOperationSlot$[esp+8]
	push	ecx
	push	edi
	push	eax
	lea	edx, DWORD PTR $T244162[esp+24]
	push	edx
	call	??$_Find@V?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@UOperationSlot@@@std@@YA?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@0@V10@0ABUOperationSlot@@@Z ; std::_Find<std::_Vector_iterator<OperationSlot,std::allocator<OperationSlot> >,OperationSlot>
	mov	eax, DWORD PTR [eax]
	add	esp, 16					; 00000010H

; 436  : 	// if we found it
; 437  : 	if(iter != m_viListOfUnitsCitiesHaveCommittedToBuild.end())

	cmp	eax, edi
	je	$LN6@FinishedBu

; 438  : 	{
; 439  : 		// remove it from the list of committed units
; 440  : 		m_viListOfUnitsCitiesHaveCommittedToBuild.erase(iter);

	push	eax
	lea	eax, DWORD PTR $T244125[esp+16]
	push	eax
	lea	ecx, DWORD PTR [esi+36]
	call	?erase@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::erase

; 441  : 
; 442  : 		// See if our army is now complete
; 443  : 		if(m_viListOfUnitsWeStillNeedToBuild.empty() && m_eCurrentState  == AI_OPERATION_STATE_RECRUITING_UNITS)

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	jne	SHORT $LN2@FinishedBu
	cmp	DWORD PTR [esi+56], 1
	jne	SHORT $LN2@FinishedBu

; 444  : 		{
; 445  : 			m_eCurrentState = AI_OPERATION_STATE_GATHERING_FORCES;

	mov	DWORD PTR [esi+56], 2

; 446  : 
; 447  : 			for(unsigned int uiI = 0; uiI < m_viArmyIDs.size(); uiI++)

	mov	edx, DWORD PTR [esi+12]
	sub	edx, DWORD PTR [esi+8]
	xor	edi, edi
	sar	edx, 2
	test	edx, edx
	jbe	SHORT $LN2@FinishedBu
	npad	5
$LL4@FinishedBu:

; 448  : 			{
; 449  : 				CvArmyAI* pThisArmy = GET_PLAYER(m_eOwner).getArmyAI(m_viArmyIDs[uiI]);

	mov	ecx, DWORD PTR [esi+72]
	mov	eax, DWORD PTR [esi+8]
	imul	ecx, 63236				; 0000f704H
	mov	edx, DWORD PTR [eax+edi*4]
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	eax, DWORD PTR [eax+edi*4]
	push	edx
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI

; 450  : 				if(pThisArmy)

	test	eax, eax
	je	SHORT $LN3@FinishedBu

; 451  : 				{
; 452  : 					pThisArmy->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_CATCH_UP);

	push	1
	mov	ecx, eax
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState
$LN3@FinishedBu:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, DWORD PTR [esi+8]
	inc	edi
	sar	eax, 2
	cmp	edi, eax
	jb	SHORT $LL4@FinishedBu
$LN2@FinishedBu:
	pop	edi

; 453  : 				}
; 454  : 			}
; 455  : 		}
; 456  : 		return true;

	mov	al, 1
	pop	esi

; 459  : }

	pop	ecx
	ret	12					; 0000000cH
$LN6@FinishedBu:
	pop	edi

; 457  : 	}
; 458  : 	return false;

	xor	al, al
	pop	esi

; 459  : }

	pop	ecx
	ret	12					; 0000000cH
?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z ENDP ; CvAIOperation::FinishedBuilding
_TEXT	ENDS
PUBLIC	?BuyFinalUnit@CvAIOperation@@QAE_NXZ		; CvAIOperation::BuyFinalUnit
EXTRN	?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z:PROC ; CvMilitaryAI::BuyEmergencyUnit
EXTRN	?getFormationSlotEntry@CvMultiUnitFormationInfo@@QBEABVCvFormationSlotEntry@@H@Z:PROC ; CvMultiUnitFormationInfo::getFormationSlotEntry
EXTRN	?getMultiUnitFormationInfo@CvGlobals@@QAEPAVCvMultiUnitFormationInfo@@H@Z:PROC ; CvGlobals::getMultiUnitFormationInfo
EXTRN	?GetFormationIndex@CvArmyAI@@QBEHXZ:PROC	; CvArmyAI::GetFormationIndex
; Function compile flags: /Ogtpy
;	COMDAT ?BuyFinalUnit@CvAIOperation@@QAE_NXZ
_TEXT	SEGMENT
_pCity$ = -16						; size = 4
_thisSlot$224637 = -12					; size = 12
?BuyFinalUnit@CvAIOperation@@QAE_NXZ PROC		; CvAIOperation::BuyFinalUnit, COMDAT
; _this$ = ecx

; 1130 : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 1131 : 	CvCity* pCity = GetOperationStartCity();

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+52]
	push	edi
	call	edx

; 1132 : 
; 1133 : 	if(!m_viListOfUnitsWeStillNeedToBuild.empty() && pCity != NULL && pCity->getOwner() == m_eOwner)

	mov	ecx, DWORD PTR [esi+28]
	sub	ecx, DWORD PTR [esi+24]
	mov	edi, eax
	lea	ebp, DWORD PTR [esi+20]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _pCity$[esp+32], edi
	je	$LN6@BuyFinalUn
	test	edi, edi
	je	$LN6@BuyFinalUn
	mov	ecx, DWORD PTR [esi+72]
	cmp	DWORD PTR [edi+84], ecx
	jne	$LN6@BuyFinalUn

; 1134 : 	{
; 1135 : 		OperationSlot thisSlot = m_viListOfUnitsWeStillNeedToBuild.back();

	mov	eax, DWORD PTR [esi+28]

; 1136 : 		CvArmyAI* pArmy = GET_PLAYER(m_eOwner).getArmyAI(thisSlot.m_iArmyID);

	imul	ecx, 63236				; 0000f704H
	mov	edx, DWORD PTR [eax-12]
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edi, DWORD PTR [eax-4]
	sub	eax, 12					; 0000000cH
	mov	DWORD PTR _thisSlot$224637[esp+32], edx
	mov	edx, DWORD PTR [eax+4]
	push	edx
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI
	mov	ebx, eax

; 1137 : 		CvMultiUnitFormationInfo* thisFormation = GC.getMultiUnitFormationInfo(pArmy->GetFormationIndex());

	mov	ecx, ebx
	call	?GetFormationIndex@CvArmyAI@@QBEHXZ	; CvArmyAI::GetFormationIndex
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMultiUnitFormationInfo@CvGlobals@@QAEPAVCvMultiUnitFormationInfo@@H@Z ; CvGlobals::getMultiUnitFormationInfo

; 1138 : #ifdef AUI_WARNING_FIXES
; 1139 : 		if (!thisFormation)
; 1140 : 			return false;
; 1141 : #endif
; 1142 : 		const CvFormationSlotEntry& thisSlotEntry = thisFormation->getFormationSlotEntry(thisSlot.m_iSlotID);

	push	edi
	mov	ecx, eax
	call	?getFormationSlotEntry@CvMultiUnitFormationInfo@@QBEABVCvFormationSlotEntry@@H@Z ; CvMultiUnitFormationInfo::getFormationSlotEntry

; 1143 : 
; 1144 : 		CvUnit* pUnit = GET_PLAYER(m_eOwner).GetMilitaryAI()->BuyEmergencyUnit((UnitAITypes)thisSlotEntry.m_primaryUnitType, pCity);

	mov	ecx, DWORD PTR [esi+72]
	mov	edx, DWORD PTR _pCity$[esp+32]
	imul	ecx, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax]
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	push	eax
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?BuyEmergencyUnit@CvMilitaryAI@@QAEPAVCvUnit@@W4UnitAITypes@@PAVCvCity@@@Z ; CvMilitaryAI::BuyEmergencyUnit

; 1145 : 		if(pUnit != NULL)

	test	eax, eax
	je	$LN6@BuyFinalUn

; 1146 : 		{
; 1147 : 			pArmy->AddUnit(pUnit->GetID(), thisSlot.m_iSlotID);

	mov	ecx, DWORD PTR [eax+100]
	push	edi
	push	ecx
	mov	ecx, ebx
	call	?AddUnit@CvArmyAI@@QAEXHH@Z		; CvArmyAI::AddUnit

; 1148 : 			m_viListOfUnitsWeStillNeedToBuild.pop_back();

	mov	ecx, ebp
	call	?pop_back@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXXZ ; std::vector<OperationSlot,std::allocator<OperationSlot> >::pop_back

; 1149 : 			if (m_viListOfUnitsWeStillNeedToBuild.size() == 0 && m_viListOfUnitsCitiesHaveCommittedToBuild.size() == 0 && m_eCurrentState == AI_OPERATION_STATE_RECRUITING_UNITS)

	mov	ecx, DWORD PTR [ebp+8]
	sub	ecx, DWORD PTR [ebp+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	jne	SHORT $LN2@BuyFinalUn
	mov	ecx, DWORD PTR [esi+44]
	sub	ecx, DWORD PTR [esi+40]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	jne	SHORT $LN2@BuyFinalUn
	cmp	DWORD PTR [esi+56], 1
	jne	SHORT $LN2@BuyFinalUn

; 1150 : 			{
; 1151 : 				m_eCurrentState = AI_OPERATION_STATE_GATHERING_FORCES;

	mov	DWORD PTR [esi+56], 2

; 1152 : 				for(unsigned int uiI = 0; uiI < m_viArmyIDs.size(); uiI++)

	mov	edx, DWORD PTR [esi+12]
	sub	edx, DWORD PTR [esi+8]
	xor	edi, edi
	sar	edx, 2
	test	edx, edx
	jbe	SHORT $LN2@BuyFinalUn
$LL4@BuyFinalUn:

; 1153 : 				{
; 1154 : 					CvArmyAI* pThisArmy = GET_PLAYER(m_eOwner).getArmyAI(m_viArmyIDs[uiI]);

	mov	ecx, DWORD PTR [esi+72]
	mov	eax, DWORD PTR [esi+8]
	imul	ecx, 63236				; 0000f704H
	mov	edx, DWORD PTR [eax+edi*4]
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	eax, DWORD PTR [eax+edi*4]
	push	edx
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI

; 1155 : 					if(pThisArmy)

	test	eax, eax
	je	SHORT $LN3@BuyFinalUn

; 1156 : 					{
; 1157 : 						pThisArmy->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_CATCH_UP);

	push	1
	mov	ecx, eax
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState
$LN3@BuyFinalUn:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, DWORD PTR [esi+8]
	inc	edi
	sar	eax, 2
	cmp	edi, eax
	jb	SHORT $LL4@BuyFinalUn
$LN2@BuyFinalUn:
	pop	edi
	pop	esi
	pop	ebp

; 1158 : 					}
; 1159 : 				}
; 1160 : 			}
; 1161 : 			return true;

	mov	al, 1
	pop	ebx

; 1166 : }

	add	esp, 16					; 00000010H
	ret	0
$LN6@BuyFinalUn:
	pop	edi
	pop	esi
	pop	ebp

; 1162 : 		}
; 1163 : 	}
; 1164 : 
; 1165 : 	return false;

	xor	al, al
	pop	ebx

; 1166 : }

	add	esp, 16					; 00000010H
	ret	0
?BuyFinalUnit@CvAIOperation@@QAE_NXZ ENDP		; CvAIOperation::BuyFinalUnit
_TEXT	ENDS
PUBLIC	?clear@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXXZ ; std::vector<OperationSlot,std::allocator<OperationSlot> >::clear
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?clear@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T244354 = -4						; size = 4
?clear@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXXZ PROC ; std::vector<OperationSlot,std::allocator<OperationSlot> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ecx

; 1060 : 		erase(begin(), end());

	mov	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR [ecx+4]
	push	eax
	push	edx
	lea	eax, DWORD PTR $T244354[esp+12]
	push	eax
	call	?erase@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@0@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::erase

; 1061 : 		}

	pop	ecx
	ret	0
?clear@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXXZ ENDP ; std::vector<OperationSlot,std::allocator<OperationSlot> >::clear
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@IABUOperationSlot@@@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Insert_n
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@IABUOperationSlot@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@IABUOperationSlot@@@Z$2
__catchsym$?_Insert_n@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@IABUOperationSlot@@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@IABUOperationSlot@@@Z$0
__unwindtable$?_Insert_n@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@IABUOperationSlot@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@IABUOperationSlot@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@IABUOperationSlot@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@IABUOperationSlot@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@IABUOperationSlot@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@IABUOperationSlot@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@IABUOperationSlot@@@Z$5
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@IABUOperationSlot@@@Z
_TEXT	SEGMENT
__Tmp$227493 = -32					; size = 12
__Tmp$227483 = -32					; size = 12
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$244595 = 8					; size = 1
__Cat$244522 = 8					; size = 1
__Where$ = 8						; size = 4
__Newvec$227468 = 12					; size = 4
__Count$ = 12						; size = 4
tv525 = 16						; size = 4
tv515 = 16						; size = 4
$T244592 = 16						; size = 1
$T244519 = 16						; size = 1
__Val$ = 16						; size = 4
?_Insert_n@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@IABUOperationSlot@@@Z PROC ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@IABUOperationSlot@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	test	eax, eax
	jne	SHORT $LN29@Insert_n@2
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n@2
$LN29@Insert_n@2:
	mov	edx, DWORD PTR [esi+12]
	sub	edx, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	ecx, eax
$LN30@Insert_n@2:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[ebp]
	test	edi, edi
	je	$LN1@Insert_n@2

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	edx, ebx
	sub	edx, DWORD PTR [esi+4]
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	edx, 357913941				; 15555555H
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n@2

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@KAXXZ ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Xlen
$LN87@Insert_n@2:
$LN12@Insert_n@2:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	cmp	ecx, edx
	jae	$LN10@Insert_n@2

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 357913941				; 15555555H
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n@2
	mov	DWORD PTR __Capacity$[ebp], 0
	mov	ecx, DWORD PTR __Capacity$[ebp]
	jmp	SHORT $LN18@Insert_n@2
$LN17@Insert_n@2:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n@2:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n@2

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[ebp], edx
	mov	ecx, edx
$LN9@Insert_n@2:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@UOperationSlot@@@std@@YAPAUOperationSlot@@IPAU1@@Z ; std::_Allocate<OperationSlot>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR __Where$[ebp]
	sub	edx, DWORD PTR [esi+4]
	mov	ecx, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Val$[ebp]
	sar	edx, 1
	mov	ebx, edx
	add	esp, 8
	shr	ebx, 31					; 0000001fH
	add	ebx, edx
	push	eax
	lea	edx, DWORD PTR [ebx+ebx*2]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	edi
	mov	DWORD PTR __Newvec$227468[ebp], ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Ufill@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEPAUOperationSlot@@PAU3@IABU3@@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Cat$244522[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR $T244519[ebp], 0
	mov	ecx, DWORD PTR $T244519[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Newvec$227468[ebp]
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	push	esi
	push	ecx
	push	edx
	push	eax
	call	??$_Uninit_copy@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@@std@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<OperationSlot *,OperationSlot *,std::allocator<OperationSlot> >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR __Newvec$227468[ebp]
	mov	eax, DWORD PTR [esi+8]
	add	esp, 24					; 00000018H
	add	ebx, edi
	lea	ecx, DWORD PTR [ebx+ebx*2]
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	BYTE PTR $T244592[ebp], 0
	mov	edx, DWORD PTR $T244592[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$244595[ebp]
	push	edx
	push	esi
	push	ecx
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Uninit_copy@PAUOperationSlot@@PAU1@V?$allocator@UOperationSlot@@@std@@@std@@YAPAUOperationSlot@@PAU1@00AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<OperationSlot *,OperationSlot *,std::allocator<OperationSlot> >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	ebx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, ebx
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	esp, 24					; 00000018H
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	ebx, ebx
	je	SHORT $LN81@Insert_n@2

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN81@Insert_n@2:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR __Newvec$227468[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	edx, DWORD PTR [edi+edi*2]
	mov	DWORD PTR [esi+12], ecx
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [esi+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], eax

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Insert_n@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@IABUOperationSlot@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	edx, DWORD PTR __Newvec$227468[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
__catch$?_Insert_n@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@IABUOperationSlot@@@Z$2:

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN88@Insert_n@2:
$LN10@Insert_n@2:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR __Where$[ebp]
	mov	edx, ebx
	sub	edx, ecx
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, edi

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	jae	$LN3@Insert_n@2
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$227483[ebp], edx
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR __Tmp$227483[ebp+8], eax

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	eax, DWORD PTR [edi+edi*2]
	add	eax, eax
	add	eax, eax
	mov	DWORD PTR tv515[ebp], eax
	add	eax, ecx
	push	eax
	push	ebx
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR __Tmp$227483[ebp+4], edx
	call	??$_Umove@PAUOperationSlot@@@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEPAUOperationSlot@@PAU2@00@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Umove<OperationSlot *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	ebx, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR __Tmp$227483[ebp]
	push	ecx
	mov	ecx, ebx
	sub	ecx, DWORD PTR __Where$[ebp]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	sub	edi, eax
	push	edi
	push	ebx
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	?_Ufill@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEPAUOperationSlot@@PAU3@IABU3@@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR tv515[ebp]
	add	DWORD PTR [esi+8], eax
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR __Tmp$227483[ebp]
	push	ecx
	sub	esi, eax
	push	esi
	push	edx
	call	??$fill@PAUOperationSlot@@U1@@std@@YAXPAUOperationSlot@@0ABU1@@Z ; std::fill<OperationSlot *,OperationSlot>
	add	esp, 12					; 0000000cH

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN3@Insert_n@2:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+8]

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	lea	edi, DWORD PTR [edi+edi*2]
	mov	DWORD PTR __Tmp$227493[ebp+8], eax
	add	edi, edi
	push	ebx
	add	edi, edi
	mov	eax, ebx
	sub	eax, edi
	push	ebx
	mov	DWORD PTR __Tmp$227493[ebp], ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __Tmp$227493[ebp+4], edx
	mov	DWORD PTR tv525[ebp], eax
	call	??$_Umove@PAUOperationSlot@@@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEPAUOperationSlot@@PAU2@00@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Umove<OperationSlot *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	ecx, DWORD PTR tv525[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	push	ebx
	push	ecx
	push	edx
	mov	DWORD PTR [esi+8], eax
	call	??$_Unchecked_move_backward@PAUOperationSlot@@PAU1@@stdext@@YAPAUOperationSlot@@PAU1@00@Z ; stdext::_Unchecked_move_backward<OperationSlot *,OperationSlot *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$227493[ebp]
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	add	edi, eax
	push	edi
	push	eax
	call	??$fill@PAUOperationSlot@@U1@@std@@YAXPAUOperationSlot@@0ABU1@@Z ; std::fill<OperationSlot *,OperationSlot>
	add	esp, 24					; 00000018H
$LN1@Insert_n@2:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN86@Insert_n@2:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@IABUOperationSlot@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@IABUOperationSlot@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@IABUOperationSlot@@@Z ENDP ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Insert_n
PUBLIC	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0H@Z ; std::_Sort<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0H@Z
_TEXT	SEGMENT
__Mid$228088 = -8					; size = 8
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0H@Z PROC ; std::_Sort<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int>, COMDAT

; 3082 : 	{	// order [_First, _Last), using operator<

	sub	esp, 8
	push	ebx

; 3083 : 	_Diff _Count;
; 3084 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

	mov	ebx, DWORD PTR __First$[esp+8]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Last$[esp+20]
	mov	eax, edi
	sub	eax, ebx
	sar	eax, 3
	cmp	eax, 32					; 00000020H
	jle	SHORT $LN25@Sort
	mov	esi, DWORD PTR __Ideal$[esp+20]
	npad	1
$LL7@Sort:
	test	esi, esi
	jle	SHORT $LN6@Sort

; 3085 : 		{	// divide and conquer by quicksort
; 3086 : 		pair<_RanIt, _RanIt> _Mid =
; 3087 : 			std::_Unguarded_partition(_First, _Last);

	push	edi
	lea	eax, DWORD PTR __Mid$228088[esp+28]
	push	ebx
	push	eax
	call	??$_Unguarded_partition@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YA?AU?$pair@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@PAU12@@0@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ; std::_Unguarded_partition<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>

; 3088 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions
; 3089 : 
; 3090 : 		if (_Mid.first - _First < _Last - _Mid.second)

	mov	ebp, DWORD PTR __Mid$228088[esp+40]
	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	cdq
	sub	eax, edx
	sar	eax, 1
	add	esi, eax
	mov	eax, DWORD PTR __Mid$228088[esp+36]
	mov	ecx, edi
	mov	edx, eax
	sub	ecx, ebp
	sub	edx, ebx
	add	esp, 12					; 0000000cH
	and	ecx, -8					; fffffff8H
	and	edx, -8					; fffffff8H
	cmp	edx, ecx

; 3091 : 			{	// loop on second half
; 3092 : 			std::_Sort(_First, _Mid.first, _Ideal);

	push	esi
	jge	SHORT $LN5@Sort
	push	eax
	push	ebx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0H@Z ; std::_Sort<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int>

; 3093 : 			_First = _Mid.second;

	mov	ebx, ebp

; 3094 : 			}
; 3095 : 		else

	jmp	SHORT $LN26@Sort
$LN5@Sort:

; 3096 : 			{	// loop on first half
; 3097 : 			std::_Sort(_Mid.second, _Last, _Ideal);

	push	edi
	push	ebp
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0H@Z ; std::_Sort<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int>

; 3098 : 			_Last = _Mid.first;

	mov	edi, DWORD PTR __Mid$228088[esp+36]
$LN26@Sort:
	mov	eax, edi
	sub	eax, ebx
	sar	eax, 3
	add	esp, 12					; 0000000cH
	cmp	eax, 32					; 00000020H
	jg	SHORT $LL7@Sort
$LN25@Sort:

; 3106 : 		}
; 3107 : 	else if (1 < _Count)

	cmp	eax, 1
	jle	SHORT $LN19@Sort

; 3108 : 		std::_Insertion_sort(_First, _Last);	// small

	push	0
	push	edi
	push	ebx
	call	??$_Insertion_sort1@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@U12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@00@Z ; std::_Insertion_sort1<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
	add	esp, 12					; 0000000cH
$LN19@Sort:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3109 : 	}

	add	esp, 8
	ret	0
$LN6@Sort:

; 3099 : 			}
; 3100 : 		}
; 3101 : 
; 3102 : 	if (_ISORT_MAX < _Count)

	cmp	eax, 32					; 00000020H
	jle	SHORT $LN25@Sort

; 3103 : 		{	// heap sort if too many divisions
; 3104 : 		std::make_heap(_First, _Last);

	mov	eax, edi
	sub	eax, ebx
	and	eax, -8					; fffffff8H
	cmp	eax, 8
	jle	SHORT $LN10@Sort
	push	0
	push	0
	push	edi
	push	ebx
	call	??$_Make_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@HU12@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0PAH0@Z ; std::_Make_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int,CvWeightedVector<CvPlot *,1,1>::WeightedElement>
	add	esp, 16					; 00000010H
$LN10@Sort:

; 3105 : 		std::sort_heap(_First, _Last);

	push	edi
	push	ebx
	call	??$_Sort_heap@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ; std::_Sort_heap<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3109 : 	}

	add	esp, 8
	ret	0
??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0H@Z ENDP ; std::_Sort<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int>
_TEXT	ENDS
PUBLIC	??$_Unchecked_chunked_merge@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@H@stdext@@YAXPAVCvOperationSearchUnit@@0V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@HH@Z ; stdext::_Unchecked_chunked_merge<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit>,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_chunked_merge@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@H@stdext@@YAXPAVCvOperationSearchUnit@@0V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@HH@Z
_TEXT	SEGMENT
$T244657 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 20
__Chunk$ = 36						; size = 4
$T244658 = 40						; size = 4
__Count$ = 40						; size = 4
??$_Unchecked_chunked_merge@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@H@stdext@@YAXPAVCvOperationSearchUnit@@0V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@HH@Z PROC ; stdext::_Unchecked_chunked_merge<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit>,int>, COMDAT

; 5252 : 	{

	push	ecx

; 5253 : 		_STD _Chunked_merge(_First, _Last, _Dest, _Chunk, _Count, _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Count$[esp]
	mov	edx, DWORD PTR __Chunk$[esp]
	push	ebx
	xor	ebx, ebx
	mov	BYTE PTR $T244657[esp+8], bl
	mov	eax, DWORD PTR $T244657[esp+8]
	push	eax
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last$[esp+16]
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	mov	ecx, DWORD PTR __Dest$[esp+52]
	mov	DWORD PTR $T244658[esp+36], esp
	mov	DWORD PTR [eax+16], ecx
	mov	eax, DWORD PTR __First$[esp+36]
	push	edx
	push	eax
	call	??$_Chunked_merge@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@H@std@@YAXPAVCvOperationSearchUnit@@0V?$_Temp_iterator@VCvOperationSearchUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit>,int>

; 5254 : 	}

	mov	eax, DWORD PTR __Dest$[esp+44]
	add	esp, 40					; 00000028H
	cmp	eax, ebx
	je	SHORT $LN17@Unchecked_@4
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@Unchecked_@4:
	pop	ebx
	pop	ecx
	ret	0
??$_Unchecked_chunked_merge@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@H@stdext@@YAXPAVCvOperationSearchUnit@@0V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@HH@Z ENDP ; stdext::_Unchecked_chunked_merge<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit>,int>
_TEXT	ENDS
PUBLIC	??4?$FAutoVariable@HVCvUnit@@@@QAEAAHABH@Z	; FAutoVariable<int,CvUnit>::operator=
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ??4?$FAutoVariable@HVCvUnit@@@@QAEAAHABH@Z
_TEXT	SEGMENT
$T244708 = -8						; size = 8
$T244706 = 8						; size = 4
_rhs$ = 8						; size = 4
??4?$FAutoVariable@HVCvUnit@@@@QAEAAHABH@Z PROC		; FAutoVariable<int,CvUnit>::operator=, COMDAT
; _this$ = ecx

; 201  : {

	sub	esp, 8
	push	esi
	push	edi

; 202  : 	if(rhs != m_value)

	mov	edi, DWORD PTR _rhs$[esp+12]
	mov	eax, DWORD PTR [edi]
	cmp	eax, DWORD PTR [ecx+4]
	lea	esi, DWORD PTR [ecx+4]
	je	SHORT $LN9@operator@6

; 203  : 	{
; 204  : 		set(rhs);

	mov	DWORD PTR $T244706[esp+12], ecx
	mov	ecx, DWORD PTR [ecx+8]
	lea	edx, DWORD PTR $T244706[esp+12]
	push	edx
	lea	eax, DWORD PTR $T244708[esp+20]
	push	eax
	add	ecx, 20					; 00000014H
	call	?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::insert
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [esi], ecx
$LN9@operator@6:
	pop	edi

; 205  : 	}
; 206  : 	return m_value;

	mov	eax, esi
	pop	esi

; 207  : }

	add	esp, 8
	ret	4
??4?$FAutoVariable@HVCvUnit@@@@QAEAAHABH@Z ENDP		; FAutoVariable<int,CvUnit>::operator=
_TEXT	ENDS
PUBLIC	?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ; std::vector<int,std::allocator<int> >::insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z PROC ; std::vector<int,std::allocator<int> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	esi
	push	edi
	mov	edi, ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
	test	ecx, -4					; fffffffcH
	mov	ecx, DWORD PTR __Where$[esp+4]
	jne	SHORT $LN3@insert@2
	xor	esi, esi
	jmp	SHORT $LN4@insert@2
$LN3@insert@2:
	mov	esi, ecx
	sub	esi, eax
	sar	esi, 2
$LN4@insert@2:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[esp+4]
	push	edx
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ENDP ; std::vector<int,std::allocator<int> >::insert
_TEXT	ENDS
EXTRN	?deleteArmyAI@CvPlayer@@QAEXH@Z:PROC		; CvPlayer::deleteArmyAI
EXTRN	?Kill@CvArmyAI@@QAEXXZ:PROC			; CvArmyAI::Kill
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
;	COMDAT ?Uninit@CvAIOperation@@UAEXXZ
_TEXT	SEGMENT
?Uninit@CvAIOperation@@UAEXXZ PROC			; CvAIOperation::Uninit, COMDAT
; _this$ = ecx

; 67   : {

	push	ebx
	push	esi
	mov	esi, ecx

; 68   : 	if(m_eOwner != NO_PLAYER)  // hopefully if this has been init'ed this should not happen

	mov	eax, DWORD PTR [esi+72]
	push	edi
	cmp	eax, -1
	je	SHORT $LN154@Uninit

; 69   : 	{
; 70   : 		CvPlayer& thisPlayer = GET_PLAYER(m_eOwner);

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebp
	mov	ebp, eax

; 71   : 
; 72   : 		// remove the armies (which should, in turn, free up their units for other tasks)
; 73   : 		for(unsigned int uiI = 0; uiI < m_viArmyIDs.size(); uiI++)

	mov	eax, DWORD PTR [esi+12]
	sub	eax, DWORD PTR [esi+8]
	xor	ebx, ebx
	sar	eax, 2
	test	eax, eax
	jbe	SHORT $LN155@Uninit
	npad	5
$LL4@Uninit:
	mov	eax, DWORD PTR [esi+8]
	lea	edi, DWORD PTR [ebx*4]

; 74   : 		{
; 75   : 			CvArmyAI* thisArmy = thisPlayer.getArmyAI(m_viArmyIDs[uiI]);

	mov	ecx, DWORD PTR [eax+edi]
	add	eax, edi
	push	ecx
	mov	ecx, ebp
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI

; 76   : 			if(thisArmy)

	test	eax, eax
	je	SHORT $LN3@Uninit

; 77   : 			{
; 78   : 				thisArmy->Kill();

	mov	ecx, eax
	call	?Kill@CvArmyAI@@QAEXXZ			; CvArmyAI::Kill

; 79   : 				thisPlayer.deleteArmyAI(m_viArmyIDs[uiI]);

	mov	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [edi+edx]
	push	eax
	mov	ecx, ebp
	call	?deleteArmyAI@CvPlayer@@QAEXH@Z		; CvPlayer::deleteArmyAI

; 80   : 				DeleteArmyAI(m_viArmyIDs[uiI]);

	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [edi+ecx]
	push	edx
	mov	ecx, esi
	call	?DeleteArmyAI@CvAIOperation@@QAE_NH@Z	; CvAIOperation::DeleteArmyAI
$LN3@Uninit:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, DWORD PTR [esi+8]
	inc	ebx
	sar	eax, 2
	cmp	ebx, eax
	jb	SHORT $LL4@Uninit
$LN155@Uninit:
	pop	ebp
$LN154@Uninit:

; 81   : 			}
; 82   : 		}
; 83   : 	}
; 84   : 
; 85   : 	// clear out the lists
; 86   : 	m_viArmyIDs.clear();

	mov	edi, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+12]
	cmp	edi, ecx
	je	SHORT $LN32@Uninit
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	ebx, DWORD PTR [edx+edi]
	test	eax, eax
	jle	SHORT $LN57@Uninit
	push	edx
	push	ecx
	push	edx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN57@Uninit:
	mov	DWORD PTR [esi+12], ebx
$LN32@Uninit:

; 87   : 	m_viListOfUnitsWeStillNeedToBuild.clear();

	mov	ecx, DWORD PTR [esi+24]
	mov	edx, DWORD PTR [esi+28]
	cmp	ecx, edx
	je	SHORT $LN74@Uninit
	mov	eax, edx
	cmp	edx, edx
	je	SHORT $LN99@Uninit
	npad	4
$LL101@Uninit:
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edi
	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edi
	mov	edi, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edi
	add	eax, 12					; 0000000cH
	add	ecx, 12					; 0000000cH
	cmp	eax, edx
	jne	SHORT $LL101@Uninit
$LN99@Uninit:
	mov	DWORD PTR [esi+28], ecx
$LN74@Uninit:

; 88   : 	m_viListOfUnitsCitiesHaveCommittedToBuild.clear();

	mov	ecx, DWORD PTR [esi+40]
	mov	edx, DWORD PTR [esi+44]
	cmp	ecx, edx
	je	SHORT $LN118@Uninit
	mov	eax, edx
	cmp	edx, edx
	je	SHORT $LN143@Uninit
	npad	3
$LL145@Uninit:
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edi
	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edi
	mov	edi, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edi
	add	eax, 12					; 0000000cH
	add	ecx, 12					; 0000000cH
	cmp	eax, edx
	jne	SHORT $LL145@Uninit
$LN143@Uninit:
	mov	DWORD PTR [esi+44], ecx
$LN118@Uninit:

; 89   : 
; 90   : 	Reset();

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+12]
	pop	edi
	mov	ecx, esi
	pop	esi
	pop	ebx
	jmp	eax
?Uninit@CvAIOperation@@UAEXXZ ENDP			; CvAIOperation::Uninit
_TEXT	ENDS
PUBLIC	?insert@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@ABUOperationSlot@@@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?insert@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@ABUOperationSlot@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@ABUOperationSlot@@@Z PROC ; std::vector<OperationSlot,std::allocator<OperationSlot> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ebx, DWORD PTR __Where$[esp]
	push	esi
	push	edi
	mov	edi, ecx
	mov	esi, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, esi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	jne	SHORT $LN3@insert@3
	xor	esi, esi
	jmp	SHORT $LN4@insert@3
$LN3@insert@3:
	mov	ecx, ebx
	sub	ecx, esi
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
$LN4@insert@3:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	ecx, DWORD PTR __Val$[esp+8]
	push	ecx
	push	1
	push	ebx
	mov	ecx, edi
	call	?_Insert_n@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@IAEXV?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@IABUOperationSlot@@@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	edx, DWORD PTR [esi+esi*2]
	pop	edi
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	esi
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@ABUOperationSlot@@@Z ENDP ; std::vector<OperationSlot,std::allocator<OperationSlot> >::insert
_TEXT	ENDS
PUBLIC	??$sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ; std::sort<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z PROC ; std::sort<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>, COMDAT

; 3114 : 	_DEBUG_RANGE(_First, _Last);
; 3115 : 	std::_Sort(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, eax
	sub	edx, ecx
	sar	edx, 3
	push	edx
	push	eax
	push	ecx
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0H@Z ; std::_Sort<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 3116 : 	}

	ret	0
??$sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0@Z ENDP ; std::sort<CvWeightedVector<CvPlot *,1,1>::WeightedElement *>
_TEXT	ENDS
PUBLIC	??$_Buffered_merge_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0HAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z ; std::_Buffered_merge_sort<CvOperationSearchUnit *,int,CvOperationSearchUnit>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Buffered_merge_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0HAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z
_TEXT	SEGMENT
$T245621 = -8						; size = 1
$T245592 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
$T245591 = 16						; size = 1
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
??$_Buffered_merge_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0HAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z PROC ; std::_Buffered_merge_sort<CvOperationSearchUnit *,int,CvOperationSearchUnit>, COMDAT

; 3356 : 	_BidIt _Mid = _First;

	mov	eax, DWORD PTR __First$[esp-4]
	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi

; 3357 : 	for (_Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX)

	mov	edi, DWORD PTR __Count$[esp+20]
	xor	ebx, ebx
	cmp	edi, 32					; 00000020H
	jl	SHORT $LN4@Buffered_m@2
	mov	ebp, edi
	shr	ebp, 5
	npad	5
$LL6@Buffered_m@2:

; 3358 : 		{	// sort chunks
; 3359 : 		_BidIt _Midend = _Mid;
; 3360 : 		std::advance(_Midend, (int)_ISORT_MAX);

	lea	esi, DWORD PTR [eax+256]

; 3361 : 
; 3362 : 		std::_Insertion_sort(_Mid, _Midend);

	push	ebx
	push	esi
	push	eax
	call	??$_Insertion_sort1@PAVCvOperationSearchUnit@@V1@@std@@YAXPAVCvOperationSearchUnit@@00@Z ; std::_Insertion_sort1<CvOperationSearchUnit *,CvOperationSearchUnit>
	add	esp, 12					; 0000000cH
	sub	ebp, 1

; 3363 : 		_Mid = _Midend;

	mov	eax, esi
	jne	SHORT $LL6@Buffered_m@2
$LN4@Buffered_m@2:

; 3364 : 		}
; 3365 : 	std::_Insertion_sort(_Mid, _Last);	// sort partial last chunk

	mov	ecx, DWORD PTR __Last$[esp+20]
	push	ebx
	push	ecx
	push	eax
	call	??$_Insertion_sort1@PAVCvOperationSearchUnit@@V1@@std@@YAXPAVCvOperationSearchUnit@@00@Z ; std::_Insertion_sort1<CvOperationSearchUnit *,CvOperationSearchUnit>

; 3366 : 
; 3367 : 	for (_Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2)

	mov	esi, 32					; 00000020H
	add	esp, 12					; 0000000cH
	cmp	edi, esi
	jle	SHORT $LN1@Buffered_m@2
	mov	ebp, DWORD PTR __Tempbuf$[esp+20]
$LL3@Buffered_m@2:

; 3368 : 		{	// merge adjacent pairs of chunks to and from temp buffer
; 3369 : 		_STDEXT _Unchecked_chunked_merge(_First, _Last, _Tempbuf._Init(),
; 3370 : 			_Chunk, _Count);

	mov	eax, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR __First$[esp+20]
	mov	BYTE PTR $T245591[esp+20], bl
	mov	eax, DWORD PTR $T245591[esp+20]
	push	eax
	push	edi
	push	esi
	sub	esp, 20					; 00000014H
	mov	eax, esp
	mov	DWORD PTR [eax+16], ecx
	mov	ecx, DWORD PTR __Last$[esp+52]
	mov	DWORD PTR $T245592[esp+56], esp
	push	ecx
	push	edx
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ebx
	mov	DWORD PTR [eax+12], ebx
	call	??$_Chunked_merge@PAVCvOperationSearchUnit@@V?$_Temp_iterator@VCvOperationSearchUnit@@@std@@H@std@@YAXPAVCvOperationSearchUnit@@0V?$_Temp_iterator@VCvOperationSearchUnit@@@0@HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvOperationSearchUnit *,std::_Temp_iterator<CvOperationSearchUnit>,int>

; 3371 : 		_STDEXT _Unchecked_chunked_merge(_Tempbuf._First(), _Tempbuf._Last(), _First,
; 3372 : 			_Chunk *= 2, _Count);

	mov	eax, DWORD PTR [ebp+16]
	mov	edx, DWORD PTR __First$[esp+60]
	mov	BYTE PTR $T245621[esp+64], bl
	mov	ecx, DWORD PTR $T245621[esp+64]
	push	ecx
	mov	ecx, DWORD PTR [eax+4]
	push	edi
	add	esi, esi
	push	esi
	push	edx
	mov	edx, DWORD PTR [eax]
	push	ecx
	push	edx
	call	??$_Chunked_merge@PAVCvOperationSearchUnit@@PAV1@H@std@@YAXPAVCvOperationSearchUnit@@00HHU_Range_checked_iterator_tag@0@@Z ; std::_Chunked_merge<CvOperationSearchUnit *,CvOperationSearchUnit *,int>
	add	esi, esi
	add	esp, 64					; 00000040H
	cmp	esi, edi
	jl	SHORT $LL3@Buffered_m@2
$LN1@Buffered_m@2:

; 3373 : 		}
; 3374 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	0
??$_Buffered_merge_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0HAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z ENDP ; std::_Buffered_merge_sort<CvOperationSearchUnit *,int,CvOperationSearchUnit>
_TEXT	ENDS
PUBLIC	?SetDeployFromOperationTurn@CvUnit@@QAEXH@Z	; CvUnit::SetDeployFromOperationTurn
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunit.h
;	COMDAT ?SetDeployFromOperationTurn@CvUnit@@QAEXH@Z
_TEXT	SEGMENT
$T245655 = -8						; size = 8
$T245654 = 8						; size = 4
_iTurn$ = 8						; size = 4
?SetDeployFromOperationTurn@CvUnit@@QAEXH@Z PROC	; CvUnit::SetDeployFromOperationTurn, COMDAT
; _this$ = ecx

; 700  : 	{

	sub	esp, 8
	push	esi
	push	edi

; 701  : 		m_iDeployFromOperationTurn = iTurn;

	mov	edi, DWORD PTR _iTurn$[esp+12]
	cmp	edi, DWORD PTR [ecx+124]
	lea	esi, DWORD PTR [ecx+120]
	je	SHORT $LN6@SetDeployF
	lea	eax, DWORD PTR $T245654[esp+12]
	push	eax
	lea	ecx, DWORD PTR $T245655[esp+20]
	push	ecx
	mov	ecx, DWORD PTR [esi+8]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR $T245654[esp+20], esi
	call	?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::insert
	mov	DWORD PTR [esi+4], edi
$LN6@SetDeployF:
	pop	edi
	pop	esi

; 702  : 	};

	add	esp, 8
	ret	4
?SetDeployFromOperationTurn@CvUnit@@QAEXH@Z ENDP	; CvUnit::SetDeployFromOperationTurn
_TEXT	ENDS
PUBLIC	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z PROC ; std::vector<int,std::allocator<int> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	esi

; 810  : 		if (size() < capacity())

	mov	esi, DWORD PTR [ecx+4]
	push	edi
	test	esi, esi
	jne	SHORT $LN9@push_back@5
	xor	eax, eax
	jmp	SHORT $LN10@push_back@5
$LN9@push_back@5:
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, esi
	sar	eax, 2
$LN10@push_back@5:
	mov	edx, DWORD PTR [ecx+8]
	mov	edi, edx
	sub	edi, esi
	sar	edi, 2
	cmp	edi, eax

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR __Val$[esp+4]
	pop	edi
	pop	esi
	jae	SHORT $LN2@push_back@5
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	add	edx, 4
	mov	DWORD PTR [ecx+8], edx

; 824  : 		}

	ret	4
$LN2@push_back@5:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	push	eax
	push	1
	push	edx
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n

; 824  : 		}

	ret	4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::vector<int,std::allocator<int> >::push_back
_TEXT	ENDS
PUBLIC	??1CvAIOperation@@UAE@XZ			; CvAIOperation::~CvAIOperation
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??1CvAIOperation@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvAIOperation@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvAIOperation@@UAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvAIOperation@@UAE@XZ$2
__ehfuncinfo$??1CvAIOperation@@UAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??1CvAIOperation@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
xdata$x	ENDS
;	COMDAT ??1CvAIOperation@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvAIOperation@@UAE@XZ PROC				; CvAIOperation::~CvAIOperation, COMDAT
; _this$ = ecx

; 42   : {

	push	-1
	push	__ehhandler$??1CvAIOperation@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+24], esi
	mov	DWORD PTR [esi], OFFSET ??_7CvAIOperation@@6B@
	mov	DWORD PTR __$EHRec$[esp+32], 2

; 43   : 	Uninit();

	call	?Uninit@CvAIOperation@@UAEXXZ		; CvAIOperation::Uninit

; 44   : }

	mov	eax, DWORD PTR [esi+40]
	xor	edi, edi
	cmp	eax, edi
	je	SHORT $LN11@CvAIOperat
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN11@CvAIOperat:
	mov	DWORD PTR [esi+40], edi
	mov	DWORD PTR [esi+44], edi
	mov	DWORD PTR [esi+48], edi
	mov	eax, DWORD PTR [esi+24]
	cmp	eax, edi
	je	SHORT $LN18@CvAIOperat
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN18@CvAIOperat:
	mov	DWORD PTR [esi+24], edi
	mov	DWORD PTR [esi+28], edi
	mov	DWORD PTR [esi+32], edi
	mov	eax, DWORD PTR [esi+8]
	cmp	eax, edi
	je	SHORT $LN25@CvAIOperat
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN25@CvAIOperat:
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [esi+16], edi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvAIOperation@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??1CvAIOperation@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	jmp	??1?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ ; std::vector<OperationSlot,std::allocator<OperationSlot> >::~vector<OperationSlot,std::allocator<OperationSlot> >
__unwindfunclet$??1CvAIOperation@@UAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ ; std::vector<OperationSlot,std::allocator<OperationSlot> >::~vector<OperationSlot,std::allocator<OperationSlot> >
__ehhandler$??1CvAIOperation@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvAIOperation@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvAIOperation@@UAE@XZ ENDP				; CvAIOperation::~CvAIOperation
EXTRN	?GetNextUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ:PROC ; CvArmyAI::GetNextUnit
EXTRN	?GetFirstUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ:PROC ; CvArmyAI::GetFirstUnit
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?ShouldAbort@CvAIOperation@@UAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ShouldAbort@CvAIOperation@@UAE_NXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ShouldAbort@CvAIOperation@@UAE_NXZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$?ShouldAbort@CvAIOperation@@UAE_NXZ$2
__ehfuncinfo$?ShouldAbort@CvAIOperation@@UAE_NXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?ShouldAbort@CvAIOperation@@UAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
xdata$x	ENDS
;	COMDAT ?ShouldAbort@CvAIOperation@@UAE_NXZ
_TEXT	SEGMENT
_uiI$224419 = -60					; size = 4
$T246078 = -56						; size = 4
_pArmy$224423 = -52					; size = 4
_pUnit$ = -48						; size = 8
$T245983 = -40						; size = 8
$T245984 = -32						; size = 8
$T246079 = -24						; size = 8
__$EHRec$ = -12						; size = 12
?ShouldAbort@CvAIOperation@@UAE_NXZ PROC		; CvAIOperation::ShouldAbort, COMDAT
; _this$ = ecx

; 811  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	-1
	push	__ehhandler$?ShouldAbort@CvAIOperation@@UAE_NXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 52					; 00000034H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 812  : 	UnitHandle pUnit;

	xor	edi, edi
	mov	ebx, ecx
	xor	ebp, ebp
	mov	DWORD PTR _pUnit$[esp+80], edi
	mov	BYTE PTR _pUnit$[esp+84], 0

; 813  : 
; 814  : 	// Mark units in successful operation
; 815  : 	if(m_eCurrentState == AI_OPERATION_STATE_SUCCESSFUL_FINISH)

	cmp	DWORD PTR [ebx+56], 5
	mov	DWORD PTR __$EHRec$[esp+88], ebp
	jne	$LN3@ShouldAbor

; 816  : 	{
; 817  : 		for(unsigned int uiI = 0; uiI < m_viArmyIDs.size(); uiI++)

	mov	eax, DWORD PTR [ebx+12]
	sub	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR _uiI$224419[esp+80], ebp
	sar	eax, 2
	test	eax, eax
	jbe	$LN3@ShouldAbor
$LL5@ShouldAbor:
	mov	ecx, DWORD PTR [ebx+8]

; 818  : 		{
; 819  : 			CvArmyAI* pArmy = GET_PLAYER(m_eOwner).getArmyAI(m_viArmyIDs[uiI]);

	mov	edx, DWORD PTR [ecx+ebp*4]
	lea	eax, DWORD PTR [ecx+ebp*4]
	mov	ecx, DWORD PTR [ebx+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI

; 820  : 
; 821  : 			pUnit = pArmy->GetFirstUnit();

	lea	ecx, DWORD PTR $T245983[esp+80]
	push	ecx
	mov	ecx, eax
	mov	DWORD PTR _pArmy$224423[esp+84], eax
	call	?GetFirstUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ ; CvArmyAI::GetFirstUnit
	mov	esi, eax
	lea	edx, DWORD PTR _pUnit$[esp+80]
	mov	BYTE PTR __$EHRec$[esp+88], 1
	cmp	esi, edx
	je	SHORT $LN29@ShouldAbor
	test	edi, edi
	je	SHORT $LN27@ShouldAbor
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN27@ShouldAbor:
	mov	edi, DWORD PTR [esi]
	mov	DWORD PTR _pUnit$[esp+80], edi
	test	edi, edi
	je	SHORT $LN29@ShouldAbor
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN29@ShouldAbor:
	mov	ecx, DWORD PTR $T245983[esp+80]
	mov	BYTE PTR __$EHRec$[esp+88], 0
	test	ecx, ecx
	je	SHORT $LN72@ShouldAbor
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN72@ShouldAbor:

; 822  : 			while(pUnit)

	test	edi, edi
	je	$LN4@ShouldAbor
	npad	9
$LL2@ShouldAbor:

; 823  : 			{
; 824  : 				pUnit->SetDeployFromOperationTurn(GC.getGame().getGameTurn());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	mov	ebp, eax
	cmp	ebp, DWORD PTR [edi+124]
	lea	esi, DWORD PTR [edi+120]
	je	SHORT $LN47@ShouldAbor
	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR $T246078[esp+80]
	push	ecx
	lea	edx, DWORD PTR $T246079[esp+84]
	push	edx
	lea	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR $T246078[esp+88], esi
	call	?insert@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tset_traits@PAVFAutoVariableBase@@U?$less@PAVFAutoVariableBase@@@std@@V?$allocator@PAVFAutoVariableBase@@@3@$0A@@std@@@std@@_N@2@ABQAVFAutoVariableBase@@@Z ; std::_Tree<std::_Tset_traits<FAutoVariableBase *,std::less<FAutoVariableBase *>,std::allocator<FAutoVariableBase *>,0> >::insert
	mov	DWORD PTR [esi+4], ebp
$LN47@ShouldAbor:

; 825  : 				pUnit = pArmy->GetNextUnit();

	mov	ecx, DWORD PTR _pArmy$224423[esp+80]
	lea	eax, DWORD PTR $T245984[esp+80]
	push	eax
	call	?GetNextUnit@CvArmyAI@@QAE?AV?$FObjectHandle@VCvUnit@@@@XZ ; CvArmyAI::GetNextUnit
	mov	esi, eax
	lea	ecx, DWORD PTR _pUnit$[esp+80]
	mov	BYTE PTR __$EHRec$[esp+88], 2
	cmp	esi, ecx
	je	SHORT $LN59@ShouldAbor
	test	edi, edi
	je	SHORT $LN57@ShouldAbor
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN57@ShouldAbor:
	mov	edi, DWORD PTR [esi]
	mov	DWORD PTR _pUnit$[esp+80], edi
	test	edi, edi
	je	SHORT $LN59@ShouldAbor
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN59@ShouldAbor:
	mov	ecx, DWORD PTR $T245984[esp+80]
	mov	BYTE PTR __$EHRec$[esp+88], 0
	test	ecx, ecx
	je	SHORT $LN64@ShouldAbor
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN64@ShouldAbor:

; 822  : 			while(pUnit)

	test	edi, edi
	jne	SHORT $LL2@ShouldAbor
	mov	ebp, DWORD PTR _uiI$224419[esp+80]
$LN4@ShouldAbor:

; 816  : 	{
; 817  : 		for(unsigned int uiI = 0; uiI < m_viArmyIDs.size(); uiI++)

	mov	edx, DWORD PTR [ebx+12]
	sub	edx, DWORD PTR [ebx+8]
	inc	ebp
	sar	edx, 2
	mov	DWORD PTR _uiI$224419[esp+80], ebp
	cmp	ebp, edx
	jb	$LL5@ShouldAbor
$LN3@ShouldAbor:

; 826  : 			}
; 827  : 		}
; 828  : 	}
; 829  : 
; 830  : 	return (m_eCurrentState == AI_OPERATION_STATE_ABORTED || m_eCurrentState == AI_OPERATION_STATE_SUCCESSFUL_FINISH);

	mov	eax, DWORD PTR [ebx+56]
	test	eax, eax
	je	SHORT $LN9@ShouldAbor
	cmp	eax, 5
	je	SHORT $LN9@ShouldAbor
	xor	bl, bl
	jmp	SHORT $LN10@ShouldAbor
$LN9@ShouldAbor:
	mov	bl, 1
$LN10@ShouldAbor:
	mov	DWORD PTR __$EHRec$[esp+88], -1
	test	edi, edi
	je	SHORT $LN74@ShouldAbor
	mov	ecx, edi
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN74@ShouldAbor:

; 831  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+80]
	pop	edi
	mov	al, bl
	mov	DWORD PTR fs:0, ecx
	pop	esi
	pop	ebp
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ShouldAbort@CvAIOperation@@UAE_NXZ$0:
	lea	ecx, DWORD PTR _pUnit$[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ShouldAbort@CvAIOperation@@UAE_NXZ$1:
	lea	ecx, DWORD PTR $T245983[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__unwindfunclet$?ShouldAbort@CvAIOperation@@UAE_NXZ$2:
	lea	ecx, DWORD PTR $T245984[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?ShouldAbort@CvAIOperation@@UAE_NXZ:
	mov	eax, OFFSET __ehfuncinfo$?ShouldAbort@CvAIOperation@@UAE_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ShouldAbort@CvAIOperation@@UAE_NXZ ENDP		; CvAIOperation::ShouldAbort
PUBLIC	??_7CvAIEnemyTerritoryOperation@@6B@		; CvAIEnemyTerritoryOperation::`vftable'
PUBLIC	??0CvAIEnemyTerritoryOperation@@QAE@XZ		; CvAIEnemyTerritoryOperation::CvAIEnemyTerritoryOperation
PUBLIC	??_R4CvAIEnemyTerritoryOperation@@6B@		; CvAIEnemyTerritoryOperation::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvAIEnemyTerritoryOperation@@@8		; CvAIEnemyTerritoryOperation `RTTI Type Descriptor'
PUBLIC	??_R3CvAIEnemyTerritoryOperation@@8		; CvAIEnemyTerritoryOperation::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvAIEnemyTerritoryOperation@@8		; CvAIEnemyTerritoryOperation::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvAIEnemyTerritoryOperation@@8	; CvAIEnemyTerritoryOperation::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?Init@CvAIEnemyTerritoryOperation@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ; CvAIEnemyTerritoryOperation::Init
EXTRN	??_ECvAIEnemyTerritoryOperation@@UAEPAXI@Z:PROC	; CvAIEnemyTerritoryOperation::`vector deleting destructor'
EXTRN	__purecall:PROC
;	COMDAT ??_R1A@?0A@EA@CvAIEnemyTerritoryOperation@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvAIEnemyTerritoryOperation@@8 DD FLAT:??_R0?AVCvAIEnemyTerritoryOperation@@@8 ; CvAIEnemyTerritoryOperation::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvAIEnemyTerritoryOperation@@8
rdata$r	ENDS
;	COMDAT ??_R2CvAIEnemyTerritoryOperation@@8
rdata$r	SEGMENT
??_R2CvAIEnemyTerritoryOperation@@8 DD FLAT:??_R1A@?0A@EA@CvAIEnemyTerritoryOperation@@8 ; CvAIEnemyTerritoryOperation::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvAIOperation@@8
rdata$r	ENDS
;	COMDAT ??_R3CvAIEnemyTerritoryOperation@@8
rdata$r	SEGMENT
??_R3CvAIEnemyTerritoryOperation@@8 DD 00H		; CvAIEnemyTerritoryOperation::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvAIEnemyTerritoryOperation@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvAIEnemyTerritoryOperation@@@8
_DATA	SEGMENT
??_R0?AVCvAIEnemyTerritoryOperation@@@8 DD FLAT:??_7type_info@@6B@ ; CvAIEnemyTerritoryOperation `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvAIEnemyTerritoryOperation@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvAIEnemyTerritoryOperation@@6B@
rdata$r	SEGMENT
??_R4CvAIEnemyTerritoryOperation@@6B@ DD 00H		; CvAIEnemyTerritoryOperation::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvAIEnemyTerritoryOperation@@@8
	DD	FLAT:??_R3CvAIEnemyTerritoryOperation@@8
rdata$r	ENDS
;	COMDAT ??_7CvAIEnemyTerritoryOperation@@6B@
CONST	SEGMENT
??_7CvAIEnemyTerritoryOperation@@6B@ DD FLAT:??_R4CvAIEnemyTerritoryOperation@@6B@ ; CvAIEnemyTerritoryOperation::`vftable'
	DD	FLAT:??_ECvAIEnemyTerritoryOperation@@UAEPAXI@Z
	DD	FLAT:?Init@CvAIEnemyTerritoryOperation@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAIOperation@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAIEnemyTerritoryOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAIOperation@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAIOperation@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperation@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAIOperation@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAIOperation@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAIOperation@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAIOperation@@MBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAIEnemyTerritoryOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	DD	FLAT:?GetDeployRange@CvAIEnemyTerritoryOperation@@UBEHXZ
	DD	FLAT:__purecall
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvAIEnemyTerritoryOperation@@QAE@XZ
_TEXT	SEGMENT
??0CvAIEnemyTerritoryOperation@@QAE@XZ PROC		; CvAIEnemyTerritoryOperation::CvAIEnemyTerritoryOperation, COMDAT
; _this$ = ecx

; 1903 : {

	push	esi
	mov	esi, ecx
	call	??0CvAIOperation@@QAE@XZ		; CvAIOperation::CvAIOperation
	mov	DWORD PTR [esi], OFFSET ??_7CvAIEnemyTerritoryOperation@@6B@

; 1904 : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvAIEnemyTerritoryOperation@@QAE@XZ ENDP		; CvAIEnemyTerritoryOperation::CvAIEnemyTerritoryOperation
_TEXT	ENDS
PUBLIC	??1CvAIEnemyTerritoryOperation@@UAE@XZ		; CvAIEnemyTerritoryOperation::~CvAIEnemyTerritoryOperation
; Function compile flags: /Ogtpy
;	COMDAT ??1CvAIEnemyTerritoryOperation@@UAE@XZ
_TEXT	SEGMENT
??1CvAIEnemyTerritoryOperation@@UAE@XZ PROC		; CvAIEnemyTerritoryOperation::~CvAIEnemyTerritoryOperation, COMDAT
; _this$ = ecx

; 1907 : {

	mov	DWORD PTR [ecx], OFFSET ??_7CvAIEnemyTerritoryOperation@@6B@

; 1908 : }

	jmp	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
??1CvAIEnemyTerritoryOperation@@UAE@XZ ENDP		; CvAIEnemyTerritoryOperation::~CvAIEnemyTerritoryOperation
_TEXT	ENDS
EXTRN	?SetXY@CvArmyAI@@QAEXHH@Z:PROC			; CvArmyAI::SetXY
EXTRN	?SetFormationIndex@CvArmyAI@@QAEXH@Z:PROC	; CvArmyAI::SetFormationIndex
EXTRN	?Init@CvArmyAI@@QAEXHW4PlayerTypes@@H@Z:PROC	; CvArmyAI::Init
EXTRN	?addArmyAI@CvPlayer@@QAEPAVCvArmyAI@@XZ:PROC	; CvPlayer::addArmyAI
; Function compile flags: /Ogtpy
;	COMDAT ?Init@CvAIEnemyTerritoryOperation@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
_TEXT	SEGMENT
$T246189 = 8						; size = 4
$T246143 = 8						; size = 4
_iID$ = 8						; size = 4
_eOwner$ = 12						; size = 4
_eEnemy$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 4
?Init@CvAIEnemyTerritoryOperation@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z PROC ; CvAIEnemyTerritoryOperation::Init, COMDAT
; _this$ = ecx

; 1918 : {

	push	esi
	mov	esi, ecx

; 1919 : 	Reset();

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+12]
	call	edx

; 1920 : 	m_eMoveType = AI_OPERATION_MOVETYPE_ENEMY_TERRITORY;
; 1921 : 	m_iID = iID;

	mov	ecx, DWORD PTR _iID$[esp]

; 1922 : 	m_eOwner = eOwner;

	mov	eax, DWORD PTR _eOwner$[esp]

; 1923 : 	m_eEnemy = eEnemy;

	mov	edx, DWORD PTR _eEnemy$[esp]
	mov	DWORD PTR [esi+84], 1
	mov	DWORD PTR [esi+52], ecx
	mov	DWORD PTR [esi+72], eax
	mov	DWORD PTR [esi+76], edx

; 1924 : 
; 1925 : 	if(iID != -1)

	cmp	ecx, -1
	je	$LN1@Init

; 1926 : 	{
; 1927 : 		// create the armies that are needed and set the state to ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE
; 1928 : 		CvPlayer& kPlayer = GET_PLAYER(m_eOwner);

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebp
	push	edi

; 1929 : 		CvArmyAI* pArmyAI = kPlayer.addArmyAI();

	mov	ecx, eax
	call	?addArmyAI@CvPlayer@@QAEPAVCvArmyAI@@XZ	; CvPlayer::addArmyAI
	mov	edi, eax

; 1930 : 		if(pArmyAI)

	xor	ebp, ebp
	cmp	edi, ebp
	je	$LN39@Init
	push	ebx

; 1931 : 		{
; 1932 : 			m_viArmyIDs.push_back(pArmyAI->GetID());

	mov	ecx, edi
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	mov	DWORD PTR $T246143[esp+12], eax
	lea	eax, DWORD PTR $T246143[esp+12]
	push	eax
	lea	ecx, DWORD PTR [esi+4]
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 1933 : 			pArmyAI->Init(pArmyAI->GetID(),m_eOwner,m_iID);

	mov	ecx, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [esi+72]
	push	ecx
	push	edx
	mov	ecx, edi
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	push	eax
	mov	ecx, edi
	call	?Init@CvArmyAI@@QAEXHW4PlayerTypes@@H@Z	; CvArmyAI::Init

; 1934 : 			pArmyAI->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE);

	push	ebp
	mov	ecx, edi
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 1935 : 			pArmyAI->SetFormationIndex(GetFormation());

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+32]
	mov	ecx, esi
	call	edx
	push	eax
	mov	ecx, edi
	call	?SetFormationIndex@CvArmyAI@@QAEXH@Z	; CvArmyAI::SetFormationIndex

; 1936 : 
; 1937 : 			// Figure out the initial rally point
; 1938 : 			CvPlot* pTargetPlot = FindBestTarget();

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+148]
	mov	ecx, esi
	call	edx
	mov	ebx, eax

; 1939 : 			if(pTargetPlot != NULL)

	cmp	ebx, ebp
	je	$LN10@Init

; 1940 : 			{
; 1941 : 				SetTargetPlot(pTargetPlot);

	movsx	eax, WORD PTR [ebx]
	mov	DWORD PTR [esi+104], eax
	movsx	ecx, WORD PTR [ebx+2]
	mov	DWORD PTR [esi+108], ecx

; 1942 : 				pArmyAI->SetGoalPlot(pTargetPlot);

	push	ebx
	mov	ecx, edi
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 1943 : 				if(SelectInitialMusterPoint(pArmyAI) != NULL)

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+136]
	push	edi
	mov	ecx, esi
	call	eax
	test	eax, eax
	je	$LN9@Init

; 1944 : 				{
; 1945 : 					pArmyAI->SetXY(GetMusterPlot()->getX(), GetMusterPlot()->getY());

	mov	ecx, esi
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	ecx, esi
	mov	ebp, eax
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	movsx	ecx, WORD PTR [eax+2]
	movsx	edx, WORD PTR [ebp]
	push	ecx
	push	edx
	mov	ecx, edi
	call	?SetXY@CvArmyAI@@QAEXHH@Z		; CvArmyAI::SetXY

; 1946 : 					SetDefaultArea(GetMusterPlot()->getArea());

	mov	ecx, esi
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	eax, DWORD PTR [eax+356]
	mov	DWORD PTR [esi+64], eax

; 1947 : 
; 1948 : 					if (GetDefaultArea() != pTargetPlot->getArea())

	cmp	eax, DWORD PTR [ebx+356]
	je	SHORT $LN8@Init

; 1949 : 					{
; 1950 : 						pArmyAI->SetGoalPlot(pTargetPlot);

	push	ebx
	mov	ecx, edi
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 1951 : 					}
; 1952 : 					else

	jmp	SHORT $LN5@Init
$LN8@Init:

; 1953 : 					{
; 1954 : 						CvPlot* pDeployPt;
; 1955 : 						pDeployPt = GC.getStepFinder().GetXPlotsFromEnd(GetOwner(), GetEnemy(), GetMusterPlot(), GetTargetPlot(), (GetDeployRange() / 2), true);

	mov	eax, DWORD PTR [esi+72]
	mov	edx, DWORD PTR [esi]
	mov	ebp, DWORD PTR [esi+76]
	mov	DWORD PTR $T246189[esp+12], eax
	mov	eax, DWORD PTR [edx+144]
	push	1
	mov	ecx, esi
	call	eax
	cdq
	sub	eax, edx
	sar	eax, 1
	push	eax
	mov	ecx, esi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	push	eax
	mov	ecx, esi
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	ecx, DWORD PTR $T246189[esp+24]
	push	eax
	push	ebp
	push	ecx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, eax
	call	?GetXPlotsFromEnd@CvStepPathFinder@@QBEPAVCvPlot@@W4PlayerTypes@@0PAV2@1H_N@Z ; CvStepPathFinder::GetXPlotsFromEnd

; 1956 : 						if (pDeployPt)

	test	eax, eax
	je	SHORT $LN6@Init

; 1957 : 						{
; 1958 : 							pArmyAI->SetGoalPlot(pDeployPt);

	push	eax
	mov	ecx, edi
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 1959 : 						}
; 1960 : 						else

	jmp	SHORT $LN5@Init
$LN6@Init:

; 1961 : 						{
; 1962 : 							// No path, abort
; 1963 : 							m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	DWORD PTR [esi+56], 0

; 1964 : 							m_eAbortReason = AI_ABORT_LOST_PATH;

	mov	DWORD PTR [esi+60], 14			; 0000000eH
$LN5@Init:

; 1965 : 						}
; 1966 : 					}
; 1967 : 
; 1968 : 					// Find the list of units we need to build before starting this operation in earnest
; 1969 : 					BuildListOfUnitsWeStillNeedToBuild();

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+92]
	mov	ecx, esi
	call	eax

; 1970 : 
; 1971 : 					// try to get as many units as possible from existing units that are waiting around
; 1972 : 					if(GrabUnitsFromTheReserves(GetMusterPlot(), pTargetPlot))

	mov	ebp, DWORD PTR [esi]
	push	ebx
	mov	ecx, esi
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	edx, DWORD PTR [ebp+112]
	push	eax
	mov	ecx, esi
	call	edx
	test	al, al
	je	SHORT $LN4@Init

; 1973 : 					{
; 1974 : 						pArmyAI->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_CATCH_UP);

	push	1
	mov	ecx, edi
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 1975 : 						m_eCurrentState = AI_OPERATION_STATE_GATHERING_FORCES;
; 1976 : 					}
; 1977 : 					else
; 1978 : 					{
; 1979 : 						m_eCurrentState = AI_OPERATION_STATE_RECRUITING_UNITS;
; 1980 : 					}
; 1981 : 
; 1982 : 					LogOperationStart();

	mov	ecx, esi
	mov	DWORD PTR [esi+56], 2
	call	?LogOperationStart@CvAIOperation@@QAEXXZ ; CvAIOperation::LogOperationStart
	pop	ebx
	pop	edi
	pop	ebp
	pop	esi

; 1997 : 			}
; 1998 : 		}
; 1999 : 	}
; 2000 : }

	ret	24					; 00000018H
$LN4@Init:

; 1975 : 						m_eCurrentState = AI_OPERATION_STATE_GATHERING_FORCES;
; 1976 : 					}
; 1977 : 					else
; 1978 : 					{
; 1979 : 						m_eCurrentState = AI_OPERATION_STATE_RECRUITING_UNITS;
; 1980 : 					}
; 1981 : 
; 1982 : 					LogOperationStart();

	mov	ecx, esi
	mov	DWORD PTR [esi+56], 1
	call	?LogOperationStart@CvAIOperation@@QAEXXZ ; CvAIOperation::LogOperationStart
	pop	ebx
	pop	edi
	pop	ebp
	pop	esi

; 1997 : 			}
; 1998 : 		}
; 1999 : 	}
; 2000 : }

	ret	24					; 00000018H
$LN9@Init:
	pop	ebx
	pop	edi

; 1983 : 				}
; 1984 : 				else
; 1985 : 				{
; 1986 : 					// No muster point, abort
; 1987 : 					m_eCurrentState = AI_OPERATION_STATE_ABORTED;
; 1988 : 					m_eAbortReason = AI_ABORT_NO_MUSTER;
; 1989 : 				}
; 1990 : 			}
; 1991 : 
; 1992 : 			else
; 1993 : 			{
; 1994 : 				// Lost our target, abort
; 1995 : 				m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	DWORD PTR [esi+56], ebp
	pop	ebp
	mov	DWORD PTR [esi+60], 7
	pop	esi

; 1997 : 			}
; 1998 : 		}
; 1999 : 	}
; 2000 : }

	ret	24					; 00000018H
$LN10@Init:

; 1996 : 				m_eAbortReason = AI_ABORT_LOST_TARGET;

	mov	DWORD PTR [esi+60], 3
	mov	DWORD PTR [esi+56], ebp
	pop	ebx
$LN39@Init:
	pop	edi
	pop	ebp
$LN1@Init:
	pop	esi

; 1997 : 			}
; 1998 : 		}
; 1999 : 	}
; 2000 : }

	ret	24					; 00000018H
?Init@CvAIEnemyTerritoryOperation@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ENDP ; CvAIEnemyTerritoryOperation::Init
_TEXT	ENDS
PUBLIC	??_7CvAIOperationBasicCityAttack@@6B@		; CvAIOperationBasicCityAttack::`vftable'
PUBLIC	??0CvAIOperationBasicCityAttack@@QAE@XZ		; CvAIOperationBasicCityAttack::CvAIOperationBasicCityAttack
PUBLIC	??_R4CvAIOperationBasicCityAttack@@6B@		; CvAIOperationBasicCityAttack::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvAIOperationBasicCityAttack@@@8	; CvAIOperationBasicCityAttack `RTTI Type Descriptor'
PUBLIC	??_R3CvAIOperationBasicCityAttack@@8		; CvAIOperationBasicCityAttack::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvAIOperationBasicCityAttack@@8		; CvAIOperationBasicCityAttack::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvAIOperationBasicCityAttack@@8	; CvAIOperationBasicCityAttack::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?Init@CvAIOperationBasicCityAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ; CvAIOperationBasicCityAttack::Init
PUBLIC	?GetOperationType@CvAIOperationBasicCityAttack@@UBEHXZ ; CvAIOperationBasicCityAttack::GetOperationType
PUBLIC	?NeedToCheckPathToTarget@CvAIOperationBasicCityAttack@@UBE_NXZ ; CvAIOperationBasicCityAttack::NeedToCheckPathToTarget
PUBLIC	?ShouldAbort@CvAIOperationBasicCityAttack@@UAE_NXZ ; CvAIOperationBasicCityAttack::ShouldAbort
PUBLIC	?Read@CvAIOperationBasicCityAttack@@UAEXAAVFDataStream@@@Z ; CvAIOperationBasicCityAttack::Read
PUBLIC	?GetOperationName@CvAIOperationBasicCityAttack@@UBE?AVCvString@@XZ ; CvAIOperationBasicCityAttack::GetOperationName
EXTRN	??_ECvAIOperationBasicCityAttack@@UAEPAXI@Z:PROC ; CvAIOperationBasicCityAttack::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvAIOperationBasicCityAttack@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvAIOperationBasicCityAttack@@8 DD FLAT:??_R0?AVCvAIOperationBasicCityAttack@@@8 ; CvAIOperationBasicCityAttack::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvAIOperationBasicCityAttack@@8
rdata$r	ENDS
;	COMDAT ??_R2CvAIOperationBasicCityAttack@@8
rdata$r	SEGMENT
??_R2CvAIOperationBasicCityAttack@@8 DD FLAT:??_R1A@?0A@EA@CvAIOperationBasicCityAttack@@8 ; CvAIOperationBasicCityAttack::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvAIEnemyTerritoryOperation@@8
	DD	FLAT:??_R1A@?0A@EA@CvAIOperation@@8
rdata$r	ENDS
;	COMDAT ??_R3CvAIOperationBasicCityAttack@@8
rdata$r	SEGMENT
??_R3CvAIOperationBasicCityAttack@@8 DD 00H		; CvAIOperationBasicCityAttack::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CvAIOperationBasicCityAttack@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvAIOperationBasicCityAttack@@@8
_DATA	SEGMENT
??_R0?AVCvAIOperationBasicCityAttack@@@8 DD FLAT:??_7type_info@@6B@ ; CvAIOperationBasicCityAttack `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvAIOperationBasicCityAttack@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvAIOperationBasicCityAttack@@6B@
rdata$r	SEGMENT
??_R4CvAIOperationBasicCityAttack@@6B@ DD 00H		; CvAIOperationBasicCityAttack::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvAIOperationBasicCityAttack@@@8
	DD	FLAT:??_R3CvAIOperationBasicCityAttack@@8
rdata$r	ENDS
;	COMDAT ??_7CvAIOperationBasicCityAttack@@6B@
CONST	SEGMENT
??_7CvAIOperationBasicCityAttack@@6B@ DD FLAT:??_R4CvAIOperationBasicCityAttack@@6B@ ; CvAIOperationBasicCityAttack::`vftable'
	DD	FLAT:??_ECvAIOperationBasicCityAttack@@UAEPAXI@Z
	DD	FLAT:?Init@CvAIOperationBasicCityAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAIOperationBasicCityAttack@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperationBasicCityAttack@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAIEnemyTerritoryOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAIOperationBasicCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAIOperation@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:?ArmyInPosition@CvAIOperationBasicCityAttack@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperationBasicCityAttack@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAIOperation@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAIOperationBasicCityAttack@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAIOperationBasicCityAttack@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAIOperationBasicCityAttack@@UBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAIEnemyTerritoryOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	DD	FLAT:?GetDeployRange@CvAIEnemyTerritoryOperation@@UBEHXZ
	DD	FLAT:?FindBestTarget@CvAIOperationBasicCityAttack@@MAEPAVCvPlot@@XZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvAIOperationBasicCityAttack@@QAE@XZ
_TEXT	SEGMENT
??0CvAIOperationBasicCityAttack@@QAE@XZ PROC		; CvAIOperationBasicCityAttack::CvAIOperationBasicCityAttack, COMDAT
; _this$ = ecx

; 2108 : {

	push	esi
	mov	esi, ecx
	call	??0CvAIOperation@@QAE@XZ		; CvAIOperation::CvAIOperation
	mov	DWORD PTR [esi], OFFSET ??_7CvAIOperationBasicCityAttack@@6B@

; 2109 : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvAIOperationBasicCityAttack@@QAE@XZ ENDP		; CvAIOperationBasicCityAttack::CvAIOperationBasicCityAttack
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
_TEXT	ENDS
;	COMDAT ?GetOperationType@CvAIOperationBasicCityAttack@@UBEHXZ
_TEXT	SEGMENT
?GetOperationType@CvAIOperationBasicCityAttack@@UBEHXZ PROC ; CvAIOperationBasicCityAttack::GetOperationType, COMDAT
; _this$ = ecx

; 348  : 		return AI_OPERATION_BASIC_CITY_ATTACK;

	mov	eax, 2

; 349  : 	}

	ret	0
?GetOperationType@CvAIOperationBasicCityAttack@@UBEHXZ ENDP ; CvAIOperationBasicCityAttack::GetOperationType
_TEXT	ENDS
PUBLIC	??_C@_0BP@FCHPOOHL@AI_OPERATION_BASIC_CITY_ATTACK?$AA@ ; `string'
;	COMDAT ??_C@_0BP@FCHPOOHL@AI_OPERATION_BASIC_CITY_ATTACK?$AA@
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BP@FCHPOOHL@AI_OPERATION_BASIC_CITY_ATTACK?$AA@ DB 'AI_OPERATION_B'
	DB	'ASIC_CITY_ATTACK', 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
CONST	ENDS
;	COMDAT ?GetOperationName@CvAIOperationBasicCityAttack@@UBE?AVCvString@@XZ
_TEXT	SEGMENT
$T246209 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetOperationName@CvAIOperationBasicCityAttack@@UBE?AVCvString@@XZ PROC ; CvAIOperationBasicCityAttack::GetOperationName, COMDAT
; _this$ = ecx

; 351  : 	{

	push	ecx
	push	esi

; 352  : 		return CvString("AI_OPERATION_BASIC_CITY_ATTACK");

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	push	OFFSET ??_C@_0BP@FCHPOOHL@AI_OPERATION_BASIC_CITY_ATTACK?$AA@
	mov	ecx, esi
	mov	DWORD PTR $T246209[esp+12], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi

; 353  : 	}

	pop	ecx
	ret	4
?GetOperationName@CvAIOperationBasicCityAttack@@UBE?AVCvString@@XZ ENDP ; CvAIOperationBasicCityAttack::GetOperationName
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?NeedToCheckPathToTarget@CvAIOperationBasicCityAttack@@UBE_NXZ
_TEXT	SEGMENT
?NeedToCheckPathToTarget@CvAIOperationBasicCityAttack@@UBE_NXZ PROC ; CvAIOperationBasicCityAttack::NeedToCheckPathToTarget, COMDAT
; _this$ = ecx

; 356  : 		return false;

	xor	al, al

; 357  : 	}

	ret	0
?NeedToCheckPathToTarget@CvAIOperationBasicCityAttack@@UBE_NXZ ENDP ; CvAIOperationBasicCityAttack::NeedToCheckPathToTarget
_TEXT	ENDS
PUBLIC	??1CvAIOperationBasicCityAttack@@UAE@XZ		; CvAIOperationBasicCityAttack::~CvAIOperationBasicCityAttack
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
;	COMDAT ??1CvAIOperationBasicCityAttack@@UAE@XZ
_TEXT	SEGMENT
??1CvAIOperationBasicCityAttack@@UAE@XZ PROC		; CvAIOperationBasicCityAttack::~CvAIOperationBasicCityAttack, COMDAT
; _this$ = ecx

; 2114 : }

	mov	DWORD PTR [ecx], OFFSET ??_7CvAIEnemyTerritoryOperation@@6B@
	jmp	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
??1CvAIOperationBasicCityAttack@@UAE@XZ ENDP		; CvAIOperationBasicCityAttack::~CvAIOperationBasicCityAttack
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Init@CvAIOperationBasicCityAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
_TEXT	SEGMENT
$T246234 = 8						; size = 4
_iID$ = 8						; size = 4
_eOwner$ = 12						; size = 4
_eEnemy$ = 16						; size = 4
___formal$ = 20						; size = 4
_pTarget$ = 24						; size = 4
_pMuster$ = 28						; size = 4
?Init@CvAIOperationBasicCityAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z PROC ; CvAIOperationBasicCityAttack::Init, COMDAT
; _this$ = ecx

; 2118 : {

	push	esi
	mov	esi, ecx

; 2119 : 	Reset();

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+12]
	push	edi
	call	edx

; 2120 : 	m_eMoveType = AI_OPERATION_MOVETYPE_ENEMY_TERRITORY;
; 2121 : 	m_iID = iID;
; 2122 : 	m_eOwner = eOwner;
; 2123 : 	m_eEnemy = eEnemy;

	mov	ecx, DWORD PTR _eEnemy$[esp+4]
	mov	eax, DWORD PTR _eOwner$[esp+4]
	mov	edi, DWORD PTR _iID$[esp+4]
	mov	DWORD PTR [esi+76], ecx

; 2124 : 	SetStartCityPlot(pMuster->plot());

	mov	ecx, DWORD PTR _pMuster$[esp+4]
	mov	DWORD PTR [esi+84], 1
	mov	DWORD PTR [esi+52], edi
	mov	DWORD PTR [esi+72], eax
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	movsx	edx, WORD PTR [eax]
	mov	DWORD PTR [esi+88], edx
	movsx	eax, WORD PTR [eax+2]
	mov	DWORD PTR [esi+92], eax

; 2125 : 
; 2126 : 	if(iID != -1)

	cmp	edi, -1
	je	$LN1@Init@2

; 2127 : 	{
; 2128 : 		// create the armies that are needed and set the state to ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE
; 2129 : 		CvPlayer& kPlayer = GET_PLAYER(m_eOwner);

	mov	ecx, DWORD PTR [esi+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 2130 : 		CvArmyAI* pArmyAI = kPlayer.addArmyAI();

	call	?addArmyAI@CvPlayer@@QAEPAVCvArmyAI@@XZ	; CvPlayer::addArmyAI
	mov	edi, eax

; 2131 : 		if(pArmyAI)

	test	edi, edi
	je	$LN1@Init@2

; 2132 : 		{
; 2133 : 			m_viArmyIDs.push_back(pArmyAI->GetID());

	mov	ecx, edi
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	lea	ecx, DWORD PTR $T246234[esp+4]
	push	ecx
	lea	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR $T246234[esp+8], eax
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 2134 : 			pArmyAI->Init(pArmyAI->GetID(),m_eOwner,m_iID);

	mov	edx, DWORD PTR [esi+52]
	mov	eax, DWORD PTR [esi+72]
	push	edx
	push	eax
	mov	ecx, edi
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	push	eax
	mov	ecx, edi
	call	?Init@CvArmyAI@@QAEXHW4PlayerTypes@@H@Z	; CvArmyAI::Init

; 2135 : 			pArmyAI->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE);

	push	0
	mov	ecx, edi
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 2136 : 			pArmyAI->SetFormationIndex(GetFormation());

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+32]
	mov	ecx, esi
	call	eax
	push	eax
	mov	ecx, edi
	call	?SetFormationIndex@CvArmyAI@@QAEXH@Z	; CvArmyAI::SetFormationIndex

; 2137 : 
; 2138 : 			if(pTarget)

	mov	ecx, DWORD PTR _pTarget$[esp+4]
	test	ecx, ecx
	je	$LN6@Init@2
	push	ebx
	push	ebp

; 2139 : 			{
; 2140 : 				SetTargetPlot(pTarget->plot());

	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR [esi+104], ecx
	movsx	edx, WORD PTR [eax+2]

; 2141 : 				pArmyAI->SetGoalPlot(GetTargetPlot());

	mov	ecx, esi
	mov	DWORD PTR [esi+108], edx
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	push	eax
	mov	ecx, edi
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 2142 : 				SetMusterPlot(GetStartCityPlot());

	mov	ecx, esi
	call	?GetStartCityPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetStartCityPlot
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR [esi+96], ecx
	movsx	edx, WORD PTR [eax+2]

; 2143 : 				pArmyAI->SetXY(GetMusterPlot()->getX(), GetMusterPlot()->getY());

	mov	ecx, esi
	mov	DWORD PTR [esi+100], edx
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	ecx, esi
	mov	ebx, eax
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	movsx	eax, WORD PTR [eax+2]
	movsx	ecx, WORD PTR [ebx]
	push	eax
	push	ecx
	mov	ecx, edi
	call	?SetXY@CvArmyAI@@QAEXHH@Z		; CvArmyAI::SetXY

; 2144 : 				SetDefaultArea(GetMusterPlot()->getArea());

	mov	ecx, esi
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	edx, DWORD PTR [eax+356]

; 2145 : 
; 2146 : 				// Reset our destination to be a few plots shy of the final target
; 2147 : 				CvPlot* pDeployPt;
; 2148 : 				pDeployPt = GC.getStepFinder().GetXPlotsFromEnd(GetOwner(), GetEnemy(), GetMusterPlot(), GetTargetPlot(), (GetDeployRange() / 2), true);

	mov	eax, DWORD PTR [esi]
	mov	ebx, DWORD PTR [esi+76]
	mov	ebp, DWORD PTR [esi+72]
	mov	DWORD PTR [esi+64], edx
	mov	edx, DWORD PTR [eax+144]
	push	1
	mov	ecx, esi
	call	edx
	cdq
	sub	eax, edx
	sar	eax, 1
	push	eax
	mov	ecx, esi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	push	eax
	mov	ecx, esi
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	push	eax
	push	ebx
	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getStepFinder@CvGlobals@@QAEAAVCvStepPathFinder@@XZ ; CvGlobals::getStepFinder
	mov	ecx, eax
	call	?GetXPlotsFromEnd@CvStepPathFinder@@QBEPAVCvPlot@@W4PlayerTypes@@0PAV2@1H_N@Z ; CvStepPathFinder::GetXPlotsFromEnd

; 2149 : 				if (pDeployPt)

	test	eax, eax
	je	SHORT $LN5@Init@2

; 2150 : 				{
; 2151 : 					pArmyAI->SetGoalPlot(pDeployPt);

	push	eax
	mov	ecx, edi
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 2152 : 
; 2153 : 					// Find the list of units we need to build before starting this operation in earnest
; 2154 : 					BuildListOfUnitsWeStillNeedToBuild();

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+92]
	mov	ecx, esi
	call	edx

; 2155 : 
; 2156 : 					// try to get as many units as possible from existing units that are waiting around
; 2157 : 					if(GrabUnitsFromTheReserves(GetMusterPlot(), GetTargetPlot()))

	mov	ebx, DWORD PTR [esi]
	mov	ecx, esi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	push	eax
	mov	ecx, esi
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	push	eax
	mov	eax, DWORD PTR [ebx+112]
	mov	ecx, esi
	call	eax
	test	al, al
	je	SHORT $LN4@Init@2

; 2158 : 					{
; 2159 : 						pArmyAI->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_CATCH_UP);

	push	1
	mov	ecx, edi
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 2160 : 						m_eCurrentState = AI_OPERATION_STATE_GATHERING_FORCES;
; 2161 : 					}
; 2162 : 					else
; 2163 : 					{
; 2164 : 						m_eCurrentState = AI_OPERATION_STATE_RECRUITING_UNITS;
; 2165 : 					}
; 2166 : 
; 2167 : 					LogOperationStart();

	mov	ecx, esi
	mov	DWORD PTR [esi+56], 2
	call	?LogOperationStart@CvAIOperation@@QAEXXZ ; CvAIOperation::LogOperationStart
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi

; 2181 : 			}
; 2182 : 		}
; 2183 : 	}
; 2184 : }

	ret	24					; 00000018H
$LN4@Init@2:

; 2160 : 						m_eCurrentState = AI_OPERATION_STATE_GATHERING_FORCES;
; 2161 : 					}
; 2162 : 					else
; 2163 : 					{
; 2164 : 						m_eCurrentState = AI_OPERATION_STATE_RECRUITING_UNITS;
; 2165 : 					}
; 2166 : 
; 2167 : 					LogOperationStart();

	mov	ecx, esi
	mov	DWORD PTR [esi+56], 1
	call	?LogOperationStart@CvAIOperation@@QAEXXZ ; CvAIOperation::LogOperationStart
	pop	ebp
	pop	ebx
$LN1@Init@2:
	pop	edi
	pop	esi

; 2181 : 			}
; 2182 : 		}
; 2183 : 	}
; 2184 : }

	ret	24					; 00000018H
$LN5@Init@2:
	pop	ebp
	pop	ebx
	pop	edi

; 2168 : 				}
; 2169 : 				else
; 2170 : 				{
; 2171 : 					m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	DWORD PTR [esi+56], 0

; 2172 : 					m_eAbortReason = AI_ABORT_LOST_PATH;

	mov	DWORD PTR [esi+60], 14			; 0000000eH
	pop	esi

; 2181 : 			}
; 2182 : 		}
; 2183 : 	}
; 2184 : }

	ret	24					; 00000018H
$LN6@Init@2:
	pop	edi

; 2173 : 				}
; 2174 : 			}
; 2175 : 
; 2176 : 			else
; 2177 : 			{
; 2178 : 				// Lost our target, abort
; 2179 : 				m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	DWORD PTR [esi+56], 0

; 2180 : 				m_eAbortReason = AI_ABORT_LOST_TARGET;

	mov	DWORD PTR [esi+60], 3
	pop	esi

; 2181 : 			}
; 2182 : 		}
; 2183 : 	}
; 2184 : }

	ret	24					; 00000018H
?Init@CvAIOperationBasicCityAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ENDP ; CvAIOperationBasicCityAttack::Init
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?ShouldAbort@CvAIOperationBasicCityAttack@@UAE_NXZ
_TEXT	SEGMENT
?ShouldAbort@CvAIOperationBasicCityAttack@@UAE_NXZ PROC	; CvAIOperationBasicCityAttack::ShouldAbort, COMDAT
; _this$ = ecx

; 2273 : {

	push	ebx
	push	esi
	mov	esi, ecx

; 2274 : 	// If parent says we're done, don't even check anything else
; 2275 : 	bool rtnValue = CvAIOperation::ShouldAbort();

	call	?ShouldAbort@CvAIOperation@@UAE_NXZ	; CvAIOperation::ShouldAbort
	mov	bl, al

; 2276 : 
; 2277 : 	if(!rtnValue)

	test	bl, bl
	jne	SHORT $LN2@ShouldAbor@2

; 2278 : 	{
; 2279 : 		// See if our target city is still owned by our enemy
; 2280 : 		if(GetTargetPlot()->getPlotCity() == NULL || GetTargetPlot()->getOwner() != m_eEnemy)

	mov	ecx, esi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	mov	ecx, DWORD PTR [eax+104]
	test	ecx, ecx
	jl	SHORT $LN1@ShouldAbor@2
	cmp	ecx, 64					; 00000040H
	jge	SHORT $LN1@ShouldAbor@2
	mov	eax, DWORD PTR [eax+108]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	je	SHORT $LN1@ShouldAbor@2
	mov	ecx, esi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	movsx	ecx, BYTE PTR [eax+4]
	cmp	ecx, DWORD PTR [esi+76]
	je	SHORT $LN2@ShouldAbor@2
$LN1@ShouldAbor@2:
	pop	esi

; 2281 : 		{
; 2282 : 			// Success!  The city has been captured/destroyed
; 2283 : 			return true;

	mov	al, 1
	pop	ebx

; 2288 : }

	ret	0
$LN2@ShouldAbor@2:
	pop	esi

; 2284 : 		}
; 2285 : 	}
; 2286 : 
; 2287 : 	return rtnValue;

	mov	al, bl
	pop	ebx

; 2288 : }

	ret	0
?ShouldAbort@CvAIOperationBasicCityAttack@@UAE_NXZ ENDP	; CvAIOperationBasicCityAttack::ShouldAbort
_TEXT	ENDS
PUBLIC	??_7CvAIOperationSneakCityAttack@@6B@		; CvAIOperationSneakCityAttack::`vftable'
PUBLIC	??0CvAIOperationSneakCityAttack@@QAE@XZ		; CvAIOperationSneakCityAttack::CvAIOperationSneakCityAttack
PUBLIC	??_R4CvAIOperationSneakCityAttack@@6B@		; CvAIOperationSneakCityAttack::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvAIOperationSneakCityAttack@@@8	; CvAIOperationSneakCityAttack `RTTI Type Descriptor'
PUBLIC	??_R3CvAIOperationSneakCityAttack@@8		; CvAIOperationSneakCityAttack::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvAIOperationSneakCityAttack@@8		; CvAIOperationSneakCityAttack::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvAIOperationSneakCityAttack@@8	; CvAIOperationSneakCityAttack::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?GetOperationType@CvAIOperationSneakCityAttack@@UBEHXZ ; CvAIOperationSneakCityAttack::GetOperationType
PUBLIC	?GetOperationName@CvAIOperationSneakCityAttack@@UBE?AVCvString@@XZ ; CvAIOperationSneakCityAttack::GetOperationName
EXTRN	??_ECvAIOperationSneakCityAttack@@UAEPAXI@Z:PROC ; CvAIOperationSneakCityAttack::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvAIOperationSneakCityAttack@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvAIOperationSneakCityAttack@@8 DD FLAT:??_R0?AVCvAIOperationSneakCityAttack@@@8 ; CvAIOperationSneakCityAttack::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvAIOperationSneakCityAttack@@8
rdata$r	ENDS
;	COMDAT ??_R2CvAIOperationSneakCityAttack@@8
rdata$r	SEGMENT
??_R2CvAIOperationSneakCityAttack@@8 DD FLAT:??_R1A@?0A@EA@CvAIOperationSneakCityAttack@@8 ; CvAIOperationSneakCityAttack::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvAIOperationBasicCityAttack@@8
	DD	FLAT:??_R1A@?0A@EA@CvAIEnemyTerritoryOperation@@8
	DD	FLAT:??_R1A@?0A@EA@CvAIOperation@@8
rdata$r	ENDS
;	COMDAT ??_R3CvAIOperationSneakCityAttack@@8
rdata$r	SEGMENT
??_R3CvAIOperationSneakCityAttack@@8 DD 00H		; CvAIOperationSneakCityAttack::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2CvAIOperationSneakCityAttack@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvAIOperationSneakCityAttack@@@8
_DATA	SEGMENT
??_R0?AVCvAIOperationSneakCityAttack@@@8 DD FLAT:??_7type_info@@6B@ ; CvAIOperationSneakCityAttack `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvAIOperationSneakCityAttack@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvAIOperationSneakCityAttack@@6B@
rdata$r	SEGMENT
??_R4CvAIOperationSneakCityAttack@@6B@ DD 00H		; CvAIOperationSneakCityAttack::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvAIOperationSneakCityAttack@@@8
	DD	FLAT:??_R3CvAIOperationSneakCityAttack@@8
rdata$r	ENDS
;	COMDAT ??_7CvAIOperationSneakCityAttack@@6B@
CONST	SEGMENT
??_7CvAIOperationSneakCityAttack@@6B@ DD FLAT:??_R4CvAIOperationSneakCityAttack@@6B@ ; CvAIOperationSneakCityAttack::`vftable'
	DD	FLAT:??_ECvAIOperationSneakCityAttack@@UAEPAXI@Z
	DD	FLAT:?Init@CvAIOperationBasicCityAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAIOperationSneakCityAttack@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperationBasicCityAttack@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAIEnemyTerritoryOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAIOperationSneakCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAIOperation@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:?ArmyInPosition@CvAIOperationBasicCityAttack@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperationBasicCityAttack@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAIOperation@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAIOperationBasicCityAttack@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAIOperationBasicCityAttack@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAIOperationSneakCityAttack@@UBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAIEnemyTerritoryOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	DD	FLAT:?GetDeployRange@CvAIEnemyTerritoryOperation@@UBEHXZ
	DD	FLAT:?FindBestTarget@CvAIOperationBasicCityAttack@@MAEPAVCvPlot@@XZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvAIOperationSneakCityAttack@@QAE@XZ
_TEXT	SEGMENT
??0CvAIOperationSneakCityAttack@@QAE@XZ PROC		; CvAIOperationSneakCityAttack::CvAIOperationSneakCityAttack, COMDAT
; _this$ = ecx

; 2304 : {

	push	esi
	mov	esi, ecx
	call	??0CvAIOperation@@QAE@XZ		; CvAIOperation::CvAIOperation
	mov	DWORD PTR [esi], OFFSET ??_7CvAIOperationSneakCityAttack@@6B@

; 2305 : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvAIOperationSneakCityAttack@@QAE@XZ ENDP		; CvAIOperationSneakCityAttack::CvAIOperationSneakCityAttack
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
_TEXT	ENDS
;	COMDAT ?GetOperationType@CvAIOperationSneakCityAttack@@UBEHXZ
_TEXT	SEGMENT
?GetOperationType@CvAIOperationSneakCityAttack@@UBEHXZ PROC ; CvAIOperationSneakCityAttack::GetOperationType, COMDAT
; _this$ = ecx

; 378  : 		return AI_OPERATION_SNEAK_CITY_ATTACK;

	mov	eax, 6

; 379  : 	}

	ret	0
?GetOperationType@CvAIOperationSneakCityAttack@@UBEHXZ ENDP ; CvAIOperationSneakCityAttack::GetOperationType
_TEXT	ENDS
PUBLIC	??_C@_0BP@BMGKLCJM@AI_OPERATION_SNEAK_CITY_ATTACK?$AA@ ; `string'
;	COMDAT ??_C@_0BP@BMGKLCJM@AI_OPERATION_SNEAK_CITY_ATTACK?$AA@
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BP@BMGKLCJM@AI_OPERATION_SNEAK_CITY_ATTACK?$AA@ DB 'AI_OPERATION_S'
	DB	'NEAK_CITY_ATTACK', 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
CONST	ENDS
;	COMDAT ?GetOperationName@CvAIOperationSneakCityAttack@@UBE?AVCvString@@XZ
_TEXT	SEGMENT
$T246343 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetOperationName@CvAIOperationSneakCityAttack@@UBE?AVCvString@@XZ PROC ; CvAIOperationSneakCityAttack::GetOperationName, COMDAT
; _this$ = ecx

; 381  : 	{

	push	ecx
	push	esi

; 382  : 		return CvString("AI_OPERATION_SNEAK_CITY_ATTACK");

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	push	OFFSET ??_C@_0BP@BMGKLCJM@AI_OPERATION_SNEAK_CITY_ATTACK?$AA@
	mov	ecx, esi
	mov	DWORD PTR $T246343[esp+12], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi

; 383  : 	}

	pop	ecx
	ret	4
?GetOperationName@CvAIOperationSneakCityAttack@@UBE?AVCvString@@XZ ENDP ; CvAIOperationSneakCityAttack::GetOperationName
_TEXT	ENDS
PUBLIC	??1CvAIOperationSneakCityAttack@@UAE@XZ		; CvAIOperationSneakCityAttack::~CvAIOperationSneakCityAttack
; Function compile flags: /Ogtpy
;	COMDAT ??1CvAIOperationSneakCityAttack@@UAE@XZ
_TEXT	SEGMENT
??1CvAIOperationSneakCityAttack@@UAE@XZ PROC		; CvAIOperationSneakCityAttack::~CvAIOperationSneakCityAttack, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], OFFSET ??_7CvAIEnemyTerritoryOperation@@6B@
	jmp	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
??1CvAIOperationSneakCityAttack@@UAE@XZ ENDP		; CvAIOperationSneakCityAttack::~CvAIOperationSneakCityAttack
_TEXT	ENDS
PUBLIC	??_7CvAIOperationQuickSneakCityAttack@@6B@	; CvAIOperationQuickSneakCityAttack::`vftable'
PUBLIC	??0CvAIOperationQuickSneakCityAttack@@QAE@XZ	; CvAIOperationQuickSneakCityAttack::CvAIOperationQuickSneakCityAttack
PUBLIC	??_R4CvAIOperationQuickSneakCityAttack@@6B@	; CvAIOperationQuickSneakCityAttack::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvAIOperationQuickSneakCityAttack@@@8	; CvAIOperationQuickSneakCityAttack `RTTI Type Descriptor'
PUBLIC	??_R3CvAIOperationQuickSneakCityAttack@@8	; CvAIOperationQuickSneakCityAttack::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvAIOperationQuickSneakCityAttack@@8	; CvAIOperationQuickSneakCityAttack::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvAIOperationQuickSneakCityAttack@@8 ; CvAIOperationQuickSneakCityAttack::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?GetFormation@CvAIOperationQuickSneakCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ ; CvAIOperationQuickSneakCityAttack::GetFormation
EXTRN	??_ECvAIOperationQuickSneakCityAttack@@UAEPAXI@Z:PROC ; CvAIOperationQuickSneakCityAttack::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvAIOperationQuickSneakCityAttack@@8
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@CvAIOperationQuickSneakCityAttack@@8 DD FLAT:??_R0?AVCvAIOperationQuickSneakCityAttack@@@8 ; CvAIOperationQuickSneakCityAttack::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvAIOperationQuickSneakCityAttack@@8
rdata$r	ENDS
;	COMDAT ??_R2CvAIOperationQuickSneakCityAttack@@8
rdata$r	SEGMENT
??_R2CvAIOperationQuickSneakCityAttack@@8 DD FLAT:??_R1A@?0A@EA@CvAIOperationQuickSneakCityAttack@@8 ; CvAIOperationQuickSneakCityAttack::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvAIOperationSneakCityAttack@@8
	DD	FLAT:??_R1A@?0A@EA@CvAIOperationBasicCityAttack@@8
	DD	FLAT:??_R1A@?0A@EA@CvAIEnemyTerritoryOperation@@8
	DD	FLAT:??_R1A@?0A@EA@CvAIOperation@@8
rdata$r	ENDS
;	COMDAT ??_R3CvAIOperationQuickSneakCityAttack@@8
rdata$r	SEGMENT
??_R3CvAIOperationQuickSneakCityAttack@@8 DD 00H	; CvAIOperationQuickSneakCityAttack::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2CvAIOperationQuickSneakCityAttack@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvAIOperationQuickSneakCityAttack@@@8
_DATA	SEGMENT
??_R0?AVCvAIOperationQuickSneakCityAttack@@@8 DD FLAT:??_7type_info@@6B@ ; CvAIOperationQuickSneakCityAttack `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvAIOperationQuickSneakCityAttack@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvAIOperationQuickSneakCityAttack@@6B@
rdata$r	SEGMENT
??_R4CvAIOperationQuickSneakCityAttack@@6B@ DD 00H	; CvAIOperationQuickSneakCityAttack::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvAIOperationQuickSneakCityAttack@@@8
	DD	FLAT:??_R3CvAIOperationQuickSneakCityAttack@@8
rdata$r	ENDS
;	COMDAT ??_7CvAIOperationQuickSneakCityAttack@@6B@
CONST	SEGMENT
??_7CvAIOperationQuickSneakCityAttack@@6B@ DD FLAT:??_R4CvAIOperationQuickSneakCityAttack@@6B@ ; CvAIOperationQuickSneakCityAttack::`vftable'
	DD	FLAT:??_ECvAIOperationQuickSneakCityAttack@@UAEPAXI@Z
	DD	FLAT:?Init@CvAIOperationBasicCityAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAIOperationSneakCityAttack@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperationBasicCityAttack@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAIEnemyTerritoryOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAIOperationQuickSneakCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAIOperation@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:?ArmyInPosition@CvAIOperationBasicCityAttack@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperationBasicCityAttack@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAIOperation@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAIOperationBasicCityAttack@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAIOperationBasicCityAttack@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAIOperationSneakCityAttack@@UBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAIEnemyTerritoryOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	DD	FLAT:?GetDeployRange@CvAIEnemyTerritoryOperation@@UBEHXZ
	DD	FLAT:?FindBestTarget@CvAIOperationBasicCityAttack@@MAEPAVCvPlot@@XZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvAIOperationQuickSneakCityAttack@@QAE@XZ
_TEXT	SEGMENT
??0CvAIOperationQuickSneakCityAttack@@QAE@XZ PROC	; CvAIOperationQuickSneakCityAttack::CvAIOperationQuickSneakCityAttack, COMDAT
; _this$ = ecx

; 2312 : {

	push	esi
	mov	esi, ecx
	call	??0CvAIOperation@@QAE@XZ		; CvAIOperation::CvAIOperation
	mov	DWORD PTR [esi], OFFSET ??_7CvAIOperationQuickSneakCityAttack@@6B@

; 2313 : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvAIOperationQuickSneakCityAttack@@QAE@XZ ENDP	; CvAIOperationQuickSneakCityAttack::CvAIOperationQuickSneakCityAttack
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
_TEXT	ENDS
;	COMDAT ?GetFormation@CvAIOperationQuickSneakCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ
_TEXT	SEGMENT
?GetFormation@CvAIOperationQuickSneakCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ PROC ; CvAIOperationQuickSneakCityAttack::GetFormation, COMDAT
; _this$ = ecx

; 393  : 		return MUFORMATION_EARLY_RUSH;

	mov	eax, 15					; 0000000fH

; 394  : 	}

	ret	0
?GetFormation@CvAIOperationQuickSneakCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ ENDP ; CvAIOperationQuickSneakCityAttack::GetFormation
_TEXT	ENDS
PUBLIC	??1CvAIOperationQuickSneakCityAttack@@UAE@XZ	; CvAIOperationQuickSneakCityAttack::~CvAIOperationQuickSneakCityAttack
; Function compile flags: /Ogtpy
;	COMDAT ??1CvAIOperationQuickSneakCityAttack@@UAE@XZ
_TEXT	SEGMENT
??1CvAIOperationQuickSneakCityAttack@@UAE@XZ PROC	; CvAIOperationQuickSneakCityAttack::~CvAIOperationQuickSneakCityAttack, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], OFFSET ??_7CvAIEnemyTerritoryOperation@@6B@
	jmp	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
??1CvAIOperationQuickSneakCityAttack@@UAE@XZ ENDP	; CvAIOperationQuickSneakCityAttack::~CvAIOperationQuickSneakCityAttack
_TEXT	ENDS
PUBLIC	??_7CvAIOperationSmallCityAttack@@6B@		; CvAIOperationSmallCityAttack::`vftable'
PUBLIC	??0CvAIOperationSmallCityAttack@@QAE@XZ		; CvAIOperationSmallCityAttack::CvAIOperationSmallCityAttack
PUBLIC	??_R4CvAIOperationSmallCityAttack@@6B@		; CvAIOperationSmallCityAttack::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvAIOperationSmallCityAttack@@@8	; CvAIOperationSmallCityAttack `RTTI Type Descriptor'
PUBLIC	??_R3CvAIOperationSmallCityAttack@@8		; CvAIOperationSmallCityAttack::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvAIOperationSmallCityAttack@@8		; CvAIOperationSmallCityAttack::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvAIOperationSmallCityAttack@@8	; CvAIOperationSmallCityAttack::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?GetOperationType@CvAIOperationSmallCityAttack@@UBEHXZ ; CvAIOperationSmallCityAttack::GetOperationType
PUBLIC	?GetFormation@CvAIOperationSmallCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ ; CvAIOperationSmallCityAttack::GetFormation
PUBLIC	?GetOperationName@CvAIOperationSmallCityAttack@@UBE?AVCvString@@XZ ; CvAIOperationSmallCityAttack::GetOperationName
EXTRN	??_ECvAIOperationSmallCityAttack@@UAEPAXI@Z:PROC ; CvAIOperationSmallCityAttack::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvAIOperationSmallCityAttack@@8
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@CvAIOperationSmallCityAttack@@8 DD FLAT:??_R0?AVCvAIOperationSmallCityAttack@@@8 ; CvAIOperationSmallCityAttack::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvAIOperationSmallCityAttack@@8
rdata$r	ENDS
;	COMDAT ??_R2CvAIOperationSmallCityAttack@@8
rdata$r	SEGMENT
??_R2CvAIOperationSmallCityAttack@@8 DD FLAT:??_R1A@?0A@EA@CvAIOperationSmallCityAttack@@8 ; CvAIOperationSmallCityAttack::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvAIOperationBasicCityAttack@@8
	DD	FLAT:??_R1A@?0A@EA@CvAIEnemyTerritoryOperation@@8
	DD	FLAT:??_R1A@?0A@EA@CvAIOperation@@8
rdata$r	ENDS
;	COMDAT ??_R3CvAIOperationSmallCityAttack@@8
rdata$r	SEGMENT
??_R3CvAIOperationSmallCityAttack@@8 DD 00H		; CvAIOperationSmallCityAttack::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2CvAIOperationSmallCityAttack@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvAIOperationSmallCityAttack@@@8
_DATA	SEGMENT
??_R0?AVCvAIOperationSmallCityAttack@@@8 DD FLAT:??_7type_info@@6B@ ; CvAIOperationSmallCityAttack `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvAIOperationSmallCityAttack@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvAIOperationSmallCityAttack@@6B@
rdata$r	SEGMENT
??_R4CvAIOperationSmallCityAttack@@6B@ DD 00H		; CvAIOperationSmallCityAttack::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvAIOperationSmallCityAttack@@@8
	DD	FLAT:??_R3CvAIOperationSmallCityAttack@@8
rdata$r	ENDS
;	COMDAT ??_7CvAIOperationSmallCityAttack@@6B@
CONST	SEGMENT
??_7CvAIOperationSmallCityAttack@@6B@ DD FLAT:??_R4CvAIOperationSmallCityAttack@@6B@ ; CvAIOperationSmallCityAttack::`vftable'
	DD	FLAT:??_ECvAIOperationSmallCityAttack@@UAEPAXI@Z
	DD	FLAT:?Init@CvAIOperationBasicCityAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAIOperationSmallCityAttack@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperationBasicCityAttack@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAIEnemyTerritoryOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAIOperationSmallCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAIOperation@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:?ArmyInPosition@CvAIOperationBasicCityAttack@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperationBasicCityAttack@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAIOperation@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAIOperationBasicCityAttack@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAIOperationBasicCityAttack@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAIOperationSmallCityAttack@@UBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAIEnemyTerritoryOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	DD	FLAT:?GetDeployRange@CvAIEnemyTerritoryOperation@@UBEHXZ
	DD	FLAT:?FindBestTarget@CvAIOperationBasicCityAttack@@MAEPAVCvPlot@@XZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvAIOperationSmallCityAttack@@QAE@XZ
_TEXT	SEGMENT
??0CvAIOperationSmallCityAttack@@QAE@XZ PROC		; CvAIOperationSmallCityAttack::CvAIOperationSmallCityAttack, COMDAT
; _this$ = ecx

; 2321 : {

	push	esi
	mov	esi, ecx
	call	??0CvAIOperation@@QAE@XZ		; CvAIOperation::CvAIOperation
	mov	DWORD PTR [esi], OFFSET ??_7CvAIOperationSmallCityAttack@@6B@

; 2322 : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvAIOperationSmallCityAttack@@QAE@XZ ENDP		; CvAIOperationSmallCityAttack::CvAIOperationSmallCityAttack
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
_TEXT	ENDS
;	COMDAT ?GetOperationType@CvAIOperationSmallCityAttack@@UBEHXZ
_TEXT	SEGMENT
?GetOperationType@CvAIOperationSmallCityAttack@@UBEHXZ PROC ; CvAIOperationSmallCityAttack::GetOperationType, COMDAT
; _this$ = ecx

; 408  : 		return AI_OPERATION_SMALL_CITY_ATTACK;

	mov	eax, 7

; 409  : 	}

	ret	0
?GetOperationType@CvAIOperationSmallCityAttack@@UBEHXZ ENDP ; CvAIOperationSmallCityAttack::GetOperationType
_TEXT	ENDS
PUBLIC	??_C@_0BP@CACHNFD@AI_OPERATION_SMALL_CITY_ATTACK?$AA@ ; `string'
;	COMDAT ??_C@_0BP@CACHNFD@AI_OPERATION_SMALL_CITY_ATTACK?$AA@
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BP@CACHNFD@AI_OPERATION_SMALL_CITY_ATTACK?$AA@ DB 'AI_OPERATION_SM'
	DB	'ALL_CITY_ATTACK', 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
CONST	ENDS
;	COMDAT ?GetOperationName@CvAIOperationSmallCityAttack@@UBE?AVCvString@@XZ
_TEXT	SEGMENT
$T246437 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetOperationName@CvAIOperationSmallCityAttack@@UBE?AVCvString@@XZ PROC ; CvAIOperationSmallCityAttack::GetOperationName, COMDAT
; _this$ = ecx

; 411  : 	{

	push	ecx
	push	esi

; 412  : 		return CvString("AI_OPERATION_SMALL_CITY_ATTACK");

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	push	OFFSET ??_C@_0BP@CACHNFD@AI_OPERATION_SMALL_CITY_ATTACK?$AA@
	mov	ecx, esi
	mov	DWORD PTR $T246437[esp+12], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi

; 413  : 	}

	pop	ecx
	ret	4
?GetOperationName@CvAIOperationSmallCityAttack@@UBE?AVCvString@@XZ ENDP ; CvAIOperationSmallCityAttack::GetOperationName
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetFormation@CvAIOperationSmallCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ
_TEXT	SEGMENT
?GetFormation@CvAIOperationSmallCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ PROC ; CvAIOperationSmallCityAttack::GetFormation, COMDAT
; _this$ = ecx

; 416  : 		return (GC.getGame().getHandicapInfo().GetID() > 4) ? MUFORMATION_BASIC_CITY_ATTACK_FORCE : MUFORMATION_SMALL_CITY_ATTACK_FORCE;

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getHandicapInfo@CvGame@@QBEAAVCvHandicapInfo@@XZ ; CvGame::getHandicapInfo
	xor	ecx, ecx
	cmp	DWORD PTR [eax+4], 4
	setg	cl
	dec	ecx
	and	ecx, 7
	mov	eax, ecx

; 417  : 	}

	ret	0
?GetFormation@CvAIOperationSmallCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ ENDP ; CvAIOperationSmallCityAttack::GetFormation
_TEXT	ENDS
PUBLIC	??1CvAIOperationSmallCityAttack@@UAE@XZ		; CvAIOperationSmallCityAttack::~CvAIOperationSmallCityAttack
; Function compile flags: /Ogtpy
;	COMDAT ??1CvAIOperationSmallCityAttack@@UAE@XZ
_TEXT	SEGMENT
??1CvAIOperationSmallCityAttack@@UAE@XZ PROC		; CvAIOperationSmallCityAttack::~CvAIOperationSmallCityAttack, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], OFFSET ??_7CvAIEnemyTerritoryOperation@@6B@
	jmp	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
??1CvAIOperationSmallCityAttack@@UAE@XZ ENDP		; CvAIOperationSmallCityAttack::~CvAIOperationSmallCityAttack
_TEXT	ENDS
PUBLIC	??_7CvAIOperationCityStateAttack@@6B@		; CvAIOperationCityStateAttack::`vftable'
PUBLIC	??0CvAIOperationCityStateAttack@@QAE@XZ		; CvAIOperationCityStateAttack::CvAIOperationCityStateAttack
PUBLIC	??_R4CvAIOperationCityStateAttack@@6B@		; CvAIOperationCityStateAttack::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvAIOperationCityStateAttack@@@8	; CvAIOperationCityStateAttack `RTTI Type Descriptor'
PUBLIC	??_R3CvAIOperationCityStateAttack@@8		; CvAIOperationCityStateAttack::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvAIOperationCityStateAttack@@8		; CvAIOperationCityStateAttack::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvAIOperationCityStateAttack@@8	; CvAIOperationCityStateAttack::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?GetOperationType@CvAIOperationCityStateAttack@@UBEHXZ ; CvAIOperationCityStateAttack::GetOperationType
PUBLIC	?GetOperationName@CvAIOperationCityStateAttack@@UBE?AVCvString@@XZ ; CvAIOperationCityStateAttack::GetOperationName
EXTRN	??_ECvAIOperationCityStateAttack@@UAEPAXI@Z:PROC ; CvAIOperationCityStateAttack::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvAIOperationCityStateAttack@@8
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@CvAIOperationCityStateAttack@@8 DD FLAT:??_R0?AVCvAIOperationCityStateAttack@@@8 ; CvAIOperationCityStateAttack::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvAIOperationCityStateAttack@@8
rdata$r	ENDS
;	COMDAT ??_R2CvAIOperationCityStateAttack@@8
rdata$r	SEGMENT
??_R2CvAIOperationCityStateAttack@@8 DD FLAT:??_R1A@?0A@EA@CvAIOperationCityStateAttack@@8 ; CvAIOperationCityStateAttack::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvAIOperationBasicCityAttack@@8
	DD	FLAT:??_R1A@?0A@EA@CvAIEnemyTerritoryOperation@@8
	DD	FLAT:??_R1A@?0A@EA@CvAIOperation@@8
rdata$r	ENDS
;	COMDAT ??_R3CvAIOperationCityStateAttack@@8
rdata$r	SEGMENT
??_R3CvAIOperationCityStateAttack@@8 DD 00H		; CvAIOperationCityStateAttack::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2CvAIOperationCityStateAttack@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvAIOperationCityStateAttack@@@8
_DATA	SEGMENT
??_R0?AVCvAIOperationCityStateAttack@@@8 DD FLAT:??_7type_info@@6B@ ; CvAIOperationCityStateAttack `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvAIOperationCityStateAttack@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvAIOperationCityStateAttack@@6B@
rdata$r	SEGMENT
??_R4CvAIOperationCityStateAttack@@6B@ DD 00H		; CvAIOperationCityStateAttack::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvAIOperationCityStateAttack@@@8
	DD	FLAT:??_R3CvAIOperationCityStateAttack@@8
rdata$r	ENDS
;	COMDAT ??_7CvAIOperationCityStateAttack@@6B@
CONST	SEGMENT
??_7CvAIOperationCityStateAttack@@6B@ DD FLAT:??_R4CvAIOperationCityStateAttack@@6B@ ; CvAIOperationCityStateAttack::`vftable'
	DD	FLAT:??_ECvAIOperationCityStateAttack@@UAEPAXI@Z
	DD	FLAT:?Init@CvAIOperationBasicCityAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAIOperationCityStateAttack@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperationBasicCityAttack@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAIEnemyTerritoryOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAIOperationCityStateAttack@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAIOperation@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:?ArmyInPosition@CvAIOperationBasicCityAttack@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperationBasicCityAttack@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAIOperation@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAIOperationBasicCityAttack@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAIOperationBasicCityAttack@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAIOperationCityStateAttack@@UBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAIEnemyTerritoryOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	DD	FLAT:?GetDeployRange@CvAIEnemyTerritoryOperation@@UBEHXZ
	DD	FLAT:?FindBestTarget@CvAIOperationBasicCityAttack@@MAEPAVCvPlot@@XZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvAIOperationCityStateAttack@@QAE@XZ
_TEXT	SEGMENT
??0CvAIOperationCityStateAttack@@QAE@XZ PROC		; CvAIOperationCityStateAttack::CvAIOperationCityStateAttack, COMDAT
; _this$ = ecx

; 2330 : {

	push	esi
	mov	esi, ecx
	call	??0CvAIOperation@@QAE@XZ		; CvAIOperation::CvAIOperation
	mov	DWORD PTR [esi], OFFSET ??_7CvAIOperationCityStateAttack@@6B@

; 2331 : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvAIOperationCityStateAttack@@QAE@XZ ENDP		; CvAIOperationCityStateAttack::CvAIOperationCityStateAttack
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
_TEXT	ENDS
;	COMDAT ?GetOperationType@CvAIOperationCityStateAttack@@UBEHXZ
_TEXT	SEGMENT
?GetOperationType@CvAIOperationCityStateAttack@@UBEHXZ PROC ; CvAIOperationCityStateAttack::GetOperationType, COMDAT
; _this$ = ecx

; 431  : 		return AI_OPERATION_CITY_STATE_ATTACK;

	mov	eax, 15					; 0000000fH

; 432  : 	}

	ret	0
?GetOperationType@CvAIOperationCityStateAttack@@UBEHXZ ENDP ; CvAIOperationCityStateAttack::GetOperationType
_TEXT	ENDS
PUBLIC	??_C@_0BP@LMOMDANH@AI_OPERATION_CITY_STATE_ATTACK?$AA@ ; `string'
;	COMDAT ??_C@_0BP@LMOMDANH@AI_OPERATION_CITY_STATE_ATTACK?$AA@
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BP@LMOMDANH@AI_OPERATION_CITY_STATE_ATTACK?$AA@ DB 'AI_OPERATION_C'
	DB	'ITY_STATE_ATTACK', 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
CONST	ENDS
;	COMDAT ?GetOperationName@CvAIOperationCityStateAttack@@UBE?AVCvString@@XZ
_TEXT	SEGMENT
$T246495 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetOperationName@CvAIOperationCityStateAttack@@UBE?AVCvString@@XZ PROC ; CvAIOperationCityStateAttack::GetOperationName, COMDAT
; _this$ = ecx

; 434  : 	{

	push	ecx
	push	esi

; 435  : 		return CvString("AI_OPERATION_CITY_STATE_ATTACK");

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	push	OFFSET ??_C@_0BP@LMOMDANH@AI_OPERATION_CITY_STATE_ATTACK?$AA@
	mov	ecx, esi
	mov	DWORD PTR $T246495[esp+12], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi

; 436  : 	}

	pop	ecx
	ret	4
?GetOperationName@CvAIOperationCityStateAttack@@UBE?AVCvString@@XZ ENDP ; CvAIOperationCityStateAttack::GetOperationName
_TEXT	ENDS
PUBLIC	??1CvAIOperationCityStateAttack@@UAE@XZ		; CvAIOperationCityStateAttack::~CvAIOperationCityStateAttack
; Function compile flags: /Ogtpy
;	COMDAT ??1CvAIOperationCityStateAttack@@UAE@XZ
_TEXT	SEGMENT
??1CvAIOperationCityStateAttack@@UAE@XZ PROC		; CvAIOperationCityStateAttack::~CvAIOperationCityStateAttack, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], OFFSET ??_7CvAIEnemyTerritoryOperation@@6B@
	jmp	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
??1CvAIOperationCityStateAttack@@UAE@XZ ENDP		; CvAIOperationCityStateAttack::~CvAIOperationCityStateAttack
_TEXT	ENDS
PUBLIC	??_7CvAIOperationDestroyBarbarianCamp@@6B@	; CvAIOperationDestroyBarbarianCamp::`vftable'
PUBLIC	??0CvAIOperationDestroyBarbarianCamp@@QAE@XZ	; CvAIOperationDestroyBarbarianCamp::CvAIOperationDestroyBarbarianCamp
PUBLIC	??_R4CvAIOperationDestroyBarbarianCamp@@6B@	; CvAIOperationDestroyBarbarianCamp::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvAIOperationDestroyBarbarianCamp@@@8	; CvAIOperationDestroyBarbarianCamp `RTTI Type Descriptor'
PUBLIC	??_R3CvAIOperationDestroyBarbarianCamp@@8	; CvAIOperationDestroyBarbarianCamp::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvAIOperationDestroyBarbarianCamp@@8	; CvAIOperationDestroyBarbarianCamp::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvAIOperationDestroyBarbarianCamp@@8 ; CvAIOperationDestroyBarbarianCamp::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?GetOperationType@CvAIOperationDestroyBarbarianCamp@@UBEHXZ ; CvAIOperationDestroyBarbarianCamp::GetOperationType
PUBLIC	?GetFormation@CvAIOperationDestroyBarbarianCamp@@UBE?AW4MultiunitFormationTypes@@XZ ; CvAIOperationDestroyBarbarianCamp::GetFormation
PUBLIC	?ShouldAbort@CvAIOperationDestroyBarbarianCamp@@UAE_NXZ ; CvAIOperationDestroyBarbarianCamp::ShouldAbort
PUBLIC	?Read@CvAIOperationDestroyBarbarianCamp@@UAEXAAVFDataStream@@@Z ; CvAIOperationDestroyBarbarianCamp::Read
PUBLIC	?GetOperationName@CvAIOperationDestroyBarbarianCamp@@UBE?AVCvString@@XZ ; CvAIOperationDestroyBarbarianCamp::GetOperationName
EXTRN	??_ECvAIOperationDestroyBarbarianCamp@@UAEPAXI@Z:PROC ; CvAIOperationDestroyBarbarianCamp::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvAIOperationDestroyBarbarianCamp@@8
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@CvAIOperationDestroyBarbarianCamp@@8 DD FLAT:??_R0?AVCvAIOperationDestroyBarbarianCamp@@@8 ; CvAIOperationDestroyBarbarianCamp::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvAIOperationDestroyBarbarianCamp@@8
rdata$r	ENDS
;	COMDAT ??_R2CvAIOperationDestroyBarbarianCamp@@8
rdata$r	SEGMENT
??_R2CvAIOperationDestroyBarbarianCamp@@8 DD FLAT:??_R1A@?0A@EA@CvAIOperationDestroyBarbarianCamp@@8 ; CvAIOperationDestroyBarbarianCamp::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvAIEnemyTerritoryOperation@@8
	DD	FLAT:??_R1A@?0A@EA@CvAIOperation@@8
rdata$r	ENDS
;	COMDAT ??_R3CvAIOperationDestroyBarbarianCamp@@8
rdata$r	SEGMENT
??_R3CvAIOperationDestroyBarbarianCamp@@8 DD 00H	; CvAIOperationDestroyBarbarianCamp::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CvAIOperationDestroyBarbarianCamp@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvAIOperationDestroyBarbarianCamp@@@8
_DATA	SEGMENT
??_R0?AVCvAIOperationDestroyBarbarianCamp@@@8 DD FLAT:??_7type_info@@6B@ ; CvAIOperationDestroyBarbarianCamp `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvAIOperationDestroyBarbarianCamp@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvAIOperationDestroyBarbarianCamp@@6B@
rdata$r	SEGMENT
??_R4CvAIOperationDestroyBarbarianCamp@@6B@ DD 00H	; CvAIOperationDestroyBarbarianCamp::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvAIOperationDestroyBarbarianCamp@@@8
	DD	FLAT:??_R3CvAIOperationDestroyBarbarianCamp@@8
rdata$r	ENDS
;	COMDAT ??_7CvAIOperationDestroyBarbarianCamp@@6B@
CONST	SEGMENT
??_7CvAIOperationDestroyBarbarianCamp@@6B@ DD FLAT:??_R4CvAIOperationDestroyBarbarianCamp@@6B@ ; CvAIOperationDestroyBarbarianCamp::`vftable'
	DD	FLAT:??_ECvAIOperationDestroyBarbarianCamp@@UAEPAXI@Z
	DD	FLAT:?Init@CvAIEnemyTerritoryOperation@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAIOperationDestroyBarbarianCamp@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAIEnemyTerritoryOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAIOperationDestroyBarbarianCamp@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAIOperation@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:?ArmyInPosition@CvAIOperationDestroyBarbarianCamp@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperationDestroyBarbarianCamp@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAIOperation@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAIOperationDestroyBarbarianCamp@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAIOperationDestroyBarbarianCamp@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAIOperationDestroyBarbarianCamp@@UBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAIEnemyTerritoryOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	DD	FLAT:?GetDeployRange@CvAIOperationDestroyBarbarianCamp@@UBEHXZ
	DD	FLAT:?FindBestTarget@CvAIOperationDestroyBarbarianCamp@@MAEPAVCvPlot@@XZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvAIOperationDestroyBarbarianCamp@@QAE@XZ
_TEXT	SEGMENT
??0CvAIOperationDestroyBarbarianCamp@@QAE@XZ PROC	; CvAIOperationDestroyBarbarianCamp::CvAIOperationDestroyBarbarianCamp, COMDAT
; _this$ = ecx

; 2343 : {

	push	esi
	mov	esi, ecx
	call	??0CvAIOperation@@QAE@XZ		; CvAIOperation::CvAIOperation

; 2344 : 	m_bCivilianRescue = false;

	xor	eax, eax
	mov	BYTE PTR [esi+112], al

; 2345 : 	m_iUnitToRescue = NULL;

	mov	DWORD PTR [esi+116], eax
	mov	DWORD PTR [esi], OFFSET ??_7CvAIOperationDestroyBarbarianCamp@@6B@

; 2346 : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvAIOperationDestroyBarbarianCamp@@QAE@XZ ENDP	; CvAIOperationDestroyBarbarianCamp::CvAIOperationDestroyBarbarianCamp
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
_TEXT	ENDS
;	COMDAT ?GetOperationType@CvAIOperationDestroyBarbarianCamp@@UBEHXZ
_TEXT	SEGMENT
?GetOperationType@CvAIOperationDestroyBarbarianCamp@@UBEHXZ PROC ; CvAIOperationDestroyBarbarianCamp::GetOperationType, COMDAT
; _this$ = ecx

; 456  : 		return AI_OPERATION_DESTROY_BARBARIAN_CAMP;

	mov	eax, 3

; 457  : 	}

	ret	0
?GetOperationType@CvAIOperationDestroyBarbarianCamp@@UBEHXZ ENDP ; CvAIOperationDestroyBarbarianCamp::GetOperationType
_TEXT	ENDS
PUBLIC	??_C@_0CE@ILNHOAMJ@AI_OPERATION_DESTROY_BARBARIAN_C@ ; `string'
;	COMDAT ??_C@_0CE@ILNHOAMJ@AI_OPERATION_DESTROY_BARBARIAN_C@
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0CE@ILNHOAMJ@AI_OPERATION_DESTROY_BARBARIAN_C@ DB 'AI_OPERATION_DES'
	DB	'TROY_BARBARIAN_CAMP', 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
CONST	ENDS
;	COMDAT ?GetOperationName@CvAIOperationDestroyBarbarianCamp@@UBE?AVCvString@@XZ
_TEXT	SEGMENT
$T246535 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetOperationName@CvAIOperationDestroyBarbarianCamp@@UBE?AVCvString@@XZ PROC ; CvAIOperationDestroyBarbarianCamp::GetOperationName, COMDAT
; _this$ = ecx

; 459  : 	{

	push	ecx
	push	esi

; 460  : 		return CvString("AI_OPERATION_DESTROY_BARBARIAN_CAMP");

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	push	OFFSET ??_C@_0CE@ILNHOAMJ@AI_OPERATION_DESTROY_BARBARIAN_C@
	mov	ecx, esi
	mov	DWORD PTR $T246535[esp+12], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi

; 461  : 	}

	pop	ecx
	ret	4
?GetOperationName@CvAIOperationDestroyBarbarianCamp@@UBE?AVCvString@@XZ ENDP ; CvAIOperationDestroyBarbarianCamp::GetOperationName
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetFormation@CvAIOperationDestroyBarbarianCamp@@UBE?AW4MultiunitFormationTypes@@XZ
_TEXT	SEGMENT
?GetFormation@CvAIOperationDestroyBarbarianCamp@@UBE?AW4MultiunitFormationTypes@@XZ PROC ; CvAIOperationDestroyBarbarianCamp::GetFormation, COMDAT
; _this$ = ecx

; 464  : 		return MUFORMATION_ANTI_BARBARIAN_TEAM;

	mov	eax, 3

; 465  : 	}

	ret	0
?GetFormation@CvAIOperationDestroyBarbarianCamp@@UBE?AW4MultiunitFormationTypes@@XZ ENDP ; CvAIOperationDestroyBarbarianCamp::GetFormation
_TEXT	ENDS
PUBLIC	??1CvAIOperationDestroyBarbarianCamp@@UAE@XZ	; CvAIOperationDestroyBarbarianCamp::~CvAIOperationDestroyBarbarianCamp
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
;	COMDAT ??1CvAIOperationDestroyBarbarianCamp@@UAE@XZ
_TEXT	SEGMENT
??1CvAIOperationDestroyBarbarianCamp@@UAE@XZ PROC	; CvAIOperationDestroyBarbarianCamp::~CvAIOperationDestroyBarbarianCamp, COMDAT
; _this$ = ecx

; 2351 : }

	mov	DWORD PTR [ecx], OFFSET ??_7CvAIEnemyTerritoryOperation@@6B@
	jmp	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
??1CvAIOperationDestroyBarbarianCamp@@UAE@XZ ENDP	; CvAIOperationDestroyBarbarianCamp::~CvAIOperationDestroyBarbarianCamp
_TEXT	ENDS
EXTRN	?GetTotalPower@CvArmyAI@@QAEHXZ:PROC		; CvArmyAI::GetTotalPower
EXTRN	?GetPower@CvUnit@@QBEHXZ:PROC			; CvUnit::GetPower
EXTRN	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z:PROC ; CvPlot::getBestDefender
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?ShouldAbort@CvAIOperationDestroyBarbarianCamp@@UAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ShouldAbort@CvAIOperationDestroyBarbarianCamp@@UAE_NXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ShouldAbort@CvAIOperationDestroyBarbarianCamp@@UAE_NXZ$1
__ehfuncinfo$?ShouldAbort@CvAIOperationDestroyBarbarianCamp@@UAE_NXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ShouldAbort@CvAIOperationDestroyBarbarianCamp@@UAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
xdata$x	ENDS
;	COMDAT ?ShouldAbort@CvAIOperationDestroyBarbarianCamp@@UAE_NXZ
_TEXT	SEGMENT
_rtnValue$ = -49					; size = 1
_pCampDefender$225529 = -48				; size = 8
_strMsg$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
?ShouldAbort@CvAIOperationDestroyBarbarianCamp@@UAE_NXZ PROC ; CvAIOperationDestroyBarbarianCamp::ShouldAbort, COMDAT
; _this$ = ecx

; 2465 : {

	push	-1
	push	__ehhandler$?ShouldAbort@CvAIOperationDestroyBarbarianCamp@@UAE_NXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 40					; 00000028H
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi

; 2466 : 	CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$[esp+64]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2467 : 
; 2468 : 	// If parent says we're done, don't even check anything else
; 2469 : 	bool rtnValue = CvAIOperation::ShouldAbort();

	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+72], 0
	call	?ShouldAbort@CvAIOperation@@UAE_NXZ	; CvAIOperation::ShouldAbort
	mov	BYTE PTR _rtnValue$[esp+64], al

; 2470 : 
; 2471 : 	if(!rtnValue)

	test	al, al
	jne	$LN67@ShouldAbor@3

; 2472 : 	{
; 2473 : 		// See if our target camp is still there
; 2474 : 		if (!m_bCivilianRescue && GetTargetPlot()->getImprovementType() != GC.getBARBARIAN_CAMP_IMPROVEMENT())

	cmp	BYTE PTR [esi+112], al
	jne	$LN70@ShouldAbor@3
	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8548
	mov	ecx, esi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	mov	ecx, eax
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, edi
	je	SHORT $LN14@ShouldAbor@3

; 2475 : 		{
; 2476 : 			// Success!  The camp is gone
; 2477 : 			if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN13@ShouldAbor@3
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN13@ShouldAbor@3

; 2478 : 			{
; 2479 : 				strMsg.Format("Barbarian camp at (x=%d y=%d) no longer exists. Aborting", GetTargetPlot()->getX(), GetTargetPlot()->getY());

	mov	ecx, esi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	movsx	edi, WORD PTR [eax+2]
	mov	ecx, esi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	movsx	eax, WORD PTR [eax]
	push	edi
	push	eax
	lea	ecx, DWORD PTR _strMsg$[esp+72]
	push	OFFSET $SG225508
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H
$LN71@ShouldAbor@3:

; 2480 : 				LogOperationSpecialMessage(strMsg);

	lea	edx, DWORD PTR _strMsg$[esp+64]
	push	edx
$LN72@ShouldAbor@3:
	mov	ecx, esi
	call	?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z ; CvAIOperation::LogOperationSpecialMessage
$LN13@ShouldAbor@3:

; 2481 : 			}
; 2482 : 			return true;

	lea	ecx, DWORD PTR _strMsg$[esp+64]
	mov	DWORD PTR __$EHRec$[esp+72], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	edi
	pop	esi
	mov	al, 1
	pop	ebp

; 2532 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+52]
	mov	DWORD PTR fs:0, ecx
	add	esp, 52					; 00000034H
	ret	0
$LN14@ShouldAbor@3:

; 2483 : 		}
; 2484 : 
; 2485 : 		else if (m_bCivilianRescue)

	cmp	BYTE PTR [esi+112], 0
	je	$LN11@ShouldAbor@3
$LN70@ShouldAbor@3:

; 2486 : 		{
; 2487 : 			// is the unit rescued?
; 2488 : 			CvPlayerAI& BarbPlayer = GET_PLAYER(BARBARIAN_PLAYER);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 2489 : 			CvUnit* pUnitToRescue = BarbPlayer.getUnit(m_iUnitToRescue);

	mov	eax, DWORD PTR [esi+116]
	add	ecx, 3983868				; 003cc9fcH
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	mov	edi, eax

; 2490 : 			if (!pUnitToRescue)

	test	edi, edi
	jne	SHORT $LN10@ShouldAbor@3

; 2491 : 			{
; 2492 : 				if (GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN13@ShouldAbor@3
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN13@ShouldAbor@3

; 2493 : 				{
; 2494 : 					strMsg.Format ("Civilian can no longer be rescued from barbarians. Aborting");

	lea	ecx, DWORD PTR _strMsg$[esp+64]
	push	OFFSET $SG225517
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 2495 : 					LogOperationSpecialMessage(strMsg);
; 2496 : 				}
; 2497 : 				return true;

	jmp	$LN71@ShouldAbor@3
$LN10@ShouldAbor@3:

; 2498 : 			}
; 2499 : 			else
; 2500 : 			{
; 2501 : 				if (pUnitToRescue->GetOriginalOwner() != m_eOwner || (pUnitToRescue->AI_getUnitAIType() != UNITAI_SETTLE && pUnitToRescue->AI_getUnitAIType() != UNITAI_WORKER))

	mov	ecx, edi
	call	?GetOriginalOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ ; CvUnit::GetOriginalOwner
	cmp	eax, DWORD PTR [esi+72]
	jne	SHORT $LN6@ShouldAbor@3
	mov	ecx, edi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 1
	je	$LN67@ShouldAbor@3
	mov	ecx, edi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType
	cmp	eax, 2

; 2509 : 				}
; 2510 : 			}

	je	$LN67@ShouldAbor@3
$LN6@ShouldAbor@3:

; 2502 : 				{
; 2503 : 					if (GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN13@ShouldAbor@3
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN13@ShouldAbor@3

; 2504 : 					{
; 2505 : 						strMsg.Format ("Civilian can no longer be rescued from barbarians. Aborting");

	lea	eax, DWORD PTR _strMsg$[esp+64]
	push	OFFSET $SG225523
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 8

; 2506 : 						LogOperationSpecialMessage(strMsg);

	lea	ecx, DWORD PTR _strMsg$[esp+64]
	push	ecx

; 2507 : 					}
; 2508 : 					return true;

	jmp	$LN72@ShouldAbor@3
$LN11@ShouldAbor@3:

; 2511 : 		}
; 2512 : 
; 2513 : 		else if(m_eCurrentState != AI_OPERATION_STATE_RECRUITING_UNITS)

	cmp	DWORD PTR [esi+56], 1
	je	$LN67@ShouldAbor@3

; 2514 : 		{
; 2515 : 			// If down below strength of camp, abort
; 2516 : 			CvArmyAI* pThisArmy = GET_PLAYER(m_eOwner).getArmyAI(m_viArmyIDs[0]);

	mov	ecx, DWORD PTR [esi+72]
	mov	eax, DWORD PTR [esi+8]
	imul	ecx, 63236				; 0000f704H
	mov	edx, DWORD PTR [eax]
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI

; 2517 : 			CvPlot* pTarget = GetTargetPlot();

	mov	ecx, esi
	mov	edi, eax
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot

; 2518 : 			UnitHandle pCampDefender = pTarget->getBestDefender(NO_PLAYER);

	push	0
	push	0
	push	0
	push	0
	push	0
	push	-1
	push	-1
	lea	ecx, DWORD PTR _pCampDefender$225529[esp+92]
	push	ecx
	mov	ecx, eax
	call	?getBestDefender@CvPlot@@QAE?AV?$FObjectHandle@VCvUnit@@@@W4PlayerTypes@@0PBVCvUnit@@_N222@Z ; CvPlot::getBestDefender

; 2519 : 			if(pCampDefender && pThisArmy->GetTotalPower() < pCampDefender->GetPower())

	mov	ecx, DWORD PTR _pCampDefender$225529[esp+64]
	mov	BYTE PTR __$EHRec$[esp+72], 1
	test	ecx, ecx
	je	SHORT $LN2@ShouldAbor@3
	call	?GetPower@CvUnit@@QBEHXZ		; CvUnit::GetPower
	mov	ecx, edi
	mov	ebp, eax
	call	?GetTotalPower@CvArmyAI@@QAEHXZ		; CvArmyAI::GetTotalPower
	cmp	eax, ebp
	jge	SHORT $LN66@ShouldAbor@3

; 2520 : 			{
; 2521 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN1@ShouldAbor@3
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN1@ShouldAbor@3

; 2522 : 				{
; 2523 : 					strMsg.Format("Barbarian camp stronger (%d) than our units (%d). Aborting", pCampDefender->GetPower(), pThisArmy->GetTotalPower());

	mov	ebp, DWORD PTR _pCampDefender$225529[esp+64]
	mov	ecx, edi
	call	?GetTotalPower@CvArmyAI@@QAEHXZ		; CvArmyAI::GetTotalPower
	push	eax
	mov	ecx, ebp
	call	?GetPower@CvUnit@@QBEHXZ		; CvUnit::GetPower
	push	eax
	lea	edx, DWORD PTR _strMsg$[esp+72]
	push	OFFSET $SG225533
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 16					; 00000010H

; 2524 : 					LogOperationSpecialMessage(strMsg);

	lea	eax, DWORD PTR _strMsg$[esp+64]
	push	eax
	mov	ecx, esi
	call	?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z ; CvAIOperation::LogOperationSpecialMessage
$LN1@ShouldAbor@3:

; 2525 : 				}
; 2526 : 				return true;

	mov	ecx, DWORD PTR _pCampDefender$225529[esp+64]
	mov	BYTE PTR __$EHRec$[esp+72], 0
	test	ecx, ecx
	je	$LN13@ShouldAbor@3
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	jmp	$LN13@ShouldAbor@3
$LN66@ShouldAbor@3:
	mov	ecx, DWORD PTR _pCampDefender$225529[esp+64]
$LN2@ShouldAbor@3:

; 2527 : 			}
; 2528 : 		}

	mov	BYTE PTR __$EHRec$[esp+72], 0
	test	ecx, ecx
	je	SHORT $LN67@ShouldAbor@3
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN67@ShouldAbor@3:

; 2529 : 	}
; 2530 : 
; 2531 : 	return rtnValue;

	lea	ecx, DWORD PTR _strMsg$[esp+64]
	mov	DWORD PTR __$EHRec$[esp+72], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2532 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+64]
	mov	al, BYTE PTR _rtnValue$[esp+64]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 52					; 00000034H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ShouldAbort@CvAIOperationDestroyBarbarianCamp@@UAE_NXZ$0:
	lea	ecx, DWORD PTR _strMsg$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?ShouldAbort@CvAIOperationDestroyBarbarianCamp@@UAE_NXZ$1:
	lea	ecx, DWORD PTR _pCampDefender$225529[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?ShouldAbort@CvAIOperationDestroyBarbarianCamp@@UAE_NXZ:
	mov	eax, OFFSET __ehfuncinfo$?ShouldAbort@CvAIOperationDestroyBarbarianCamp@@UAE_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ShouldAbort@CvAIOperationDestroyBarbarianCamp@@UAE_NXZ ENDP ; CvAIOperationDestroyBarbarianCamp::ShouldAbort
PUBLIC	??_7CvAIOperationPillageEnemy@@6B@		; CvAIOperationPillageEnemy::`vftable'
PUBLIC	??0CvAIOperationPillageEnemy@@QAE@XZ		; CvAIOperationPillageEnemy::CvAIOperationPillageEnemy
PUBLIC	??_R4CvAIOperationPillageEnemy@@6B@		; CvAIOperationPillageEnemy::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvAIOperationPillageEnemy@@@8		; CvAIOperationPillageEnemy `RTTI Type Descriptor'
PUBLIC	??_R3CvAIOperationPillageEnemy@@8		; CvAIOperationPillageEnemy::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvAIOperationPillageEnemy@@8		; CvAIOperationPillageEnemy::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvAIOperationPillageEnemy@@8	; CvAIOperationPillageEnemy::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?GetOperationType@CvAIOperationPillageEnemy@@UBEHXZ ; CvAIOperationPillageEnemy::GetOperationType
PUBLIC	?NeedToCheckPathToTarget@CvAIOperationPillageEnemy@@UBE_NXZ ; CvAIOperationPillageEnemy::NeedToCheckPathToTarget
PUBLIC	?GetFormation@CvAIOperationPillageEnemy@@UBE?AW4MultiunitFormationTypes@@XZ ; CvAIOperationPillageEnemy::GetFormation
PUBLIC	?Read@CvAIOperationPillageEnemy@@UAEXAAVFDataStream@@@Z ; CvAIOperationPillageEnemy::Read
PUBLIC	?GetOperationName@CvAIOperationPillageEnemy@@UBE?AVCvString@@XZ ; CvAIOperationPillageEnemy::GetOperationName
EXTRN	??_ECvAIOperationPillageEnemy@@UAEPAXI@Z:PROC	; CvAIOperationPillageEnemy::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvAIOperationPillageEnemy@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvAIOperationPillageEnemy@@8 DD FLAT:??_R0?AVCvAIOperationPillageEnemy@@@8 ; CvAIOperationPillageEnemy::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvAIOperationPillageEnemy@@8
rdata$r	ENDS
;	COMDAT ??_R2CvAIOperationPillageEnemy@@8
rdata$r	SEGMENT
??_R2CvAIOperationPillageEnemy@@8 DD FLAT:??_R1A@?0A@EA@CvAIOperationPillageEnemy@@8 ; CvAIOperationPillageEnemy::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvAIEnemyTerritoryOperation@@8
	DD	FLAT:??_R1A@?0A@EA@CvAIOperation@@8
rdata$r	ENDS
;	COMDAT ??_R3CvAIOperationPillageEnemy@@8
rdata$r	SEGMENT
??_R3CvAIOperationPillageEnemy@@8 DD 00H		; CvAIOperationPillageEnemy::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CvAIOperationPillageEnemy@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvAIOperationPillageEnemy@@@8
_DATA	SEGMENT
??_R0?AVCvAIOperationPillageEnemy@@@8 DD FLAT:??_7type_info@@6B@ ; CvAIOperationPillageEnemy `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvAIOperationPillageEnemy@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvAIOperationPillageEnemy@@6B@
rdata$r	SEGMENT
??_R4CvAIOperationPillageEnemy@@6B@ DD 00H		; CvAIOperationPillageEnemy::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvAIOperationPillageEnemy@@@8
	DD	FLAT:??_R3CvAIOperationPillageEnemy@@8
rdata$r	ENDS
;	COMDAT ??_7CvAIOperationPillageEnemy@@6B@
CONST	SEGMENT
??_7CvAIOperationPillageEnemy@@6B@ DD FLAT:??_R4CvAIOperationPillageEnemy@@6B@ ; CvAIOperationPillageEnemy::`vftable'
	DD	FLAT:??_ECvAIOperationPillageEnemy@@UAEPAXI@Z
	DD	FLAT:?Init@CvAIEnemyTerritoryOperation@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAIOperationPillageEnemy@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperationPillageEnemy@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAIEnemyTerritoryOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAIOperationPillageEnemy@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAIOperation@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:?ArmyInPosition@CvAIOperationPillageEnemy@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?ArmyMoved@CvAIOperationPillageEnemy@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperation@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAIOperation@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAIOperationPillageEnemy@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAIOperationPillageEnemy@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAIOperationPillageEnemy@@UBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAIEnemyTerritoryOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	DD	FLAT:?GetDeployRange@CvAIOperationPillageEnemy@@UBEHXZ
	DD	FLAT:?FindBestTarget@CvAIOperationPillageEnemy@@MAEPAVCvPlot@@XZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvAIOperationPillageEnemy@@QAE@XZ
_TEXT	SEGMENT
??0CvAIOperationPillageEnemy@@QAE@XZ PROC		; CvAIOperationPillageEnemy::CvAIOperationPillageEnemy, COMDAT
; _this$ = ecx

; 2617 : {

	push	esi
	mov	esi, ecx
	call	??0CvAIOperation@@QAE@XZ		; CvAIOperation::CvAIOperation
	mov	DWORD PTR [esi], OFFSET ??_7CvAIOperationPillageEnemy@@6B@

; 2618 : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvAIOperationPillageEnemy@@QAE@XZ ENDP		; CvAIOperationPillageEnemy::CvAIOperationPillageEnemy
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
_TEXT	ENDS
;	COMDAT ?GetOperationType@CvAIOperationPillageEnemy@@UBEHXZ
_TEXT	SEGMENT
?GetOperationType@CvAIOperationPillageEnemy@@UBEHXZ PROC ; CvAIOperationPillageEnemy::GetOperationType, COMDAT
; _this$ = ecx

; 493  : 		return AI_OPERATION_PILLAGE_ENEMY;

	mov	eax, 5

; 494  : 	}

	ret	0
?GetOperationType@CvAIOperationPillageEnemy@@UBEHXZ ENDP ; CvAIOperationPillageEnemy::GetOperationType
_TEXT	ENDS
PUBLIC	??_C@_0BL@CDKMMFEL@AI_OPERATION_PILLAGE_ENEMY?$AA@ ; `string'
;	COMDAT ??_C@_0BL@CDKMMFEL@AI_OPERATION_PILLAGE_ENEMY?$AA@
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BL@CDKMMFEL@AI_OPERATION_PILLAGE_ENEMY?$AA@ DB 'AI_OPERATION_PILLA'
	DB	'GE_ENEMY', 00H				; `string'
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
CONST	ENDS
;	COMDAT ?GetOperationName@CvAIOperationPillageEnemy@@UBE?AVCvString@@XZ
_TEXT	SEGMENT
$T246669 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetOperationName@CvAIOperationPillageEnemy@@UBE?AVCvString@@XZ PROC ; CvAIOperationPillageEnemy::GetOperationName, COMDAT
; _this$ = ecx

; 496  : 	{

	push	ecx
	push	esi

; 497  : 		return CvString("AI_OPERATION_PILLAGE_ENEMY");

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	push	OFFSET ??_C@_0BL@CDKMMFEL@AI_OPERATION_PILLAGE_ENEMY?$AA@
	mov	ecx, esi
	mov	DWORD PTR $T246669[esp+12], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi

; 498  : 	}

	pop	ecx
	ret	4
?GetOperationName@CvAIOperationPillageEnemy@@UBE?AVCvString@@XZ ENDP ; CvAIOperationPillageEnemy::GetOperationName
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?NeedToCheckPathToTarget@CvAIOperationPillageEnemy@@UBE_NXZ
_TEXT	SEGMENT
?NeedToCheckPathToTarget@CvAIOperationPillageEnemy@@UBE_NXZ PROC ; CvAIOperationPillageEnemy::NeedToCheckPathToTarget, COMDAT
; _this$ = ecx

; 501  : 		return false;

	xor	al, al

; 502  : 	}

	ret	0
?NeedToCheckPathToTarget@CvAIOperationPillageEnemy@@UBE_NXZ ENDP ; CvAIOperationPillageEnemy::NeedToCheckPathToTarget
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetFormation@CvAIOperationPillageEnemy@@UBE?AW4MultiunitFormationTypes@@XZ
_TEXT	SEGMENT
?GetFormation@CvAIOperationPillageEnemy@@UBE?AW4MultiunitFormationTypes@@XZ PROC ; CvAIOperationPillageEnemy::GetFormation, COMDAT
; _this$ = ecx

; 505  : 		return MUFORMATION_FAST_PILLAGERS;

	mov	eax, 2

; 506  : 	}

	ret	0
?GetFormation@CvAIOperationPillageEnemy@@UBE?AW4MultiunitFormationTypes@@XZ ENDP ; CvAIOperationPillageEnemy::GetFormation
_TEXT	ENDS
PUBLIC	??1CvAIOperationPillageEnemy@@UAE@XZ		; CvAIOperationPillageEnemy::~CvAIOperationPillageEnemy
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
;	COMDAT ??1CvAIOperationPillageEnemy@@UAE@XZ
_TEXT	SEGMENT
??1CvAIOperationPillageEnemy@@UAE@XZ PROC		; CvAIOperationPillageEnemy::~CvAIOperationPillageEnemy, COMDAT
; _this$ = ecx

; 2623 : }

	mov	DWORD PTR [ecx], OFFSET ??_7CvAIEnemyTerritoryOperation@@6B@
	jmp	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
??1CvAIOperationPillageEnemy@@UAE@XZ ENDP		; CvAIOperationPillageEnemy::~CvAIOperationPillageEnemy
_TEXT	ENDS
PUBLIC	??_7CvAIEscortedOperation@@6B@			; CvAIEscortedOperation::`vftable'
PUBLIC	??0CvAIEscortedOperation@@QAE@XZ		; CvAIEscortedOperation::CvAIEscortedOperation
PUBLIC	??_R4CvAIEscortedOperation@@6B@			; CvAIEscortedOperation::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvAIEscortedOperation@@@8		; CvAIEscortedOperation `RTTI Type Descriptor'
PUBLIC	??_R3CvAIEscortedOperation@@8			; CvAIEscortedOperation::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvAIEscortedOperation@@8			; CvAIEscortedOperation::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvAIEscortedOperation@@8		; CvAIEscortedOperation::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?Init@CvAIEscortedOperation@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ; CvAIEscortedOperation::Init
PUBLIC	?Read@CvAIEscortedOperation@@UAEXAAVFDataStream@@@Z ; CvAIEscortedOperation::Read
EXTRN	??_ECvAIEscortedOperation@@UAEPAXI@Z:PROC	; CvAIEscortedOperation::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvAIEscortedOperation@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvAIEscortedOperation@@8 DD FLAT:??_R0?AVCvAIEscortedOperation@@@8 ; CvAIEscortedOperation::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvAIEscortedOperation@@8
rdata$r	ENDS
;	COMDAT ??_R2CvAIEscortedOperation@@8
rdata$r	SEGMENT
??_R2CvAIEscortedOperation@@8 DD FLAT:??_R1A@?0A@EA@CvAIEscortedOperation@@8 ; CvAIEscortedOperation::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvAIOperation@@8
rdata$r	ENDS
;	COMDAT ??_R3CvAIEscortedOperation@@8
rdata$r	SEGMENT
??_R3CvAIEscortedOperation@@8 DD 00H			; CvAIEscortedOperation::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvAIEscortedOperation@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvAIEscortedOperation@@@8
_DATA	SEGMENT
??_R0?AVCvAIEscortedOperation@@@8 DD FLAT:??_7type_info@@6B@ ; CvAIEscortedOperation `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvAIEscortedOperation@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvAIEscortedOperation@@6B@
rdata$r	SEGMENT
??_R4CvAIEscortedOperation@@6B@ DD 00H			; CvAIEscortedOperation::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvAIEscortedOperation@@@8
	DD	FLAT:??_R3CvAIEscortedOperation@@8
rdata$r	ENDS
;	COMDAT ??_7CvAIEscortedOperation@@6B@
CONST	SEGMENT
??_7CvAIEscortedOperation@@6B@ DD FLAT:??_R4CvAIEscortedOperation@@6B@ ; CvAIEscortedOperation::`vftable'
	DD	FLAT:??_ECvAIEscortedOperation@@UAEPAXI@Z
	DD	FLAT:?Init@CvAIEscortedOperation@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAIOperation@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAIOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAIOperation@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAIOperation@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperation@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAIEscortedOperation@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAIEscortedOperation@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAIEscortedOperation@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAIOperation@@MBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAIOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	DD	FLAT:?FindBestCivilian@CvAIEscortedOperation@@UAEPAVCvUnit@@XZ
	DD	FLAT:__purecall
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvAIEscortedOperation@@QAE@XZ
_TEXT	SEGMENT
??0CvAIEscortedOperation@@QAE@XZ PROC			; CvAIEscortedOperation::CvAIEscortedOperation, COMDAT
; _this$ = ecx

; 2788 : {

	push	esi
	mov	esi, ecx
	call	??0CvAIOperation@@QAE@XZ		; CvAIOperation::CvAIOperation
	mov	DWORD PTR [esi], OFFSET ??_7CvAIEscortedOperation@@6B@

; 2789 : 	m_bEscorted = true;

	mov	BYTE PTR [esi+112], 1

; 2790 : 	m_iTargetArea = -1;

	mov	DWORD PTR [esi+120], -1

; 2791 : #ifdef AUI_WARNING_FIXES
; 2792 : 	m_eCivilianType = NO_UNITAI;
; 2793 : #endif
; 2794 : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvAIEscortedOperation@@QAE@XZ ENDP			; CvAIEscortedOperation::CvAIEscortedOperation
_TEXT	ENDS
PUBLIC	??1CvAIEscortedOperation@@UAE@XZ		; CvAIEscortedOperation::~CvAIEscortedOperation
; Function compile flags: /Ogtpy
;	COMDAT ??1CvAIEscortedOperation@@UAE@XZ
_TEXT	SEGMENT
??1CvAIEscortedOperation@@UAE@XZ PROC			; CvAIEscortedOperation::~CvAIEscortedOperation, COMDAT
; _this$ = ecx

; 2797 : {

	mov	DWORD PTR [ecx], OFFSET ??_7CvAIEscortedOperation@@6B@

; 2798 : }

	jmp	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
??1CvAIEscortedOperation@@UAE@XZ ENDP			; CvAIEscortedOperation::~CvAIEscortedOperation
_TEXT	ENDS
PUBLIC	??_7CvAIOperationFoundCity@@6B@			; CvAIOperationFoundCity::`vftable'
PUBLIC	??0CvAIOperationFoundCity@@QAE@XZ		; CvAIOperationFoundCity::CvAIOperationFoundCity
PUBLIC	??_R4CvAIOperationFoundCity@@6B@		; CvAIOperationFoundCity::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvAIOperationFoundCity@@@8		; CvAIOperationFoundCity `RTTI Type Descriptor'
PUBLIC	??_R3CvAIOperationFoundCity@@8			; CvAIOperationFoundCity::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvAIOperationFoundCity@@8			; CvAIOperationFoundCity::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvAIOperationFoundCity@@8		; CvAIOperationFoundCity::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?Init@CvAIOperationFoundCity@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ; CvAIOperationFoundCity::Init
PUBLIC	?GetOperationType@CvAIOperationFoundCity@@UBEHXZ ; CvAIOperationFoundCity::GetOperationType
PUBLIC	?GetFormation@CvAIOperationFoundCity@@UBE?AW4MultiunitFormationTypes@@XZ ; CvAIOperationFoundCity::GetFormation
PUBLIC	?ShouldAbort@CvAIOperationFoundCity@@UAE_NXZ	; CvAIOperationFoundCity::ShouldAbort
PUBLIC	?GetOperationName@CvAIOperationFoundCity@@UBE?AVCvString@@XZ ; CvAIOperationFoundCity::GetOperationName
EXTRN	??_ECvAIOperationFoundCity@@UAEPAXI@Z:PROC	; CvAIOperationFoundCity::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvAIOperationFoundCity@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvAIOperationFoundCity@@8 DD FLAT:??_R0?AVCvAIOperationFoundCity@@@8 ; CvAIOperationFoundCity::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvAIOperationFoundCity@@8
rdata$r	ENDS
;	COMDAT ??_R2CvAIOperationFoundCity@@8
rdata$r	SEGMENT
??_R2CvAIOperationFoundCity@@8 DD FLAT:??_R1A@?0A@EA@CvAIOperationFoundCity@@8 ; CvAIOperationFoundCity::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvAIEscortedOperation@@8
	DD	FLAT:??_R1A@?0A@EA@CvAIOperation@@8
rdata$r	ENDS
;	COMDAT ??_R3CvAIOperationFoundCity@@8
rdata$r	SEGMENT
??_R3CvAIOperationFoundCity@@8 DD 00H			; CvAIOperationFoundCity::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CvAIOperationFoundCity@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvAIOperationFoundCity@@@8
_DATA	SEGMENT
??_R0?AVCvAIOperationFoundCity@@@8 DD FLAT:??_7type_info@@6B@ ; CvAIOperationFoundCity `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvAIOperationFoundCity@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvAIOperationFoundCity@@6B@
rdata$r	SEGMENT
??_R4CvAIOperationFoundCity@@6B@ DD 00H			; CvAIOperationFoundCity::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvAIOperationFoundCity@@@8
	DD	FLAT:??_R3CvAIOperationFoundCity@@8
rdata$r	ENDS
;	COMDAT ??_7CvAIOperationFoundCity@@6B@
CONST	SEGMENT
??_7CvAIOperationFoundCity@@6B@ DD FLAT:??_R4CvAIOperationFoundCity@@6B@ ; CvAIOperationFoundCity::`vftable'
	DD	FLAT:??_ECvAIOperationFoundCity@@UAEPAXI@Z
	DD	FLAT:?Init@CvAIOperationFoundCity@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAIOperationFoundCity@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAIOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAIOperationFoundCity@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAIOperation@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:?ArmyInPosition@CvAIOperationFoundCity@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperationFoundCity@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAIEscortedOperation@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAIEscortedOperation@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAIEscortedOperation@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAIOperationFoundCity@@UBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAIOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	DD	FLAT:?FindBestCivilian@CvAIEscortedOperation@@UAEPAVCvUnit@@XZ
	DD	FLAT:?FindBestTarget@CvAIOperationFoundCity@@EAEPAVCvPlot@@PAVCvUnit@@_N@Z
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvAIOperationFoundCity@@QAE@XZ
_TEXT	SEGMENT
??0CvAIOperationFoundCity@@QAE@XZ PROC			; CvAIOperationFoundCity::CvAIOperationFoundCity, COMDAT
; _this$ = ecx

; 3027 : {

	push	esi
	mov	esi, ecx
	call	??0CvAIOperation@@QAE@XZ		; CvAIOperation::CvAIOperation
	mov	eax, 1
	mov	BYTE PTR [esi+112], al

; 3028 : 	m_eCivilianType = UNITAI_SETTLE;

	mov	DWORD PTR [esi+116], eax
	mov	DWORD PTR [esi+120], -1
	mov	DWORD PTR [esi], OFFSET ??_7CvAIOperationFoundCity@@6B@

; 3029 : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvAIOperationFoundCity@@QAE@XZ ENDP			; CvAIOperationFoundCity::CvAIOperationFoundCity
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
_TEXT	ENDS
;	COMDAT ?GetOperationType@CvAIOperationFoundCity@@UBEHXZ
_TEXT	SEGMENT
?GetOperationType@CvAIOperationFoundCity@@UBEHXZ PROC	; CvAIOperationFoundCity::GetOperationType, COMDAT
; _this$ = ecx

; 558  : 		return AI_OPERATION_FOUND_CITY;

	mov	eax, 4

; 559  : 	}

	ret	0
?GetOperationType@CvAIOperationFoundCity@@UBEHXZ ENDP	; CvAIOperationFoundCity::GetOperationType
_TEXT	ENDS
PUBLIC	??_C@_0BI@NAHPDMJL@AI_OPERATION_FOUND_CITY?$AA@	; `string'
;	COMDAT ??_C@_0BI@NAHPDMJL@AI_OPERATION_FOUND_CITY?$AA@
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BI@NAHPDMJL@AI_OPERATION_FOUND_CITY?$AA@ DB 'AI_OPERATION_FOUND_CI'
	DB	'TY', 00H					; `string'
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
CONST	ENDS
;	COMDAT ?GetOperationName@CvAIOperationFoundCity@@UBE?AVCvString@@XZ
_TEXT	SEGMENT
$T246718 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetOperationName@CvAIOperationFoundCity@@UBE?AVCvString@@XZ PROC ; CvAIOperationFoundCity::GetOperationName, COMDAT
; _this$ = ecx

; 561  : 	{

	push	ecx
	push	esi

; 562  : 		return CvString("AI_OPERATION_FOUND_CITY");

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	push	OFFSET ??_C@_0BI@NAHPDMJL@AI_OPERATION_FOUND_CITY?$AA@
	mov	ecx, esi
	mov	DWORD PTR $T246718[esp+12], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi

; 563  : 	}

	pop	ecx
	ret	4
?GetOperationName@CvAIOperationFoundCity@@UBE?AVCvString@@XZ ENDP ; CvAIOperationFoundCity::GetOperationName
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetFormation@CvAIOperationFoundCity@@UBE?AW4MultiunitFormationTypes@@XZ
_TEXT	SEGMENT
?GetFormation@CvAIOperationFoundCity@@UBE?AW4MultiunitFormationTypes@@XZ PROC ; CvAIOperationFoundCity::GetFormation, COMDAT
; _this$ = ecx

; 566  : 		return MUFORMATION_SETTLER_ESCORT;

	mov	eax, 6

; 567  : 	}

	ret	0
?GetFormation@CvAIOperationFoundCity@@UBE?AW4MultiunitFormationTypes@@XZ ENDP ; CvAIOperationFoundCity::GetFormation
_TEXT	ENDS
PUBLIC	??1CvAIOperationFoundCity@@UAE@XZ		; CvAIOperationFoundCity::~CvAIOperationFoundCity
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
;	COMDAT ??1CvAIOperationFoundCity@@UAE@XZ
_TEXT	SEGMENT
??1CvAIOperationFoundCity@@UAE@XZ PROC			; CvAIOperationFoundCity::~CvAIOperationFoundCity, COMDAT
; _this$ = ecx

; 3034 : }

	mov	DWORD PTR [ecx], OFFSET ??_7CvAIEscortedOperation@@6B@
	jmp	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
??1CvAIOperationFoundCity@@UAE@XZ ENDP			; CvAIOperationFoundCity::~CvAIOperationFoundCity
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?ShouldAbort@CvAIOperationFoundCity@@UAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ShouldAbort@CvAIOperationFoundCity@@UAE_NXZ$0
__ehfuncinfo$?ShouldAbort@CvAIOperationFoundCity@@UAE_NXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ShouldAbort@CvAIOperationFoundCity@@UAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
xdata$x	ENDS
;	COMDAT ?ShouldAbort@CvAIOperationFoundCity@@UAE_NXZ
_TEXT	SEGMENT
_rtnValue$ = -21					; size = 1
_pUnit$225830 = -20					; size = 8
__$EHRec$ = -12						; size = 12
?ShouldAbort@CvAIOperationFoundCity@@UAE_NXZ PROC	; CvAIOperationFoundCity::ShouldAbort, COMDAT
; _this$ = ecx

; 3311 : {

	push	-1
	push	__ehhandler$?ShouldAbort@CvAIOperationFoundCity@@UAE_NXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	esi, ecx

; 3312 : 	// If parent says we're done, don't even check anything else
; 3313 : 	bool rtnValue = CvAIOperation::ShouldAbort();

	call	?ShouldAbort@CvAIOperation@@UAE_NXZ	; CvAIOperation::ShouldAbort
	mov	BYTE PTR _rtnValue$[esp+28], al

; 3314 : 
; 3315 : 	if(!rtnValue)

	test	al, al
	jne	$LN54@ShouldAbor@4

; 3316 : 	{
; 3317 : 		if(m_eCurrentState == AI_OPERATION_STATE_RECRUITING_UNITS && m_bEscorted)

	mov	eax, DWORD PTR [esi+56]
	push	ebx
	push	edi
	cmp	eax, 1
	jne	$LN10@ShouldAbor@4
	cmp	BYTE PTR [esi+112], 0
	je	$LN10@ShouldAbor@4

; 3318 : 		{
; 3319 : 			CvArmyAI* pThisArmy = GET_PLAYER(m_eOwner).getArmyAI(m_viArmyIDs[0]);

	mov	ecx, DWORD PTR [esi+72]
	mov	eax, DWORD PTR [esi+8]
	imul	ecx, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax]
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI

; 3320 : 			CvArmyFormationSlot* pSlot = pThisArmy->GetFormationSlot(0);
; 3321 : 
; 3322 : 			if (GetMusterPlot()->getOwner() != m_eOwner || GC.getGame().getGameTurn() - pSlot->GetTurnAtCheckpoint() > 15) // fifteen turns and still no escort even being built?

	mov	ecx, esi
	mov	edi, eax
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	movsx	ecx, BYTE PTR [eax+4]
	cmp	ecx, DWORD PTR [esi+72]
	jne	SHORT $LN8@ShouldAbor@4
	mov	edx, DWORD PTR [edi+44]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	ebx, DWORD PTR [edx+4]
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	sub	eax, ebx
	cmp	eax, 15					; 0000000fH
	jle	$LN57@ShouldAbor@4
$LN8@ShouldAbor@4:

; 3323 : 			{
; 3324 : 				if (m_viListOfUnitsCitiesHaveCommittedToBuild.size() == 0)

	mov	ecx, DWORD PTR [esi+44]
	sub	ecx, DWORD PTR [esi+40]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	jne	$LN57@ShouldAbor@4

; 3325 : 				{
; 3326 : 					// try to get the escort from existing units that are waiting around
; 3327 : 					GrabUnitsFromTheReserves(GetMusterPlot(), GetTargetPlot());

	mov	ebx, DWORD PTR [esi]
	mov	ecx, esi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	push	eax
	mov	ecx, esi
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	edx, DWORD PTR [ebx+112]
	push	eax
	mov	ecx, esi
	call	edx

; 3328 : 					if(pThisArmy->GetNumSlotsFilled() > 1)

	mov	ecx, edi
	call	?GetNumSlotsFilled@CvArmyAI@@QBEHXZ	; CvArmyAI::GetNumSlotsFilled
	cmp	eax, 1
	jle	SHORT $LN6@ShouldAbor@4

; 3329 : 					{
; 3330 : 						pThisArmy->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_CATCH_UP);

	push	1
	mov	ecx, edi
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 3361 : 		}
; 3362 : 	}
; 3363 : 
; 3364 : 	return rtnValue;

	mov	al, BYTE PTR _rtnValue$[esp+36]
	pop	edi
	pop	ebx
	mov	DWORD PTR [esi+56], 2
	pop	esi

; 3365 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	add	esp, 24					; 00000018H
	ret	0
$LN6@ShouldAbor@4:

; 3331 : 						m_eCurrentState = AI_OPERATION_STATE_GATHERING_FORCES;
; 3332 : 					}
; 3333 : 					else
; 3334 : 					{
; 3335 : 						// we are going by our lonesome
; 3336 : 						m_bEscorted = false;
; 3337 : 						// Clear the list of units we need
; 3338 : 						m_viListOfUnitsWeStillNeedToBuild.clear();

	lea	ecx, DWORD PTR [esi+20]
	mov	BYTE PTR [esi+112], 0
	call	?clear@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXXZ ; std::vector<OperationSlot,std::allocator<OperationSlot> >::clear

; 3339 : 						// Send the settler directly to the target
; 3340 : 						pThisArmy->SetArmyAIState(ARMYAISTATE_MOVING_TO_DESTINATION);

	push	2
	mov	ecx, edi
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 3361 : 		}
; 3362 : 	}
; 3363 : 
; 3364 : 	return rtnValue;

	mov	al, BYTE PTR _rtnValue$[esp+36]
	pop	edi
	pop	ebx
	mov	DWORD PTR [esi+56], 3
	pop	esi

; 3365 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR fs:0, ecx
	add	esp, 24					; 00000018H
	ret	0
$LN10@ShouldAbor@4:

; 3341 : 						m_eCurrentState = AI_OPERATION_STATE_MOVING_TO_TARGET;
; 3342 : 					}
; 3343 : 				}
; 3344 : 			}
; 3345 : 		}
; 3346 : 		else if (m_eCurrentState == AI_OPERATION_STATE_GATHERING_FORCES && m_bEscorted)

	cmp	eax, 2
	jne	$LN57@ShouldAbor@4
	cmp	BYTE PTR [esi+112], 0
	je	$LN57@ShouldAbor@4

; 3347 : 		{
; 3348 : 			CvArmyAI* pThisArmy = GET_PLAYER(m_eOwner).getArmyAI(m_viArmyIDs[0]);

	mov	ecx, DWORD PTR [esi+72]
	mov	eax, DWORD PTR [esi+8]
	imul	ecx, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax]
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI
	mov	edi, eax

; 3349 : 			CvArmyFormationSlot* pSlot = pThisArmy->GetFormationSlot(0);

	mov	eax, DWORD PTR [edi+44]

; 3350 : 			if (pSlot->GetUnitID() != NO_UNIT)

	mov	eax, DWORD PTR [eax]
	cmp	eax, -1
	je	SHORT $LN57@ShouldAbor@4

; 3351 : 			{
; 3352 : 				UnitHandle pUnit = GET_PLAYER(m_eOwner).getUnit(pSlot->GetUnitID());

	mov	ecx, DWORD PTR [esi+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebp
	push	eax
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit
	push	eax
	lea	ecx, DWORD PTR _pUnit$225830[esp+44]
	call	??0?$FObjectHandle@VCvUnit@@@@QAE@PAVCvUnit@@@Z ; FObjectHandle<CvUnit>::FObjectHandle<CvUnit>

; 3353 : 				if (pUnit->plot()->isWater())

	mov	ebp, DWORD PTR _pUnit$225830[esp+40]
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+48], 0
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ebx, 3
	cmp	BYTE PTR [eax+5], bl
	jne	SHORT $LN1@ShouldAbor@4

; 3354 : 				{
; 3355 : 					// we are going by our lonesome
; 3356 : 					m_bEscorted = false;
; 3357 : 					pThisArmy->SetArmyAIState(ARMYAISTATE_MOVING_TO_DESTINATION);

	push	2
	mov	ecx, edi
	mov	BYTE PTR [esi+112], 0
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 3358 : 					m_eCurrentState = AI_OPERATION_STATE_MOVING_TO_TARGET;

	mov	DWORD PTR [esi+56], ebx
$LN1@ShouldAbor@4:

; 3359 : 				}
; 3360 : 			}

	mov	DWORD PTR __$EHRec$[esp+48], -1
	test	ebp, ebp
	je	SHORT $LN59@ShouldAbor@4
	mov	ecx, ebp
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN59@ShouldAbor@4:
	pop	ebp
$LN57@ShouldAbor@4:
	pop	edi
	pop	ebx
$LN54@ShouldAbor@4:

; 3365 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	al, BYTE PTR _rtnValue$[esp+28]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 24					; 00000018H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ShouldAbort@CvAIOperationFoundCity@@UAE_NXZ$0:
	lea	ecx, DWORD PTR _pUnit$225830[ebp]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?ShouldAbort@CvAIOperationFoundCity@@UAE_NXZ:
	mov	eax, OFFSET __ehfuncinfo$?ShouldAbort@CvAIOperationFoundCity@@UAE_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ShouldAbort@CvAIOperationFoundCity@@UAE_NXZ ENDP	; CvAIOperationFoundCity::ShouldAbort
PUBLIC	??_7CvAIOperationQuickColonize@@6B@		; CvAIOperationQuickColonize::`vftable'
PUBLIC	??0CvAIOperationQuickColonize@@QAE@XZ		; CvAIOperationQuickColonize::CvAIOperationQuickColonize
PUBLIC	??_R4CvAIOperationQuickColonize@@6B@		; CvAIOperationQuickColonize::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvAIOperationQuickColonize@@@8		; CvAIOperationQuickColonize `RTTI Type Descriptor'
PUBLIC	??_R3CvAIOperationQuickColonize@@8		; CvAIOperationQuickColonize::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvAIOperationQuickColonize@@8		; CvAIOperationQuickColonize::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvAIOperationQuickColonize@@8	; CvAIOperationQuickColonize::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?Init@CvAIOperationQuickColonize@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ; CvAIOperationQuickColonize::Init
PUBLIC	?GetOperationType@CvAIOperationQuickColonize@@UBEHXZ ; CvAIOperationQuickColonize::GetOperationType
PUBLIC	?GetFormation@CvAIOperationQuickColonize@@UBE?AW4MultiunitFormationTypes@@XZ ; CvAIOperationQuickColonize::GetFormation
PUBLIC	?GetOperationName@CvAIOperationQuickColonize@@UBE?AVCvString@@XZ ; CvAIOperationQuickColonize::GetOperationName
EXTRN	??_ECvAIOperationQuickColonize@@UAEPAXI@Z:PROC	; CvAIOperationQuickColonize::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvAIOperationQuickColonize@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvAIOperationQuickColonize@@8 DD FLAT:??_R0?AVCvAIOperationQuickColonize@@@8 ; CvAIOperationQuickColonize::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvAIOperationQuickColonize@@8
rdata$r	ENDS
;	COMDAT ??_R2CvAIOperationQuickColonize@@8
rdata$r	SEGMENT
??_R2CvAIOperationQuickColonize@@8 DD FLAT:??_R1A@?0A@EA@CvAIOperationQuickColonize@@8 ; CvAIOperationQuickColonize::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvAIOperationFoundCity@@8
	DD	FLAT:??_R1A@?0A@EA@CvAIEscortedOperation@@8
	DD	FLAT:??_R1A@?0A@EA@CvAIOperation@@8
rdata$r	ENDS
;	COMDAT ??_R3CvAIOperationQuickColonize@@8
rdata$r	SEGMENT
??_R3CvAIOperationQuickColonize@@8 DD 00H		; CvAIOperationQuickColonize::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2CvAIOperationQuickColonize@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvAIOperationQuickColonize@@@8
_DATA	SEGMENT
??_R0?AVCvAIOperationQuickColonize@@@8 DD FLAT:??_7type_info@@6B@ ; CvAIOperationQuickColonize `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvAIOperationQuickColonize@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvAIOperationQuickColonize@@6B@
rdata$r	SEGMENT
??_R4CvAIOperationQuickColonize@@6B@ DD 00H		; CvAIOperationQuickColonize::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvAIOperationQuickColonize@@@8
	DD	FLAT:??_R3CvAIOperationQuickColonize@@8
rdata$r	ENDS
;	COMDAT ??_7CvAIOperationQuickColonize@@6B@
CONST	SEGMENT
??_7CvAIOperationQuickColonize@@6B@ DD FLAT:??_R4CvAIOperationQuickColonize@@6B@ ; CvAIOperationQuickColonize::`vftable'
	DD	FLAT:??_ECvAIOperationQuickColonize@@UAEPAXI@Z
	DD	FLAT:?Init@CvAIOperationQuickColonize@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAIOperationQuickColonize@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAIOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAIOperationQuickColonize@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAIOperation@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:?ArmyInPosition@CvAIOperationFoundCity@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperationFoundCity@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAIEscortedOperation@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAIEscortedOperation@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAIEscortedOperation@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAIOperationQuickColonize@@UBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAIOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	DD	FLAT:?FindBestCivilian@CvAIOperationQuickColonize@@UAEPAVCvUnit@@XZ
	DD	FLAT:?FindBestTarget@CvAIOperationQuickColonize@@EAEPAVCvPlot@@PAVCvUnit@@_N@Z
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvAIOperationQuickColonize@@QAE@XZ
_TEXT	SEGMENT
??0CvAIOperationQuickColonize@@QAE@XZ PROC		; CvAIOperationQuickColonize::CvAIOperationQuickColonize, COMDAT
; _this$ = ecx

; 3374 : {

	push	esi
	mov	esi, ecx
	call	??0CvAIOperation@@QAE@XZ		; CvAIOperation::CvAIOperation
	mov	eax, 1
	mov	BYTE PTR [esi+112], al
	mov	DWORD PTR [esi+116], eax
	mov	DWORD PTR [esi+120], -1
	mov	DWORD PTR [esi], OFFSET ??_7CvAIOperationQuickColonize@@6B@

; 3375 : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvAIOperationQuickColonize@@QAE@XZ ENDP		; CvAIOperationQuickColonize::CvAIOperationQuickColonize
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
_TEXT	ENDS
;	COMDAT ?GetOperationType@CvAIOperationQuickColonize@@UBEHXZ
_TEXT	SEGMENT
?GetOperationType@CvAIOperationQuickColonize@@UBEHXZ PROC ; CvAIOperationQuickColonize::GetOperationType, COMDAT
; _this$ = ecx

; 589  : 		return AI_OPERATION_QUICK_COLONIZE;

	mov	eax, 12					; 0000000cH

; 590  : 	}

	ret	0
?GetOperationType@CvAIOperationQuickColonize@@UBEHXZ ENDP ; CvAIOperationQuickColonize::GetOperationType
_TEXT	ENDS
PUBLIC	??_C@_0BM@ILGDIKAG@AI_OPERATION_QUICK_COLONIZE?$AA@ ; `string'
;	COMDAT ??_C@_0BM@ILGDIKAG@AI_OPERATION_QUICK_COLONIZE?$AA@
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BM@ILGDIKAG@AI_OPERATION_QUICK_COLONIZE?$AA@ DB 'AI_OPERATION_QUIC'
	DB	'K_COLONIZE', 00H				; `string'
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
CONST	ENDS
;	COMDAT ?GetOperationName@CvAIOperationQuickColonize@@UBE?AVCvString@@XZ
_TEXT	SEGMENT
$T246853 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetOperationName@CvAIOperationQuickColonize@@UBE?AVCvString@@XZ PROC ; CvAIOperationQuickColonize::GetOperationName, COMDAT
; _this$ = ecx

; 592  : 	{

	push	ecx
	push	esi

; 593  : 		return CvString("AI_OPERATION_QUICK_COLONIZE");

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	push	OFFSET ??_C@_0BM@ILGDIKAG@AI_OPERATION_QUICK_COLONIZE?$AA@
	mov	ecx, esi
	mov	DWORD PTR $T246853[esp+12], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi

; 594  : 	}

	pop	ecx
	ret	4
?GetOperationName@CvAIOperationQuickColonize@@UBE?AVCvString@@XZ ENDP ; CvAIOperationQuickColonize::GetOperationName
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetFormation@CvAIOperationQuickColonize@@UBE?AW4MultiunitFormationTypes@@XZ
_TEXT	SEGMENT
?GetFormation@CvAIOperationQuickColonize@@UBE?AW4MultiunitFormationTypes@@XZ PROC ; CvAIOperationQuickColonize::GetFormation, COMDAT
; _this$ = ecx

; 597  : 		return MUFORMATION_QUICK_COLONY_SETTLER;

	mov	eax, 11					; 0000000bH

; 598  : 	}

	ret	0
?GetFormation@CvAIOperationQuickColonize@@UBE?AW4MultiunitFormationTypes@@XZ ENDP ; CvAIOperationQuickColonize::GetFormation
_TEXT	ENDS
PUBLIC	??1CvAIOperationQuickColonize@@UAE@XZ		; CvAIOperationQuickColonize::~CvAIOperationQuickColonize
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
;	COMDAT ??1CvAIOperationQuickColonize@@UAE@XZ
_TEXT	SEGMENT
??1CvAIOperationQuickColonize@@UAE@XZ PROC		; CvAIOperationQuickColonize::~CvAIOperationQuickColonize, COMDAT
; _this$ = ecx

; 3380 : }

	mov	DWORD PTR [ecx], OFFSET ??_7CvAIEscortedOperation@@6B@
	jmp	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
??1CvAIOperationQuickColonize@@UAE@XZ ENDP		; CvAIOperationQuickColonize::~CvAIOperationQuickColonize
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Init@CvAIOperationQuickColonize@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
_TEXT	SEGMENT
$T246884 = 8						; size = 4
_iID$ = 8						; size = 4
_eOwner$ = 12						; size = 4
___formal$ = 16						; size = 4
_iDefaultArea$ = 20					; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 4
?Init@CvAIOperationQuickColonize@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z PROC ; CvAIOperationQuickColonize::Init, COMDAT
; _this$ = ecx

; 3384 : {

	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 3385 : 	CvUnit* pOurCivilian;
; 3386 : 	CvPlot* pTargetSite;
; 3387 : 
; 3388 : 	Reset();

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+12]
	push	edi
	call	edx

; 3389 : 	m_eMoveType = AI_OPERATION_MOVETYPE_SINGLE_HEX;
; 3390 : 	m_iID = iID;
; 3391 : 	m_eOwner = eOwner;

	mov	eax, DWORD PTR _eOwner$[esp+12]

; 3392 : 	m_iTargetArea = iDefaultArea;

	mov	ecx, DWORD PTR _iDefaultArea$[esp+12]

; 3393 : 
; 3394 : 	// Find the free civilian (that triggered this operation)
; 3395 : 	pOurCivilian = FindBestCivilian();

	mov	edx, DWORD PTR [esi]
	mov	ebp, DWORD PTR _iID$[esp+12]
	mov	DWORD PTR [esi+72], eax
	mov	eax, DWORD PTR [edx+144]
	mov	DWORD PTR [esi+120], ecx
	xor	edi, edi
	mov	ecx, esi
	mov	DWORD PTR [esi+84], edi
	mov	DWORD PTR [esi+52], ebp
	call	eax
	mov	ebx, eax

; 3396 : 
; 3397 : 	if(pOurCivilian != NULL && iID != -1)

	cmp	ebx, edi
	je	$LN1@Init@3
	cmp	ebp, -1
	je	$LN1@Init@3

; 3398 : 	{
; 3399 : 		// Find a destination (not worrying about safe paths)
; 3400 : 		pTargetSite = FindBestTarget(pOurCivilian, false);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+148]
	push	edi
	push	ebx
	mov	ecx, esi
	call	eax
	mov	ebp, eax

; 3401 : 
; 3402 : 		if(pTargetSite != NULL)

	cmp	ebp, edi
	je	$LN3@Init@3

; 3403 : 		{
; 3404 : 			SetTargetPlot(pTargetSite);

	movsx	ecx, WORD PTR [ebp]
	mov	DWORD PTR [esi+104], ecx

; 3405 : 
; 3406 : 			CvArmyAI* pArmyAI = GET_PLAYER(m_eOwner).addArmyAI();

	mov	ecx, DWORD PTR [esi+72]
	movsx	edx, WORD PTR [ebp+2]
	imul	ecx, 63236				; 0000f704H
	mov	DWORD PTR [esi+108], edx
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?addArmyAI@CvPlayer@@QAEPAVCvArmyAI@@XZ	; CvPlayer::addArmyAI
	mov	edi, eax

; 3407 : 			if(pArmyAI)

	test	edi, edi
	je	$LN1@Init@3

; 3408 : 			{
; 3409 : 				m_viArmyIDs.push_back(pArmyAI->GetID());

	mov	ecx, edi
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	mov	DWORD PTR $T246884[esp+12], eax
	lea	eax, DWORD PTR $T246884[esp+12]
	push	eax
	lea	ecx, DWORD PTR [esi+4]
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 3410 : 				pArmyAI->Init(pArmyAI->GetID(),m_eOwner,m_iID);

	mov	ecx, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [esi+72]
	push	ecx
	push	edx
	mov	ecx, edi
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	push	eax
	mov	ecx, edi
	call	?Init@CvArmyAI@@QAEXHW4PlayerTypes@@H@Z	; CvArmyAI::Init

; 3411 : 				pArmyAI->SetFormationIndex(GetFormation());

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+32]
	mov	ecx, esi
	call	edx
	push	eax
	mov	ecx, edi
	call	?SetFormationIndex@CvArmyAI@@QAEXH@Z	; CvArmyAI::SetFormationIndex

; 3412 : 
; 3413 : 				// Figure out the initial rally point - for this operation it is wherever our civilian is standing
; 3414 : 				pArmyAI->SetGoalPlot(pTargetSite);

	push	ebp
	mov	ecx, edi
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 3415 : 				CvPlot* pMusterPt = pOurCivilian->plot();

	mov	ecx, ebx
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ebp, eax

; 3416 : 				SetMusterPlot(pMusterPt);

	movsx	eax, WORD PTR [ebp]
	mov	DWORD PTR [esi+96], eax
	movsx	ecx, WORD PTR [ebp+2]
	mov	DWORD PTR [esi+100], ecx

; 3417 : 				pArmyAI->SetXY(pMusterPt->getX(), pMusterPt->getY());

	movsx	edx, WORD PTR [ebp+2]
	movsx	eax, WORD PTR [ebp]
	push	edx
	push	eax
	mov	ecx, edi
	call	?SetXY@CvArmyAI@@QAEXHH@Z		; CvArmyAI::SetXY

; 3418 : 				pArmyAI->SetArmyAIState(ARMYAISTATE_MOVING_TO_DESTINATION);

	push	2
	mov	ecx, edi
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 3419 : 				SetDefaultArea(pMusterPt->getArea());

	mov	ecx, DWORD PTR [ebp+356]
	mov	DWORD PTR [esi+64], ecx

; 3420 : 
; 3421 : 				// Add the settler to our army
; 3422 : 				pArmyAI->AddUnit(pOurCivilian->GetID(), 0);

	mov	edx, DWORD PTR [ebx+100]
	push	0
	push	edx
	mov	ecx, edi
	call	?AddUnit@CvArmyAI@@QAEXHH@Z		; CvArmyAI::AddUnit

; 3423 : 				m_bEscorted = false;
; 3424 : 
; 3425 : 				m_eCurrentState = AI_OPERATION_STATE_MOVING_TO_TARGET;
; 3426 : 				LogOperationStart();

	mov	ecx, esi
	mov	BYTE PTR [esi+112], 0
	mov	DWORD PTR [esi+56], 3
	call	?LogOperationStart@CvAIOperation@@QAEXXZ ; CvAIOperation::LogOperationStart
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3435 : 		}
; 3436 : 	}
; 3437 : }

	ret	24					; 00000018H
$LN3@Init@3:

; 3427 : 			}
; 3428 : 		}
; 3429 : 
; 3430 : 		else
; 3431 : 		{
; 3432 : 			// Lost our target, abort
; 3433 : 			m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	DWORD PTR [esi+56], edi

; 3434 : 			m_eAbortReason = AI_ABORT_LOST_TARGET;

	mov	DWORD PTR [esi+60], 3
$LN1@Init@3:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3435 : 		}
; 3436 : 	}
; 3437 : }

	ret	24					; 00000018H
?Init@CvAIOperationQuickColonize@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ENDP ; CvAIOperationQuickColonize::Init
_TEXT	ENDS
PUBLIC	??_7CvAIOperationMerchantDelegation@@6B@	; CvAIOperationMerchantDelegation::`vftable'
PUBLIC	??0CvAIOperationMerchantDelegation@@QAE@XZ	; CvAIOperationMerchantDelegation::CvAIOperationMerchantDelegation
PUBLIC	??_R4CvAIOperationMerchantDelegation@@6B@	; CvAIOperationMerchantDelegation::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvAIOperationMerchantDelegation@@@8	; CvAIOperationMerchantDelegation `RTTI Type Descriptor'
PUBLIC	??_R3CvAIOperationMerchantDelegation@@8		; CvAIOperationMerchantDelegation::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvAIOperationMerchantDelegation@@8		; CvAIOperationMerchantDelegation::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvAIOperationMerchantDelegation@@8 ; CvAIOperationMerchantDelegation::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?GetOperationType@CvAIOperationMerchantDelegation@@UBEHXZ ; CvAIOperationMerchantDelegation::GetOperationType
PUBLIC	?GetFormation@CvAIOperationMerchantDelegation@@UBE?AW4MultiunitFormationTypes@@XZ ; CvAIOperationMerchantDelegation::GetFormation
PUBLIC	?GetOperationName@CvAIOperationMerchantDelegation@@UBE?AVCvString@@XZ ; CvAIOperationMerchantDelegation::GetOperationName
EXTRN	??_ECvAIOperationMerchantDelegation@@UAEPAXI@Z:PROC ; CvAIOperationMerchantDelegation::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvAIOperationMerchantDelegation@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvAIOperationMerchantDelegation@@8 DD FLAT:??_R0?AVCvAIOperationMerchantDelegation@@@8 ; CvAIOperationMerchantDelegation::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvAIOperationMerchantDelegation@@8
rdata$r	ENDS
;	COMDAT ??_R2CvAIOperationMerchantDelegation@@8
rdata$r	SEGMENT
??_R2CvAIOperationMerchantDelegation@@8 DD FLAT:??_R1A@?0A@EA@CvAIOperationMerchantDelegation@@8 ; CvAIOperationMerchantDelegation::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvAIEscortedOperation@@8
	DD	FLAT:??_R1A@?0A@EA@CvAIOperation@@8
rdata$r	ENDS
;	COMDAT ??_R3CvAIOperationMerchantDelegation@@8
rdata$r	SEGMENT
??_R3CvAIOperationMerchantDelegation@@8 DD 00H		; CvAIOperationMerchantDelegation::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CvAIOperationMerchantDelegation@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvAIOperationMerchantDelegation@@@8
_DATA	SEGMENT
??_R0?AVCvAIOperationMerchantDelegation@@@8 DD FLAT:??_7type_info@@6B@ ; CvAIOperationMerchantDelegation `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvAIOperationMerchantDelegation@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvAIOperationMerchantDelegation@@6B@
rdata$r	SEGMENT
??_R4CvAIOperationMerchantDelegation@@6B@ DD 00H	; CvAIOperationMerchantDelegation::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvAIOperationMerchantDelegation@@@8
	DD	FLAT:??_R3CvAIOperationMerchantDelegation@@8
rdata$r	ENDS
;	COMDAT ??_7CvAIOperationMerchantDelegation@@6B@
CONST	SEGMENT
??_7CvAIOperationMerchantDelegation@@6B@ DD FLAT:??_R4CvAIOperationMerchantDelegation@@6B@ ; CvAIOperationMerchantDelegation::`vftable'
	DD	FLAT:??_ECvAIOperationMerchantDelegation@@UAEPAXI@Z
	DD	FLAT:?Init@CvAIEscortedOperation@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAIOperationMerchantDelegation@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAIOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAIOperationMerchantDelegation@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAIOperation@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:?ArmyInPosition@CvAIOperationMerchantDelegation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperation@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAIEscortedOperation@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAIEscortedOperation@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAIEscortedOperation@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAIOperationMerchantDelegation@@UBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAIOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	DD	FLAT:?FindBestCivilian@CvAIEscortedOperation@@UAEPAVCvUnit@@XZ
	DD	FLAT:?FindBestTarget@CvAIOperationMerchantDelegation@@EAEPAVCvPlot@@PAVCvUnit@@_N@Z
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvAIOperationMerchantDelegation@@QAE@XZ
_TEXT	SEGMENT
??0CvAIOperationMerchantDelegation@@QAE@XZ PROC		; CvAIOperationMerchantDelegation::CvAIOperationMerchantDelegation, COMDAT
; _this$ = ecx

; 3479 : {

	push	esi
	mov	esi, ecx
	call	??0CvAIOperation@@QAE@XZ		; CvAIOperation::CvAIOperation
	mov	BYTE PTR [esi+112], 1
	mov	DWORD PTR [esi+120], -1
	mov	DWORD PTR [esi], OFFSET ??_7CvAIOperationMerchantDelegation@@6B@

; 3480 : 	m_eCivilianType = UNITAI_MERCHANT;

	mov	DWORD PTR [esi+116], 14			; 0000000eH

; 3481 : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvAIOperationMerchantDelegation@@QAE@XZ ENDP		; CvAIOperationMerchantDelegation::CvAIOperationMerchantDelegation
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
_TEXT	ENDS
;	COMDAT ?GetOperationType@CvAIOperationMerchantDelegation@@UBEHXZ
_TEXT	SEGMENT
?GetOperationType@CvAIOperationMerchantDelegation@@UBEHXZ PROC ; CvAIOperationMerchantDelegation::GetOperationType, COMDAT
; _this$ = ecx

; 618  : 		return AI_OPERATION_MERCHANT_DELEGATION;

	mov	eax, 8

; 619  : 	}

	ret	0
?GetOperationType@CvAIOperationMerchantDelegation@@UBEHXZ ENDP ; CvAIOperationMerchantDelegation::GetOperationType
_TEXT	ENDS
PUBLIC	??_C@_0CB@CKAKHEAD@AI_OPERATION_MERCHANT_DELEGATION@ ; `string'
;	COMDAT ??_C@_0CB@CKAKHEAD@AI_OPERATION_MERCHANT_DELEGATION@
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0CB@CKAKHEAD@AI_OPERATION_MERCHANT_DELEGATION@ DB 'AI_OPERATION_MER'
	DB	'CHANT_DELEGATION', 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
CONST	ENDS
;	COMDAT ?GetOperationName@CvAIOperationMerchantDelegation@@UBE?AVCvString@@XZ
_TEXT	SEGMENT
$T246952 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetOperationName@CvAIOperationMerchantDelegation@@UBE?AVCvString@@XZ PROC ; CvAIOperationMerchantDelegation::GetOperationName, COMDAT
; _this$ = ecx

; 621  : 	{

	push	ecx
	push	esi

; 622  : 		return CvString("AI_OPERATION_MERCHANT_DELEGATION");

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	push	OFFSET ??_C@_0CB@CKAKHEAD@AI_OPERATION_MERCHANT_DELEGATION@
	mov	ecx, esi
	mov	DWORD PTR $T246952[esp+12], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi

; 623  : 	}

	pop	ecx
	ret	4
?GetOperationName@CvAIOperationMerchantDelegation@@UBE?AVCvString@@XZ ENDP ; CvAIOperationMerchantDelegation::GetOperationName
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetFormation@CvAIOperationMerchantDelegation@@UBE?AW4MultiunitFormationTypes@@XZ
_TEXT	SEGMENT
?GetFormation@CvAIOperationMerchantDelegation@@UBE?AW4MultiunitFormationTypes@@XZ PROC ; CvAIOperationMerchantDelegation::GetFormation, COMDAT
; _this$ = ecx

; 626  : 		return MUFORMATION_MERCHANT_ESCORT;

	mov	eax, 8

; 627  : 	}

	ret	0
?GetFormation@CvAIOperationMerchantDelegation@@UBE?AW4MultiunitFormationTypes@@XZ ENDP ; CvAIOperationMerchantDelegation::GetFormation
_TEXT	ENDS
PUBLIC	??1CvAIOperationMerchantDelegation@@UAE@XZ	; CvAIOperationMerchantDelegation::~CvAIOperationMerchantDelegation
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
;	COMDAT ??1CvAIOperationMerchantDelegation@@UAE@XZ
_TEXT	SEGMENT
??1CvAIOperationMerchantDelegation@@UAE@XZ PROC		; CvAIOperationMerchantDelegation::~CvAIOperationMerchantDelegation, COMDAT
; _this$ = ecx

; 3486 : }

	mov	DWORD PTR [ecx], OFFSET ??_7CvAIEscortedOperation@@6B@
	jmp	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
??1CvAIOperationMerchantDelegation@@UAE@XZ ENDP		; CvAIOperationMerchantDelegation::~CvAIOperationMerchantDelegation
_TEXT	ENDS
PUBLIC	??_7CvAIOperationConcertTour@@6B@		; CvAIOperationConcertTour::`vftable'
PUBLIC	??0CvAIOperationConcertTour@@QAE@XZ		; CvAIOperationConcertTour::CvAIOperationConcertTour
PUBLIC	??_R4CvAIOperationConcertTour@@6B@		; CvAIOperationConcertTour::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvAIOperationConcertTour@@@8		; CvAIOperationConcertTour `RTTI Type Descriptor'
PUBLIC	??_R3CvAIOperationConcertTour@@8		; CvAIOperationConcertTour::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvAIOperationConcertTour@@8		; CvAIOperationConcertTour::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvAIOperationConcertTour@@8	; CvAIOperationConcertTour::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?GetOperationType@CvAIOperationConcertTour@@UBEHXZ ; CvAIOperationConcertTour::GetOperationType
PUBLIC	?GetFormation@CvAIOperationConcertTour@@UBE?AW4MultiunitFormationTypes@@XZ ; CvAIOperationConcertTour::GetFormation
PUBLIC	?GetOperationName@CvAIOperationConcertTour@@UBE?AVCvString@@XZ ; CvAIOperationConcertTour::GetOperationName
EXTRN	??_ECvAIOperationConcertTour@@UAEPAXI@Z:PROC	; CvAIOperationConcertTour::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvAIOperationConcertTour@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvAIOperationConcertTour@@8 DD FLAT:??_R0?AVCvAIOperationConcertTour@@@8 ; CvAIOperationConcertTour::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvAIOperationConcertTour@@8
rdata$r	ENDS
;	COMDAT ??_R2CvAIOperationConcertTour@@8
rdata$r	SEGMENT
??_R2CvAIOperationConcertTour@@8 DD FLAT:??_R1A@?0A@EA@CvAIOperationConcertTour@@8 ; CvAIOperationConcertTour::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvAIEscortedOperation@@8
	DD	FLAT:??_R1A@?0A@EA@CvAIOperation@@8
rdata$r	ENDS
;	COMDAT ??_R3CvAIOperationConcertTour@@8
rdata$r	SEGMENT
??_R3CvAIOperationConcertTour@@8 DD 00H			; CvAIOperationConcertTour::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CvAIOperationConcertTour@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvAIOperationConcertTour@@@8
_DATA	SEGMENT
??_R0?AVCvAIOperationConcertTour@@@8 DD FLAT:??_7type_info@@6B@ ; CvAIOperationConcertTour `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvAIOperationConcertTour@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvAIOperationConcertTour@@6B@
rdata$r	SEGMENT
??_R4CvAIOperationConcertTour@@6B@ DD 00H		; CvAIOperationConcertTour::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvAIOperationConcertTour@@@8
	DD	FLAT:??_R3CvAIOperationConcertTour@@8
rdata$r	ENDS
;	COMDAT ??_7CvAIOperationConcertTour@@6B@
CONST	SEGMENT
??_7CvAIOperationConcertTour@@6B@ DD FLAT:??_R4CvAIOperationConcertTour@@6B@ ; CvAIOperationConcertTour::`vftable'
	DD	FLAT:??_ECvAIOperationConcertTour@@UAEPAXI@Z
	DD	FLAT:?Init@CvAIEscortedOperation@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAIOperationConcertTour@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAIOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAIOperationConcertTour@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAIOperation@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:?ArmyInPosition@CvAIOperationConcertTour@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperation@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAIEscortedOperation@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAIEscortedOperation@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAIEscortedOperation@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAIOperationConcertTour@@UBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAIOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	DD	FLAT:?FindBestCivilian@CvAIEscortedOperation@@UAEPAVCvUnit@@XZ
	DD	FLAT:?FindBestTarget@CvAIOperationConcertTour@@EAEPAVCvPlot@@PAVCvUnit@@_N@Z
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvAIOperationConcertTour@@QAE@XZ
_TEXT	SEGMENT
??0CvAIOperationConcertTour@@QAE@XZ PROC		; CvAIOperationConcertTour::CvAIOperationConcertTour, COMDAT
; _this$ = ecx

; 3643 : {

	push	esi
	mov	esi, ecx
	call	??0CvAIOperation@@QAE@XZ		; CvAIOperation::CvAIOperation
	mov	BYTE PTR [esi+112], 1
	mov	DWORD PTR [esi+120], -1
	mov	DWORD PTR [esi], OFFSET ??_7CvAIOperationConcertTour@@6B@

; 3644 : 	m_eCivilianType = UNITAI_MUSICIAN;

	mov	DWORD PTR [esi+116], 41			; 00000029H

; 3645 : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvAIOperationConcertTour@@QAE@XZ ENDP		; CvAIOperationConcertTour::CvAIOperationConcertTour
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
_TEXT	ENDS
;	COMDAT ?GetOperationType@CvAIOperationConcertTour@@UBEHXZ
_TEXT	SEGMENT
?GetOperationType@CvAIOperationConcertTour@@UBEHXZ PROC	; CvAIOperationConcertTour::GetOperationType, COMDAT
; _this$ = ecx

; 647  : 		return AI_OPERATION_CONCERT_TOUR;

	mov	eax, 19					; 00000013H

; 648  : 	}

	ret	0
?GetOperationType@CvAIOperationConcertTour@@UBEHXZ ENDP	; CvAIOperationConcertTour::GetOperationType
_TEXT	ENDS
PUBLIC	??_C@_0BK@LENMBNJP@AI_OPERATION_CONCERT_TOUR?$AA@ ; `string'
;	COMDAT ??_C@_0BK@LENMBNJP@AI_OPERATION_CONCERT_TOUR?$AA@
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BK@LENMBNJP@AI_OPERATION_CONCERT_TOUR?$AA@ DB 'AI_OPERATION_CONCER'
	DB	'T_TOUR', 00H				; `string'
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
CONST	ENDS
;	COMDAT ?GetOperationName@CvAIOperationConcertTour@@UBE?AVCvString@@XZ
_TEXT	SEGMENT
$T246989 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetOperationName@CvAIOperationConcertTour@@UBE?AVCvString@@XZ PROC ; CvAIOperationConcertTour::GetOperationName, COMDAT
; _this$ = ecx

; 650  : 	{

	push	ecx
	push	esi

; 651  : 		return CvString("AI_OPERATION_CONCERT_TOUR");

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	push	OFFSET ??_C@_0BK@LENMBNJP@AI_OPERATION_CONCERT_TOUR?$AA@
	mov	ecx, esi
	mov	DWORD PTR $T246989[esp+12], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi

; 652  : 	}

	pop	ecx
	ret	4
?GetOperationName@CvAIOperationConcertTour@@UBE?AVCvString@@XZ ENDP ; CvAIOperationConcertTour::GetOperationName
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetFormation@CvAIOperationConcertTour@@UBE?AW4MultiunitFormationTypes@@XZ
_TEXT	SEGMENT
?GetFormation@CvAIOperationConcertTour@@UBE?AW4MultiunitFormationTypes@@XZ PROC ; CvAIOperationConcertTour::GetFormation, COMDAT
; _this$ = ecx

; 655  : 		return MUFORMATION_CONCERT_TOUR;

	mov	eax, 19					; 00000013H

; 656  : 	}

	ret	0
?GetFormation@CvAIOperationConcertTour@@UBE?AW4MultiunitFormationTypes@@XZ ENDP ; CvAIOperationConcertTour::GetFormation
_TEXT	ENDS
PUBLIC	??1CvAIOperationConcertTour@@UAE@XZ		; CvAIOperationConcertTour::~CvAIOperationConcertTour
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
;	COMDAT ??1CvAIOperationConcertTour@@UAE@XZ
_TEXT	SEGMENT
??1CvAIOperationConcertTour@@UAE@XZ PROC		; CvAIOperationConcertTour::~CvAIOperationConcertTour, COMDAT
; _this$ = ecx

; 3650 : }

	mov	DWORD PTR [ecx], OFFSET ??_7CvAIEscortedOperation@@6B@
	jmp	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
??1CvAIOperationConcertTour@@UAE@XZ ENDP		; CvAIOperationConcertTour::~CvAIOperationConcertTour
_TEXT	ENDS
PUBLIC	??_7CvAINavalOperation@@6B@			; CvAINavalOperation::`vftable'
PUBLIC	??0CvAINavalOperation@@QAE@XZ			; CvAINavalOperation::CvAINavalOperation
PUBLIC	??_R4CvAINavalOperation@@6B@			; CvAINavalOperation::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvAINavalOperation@@@8			; CvAINavalOperation `RTTI Type Descriptor'
PUBLIC	??_R3CvAINavalOperation@@8			; CvAINavalOperation::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvAINavalOperation@@8			; CvAINavalOperation::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvAINavalOperation@@8		; CvAINavalOperation::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?GetMaximumRecruitTurns@CvAINavalOperation@@UBEHXZ ; CvAINavalOperation::GetMaximumRecruitTurns
PUBLIC	?GetFormation@CvAINavalOperation@@UBE?AW4MultiunitFormationTypes@@XZ ; CvAINavalOperation::GetFormation
PUBLIC	?IsAllNavalOperation@CvAINavalOperation@@UBE_NXZ ; CvAINavalOperation::IsAllNavalOperation
PUBLIC	?Read@CvAINavalOperation@@UAEXAAVFDataStream@@@Z ; CvAINavalOperation::Read
EXTRN	??_ECvAINavalOperation@@UAEPAXI@Z:PROC		; CvAINavalOperation::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvAINavalOperation@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvAINavalOperation@@8 DD FLAT:??_R0?AVCvAINavalOperation@@@8 ; CvAINavalOperation::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvAINavalOperation@@8
rdata$r	ENDS
;	COMDAT ??_R2CvAINavalOperation@@8
rdata$r	SEGMENT
??_R2CvAINavalOperation@@8 DD FLAT:??_R1A@?0A@EA@CvAINavalOperation@@8 ; CvAINavalOperation::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvAIEnemyTerritoryOperation@@8
	DD	FLAT:??_R1A@?0A@EA@CvAIOperation@@8
rdata$r	ENDS
;	COMDAT ??_R3CvAINavalOperation@@8
rdata$r	SEGMENT
??_R3CvAINavalOperation@@8 DD 00H			; CvAINavalOperation::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CvAINavalOperation@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvAINavalOperation@@@8
_DATA	SEGMENT
??_R0?AVCvAINavalOperation@@@8 DD FLAT:??_7type_info@@6B@ ; CvAINavalOperation `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvAINavalOperation@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvAINavalOperation@@6B@
rdata$r	SEGMENT
??_R4CvAINavalOperation@@6B@ DD 00H			; CvAINavalOperation::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvAINavalOperation@@@8
	DD	FLAT:??_R3CvAINavalOperation@@8
rdata$r	ENDS
;	COMDAT ??_7CvAINavalOperation@@6B@
CONST	SEGMENT
??_7CvAINavalOperation@@6B@ DD FLAT:??_R4CvAINavalOperation@@6B@ ; CvAINavalOperation::`vftable'
	DD	FLAT:??_ECvAINavalOperation@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAIOperation@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAINavalOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAINavalOperation@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAINavalOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAINavalOperation@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:__purecall
	DD	FLAT:?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperation@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAIOperation@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAINavalOperation@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAINavalOperation@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAIOperation@@MBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAINavalOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	DD	FLAT:?GetDeployRange@CvAINavalOperation@@UBEHXZ
	DD	FLAT:__purecall
	DD	FLAT:?FindInitialUnit@CvAINavalOperation@@MAEPAVCvUnit@@XZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvAINavalOperation@@QAE@XZ
_TEXT	SEGMENT
??0CvAINavalOperation@@QAE@XZ PROC			; CvAINavalOperation::CvAINavalOperation, COMDAT
; _this$ = ecx

; 3795 : {

	push	esi
	mov	esi, ecx
	call	??0CvAIOperation@@QAE@XZ		; CvAIOperation::CvAIOperation
	mov	DWORD PTR [esi], OFFSET ??_7CvAINavalOperation@@6B@

; 3796 : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvAINavalOperation@@QAE@XZ ENDP			; CvAINavalOperation::CvAINavalOperation
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
_TEXT	ENDS
;	COMDAT ?GetFormation@CvAINavalOperation@@UBE?AW4MultiunitFormationTypes@@XZ
_TEXT	SEGMENT
?GetFormation@CvAINavalOperation@@UBE?AW4MultiunitFormationTypes@@XZ PROC ; CvAINavalOperation::GetFormation, COMDAT
; _this$ = ecx

; 680  : 		return MUFORMATION_NAVAL_SQUADRON;

	mov	eax, 9

; 681  : 	}

	ret	0
?GetFormation@CvAINavalOperation@@UBE?AW4MultiunitFormationTypes@@XZ ENDP ; CvAINavalOperation::GetFormation
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?IsAllNavalOperation@CvAINavalOperation@@UBE_NXZ
_TEXT	SEGMENT
?IsAllNavalOperation@CvAINavalOperation@@UBE_NXZ PROC	; CvAINavalOperation::IsAllNavalOperation, COMDAT
; _this$ = ecx

; 686  : 		return true;

	mov	al, 1

; 687  : 	};

	ret	0
?IsAllNavalOperation@CvAINavalOperation@@UBE_NXZ ENDP	; CvAINavalOperation::IsAllNavalOperation
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetMaximumRecruitTurns@CvAINavalOperation@@UBEHXZ
_TEXT	SEGMENT
?GetMaximumRecruitTurns@CvAINavalOperation@@UBEHXZ PROC	; CvAINavalOperation::GetMaximumRecruitTurns, COMDAT
; _this$ = ecx

; 690  : 	virtual int GetMaximumRecruitTurns() const {return MAX_INT;};   // Let naval units come from afar

	mov	eax, 2147483647				; 7fffffffH
	ret	0
?GetMaximumRecruitTurns@CvAINavalOperation@@UBEHXZ ENDP	; CvAINavalOperation::GetMaximumRecruitTurns
_TEXT	ENDS
PUBLIC	??1CvAINavalOperation@@UAE@XZ			; CvAINavalOperation::~CvAINavalOperation
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
;	COMDAT ??1CvAINavalOperation@@UAE@XZ
_TEXT	SEGMENT
??1CvAINavalOperation@@UAE@XZ PROC			; CvAINavalOperation::~CvAINavalOperation, COMDAT
; _this$ = ecx

; 3801 : }

	mov	DWORD PTR [ecx], OFFSET ??_7CvAIEnemyTerritoryOperation@@6B@
	jmp	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
??1CvAINavalOperation@@UAE@XZ ENDP			; CvAINavalOperation::~CvAINavalOperation
_TEXT	ENDS
PUBLIC	??_7CvAIOperationNavalBombardment@@6B@		; CvAIOperationNavalBombardment::`vftable'
PUBLIC	??0CvAIOperationNavalBombardment@@QAE@XZ	; CvAIOperationNavalBombardment::CvAIOperationNavalBombardment
PUBLIC	??_R4CvAIOperationNavalBombardment@@6B@		; CvAIOperationNavalBombardment::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvAIOperationNavalBombardment@@@8	; CvAIOperationNavalBombardment `RTTI Type Descriptor'
PUBLIC	??_R3CvAIOperationNavalBombardment@@8		; CvAIOperationNavalBombardment::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvAIOperationNavalBombardment@@8		; CvAIOperationNavalBombardment::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvAIOperationNavalBombardment@@8	; CvAIOperationNavalBombardment::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?Init@CvAIOperationNavalBombardment@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ; CvAIOperationNavalBombardment::Init
PUBLIC	?GetOperationType@CvAIOperationNavalBombardment@@UBEHXZ ; CvAIOperationNavalBombardment::GetOperationType
PUBLIC	?GetFormation@CvAIOperationNavalBombardment@@UBE?AW4MultiunitFormationTypes@@XZ ; CvAIOperationNavalBombardment::GetFormation
PUBLIC	?Read@CvAIOperationNavalBombardment@@UAEXAAVFDataStream@@@Z ; CvAIOperationNavalBombardment::Read
PUBLIC	?GetOperationName@CvAIOperationNavalBombardment@@UBE?AVCvString@@XZ ; CvAIOperationNavalBombardment::GetOperationName
EXTRN	??_ECvAIOperationNavalBombardment@@UAEPAXI@Z:PROC ; CvAIOperationNavalBombardment::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvAIOperationNavalBombardment@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvAIOperationNavalBombardment@@8 DD FLAT:??_R0?AVCvAIOperationNavalBombardment@@@8 ; CvAIOperationNavalBombardment::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvAIOperationNavalBombardment@@8
rdata$r	ENDS
;	COMDAT ??_R2CvAIOperationNavalBombardment@@8
rdata$r	SEGMENT
??_R2CvAIOperationNavalBombardment@@8 DD FLAT:??_R1A@?0A@EA@CvAIOperationNavalBombardment@@8 ; CvAIOperationNavalBombardment::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvAINavalOperation@@8
	DD	FLAT:??_R1A@?0A@EA@CvAIEnemyTerritoryOperation@@8
	DD	FLAT:??_R1A@?0A@EA@CvAIOperation@@8
rdata$r	ENDS
;	COMDAT ??_R3CvAIOperationNavalBombardment@@8
rdata$r	SEGMENT
??_R3CvAIOperationNavalBombardment@@8 DD 00H		; CvAIOperationNavalBombardment::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2CvAIOperationNavalBombardment@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvAIOperationNavalBombardment@@@8
_DATA	SEGMENT
??_R0?AVCvAIOperationNavalBombardment@@@8 DD FLAT:??_7type_info@@6B@ ; CvAIOperationNavalBombardment `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvAIOperationNavalBombardment@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvAIOperationNavalBombardment@@6B@
rdata$r	SEGMENT
??_R4CvAIOperationNavalBombardment@@6B@ DD 00H		; CvAIOperationNavalBombardment::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvAIOperationNavalBombardment@@@8
	DD	FLAT:??_R3CvAIOperationNavalBombardment@@8
rdata$r	ENDS
;	COMDAT ??_7CvAIOperationNavalBombardment@@6B@
CONST	SEGMENT
??_7CvAIOperationNavalBombardment@@6B@ DD FLAT:??_R4CvAIOperationNavalBombardment@@6B@ ; CvAIOperationNavalBombardment::`vftable'
	DD	FLAT:??_ECvAIOperationNavalBombardment@@UAEPAXI@Z
	DD	FLAT:?Init@CvAIOperationNavalBombardment@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAIOperationNavalBombardment@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAINavalOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAIOperationNavalBombardment@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAINavalOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAINavalOperation@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:?ArmyInPosition@CvAIOperationNavalBombardment@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperation@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAIOperation@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAIOperationNavalBombardment@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAIOperationNavalBombardment@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAIOperationNavalBombardment@@UBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAINavalOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	DD	FLAT:?GetDeployRange@CvAINavalOperation@@UBEHXZ
	DD	FLAT:?FindBestTarget@CvAIOperationNavalBombardment@@MAEPAVCvPlot@@XZ
	DD	FLAT:?FindInitialUnit@CvAINavalOperation@@MAEPAVCvUnit@@XZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvAIOperationNavalBombardment@@QAE@XZ
_TEXT	SEGMENT
??0CvAIOperationNavalBombardment@@QAE@XZ PROC		; CvAIOperationNavalBombardment::CvAIOperationNavalBombardment, COMDAT
; _this$ = ecx

; 3958 : {

	push	esi
	mov	esi, ecx
	call	??0CvAIOperation@@QAE@XZ		; CvAIOperation::CvAIOperation
	mov	DWORD PTR [esi], OFFSET ??_7CvAIOperationNavalBombardment@@6B@

; 3959 : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvAIOperationNavalBombardment@@QAE@XZ ENDP		; CvAIOperationNavalBombardment::CvAIOperationNavalBombardment
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
_TEXT	ENDS
;	COMDAT ?GetFormation@CvAIOperationNavalBombardment@@UBE?AW4MultiunitFormationTypes@@XZ
_TEXT	SEGMENT
?GetFormation@CvAIOperationNavalBombardment@@UBE?AW4MultiunitFormationTypes@@XZ PROC ; CvAIOperationNavalBombardment::GetFormation, COMDAT
; _this$ = ecx

; 715  : 		return MUFORMATION_NAVAL_BOMBARDMENT;

	mov	eax, 16					; 00000010H

; 716  : 	}

	ret	0
?GetFormation@CvAIOperationNavalBombardment@@UBE?AW4MultiunitFormationTypes@@XZ ENDP ; CvAIOperationNavalBombardment::GetFormation
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetOperationType@CvAIOperationNavalBombardment@@UBEHXZ
_TEXT	SEGMENT
?GetOperationType@CvAIOperationNavalBombardment@@UBEHXZ PROC ; CvAIOperationNavalBombardment::GetOperationType, COMDAT
; _this$ = ecx

; 719  : 		return AI_OPERATION_NAVAL_BOMBARDMENT;

	mov	eax, 9

; 720  : 	}

	ret	0
?GetOperationType@CvAIOperationNavalBombardment@@UBEHXZ ENDP ; CvAIOperationNavalBombardment::GetOperationType
_TEXT	ENDS
PUBLIC	??_C@_0BP@DADNJKAM@AI_OPERATION_NAVAL_BOMBARDMENT?$AA@ ; `string'
;	COMDAT ??_C@_0BP@DADNJKAM@AI_OPERATION_NAVAL_BOMBARDMENT?$AA@
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BP@DADNJKAM@AI_OPERATION_NAVAL_BOMBARDMENT?$AA@ DB 'AI_OPERATION_N'
	DB	'AVAL_BOMBARDMENT', 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
CONST	ENDS
;	COMDAT ?GetOperationName@CvAIOperationNavalBombardment@@UBE?AVCvString@@XZ
_TEXT	SEGMENT
$T247061 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetOperationName@CvAIOperationNavalBombardment@@UBE?AVCvString@@XZ PROC ; CvAIOperationNavalBombardment::GetOperationName, COMDAT
; _this$ = ecx

; 722  : 	{

	push	ecx
	push	esi

; 723  : 		return CvString("AI_OPERATION_NAVAL_BOMBARDMENT");

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	push	OFFSET ??_C@_0BP@DADNJKAM@AI_OPERATION_NAVAL_BOMBARDMENT?$AA@
	mov	ecx, esi
	mov	DWORD PTR $T247061[esp+12], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi

; 724  : 	}

	pop	ecx
	ret	4
?GetOperationName@CvAIOperationNavalBombardment@@UBE?AVCvString@@XZ ENDP ; CvAIOperationNavalBombardment::GetOperationName
_TEXT	ENDS
PUBLIC	??1CvAIOperationNavalBombardment@@UAE@XZ	; CvAIOperationNavalBombardment::~CvAIOperationNavalBombardment
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
;	COMDAT ??1CvAIOperationNavalBombardment@@UAE@XZ
_TEXT	SEGMENT
??1CvAIOperationNavalBombardment@@UAE@XZ PROC		; CvAIOperationNavalBombardment::~CvAIOperationNavalBombardment, COMDAT
; _this$ = ecx

; 3964 : }

	mov	DWORD PTR [ecx], OFFSET ??_7CvAIEnemyTerritoryOperation@@6B@
	jmp	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
??1CvAIOperationNavalBombardment@@UAE@XZ ENDP		; CvAIOperationNavalBombardment::~CvAIOperationNavalBombardment
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Init@CvAIOperationNavalBombardment@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
_TEXT	SEGMENT
$T247089 = 8						; size = 4
_iID$ = 8						; size = 4
_eOwner$ = 12						; size = 4
_eEnemy$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 4
?Init@CvAIOperationNavalBombardment@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z PROC ; CvAIOperationNavalBombardment::Init, COMDAT
; _this$ = ecx

; 3968 : {

	push	esi
	mov	esi, ecx

; 3969 : 	Reset();

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+12]
	call	edx

; 3970 : 	m_eMoveType = AI_OPERATION_MOVETYPE_ENEMY_TERRITORY;
; 3971 : 	m_iID = iID;

	mov	eax, DWORD PTR _iID$[esp]

; 3972 : 	m_eOwner = eOwner;

	mov	ecx, DWORD PTR _eOwner$[esp]

; 3973 : 	m_eEnemy = eEnemy;

	mov	edx, DWORD PTR _eEnemy$[esp]
	mov	DWORD PTR [esi+84], 1
	mov	DWORD PTR [esi+52], eax
	mov	DWORD PTR [esi+72], ecx
	mov	DWORD PTR [esi+76], edx

; 3974 : 
; 3975 : 	if(iID != -1 && GetOperationStartCity())

	cmp	eax, -1
	je	$LN1@Init@4
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+52]
	mov	ecx, esi
	call	edx
	test	eax, eax
	je	$LN1@Init@4

; 3976 : 	{
; 3977 : 		// create the armies that are needed and set the state to ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE
; 3978 : 		CvPlayer& kPlayer = GET_PLAYER(m_eOwner);

	mov	ecx, DWORD PTR [esi+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebx
	push	edi

; 3979 : 		CvArmyAI* pArmyAI = kPlayer.addArmyAI();

	call	?addArmyAI@CvPlayer@@QAEPAVCvArmyAI@@XZ	; CvPlayer::addArmyAI
	mov	edi, eax

; 3980 : 		if(pArmyAI)

	xor	ebx, ebx
	cmp	edi, ebx
	je	$LN27@Init@4

; 3981 : 		{
; 3982 : 			m_viArmyIDs.push_back(pArmyAI->GetID());

	mov	ecx, edi
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	mov	DWORD PTR $T247089[esp+8], eax
	lea	eax, DWORD PTR $T247089[esp+8]
	push	eax
	lea	ecx, DWORD PTR [esi+4]
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 3983 : 			pArmyAI->Init(pArmyAI->GetID(),m_eOwner,m_iID);

	mov	ecx, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [esi+72]
	push	ecx
	push	edx
	mov	ecx, edi
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	push	eax
	mov	ecx, edi
	call	?Init@CvArmyAI@@QAEXHW4PlayerTypes@@H@Z	; CvArmyAI::Init

; 3984 : 			pArmyAI->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE);

	push	ebx
	mov	ecx, edi
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 3985 : 			pArmyAI->SetFormationIndex(GetFormation());

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+32]
	mov	ecx, esi
	call	edx
	push	eax
	mov	ecx, edi
	call	?SetFormationIndex@CvArmyAI@@QAEXH@Z	; CvArmyAI::SetFormationIndex

; 3986 : 
; 3987 : 			// Figure out the initial rally point
; 3988 : 			CvPlot* pTargetPlot = FindBestTarget();

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+148]
	mov	ecx, esi
	call	edx

; 3989 : 			if(pTargetPlot != NULL)

	cmp	eax, ebx
	je	$LN6@Init@4

; 3990 : 			{
; 3991 : 				SetTargetPlot(pTargetPlot);

	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR [esi+104], ecx
	movsx	edx, WORD PTR [eax+2]

; 3992 : 				pArmyAI->SetGoalPlot(pTargetPlot);

	push	eax
	mov	ecx, edi
	mov	DWORD PTR [esi+108], edx
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 3993 : 				if(SelectInitialMusterPoint(pArmyAI) != NULL)

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+136]
	push	edi
	mov	ecx, esi
	call	edx
	test	eax, eax
	je	$LN5@Init@4

; 3994 : 				{
; 3995 : 					pArmyAI->SetXY(GetMusterPlot()->getX(), GetMusterPlot()->getY());

	mov	ecx, esi
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	ecx, esi
	mov	ebx, eax
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	movsx	eax, WORD PTR [eax+2]
	movsx	ecx, WORD PTR [ebx]
	push	eax
	push	ecx
	mov	ecx, edi
	call	?SetXY@CvArmyAI@@QAEXHH@Z		; CvArmyAI::SetXY

; 3996 : 					SetDefaultArea(GetMusterPlot()->getArea());

	mov	ecx, esi
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	edx, DWORD PTR [eax+356]

; 3997 : 
; 3998 : 					// Find the list of units we need to build before starting this operation in earnest
; 3999 : 					BuildListOfUnitsWeStillNeedToBuild();

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [esi+64], edx
	mov	edx, DWORD PTR [eax+92]
	mov	ecx, esi
	call	edx

; 4000 : 
; 4001 : 					// try to get as many units as possible from existing units that are waiting around
; 4002 : 					if(GrabUnitsFromTheReserves(GetMusterPlot(), GetMusterPlot()))

	mov	ebx, DWORD PTR [esi]
	mov	ecx, esi
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	push	eax
	mov	ecx, esi
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	push	eax
	mov	eax, DWORD PTR [ebx+112]
	mov	ecx, esi
	call	eax
	test	al, al
	je	SHORT $LN4@Init@4

; 4003 : 					{
; 4004 : 						pArmyAI->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_CATCH_UP);

	push	1
	mov	ecx, edi
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 4005 : 						m_eCurrentState = AI_OPERATION_STATE_GATHERING_FORCES;
; 4006 : 					}
; 4007 : 					else
; 4008 : 					{
; 4009 : 						m_eCurrentState = AI_OPERATION_STATE_RECRUITING_UNITS;
; 4010 : 					}
; 4011 : 
; 4012 : 					LogOperationStart();

	mov	ecx, esi
	mov	DWORD PTR [esi+56], 2
	call	?LogOperationStart@CvAIOperation@@QAEXXZ ; CvAIOperation::LogOperationStart
	pop	edi
	pop	ebx
	pop	esi

; 4027 : 			}
; 4028 : 		}
; 4029 : 	}
; 4030 : }

	ret	24					; 00000018H
$LN4@Init@4:

; 4005 : 						m_eCurrentState = AI_OPERATION_STATE_GATHERING_FORCES;
; 4006 : 					}
; 4007 : 					else
; 4008 : 					{
; 4009 : 						m_eCurrentState = AI_OPERATION_STATE_RECRUITING_UNITS;
; 4010 : 					}
; 4011 : 
; 4012 : 					LogOperationStart();

	mov	ecx, esi
	mov	DWORD PTR [esi+56], 1
	call	?LogOperationStart@CvAIOperation@@QAEXXZ ; CvAIOperation::LogOperationStart
	pop	edi
	pop	ebx
	pop	esi

; 4027 : 			}
; 4028 : 		}
; 4029 : 	}
; 4030 : }

	ret	24					; 00000018H
$LN5@Init@4:
	pop	edi

; 4013 : 				}
; 4014 : 				else
; 4015 : 				{
; 4016 : 					// No muster point, abort
; 4017 : 					m_eCurrentState = AI_OPERATION_STATE_ABORTED;
; 4018 : 					m_eAbortReason = AI_ABORT_NO_MUSTER;
; 4019 : 				}
; 4020 : 			}
; 4021 : 
; 4022 : 			else
; 4023 : 			{
; 4024 : 				// Lost our target, abort
; 4025 : 				m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	DWORD PTR [esi+56], ebx
	pop	ebx
	mov	DWORD PTR [esi+60], 7
	pop	esi

; 4027 : 			}
; 4028 : 		}
; 4029 : 	}
; 4030 : }

	ret	24					; 00000018H
$LN6@Init@4:

; 4026 : 				m_eAbortReason = AI_ABORT_LOST_TARGET;

	mov	DWORD PTR [esi+60], 3
	mov	DWORD PTR [esi+56], ebx
$LN27@Init@4:
	pop	edi
	pop	ebx
$LN1@Init@4:
	pop	esi

; 4027 : 			}
; 4028 : 		}
; 4029 : 	}
; 4030 : }

	ret	24					; 00000018H
?Init@CvAIOperationNavalBombardment@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ENDP ; CvAIOperationNavalBombardment::Init
_TEXT	ENDS
PUBLIC	??_7CvAIOperationNavalSuperiority@@6B@		; CvAIOperationNavalSuperiority::`vftable'
PUBLIC	??0CvAIOperationNavalSuperiority@@QAE@XZ	; CvAIOperationNavalSuperiority::CvAIOperationNavalSuperiority
PUBLIC	??_R4CvAIOperationNavalSuperiority@@6B@		; CvAIOperationNavalSuperiority::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvAIOperationNavalSuperiority@@@8	; CvAIOperationNavalSuperiority `RTTI Type Descriptor'
PUBLIC	??_R3CvAIOperationNavalSuperiority@@8		; CvAIOperationNavalSuperiority::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvAIOperationNavalSuperiority@@8		; CvAIOperationNavalSuperiority::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvAIOperationNavalSuperiority@@8	; CvAIOperationNavalSuperiority::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?Init@CvAIOperationNavalSuperiority@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ; CvAIOperationNavalSuperiority::Init
PUBLIC	?GetOperationType@CvAIOperationNavalSuperiority@@UBEHXZ ; CvAIOperationNavalSuperiority::GetOperationType
PUBLIC	?CanTacticalAIInterruptOperation@CvAIOperationNavalSuperiority@@UBE_NXZ ; CvAIOperationNavalSuperiority::CanTacticalAIInterruptOperation
PUBLIC	?Read@CvAIOperationNavalSuperiority@@UAEXAAVFDataStream@@@Z ; CvAIOperationNavalSuperiority::Read
PUBLIC	?GetOperationName@CvAIOperationNavalSuperiority@@UBE?AVCvString@@XZ ; CvAIOperationNavalSuperiority::GetOperationName
PUBLIC	?FindBestTarget@CvAIOperationNavalSuperiority@@MAEPAVCvPlot@@XZ ; CvAIOperationNavalSuperiority::FindBestTarget
EXTRN	??_ECvAIOperationNavalSuperiority@@UAEPAXI@Z:PROC ; CvAIOperationNavalSuperiority::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvAIOperationNavalSuperiority@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvAIOperationNavalSuperiority@@8 DD FLAT:??_R0?AVCvAIOperationNavalSuperiority@@@8 ; CvAIOperationNavalSuperiority::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvAIOperationNavalSuperiority@@8
rdata$r	ENDS
;	COMDAT ??_R2CvAIOperationNavalSuperiority@@8
rdata$r	SEGMENT
??_R2CvAIOperationNavalSuperiority@@8 DD FLAT:??_R1A@?0A@EA@CvAIOperationNavalSuperiority@@8 ; CvAIOperationNavalSuperiority::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvAINavalOperation@@8
	DD	FLAT:??_R1A@?0A@EA@CvAIEnemyTerritoryOperation@@8
	DD	FLAT:??_R1A@?0A@EA@CvAIOperation@@8
rdata$r	ENDS
;	COMDAT ??_R3CvAIOperationNavalSuperiority@@8
rdata$r	SEGMENT
??_R3CvAIOperationNavalSuperiority@@8 DD 00H		; CvAIOperationNavalSuperiority::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2CvAIOperationNavalSuperiority@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvAIOperationNavalSuperiority@@@8
_DATA	SEGMENT
??_R0?AVCvAIOperationNavalSuperiority@@@8 DD FLAT:??_7type_info@@6B@ ; CvAIOperationNavalSuperiority `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvAIOperationNavalSuperiority@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvAIOperationNavalSuperiority@@6B@
rdata$r	SEGMENT
??_R4CvAIOperationNavalSuperiority@@6B@ DD 00H		; CvAIOperationNavalSuperiority::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvAIOperationNavalSuperiority@@@8
	DD	FLAT:??_R3CvAIOperationNavalSuperiority@@8
rdata$r	ENDS
;	COMDAT ??_7CvAIOperationNavalSuperiority@@6B@
CONST	SEGMENT
??_7CvAIOperationNavalSuperiority@@6B@ DD FLAT:??_R4CvAIOperationNavalSuperiority@@6B@ ; CvAIOperationNavalSuperiority::`vftable'
	DD	FLAT:??_ECvAIOperationNavalSuperiority@@UAEPAXI@Z
	DD	FLAT:?Init@CvAIOperationNavalSuperiority@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAIOperationNavalSuperiority@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperationNavalSuperiority@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAINavalOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAINavalOperation@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAINavalOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAINavalOperation@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:?ArmyInPosition@CvAIOperationNavalSuperiority@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperation@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAIOperation@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAIOperationNavalSuperiority@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAIOperationNavalSuperiority@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAIOperationNavalSuperiority@@UBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAINavalOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	DD	FLAT:?GetDeployRange@CvAINavalOperation@@UBEHXZ
	DD	FLAT:?FindBestTarget@CvAIOperationNavalSuperiority@@MAEPAVCvPlot@@XZ
	DD	FLAT:?FindInitialUnit@CvAINavalOperation@@MAEPAVCvUnit@@XZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvAIOperationNavalSuperiority@@QAE@XZ
_TEXT	SEGMENT
??0CvAIOperationNavalSuperiority@@QAE@XZ PROC		; CvAIOperationNavalSuperiority::CvAIOperationNavalSuperiority, COMDAT
; _this$ = ecx

; 4203 : {

	push	esi
	mov	esi, ecx
	call	??0CvAIOperation@@QAE@XZ		; CvAIOperation::CvAIOperation
	mov	DWORD PTR [esi], OFFSET ??_7CvAIOperationNavalSuperiority@@6B@

; 4204 : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvAIOperationNavalSuperiority@@QAE@XZ ENDP		; CvAIOperationNavalSuperiority::CvAIOperationNavalSuperiority
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
_TEXT	ENDS
;	COMDAT ?GetOperationType@CvAIOperationNavalSuperiority@@UBEHXZ
_TEXT	SEGMENT
?GetOperationType@CvAIOperationNavalSuperiority@@UBEHXZ PROC ; CvAIOperationNavalSuperiority::GetOperationType, COMDAT
; _this$ = ecx

; 749  : 		return AI_OPERATION_NAVAL_SUPERIORITY;

	mov	eax, 10					; 0000000aH

; 750  : 	}

	ret	0
?GetOperationType@CvAIOperationNavalSuperiority@@UBEHXZ ENDP ; CvAIOperationNavalSuperiority::GetOperationType
_TEXT	ENDS
PUBLIC	??_C@_0BP@KMLLCJHO@AI_OPERATION_NAVAL_SUPERIORITY?$AA@ ; `string'
;	COMDAT ??_C@_0BP@KMLLCJHO@AI_OPERATION_NAVAL_SUPERIORITY?$AA@
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BP@KMLLCJHO@AI_OPERATION_NAVAL_SUPERIORITY?$AA@ DB 'AI_OPERATION_N'
	DB	'AVAL_SUPERIORITY', 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
CONST	ENDS
;	COMDAT ?GetOperationName@CvAIOperationNavalSuperiority@@UBE?AVCvString@@XZ
_TEXT	SEGMENT
$T247144 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetOperationName@CvAIOperationNavalSuperiority@@UBE?AVCvString@@XZ PROC ; CvAIOperationNavalSuperiority::GetOperationName, COMDAT
; _this$ = ecx

; 752  : 	{

	push	ecx
	push	esi

; 753  : 		return CvString("AI_OPERATION_NAVAL_SUPERIORITY");

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	push	OFFSET ??_C@_0BP@KMLLCJHO@AI_OPERATION_NAVAL_SUPERIORITY?$AA@
	mov	ecx, esi
	mov	DWORD PTR $T247144[esp+12], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi

; 754  : 	}

	pop	ecx
	ret	4
?GetOperationName@CvAIOperationNavalSuperiority@@UBE?AVCvString@@XZ ENDP ; CvAIOperationNavalSuperiority::GetOperationName
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?CanTacticalAIInterruptOperation@CvAIOperationNavalSuperiority@@UBE_NXZ
_TEXT	SEGMENT
?CanTacticalAIInterruptOperation@CvAIOperationNavalSuperiority@@UBE_NXZ PROC ; CvAIOperationNavalSuperiority::CanTacticalAIInterruptOperation, COMDAT
; _this$ = ecx

; 757  : 		return true;

	mov	al, 1

; 758  : 	}

	ret	0
?CanTacticalAIInterruptOperation@CvAIOperationNavalSuperiority@@UBE_NXZ ENDP ; CvAIOperationNavalSuperiority::CanTacticalAIInterruptOperation
_TEXT	ENDS
PUBLIC	??1CvAIOperationNavalSuperiority@@UAE@XZ	; CvAIOperationNavalSuperiority::~CvAIOperationNavalSuperiority
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
;	COMDAT ??1CvAIOperationNavalSuperiority@@UAE@XZ
_TEXT	SEGMENT
??1CvAIOperationNavalSuperiority@@UAE@XZ PROC		; CvAIOperationNavalSuperiority::~CvAIOperationNavalSuperiority, COMDAT
; _this$ = ecx

; 4209 : }

	mov	DWORD PTR [ecx], OFFSET ??_7CvAIEnemyTerritoryOperation@@6B@
	jmp	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
??1CvAIOperationNavalSuperiority@@UAE@XZ ENDP		; CvAIOperationNavalSuperiority::~CvAIOperationNavalSuperiority
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Init@CvAIOperationNavalSuperiority@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
_TEXT	SEGMENT
$T247175 = 8						; size = 4
_iID$ = 8						; size = 4
_eOwner$ = 12						; size = 4
_eEnemy$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 4
?Init@CvAIOperationNavalSuperiority@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z PROC ; CvAIOperationNavalSuperiority::Init, COMDAT
; _this$ = ecx

; 4213 : {

	push	esi
	mov	esi, ecx

; 4214 : 	Reset();

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+12]
	call	edx

; 4215 : 	m_eMoveType = AI_OPERATION_MOVETYPE_FREEFORM_NAVAL;
; 4216 : 	m_iID = iID;

	mov	eax, DWORD PTR _iID$[esp]

; 4217 : 	m_eOwner = eOwner;

	mov	ecx, DWORD PTR _eOwner$[esp]

; 4218 : 	m_eEnemy = eEnemy;

	mov	edx, DWORD PTR _eEnemy$[esp]
	mov	DWORD PTR [esi+84], 3
	mov	DWORD PTR [esi+52], eax
	mov	DWORD PTR [esi+72], ecx
	mov	DWORD PTR [esi+76], edx

; 4219 : 
; 4220 : 	if(iID != -1 && GetOperationStartCity())

	cmp	eax, -1
	je	$LN1@Init@5
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+52]
	mov	ecx, esi
	call	edx
	test	eax, eax
	je	$LN1@Init@5

; 4221 : 	{
; 4222 : 		// create the armies that are needed and set the state to ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE
; 4223 : 		CvPlayer& kPlayer = GET_PLAYER(m_eOwner);

	mov	ecx, DWORD PTR [esi+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebx
	push	edi

; 4224 : 		CvArmyAI* pArmyAI = kPlayer.addArmyAI();

	call	?addArmyAI@CvPlayer@@QAEPAVCvArmyAI@@XZ	; CvPlayer::addArmyAI
	mov	edi, eax

; 4225 : 		if(pArmyAI)

	xor	ebx, ebx
	cmp	edi, ebx
	je	$LN27@Init@5

; 4226 : 		{
; 4227 : 			m_viArmyIDs.push_back(pArmyAI->GetID());

	mov	ecx, edi
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	mov	DWORD PTR $T247175[esp+8], eax
	lea	eax, DWORD PTR $T247175[esp+8]
	push	eax
	lea	ecx, DWORD PTR [esi+4]
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 4228 : 			pArmyAI->Init(pArmyAI->GetID(),m_eOwner,m_iID);

	mov	ecx, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [esi+72]
	push	ecx
	push	edx
	mov	ecx, edi
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	push	eax
	mov	ecx, edi
	call	?Init@CvArmyAI@@QAEXHW4PlayerTypes@@H@Z	; CvArmyAI::Init

; 4229 : 			pArmyAI->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE);

	push	ebx
	mov	ecx, edi
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 4230 : 			pArmyAI->SetFormationIndex(GetFormation());

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+32]
	mov	ecx, esi
	call	edx
	push	eax
	mov	ecx, edi
	call	?SetFormationIndex@CvArmyAI@@QAEXH@Z	; CvArmyAI::SetFormationIndex

; 4231 : 
; 4232 : 			// Figure out the initial rally point
; 4233 : 			CvPlot* pTargetPlot = FindBestTarget();

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+148]
	mov	ecx, esi
	call	edx

; 4234 : 			if(pTargetPlot != NULL)

	cmp	eax, ebx
	je	$LN6@Init@5

; 4235 : 			{
; 4236 : 				SetTargetPlot(pTargetPlot);

	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR [esi+104], ecx
	movsx	edx, WORD PTR [eax+2]

; 4237 : 				pArmyAI->SetGoalPlot(pTargetPlot);

	push	eax
	mov	ecx, edi
	mov	DWORD PTR [esi+108], edx
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 4238 : 				if(SelectInitialMusterPoint(pArmyAI) != NULL)

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+136]
	push	edi
	mov	ecx, esi
	call	edx
	test	eax, eax
	je	$LN5@Init@5

; 4239 : 				{
; 4240 : 					pArmyAI->SetXY(GetMusterPlot()->getX(), GetMusterPlot()->getY());

	mov	ecx, esi
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	ecx, esi
	mov	ebx, eax
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	movsx	eax, WORD PTR [eax+2]
	movsx	ecx, WORD PTR [ebx]
	push	eax
	push	ecx
	mov	ecx, edi
	call	?SetXY@CvArmyAI@@QAEXHH@Z		; CvArmyAI::SetXY

; 4241 : 					SetDefaultArea(GetMusterPlot()->getArea());

	mov	ecx, esi
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	edx, DWORD PTR [eax+356]

; 4242 : 
; 4243 : 					// Find the list of units we need to build before starting this operation in earnest
; 4244 : 					BuildListOfUnitsWeStillNeedToBuild();

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [esi+64], edx
	mov	edx, DWORD PTR [eax+92]
	mov	ecx, esi
	call	edx

; 4245 : 
; 4246 : 					// try to get as many units as possible from existing units that are waiting around
; 4247 : 					if(GrabUnitsFromTheReserves(GetMusterPlot(), GetMusterPlot()))

	mov	ebx, DWORD PTR [esi]
	mov	ecx, esi
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	push	eax
	mov	ecx, esi
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	push	eax
	mov	eax, DWORD PTR [ebx+112]
	mov	ecx, esi
	call	eax
	test	al, al
	je	SHORT $LN4@Init@5

; 4248 : 					{
; 4249 : 						pArmyAI->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_CATCH_UP);

	push	1
	mov	ecx, edi
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 4250 : 						m_eCurrentState = AI_OPERATION_STATE_MOVING_TO_TARGET;
; 4251 : 					}
; 4252 : 					else
; 4253 : 					{
; 4254 : 						m_eCurrentState = AI_OPERATION_STATE_RECRUITING_UNITS;
; 4255 : 					}
; 4256 : 
; 4257 : 					LogOperationStart();

	mov	ecx, esi
	mov	DWORD PTR [esi+56], 3
	call	?LogOperationStart@CvAIOperation@@QAEXXZ ; CvAIOperation::LogOperationStart
	pop	edi
	pop	ebx
	pop	esi

; 4272 : 			}
; 4273 : 		}
; 4274 : 	}
; 4275 : }

	ret	24					; 00000018H
$LN4@Init@5:

; 4250 : 						m_eCurrentState = AI_OPERATION_STATE_MOVING_TO_TARGET;
; 4251 : 					}
; 4252 : 					else
; 4253 : 					{
; 4254 : 						m_eCurrentState = AI_OPERATION_STATE_RECRUITING_UNITS;
; 4255 : 					}
; 4256 : 
; 4257 : 					LogOperationStart();

	mov	ecx, esi
	mov	DWORD PTR [esi+56], 1
	call	?LogOperationStart@CvAIOperation@@QAEXXZ ; CvAIOperation::LogOperationStart
	pop	edi
	pop	ebx
	pop	esi

; 4272 : 			}
; 4273 : 		}
; 4274 : 	}
; 4275 : }

	ret	24					; 00000018H
$LN5@Init@5:
	pop	edi

; 4258 : 				}
; 4259 : 				else
; 4260 : 				{
; 4261 : 					// No muster point, abort
; 4262 : 					m_eCurrentState = AI_OPERATION_STATE_ABORTED;
; 4263 : 					m_eAbortReason = AI_ABORT_NO_MUSTER;
; 4264 : 				}
; 4265 : 			}
; 4266 : 
; 4267 : 			else
; 4268 : 			{
; 4269 : 				// Lost our target, abort
; 4270 : 				m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	DWORD PTR [esi+56], ebx
	pop	ebx
	mov	DWORD PTR [esi+60], 7
	pop	esi

; 4272 : 			}
; 4273 : 		}
; 4274 : 	}
; 4275 : }

	ret	24					; 00000018H
$LN6@Init@5:

; 4271 : 				m_eAbortReason = AI_ABORT_LOST_TARGET;

	mov	DWORD PTR [esi+60], 3
	mov	DWORD PTR [esi+56], ebx
$LN27@Init@5:
	pop	edi
	pop	ebx
$LN1@Init@5:
	pop	esi

; 4272 : 			}
; 4273 : 		}
; 4274 : 	}
; 4275 : }

	ret	24					; 00000018H
?Init@CvAIOperationNavalSuperiority@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ENDP ; CvAIOperationNavalSuperiority::Init
_TEXT	ENDS
PUBLIC	??_7CvAIOperationPureNavalCityAttack@@6B@	; CvAIOperationPureNavalCityAttack::`vftable'
PUBLIC	??0CvAIOperationPureNavalCityAttack@@QAE@XZ	; CvAIOperationPureNavalCityAttack::CvAIOperationPureNavalCityAttack
PUBLIC	??_R4CvAIOperationPureNavalCityAttack@@6B@	; CvAIOperationPureNavalCityAttack::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvAIOperationPureNavalCityAttack@@@8	; CvAIOperationPureNavalCityAttack `RTTI Type Descriptor'
PUBLIC	??_R3CvAIOperationPureNavalCityAttack@@8	; CvAIOperationPureNavalCityAttack::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvAIOperationPureNavalCityAttack@@8	; CvAIOperationPureNavalCityAttack::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvAIOperationPureNavalCityAttack@@8 ; CvAIOperationPureNavalCityAttack::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?Init@CvAIOperationPureNavalCityAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ; CvAIOperationPureNavalCityAttack::Init
PUBLIC	?GetOperationType@CvAIOperationPureNavalCityAttack@@UBEHXZ ; CvAIOperationPureNavalCityAttack::GetOperationType
PUBLIC	?CanTacticalAIInterruptOperation@CvAIOperationPureNavalCityAttack@@UBE_NXZ ; CvAIOperationPureNavalCityAttack::CanTacticalAIInterruptOperation
PUBLIC	?GetFormation@CvAIOperationPureNavalCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ ; CvAIOperationPureNavalCityAttack::GetFormation
PUBLIC	?ShouldAbort@CvAIOperationPureNavalCityAttack@@UAE_NXZ ; CvAIOperationPureNavalCityAttack::ShouldAbort
PUBLIC	?Read@CvAIOperationPureNavalCityAttack@@UAEXAAVFDataStream@@@Z ; CvAIOperationPureNavalCityAttack::Read
PUBLIC	?GetOperationName@CvAIOperationPureNavalCityAttack@@UBE?AVCvString@@XZ ; CvAIOperationPureNavalCityAttack::GetOperationName
EXTRN	??_ECvAIOperationPureNavalCityAttack@@UAEPAXI@Z:PROC ; CvAIOperationPureNavalCityAttack::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvAIOperationPureNavalCityAttack@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvAIOperationPureNavalCityAttack@@8 DD FLAT:??_R0?AVCvAIOperationPureNavalCityAttack@@@8 ; CvAIOperationPureNavalCityAttack::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvAIOperationPureNavalCityAttack@@8
rdata$r	ENDS
;	COMDAT ??_R2CvAIOperationPureNavalCityAttack@@8
rdata$r	SEGMENT
??_R2CvAIOperationPureNavalCityAttack@@8 DD FLAT:??_R1A@?0A@EA@CvAIOperationPureNavalCityAttack@@8 ; CvAIOperationPureNavalCityAttack::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvAINavalOperation@@8
	DD	FLAT:??_R1A@?0A@EA@CvAIEnemyTerritoryOperation@@8
	DD	FLAT:??_R1A@?0A@EA@CvAIOperation@@8
rdata$r	ENDS
;	COMDAT ??_R3CvAIOperationPureNavalCityAttack@@8
rdata$r	SEGMENT
??_R3CvAIOperationPureNavalCityAttack@@8 DD 00H		; CvAIOperationPureNavalCityAttack::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2CvAIOperationPureNavalCityAttack@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvAIOperationPureNavalCityAttack@@@8
_DATA	SEGMENT
??_R0?AVCvAIOperationPureNavalCityAttack@@@8 DD FLAT:??_7type_info@@6B@ ; CvAIOperationPureNavalCityAttack `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvAIOperationPureNavalCityAttack@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvAIOperationPureNavalCityAttack@@6B@
rdata$r	SEGMENT
??_R4CvAIOperationPureNavalCityAttack@@6B@ DD 00H	; CvAIOperationPureNavalCityAttack::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvAIOperationPureNavalCityAttack@@@8
	DD	FLAT:??_R3CvAIOperationPureNavalCityAttack@@8
rdata$r	ENDS
;	COMDAT ??_7CvAIOperationPureNavalCityAttack@@6B@
CONST	SEGMENT
??_7CvAIOperationPureNavalCityAttack@@6B@ DD FLAT:??_R4CvAIOperationPureNavalCityAttack@@6B@ ; CvAIOperationPureNavalCityAttack::`vftable'
	DD	FLAT:??_ECvAIOperationPureNavalCityAttack@@UAEPAXI@Z
	DD	FLAT:?Init@CvAIOperationPureNavalCityAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAIOperationPureNavalCityAttack@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperationPureNavalCityAttack@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAINavalOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAIOperationPureNavalCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAINavalOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAINavalOperation@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:?ArmyInPosition@CvAIOperationPureNavalCityAttack@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperationPureNavalCityAttack@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAIOperation@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAIOperationPureNavalCityAttack@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAIOperationPureNavalCityAttack@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAIOperationPureNavalCityAttack@@UBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAINavalOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	DD	FLAT:?GetDeployRange@CvAIOperationPureNavalCityAttack@@UBEHXZ
	DD	FLAT:?FindBestTarget@CvAIOperationPureNavalCityAttack@@MAEPAVCvPlot@@XZ
	DD	FLAT:?FindInitialUnit@CvAINavalOperation@@MAEPAVCvUnit@@XZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvAIOperationPureNavalCityAttack@@QAE@XZ
_TEXT	SEGMENT
??0CvAIOperationPureNavalCityAttack@@QAE@XZ PROC	; CvAIOperationPureNavalCityAttack::CvAIOperationPureNavalCityAttack, COMDAT
; _this$ = ecx

; 4577 : {

	push	esi
	mov	esi, ecx
	call	??0CvAIOperation@@QAE@XZ		; CvAIOperation::CvAIOperation
	mov	DWORD PTR [esi], OFFSET ??_7CvAIOperationPureNavalCityAttack@@6B@

; 4578 : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvAIOperationPureNavalCityAttack@@QAE@XZ ENDP	; CvAIOperationPureNavalCityAttack::CvAIOperationPureNavalCityAttack
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
_TEXT	ENDS
;	COMDAT ?GetFormation@CvAIOperationPureNavalCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ
_TEXT	SEGMENT
?GetFormation@CvAIOperationPureNavalCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ PROC ; CvAIOperationPureNavalCityAttack::GetFormation, COMDAT
; _this$ = ecx

; 782  : 		return MUFORMATION_PURE_NAVAL_CITY_ATTACK;

	mov	eax, 17					; 00000011H

; 783  : 	}

	ret	0
?GetFormation@CvAIOperationPureNavalCityAttack@@UBE?AW4MultiunitFormationTypes@@XZ ENDP ; CvAIOperationPureNavalCityAttack::GetFormation
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetOperationType@CvAIOperationPureNavalCityAttack@@UBEHXZ
_TEXT	SEGMENT
?GetOperationType@CvAIOperationPureNavalCityAttack@@UBEHXZ PROC ; CvAIOperationPureNavalCityAttack::GetOperationType, COMDAT
; _this$ = ecx

; 786  : 		return AI_OPERATION_PURE_NAVAL_CITY_ATTACK;

	mov	eax, 18					; 00000012H

; 787  : 	}

	ret	0
?GetOperationType@CvAIOperationPureNavalCityAttack@@UBEHXZ ENDP ; CvAIOperationPureNavalCityAttack::GetOperationType
_TEXT	ENDS
PUBLIC	??_C@_0CE@CIPDILDI@AI_OPERATION_PURE_NAVAL_CITY_ATT@ ; `string'
;	COMDAT ??_C@_0CE@CIPDILDI@AI_OPERATION_PURE_NAVAL_CITY_ATT@
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0CE@CIPDILDI@AI_OPERATION_PURE_NAVAL_CITY_ATT@ DB 'AI_OPERATION_PUR'
	DB	'E_NAVAL_CITY_ATTACK', 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
CONST	ENDS
;	COMDAT ?GetOperationName@CvAIOperationPureNavalCityAttack@@UBE?AVCvString@@XZ
_TEXT	SEGMENT
$T247233 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetOperationName@CvAIOperationPureNavalCityAttack@@UBE?AVCvString@@XZ PROC ; CvAIOperationPureNavalCityAttack::GetOperationName, COMDAT
; _this$ = ecx

; 789  : 	{

	push	ecx
	push	esi

; 790  : 		return CvString("AI_OPERATION_PURE_NAVAL_CITY_ATTACK");

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	push	OFFSET ??_C@_0CE@CIPDILDI@AI_OPERATION_PURE_NAVAL_CITY_ATT@
	mov	ecx, esi
	mov	DWORD PTR $T247233[esp+12], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi

; 791  : 	}

	pop	ecx
	ret	4
?GetOperationName@CvAIOperationPureNavalCityAttack@@UBE?AVCvString@@XZ ENDP ; CvAIOperationPureNavalCityAttack::GetOperationName
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?CanTacticalAIInterruptOperation@CvAIOperationPureNavalCityAttack@@UBE_NXZ
_TEXT	SEGMENT
?CanTacticalAIInterruptOperation@CvAIOperationPureNavalCityAttack@@UBE_NXZ PROC ; CvAIOperationPureNavalCityAttack::CanTacticalAIInterruptOperation, COMDAT
; _this$ = ecx

; 794  : 		return true;

	mov	al, 1

; 795  : 	}

	ret	0
?CanTacticalAIInterruptOperation@CvAIOperationPureNavalCityAttack@@UBE_NXZ ENDP ; CvAIOperationPureNavalCityAttack::CanTacticalAIInterruptOperation
_TEXT	ENDS
PUBLIC	??1CvAIOperationPureNavalCityAttack@@UAE@XZ	; CvAIOperationPureNavalCityAttack::~CvAIOperationPureNavalCityAttack
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
;	COMDAT ??1CvAIOperationPureNavalCityAttack@@UAE@XZ
_TEXT	SEGMENT
??1CvAIOperationPureNavalCityAttack@@UAE@XZ PROC	; CvAIOperationPureNavalCityAttack::~CvAIOperationPureNavalCityAttack, COMDAT
; _this$ = ecx

; 4583 : }

	mov	DWORD PTR [ecx], OFFSET ??_7CvAIEnemyTerritoryOperation@@6B@
	jmp	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
??1CvAIOperationPureNavalCityAttack@@UAE@XZ ENDP	; CvAIOperationPureNavalCityAttack::~CvAIOperationPureNavalCityAttack
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Init@CvAIOperationPureNavalCityAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
_TEXT	SEGMENT
$T247264 = 8						; size = 4
_iID$ = 8						; size = 4
_eOwner$ = 12						; size = 4
_eEnemy$ = 16						; size = 4
___formal$ = 20						; size = 4
_pTarget$ = 24						; size = 4
_pMuster$ = 28						; size = 4
?Init@CvAIOperationPureNavalCityAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z PROC ; CvAIOperationPureNavalCityAttack::Init, COMDAT
; _this$ = ecx

; 4587 : {

	push	esi
	mov	esi, ecx

; 4588 : 	Reset();

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+12]
	call	edx

; 4589 : 	m_eMoveType = AI_OPERATION_MOVETYPE_ENEMY_TERRITORY;
; 4590 : 	m_iID = iID;

	mov	ecx, DWORD PTR _iID$[esp]

; 4591 : 	m_eOwner = eOwner;

	mov	eax, DWORD PTR _eOwner$[esp]

; 4592 : 	m_eEnemy = eEnemy;

	mov	edx, DWORD PTR _eEnemy$[esp]
	mov	DWORD PTR [esi+84], 1
	mov	DWORD PTR [esi+52], ecx
	mov	DWORD PTR [esi+72], eax
	mov	DWORD PTR [esi+76], edx

; 4593 : 
; 4594 : 	if(iID != -1)

	cmp	ecx, -1
	je	$LN1@Init@6

; 4595 : 	{
; 4596 : 		// create the armies that are needed and set the state to ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE
; 4597 : 		CvPlayer& kPlayer = GET_PLAYER(m_eOwner);

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebx
	mov	ebx, eax
	push	edi

; 4598 : 		CvArmyAI* pArmyAI = kPlayer.addArmyAI();

	mov	ecx, ebx
	call	?addArmyAI@CvPlayer@@QAEPAVCvArmyAI@@XZ	; CvPlayer::addArmyAI
	mov	edi, eax

; 4599 : 		if(pArmyAI)

	test	edi, edi
	je	$LN39@Init@6

; 4600 : 		{
; 4601 : 			m_viArmyIDs.push_back(pArmyAI->GetID());

	mov	ecx, edi
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	mov	DWORD PTR $T247264[esp+8], eax
	lea	eax, DWORD PTR $T247264[esp+8]
	push	eax
	lea	ecx, DWORD PTR [esi+4]
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 4602 : 			pArmyAI->Init(pArmyAI->GetID(),m_eOwner,m_iID);

	mov	ecx, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [esi+72]
	push	ecx
	push	edx
	mov	ecx, edi
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	push	eax
	mov	ecx, edi
	call	?Init@CvArmyAI@@QAEXHW4PlayerTypes@@H@Z	; CvArmyAI::Init

; 4603 : 			pArmyAI->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE);

	push	0
	mov	ecx, edi
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 4604 : 			pArmyAI->SetFormationIndex(GetFormation());

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+32]
	mov	ecx, esi
	call	edx
	push	eax
	mov	ecx, edi
	call	?SetFormationIndex@CvArmyAI@@QAEXH@Z	; CvArmyAI::SetFormationIndex

; 4605 : 
; 4606 : 			if(pTarget)

	mov	ecx, DWORD PTR _pTarget$[esp+8]
	test	ecx, ecx
	je	$LN6@Init@6

; 4607 : 			{
; 4608 : 				SetTargetPlot(pTarget->plot());

	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR [esi+104], ecx
	movsx	edx, WORD PTR [eax+2]

; 4609 : 				pArmyAI->SetGoalPlot(GetTargetPlot());

	mov	ecx, esi
	mov	DWORD PTR [esi+108], edx
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	push	eax
	mov	ecx, edi
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 4610 : 
; 4611 : 				// Muster just off the coast
; 4612 : 				CvPlot *pCoastalMuster = kPlayer.GetMilitaryAI()->GetCoastalPlotAdjacentToTarget(pMuster->plot(), pArmyAI);

	mov	ecx, DWORD PTR _pMuster$[esp+8]
	push	edi
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	push	eax
	mov	ecx, ebx
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?GetCoastalPlotAdjacentToTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAV2@PAVCvArmyAI@@@Z ; CvMilitaryAI::GetCoastalPlotAdjacentToTarget

; 4613 : 				if (pCoastalMuster)

	test	eax, eax
	je	$LN5@Init@6

; 4614 : 				{
; 4615 : 					SetDefaultArea(pCoastalMuster->getArea());

	mov	ecx, DWORD PTR [eax+356]
	mov	DWORD PTR [esi+64], ecx

; 4616 : 					SetStartCityPlot(pCoastalMuster);

	movsx	edx, WORD PTR [eax]
	mov	DWORD PTR [esi+88], edx
	movsx	eax, WORD PTR [eax+2]

; 4617 : 					SetMusterPlot(GetStartCityPlot());

	mov	ecx, esi
	mov	DWORD PTR [esi+92], eax
	call	?GetStartCityPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetStartCityPlot
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR [esi+96], ecx
	movsx	edx, WORD PTR [eax+2]

; 4618 : 					pArmyAI->SetXY(GetStartCityPlot()->getX(), GetStartCityPlot()->getY());

	mov	ecx, esi
	mov	DWORD PTR [esi+100], edx
	call	?GetStartCityPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetStartCityPlot
	mov	ecx, esi
	mov	ebx, eax
	call	?GetStartCityPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetStartCityPlot
	movsx	eax, WORD PTR [eax+2]
	movsx	ecx, WORD PTR [ebx]
	push	eax
	push	ecx
	mov	ecx, edi
	call	?SetXY@CvArmyAI@@QAEXHH@Z		; CvArmyAI::SetXY

; 4619 : 
; 4620 : 					// Find the list of units we need to build before starting this operation in earnest
; 4621 : 					BuildListOfUnitsWeStillNeedToBuild();

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+92]
	mov	ecx, esi
	call	eax

; 4622 : 
; 4623 : 					// try to get as many units as possible from existing units that are waiting around
; 4624 : 					if(GrabUnitsFromTheReserves(GetMusterPlot(), GetMusterPlot()))

	mov	ebx, DWORD PTR [esi]
	mov	ecx, esi
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	push	eax
	mov	ecx, esi
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	edx, DWORD PTR [ebx+112]
	push	eax
	mov	ecx, esi
	call	edx
	test	al, al
	je	SHORT $LN4@Init@6

; 4625 : 					{
; 4626 : 						pArmyAI->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_CATCH_UP);

	push	1
	mov	ecx, edi
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 4627 : 						m_eCurrentState = AI_OPERATION_STATE_GATHERING_FORCES;
; 4628 : 					}
; 4629 : 					else
; 4630 : 					{
; 4631 : 						m_eCurrentState = AI_OPERATION_STATE_RECRUITING_UNITS;
; 4632 : 					}
; 4633 : 
; 4634 : 					LogOperationStart();

	mov	ecx, esi
	mov	DWORD PTR [esi+56], 2
	call	?LogOperationStart@CvAIOperation@@QAEXXZ ; CvAIOperation::LogOperationStart
	pop	edi
	pop	ebx
	pop	esi

; 4649 : 			}
; 4650 : 		}
; 4651 : 	}
; 4652 : }

	ret	24					; 00000018H
$LN4@Init@6:

; 4627 : 						m_eCurrentState = AI_OPERATION_STATE_GATHERING_FORCES;
; 4628 : 					}
; 4629 : 					else
; 4630 : 					{
; 4631 : 						m_eCurrentState = AI_OPERATION_STATE_RECRUITING_UNITS;
; 4632 : 					}
; 4633 : 
; 4634 : 					LogOperationStart();

	mov	ecx, esi
	mov	DWORD PTR [esi+56], 1
	call	?LogOperationStart@CvAIOperation@@QAEXXZ ; CvAIOperation::LogOperationStart
	pop	edi
	pop	ebx
	pop	esi

; 4649 : 			}
; 4650 : 		}
; 4651 : 	}
; 4652 : }

	ret	24					; 00000018H
$LN5@Init@6:
	pop	edi
	pop	ebx

; 4635 : 				}
; 4636 : 				else
; 4637 : 				{
; 4638 : 					// No muster point, abort
; 4639 : 					m_eCurrentState = AI_OPERATION_STATE_ABORTED;
; 4640 : 					m_eAbortReason = AI_ABORT_NO_MUSTER;

	mov	DWORD PTR [esi+60], 7

; 4641 : 				}
; 4642 : 			}
; 4643 : 
; 4644 : 			else
; 4645 : 			{
; 4646 : 				// Lost our target, abort
; 4647 : 				m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	DWORD PTR [esi+56], 0
	pop	esi

; 4649 : 			}
; 4650 : 		}
; 4651 : 	}
; 4652 : }

	ret	24					; 00000018H
$LN6@Init@6:

; 4648 : 				m_eAbortReason = AI_ABORT_LOST_TARGET;

	mov	DWORD PTR [esi+60], 3
	mov	DWORD PTR [esi+56], 0
$LN39@Init@6:
	pop	edi
	pop	ebx
$LN1@Init@6:
	pop	esi

; 4649 : 			}
; 4650 : 		}
; 4651 : 	}
; 4652 : }

	ret	24					; 00000018H
?Init@CvAIOperationPureNavalCityAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ENDP ; CvAIOperationPureNavalCityAttack::Init
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?ShouldAbort@CvAIOperationPureNavalCityAttack@@UAE_NXZ
_TEXT	SEGMENT
?ShouldAbort@CvAIOperationPureNavalCityAttack@@UAE_NXZ PROC ; CvAIOperationPureNavalCityAttack::ShouldAbort, COMDAT
; _this$ = ecx

; 4736 : {

	push	ebx
	push	esi
	mov	esi, ecx

; 4737 : 	// If parent says we're done, don't even check anything else
; 4738 : 	bool rtnValue = CvAIOperation::ShouldAbort();

	call	?ShouldAbort@CvAIOperation@@UAE_NXZ	; CvAIOperation::ShouldAbort
	mov	bl, al

; 4739 : 
; 4740 : 	if(!rtnValue)

	test	bl, bl
	jne	SHORT $LN1@ShouldAbor@5

; 4741 : 	{
; 4742 : 		// See if our target city is still owned by our enemy
; 4743 : 		if(GetTargetPlot()->getOwner() != m_eEnemy)

	mov	ecx, esi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	movsx	eax, BYTE PTR [eax+4]
	cmp	eax, DWORD PTR [esi+76]

; 4744 : 		{
; 4745 : 			// Success!  The city has been captured/destroyed
; 4746 : 			return true;

	mov	al, 1
	jne	SHORT $LN3@ShouldAbor@5
$LN1@ShouldAbor@5:

; 4747 : 		}
; 4748 : 	}
; 4749 : 
; 4750 : 	return rtnValue;

	mov	al, bl
$LN3@ShouldAbor@5:
	pop	esi
	pop	ebx

; 4751 : }

	ret	0
?ShouldAbort@CvAIOperationPureNavalCityAttack@@UAE_NXZ ENDP ; CvAIOperationPureNavalCityAttack::ShouldAbort
_TEXT	ENDS
PUBLIC	??_7CvAIOperationCityCloseDefense@@6B@		; CvAIOperationCityCloseDefense::`vftable'
PUBLIC	??0CvAIOperationCityCloseDefense@@QAE@XZ	; CvAIOperationCityCloseDefense::CvAIOperationCityCloseDefense
PUBLIC	??_R4CvAIOperationCityCloseDefense@@6B@		; CvAIOperationCityCloseDefense::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvAIOperationCityCloseDefense@@@8	; CvAIOperationCityCloseDefense `RTTI Type Descriptor'
PUBLIC	??_R3CvAIOperationCityCloseDefense@@8		; CvAIOperationCityCloseDefense::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvAIOperationCityCloseDefense@@8		; CvAIOperationCityCloseDefense::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvAIOperationCityCloseDefense@@8	; CvAIOperationCityCloseDefense::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?Init@CvAIOperationCityCloseDefense@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ; CvAIOperationCityCloseDefense::Init
PUBLIC	?GetOperationType@CvAIOperationCityCloseDefense@@UBEHXZ ; CvAIOperationCityCloseDefense::GetOperationType
PUBLIC	?GetFormation@CvAIOperationCityCloseDefense@@UBE?AW4MultiunitFormationTypes@@XZ ; CvAIOperationCityCloseDefense::GetFormation
PUBLIC	?Read@CvAIOperationCityCloseDefense@@UAEXAAVFDataStream@@@Z ; CvAIOperationCityCloseDefense::Read
PUBLIC	?GetOperationName@CvAIOperationCityCloseDefense@@UBE?AVCvString@@XZ ; CvAIOperationCityCloseDefense::GetOperationName
EXTRN	??_ECvAIOperationCityCloseDefense@@UAEPAXI@Z:PROC ; CvAIOperationCityCloseDefense::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvAIOperationCityCloseDefense@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvAIOperationCityCloseDefense@@8 DD FLAT:??_R0?AVCvAIOperationCityCloseDefense@@@8 ; CvAIOperationCityCloseDefense::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvAIOperationCityCloseDefense@@8
rdata$r	ENDS
;	COMDAT ??_R2CvAIOperationCityCloseDefense@@8
rdata$r	SEGMENT
??_R2CvAIOperationCityCloseDefense@@8 DD FLAT:??_R1A@?0A@EA@CvAIOperationCityCloseDefense@@8 ; CvAIOperationCityCloseDefense::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvAIOperation@@8
rdata$r	ENDS
;	COMDAT ??_R3CvAIOperationCityCloseDefense@@8
rdata$r	SEGMENT
??_R3CvAIOperationCityCloseDefense@@8 DD 00H		; CvAIOperationCityCloseDefense::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvAIOperationCityCloseDefense@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvAIOperationCityCloseDefense@@@8
_DATA	SEGMENT
??_R0?AVCvAIOperationCityCloseDefense@@@8 DD FLAT:??_7type_info@@6B@ ; CvAIOperationCityCloseDefense `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvAIOperationCityCloseDefense@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvAIOperationCityCloseDefense@@6B@
rdata$r	SEGMENT
??_R4CvAIOperationCityCloseDefense@@6B@ DD 00H		; CvAIOperationCityCloseDefense::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvAIOperationCityCloseDefense@@@8
	DD	FLAT:??_R3CvAIOperationCityCloseDefense@@8
rdata$r	ENDS
;	COMDAT ??_7CvAIOperationCityCloseDefense@@6B@
CONST	SEGMENT
??_7CvAIOperationCityCloseDefense@@6B@ DD FLAT:??_R4CvAIOperationCityCloseDefense@@6B@ ; CvAIOperationCityCloseDefense::`vftable'
	DD	FLAT:??_ECvAIOperationCityCloseDefense@@UAEPAXI@Z
	DD	FLAT:?Init@CvAIOperationCityCloseDefense@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAIOperationCityCloseDefense@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAIOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAIOperationCityCloseDefense@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAIOperation@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:?ArmyInPosition@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperation@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAIOperation@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAIOperationCityCloseDefense@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAIOperationCityCloseDefense@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAIOperationCityCloseDefense@@UBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAIOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvAIOperationCityCloseDefense@@QAE@XZ
_TEXT	SEGMENT
??0CvAIOperationCityCloseDefense@@QAE@XZ PROC		; CvAIOperationCityCloseDefense::CvAIOperationCityCloseDefense, COMDAT
; _this$ = ecx

; 4767 : {

	push	esi
	mov	esi, ecx
	call	??0CvAIOperation@@QAE@XZ		; CvAIOperation::CvAIOperation
	mov	DWORD PTR [esi], OFFSET ??_7CvAIOperationCityCloseDefense@@6B@

; 4768 : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvAIOperationCityCloseDefense@@QAE@XZ ENDP		; CvAIOperationCityCloseDefense::CvAIOperationCityCloseDefense
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
_TEXT	ENDS
;	COMDAT ?GetOperationType@CvAIOperationCityCloseDefense@@UBEHXZ
_TEXT	SEGMENT
?GetOperationType@CvAIOperationCityCloseDefense@@UBEHXZ PROC ; CvAIOperationCityCloseDefense::GetOperationType, COMDAT
; _this$ = ecx

; 822  : 		return AI_OPERATION_CITY_CLOSE_DEFENSE;

	xor	eax, eax

; 823  : 	}

	ret	0
?GetOperationType@CvAIOperationCityCloseDefense@@UBEHXZ ENDP ; CvAIOperationCityCloseDefense::GetOperationType
_TEXT	ENDS
PUBLIC	??_C@_0CA@PDBCJBK@AI_OPERATION_CITY_CLOSE_DEFENSE?$AA@ ; `string'
;	COMDAT ??_C@_0CA@PDBCJBK@AI_OPERATION_CITY_CLOSE_DEFENSE?$AA@
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0CA@PDBCJBK@AI_OPERATION_CITY_CLOSE_DEFENSE?$AA@ DB 'AI_OPERATION_C'
	DB	'ITY_CLOSE_DEFENSE', 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
CONST	ENDS
;	COMDAT ?GetOperationName@CvAIOperationCityCloseDefense@@UBE?AVCvString@@XZ
_TEXT	SEGMENT
$T247344 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetOperationName@CvAIOperationCityCloseDefense@@UBE?AVCvString@@XZ PROC ; CvAIOperationCityCloseDefense::GetOperationName, COMDAT
; _this$ = ecx

; 825  : 	{

	push	ecx
	push	esi

; 826  : 		return CvString("AI_OPERATION_CITY_CLOSE_DEFENSE");

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	push	OFFSET ??_C@_0CA@PDBCJBK@AI_OPERATION_CITY_CLOSE_DEFENSE?$AA@
	mov	ecx, esi
	mov	DWORD PTR $T247344[esp+12], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi

; 827  : 	}

	pop	ecx
	ret	4
?GetOperationName@CvAIOperationCityCloseDefense@@UBE?AVCvString@@XZ ENDP ; CvAIOperationCityCloseDefense::GetOperationName
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetFormation@CvAIOperationCityCloseDefense@@UBE?AW4MultiunitFormationTypes@@XZ
_TEXT	SEGMENT
?GetFormation@CvAIOperationCityCloseDefense@@UBE?AW4MultiunitFormationTypes@@XZ PROC ; CvAIOperationCityCloseDefense::GetFormation, COMDAT
; _this$ = ecx

; 830  : 		return MUFORMATION_CLOSE_CITY_DEFENSE;

	mov	eax, 5

; 831  : 	}

	ret	0
?GetFormation@CvAIOperationCityCloseDefense@@UBE?AW4MultiunitFormationTypes@@XZ ENDP ; CvAIOperationCityCloseDefense::GetFormation
_TEXT	ENDS
PUBLIC	??1CvAIOperationCityCloseDefense@@UAE@XZ	; CvAIOperationCityCloseDefense::~CvAIOperationCityCloseDefense
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
;	COMDAT ??1CvAIOperationCityCloseDefense@@UAE@XZ
_TEXT	SEGMENT
??1CvAIOperationCityCloseDefense@@UAE@XZ PROC		; CvAIOperationCityCloseDefense::~CvAIOperationCityCloseDefense, COMDAT
; _this$ = ecx

; 4772 : {

	mov	DWORD PTR [ecx], OFFSET ??_7CvAIOperationCityCloseDefense@@6B@

; 4773 : }

	jmp	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
??1CvAIOperationCityCloseDefense@@UAE@XZ ENDP		; CvAIOperationCityCloseDefense::~CvAIOperationCityCloseDefense
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Init@CvAIOperationCityCloseDefense@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
_TEXT	SEGMENT
$T247365 = 8						; size = 4
_iID$ = 8						; size = 4
_eOwner$ = 12						; size = 4
_eEnemy$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 4
?Init@CvAIOperationCityCloseDefense@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z PROC ; CvAIOperationCityCloseDefense::Init, COMDAT
; _this$ = ecx

; 4777 : {

	push	esi
	mov	esi, ecx

; 4778 : 	Reset();

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+12]
	call	edx

; 4779 : 	m_iID = iID;

	mov	ecx, DWORD PTR _iID$[esp]

; 4780 : 	m_eOwner = eOwner;

	mov	eax, DWORD PTR _eOwner$[esp]

; 4781 : 	m_eEnemy = eEnemy;

	mov	edx, DWORD PTR _eEnemy$[esp]
	mov	DWORD PTR [esi+52], ecx
	mov	DWORD PTR [esi+72], eax
	mov	DWORD PTR [esi+76], edx

; 4782 : 
; 4783 : 	if(iID != -1)

	cmp	ecx, -1
	je	$LN3@Init@7

; 4784 : 	{
; 4785 : 		// create the armies that are needed and set the state to ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE
; 4786 : 		CvArmyAI* pArmyAI = GET_PLAYER(m_eOwner).addArmyAI();

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edi
	mov	ecx, eax
	call	?addArmyAI@CvPlayer@@QAEPAVCvArmyAI@@XZ	; CvPlayer::addArmyAI
	mov	edi, eax

; 4787 : 		if(pArmyAI)

	test	edi, edi
	je	$LN30@Init@7
	push	ebx

; 4788 : 		{
; 4789 : 			m_viArmyIDs.push_back(pArmyAI->GetID());

	mov	ecx, edi
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	mov	DWORD PTR $T247365[esp+8], eax
	lea	eax, DWORD PTR $T247365[esp+8]
	push	eax
	lea	ecx, DWORD PTR [esi+4]
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 4790 : 			pArmyAI->Init(pArmyAI->GetID(),m_eOwner,m_iID);

	mov	ecx, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [esi+72]
	push	ecx
	push	edx
	mov	ecx, edi
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	push	eax
	mov	ecx, edi
	call	?Init@CvArmyAI@@QAEXHW4PlayerTypes@@H@Z	; CvArmyAI::Init

; 4791 : 			pArmyAI->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE);

	push	0
	mov	ecx, edi
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 4792 : 			pArmyAI->SetFormationIndex(GetFormation());

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+32]
	mov	ecx, esi
	call	edx
	push	eax
	mov	ecx, edi
	call	?SetFormationIndex@CvArmyAI@@QAEXH@Z	; CvArmyAI::SetFormationIndex

; 4793 : 
; 4794 : 			CvPlot* pTargetPlot = FindBestTarget();

	mov	ecx, esi
	call	?FindBestTarget@CvAIOperationCityCloseDefense@@AAEPAVCvPlot@@XZ ; CvAIOperationCityCloseDefense::FindBestTarget
	mov	ebx, eax

; 4795 : 			if(pTargetPlot != NULL)

	test	ebx, ebx
	je	$LN31@Init@7

; 4796 : 			{
; 4797 : 				SetTargetPlot(pTargetPlot);

	movsx	eax, WORD PTR [ebx]
	mov	DWORD PTR [esi+104], eax
	movsx	ecx, WORD PTR [ebx+2]
	mov	DWORD PTR [esi+108], ecx

; 4798 : 				pArmyAI->SetGoalPlot(pTargetPlot);

	push	ebx
	mov	ecx, edi
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 4799 : 				SetMusterPlot(pTargetPlot);  // Gather directly at the point we're trying to defend

	movsx	edx, WORD PTR [ebx]
	mov	DWORD PTR [esi+96], edx
	movsx	eax, WORD PTR [ebx+2]

; 4800 : 				pArmyAI->SetXY(GetMusterPlot()->getX(), GetMusterPlot()->getY());

	mov	ecx, esi
	mov	DWORD PTR [esi+100], eax
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	ecx, esi
	mov	ebx, eax
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	movsx	ecx, WORD PTR [eax+2]
	movsx	edx, WORD PTR [ebx]
	push	ecx
	push	edx
	mov	ecx, edi
	call	?SetXY@CvArmyAI@@QAEXHH@Z		; CvArmyAI::SetXY

; 4801 : 				SetDefaultArea(GetMusterPlot()->getArea());

	mov	ecx, esi
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	eax, DWORD PTR [eax+356]

; 4802 : 
; 4803 : 				// Find the list of units we need to build before starting this operation in earnest
; 4804 : 				BuildListOfUnitsWeStillNeedToBuild();

	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [esi+64], eax
	mov	eax, DWORD PTR [edx+92]
	mov	ecx, esi
	call	eax

; 4805 : 
; 4806 : 				// Try to get as many units as possible from existing units that are waiting around
; 4807 : 				if(GrabUnitsFromTheReserves(GetMusterPlot(), NULL))

	mov	ebx, DWORD PTR [esi]
	push	0
	mov	ecx, esi
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	edx, DWORD PTR [ebx+112]
	push	eax
	mov	ecx, esi
	call	edx
	test	al, al
	je	SHORT $LN2@Init@7

; 4808 : 				{
; 4809 : 					pArmyAI->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_CATCH_UP);

	push	1
	mov	ecx, edi
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 4810 : 					m_eCurrentState = AI_OPERATION_STATE_GATHERING_FORCES;
; 4811 : 				}
; 4812 : 				else
; 4813 : 				{
; 4814 : 					m_eCurrentState = AI_OPERATION_STATE_RECRUITING_UNITS;
; 4815 : 				}
; 4816 : 
; 4817 : 				LogOperationStart();

	mov	ecx, esi
	mov	DWORD PTR [esi+56], 2
	call	?LogOperationStart@CvAIOperation@@QAEXXZ ; CvAIOperation::LogOperationStart
	pop	ebx
	pop	edi
	pop	esi

; 4818 : 			}
; 4819 : 		}
; 4820 : 	}
; 4821 : }

	ret	24					; 00000018H
$LN2@Init@7:

; 4810 : 					m_eCurrentState = AI_OPERATION_STATE_GATHERING_FORCES;
; 4811 : 				}
; 4812 : 				else
; 4813 : 				{
; 4814 : 					m_eCurrentState = AI_OPERATION_STATE_RECRUITING_UNITS;
; 4815 : 				}
; 4816 : 
; 4817 : 				LogOperationStart();

	mov	ecx, esi
	mov	DWORD PTR [esi+56], 1
	call	?LogOperationStart@CvAIOperation@@QAEXXZ ; CvAIOperation::LogOperationStart
$LN31@Init@7:
	pop	ebx
$LN30@Init@7:
	pop	edi
$LN3@Init@7:
	pop	esi

; 4818 : 			}
; 4819 : 		}
; 4820 : 	}
; 4821 : }

	ret	24					; 00000018H
?Init@CvAIOperationCityCloseDefense@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ENDP ; CvAIOperationCityCloseDefense::Init
_TEXT	ENDS
PUBLIC	??_7CvAIOperationRapidResponse@@6B@		; CvAIOperationRapidResponse::`vftable'
PUBLIC	??0CvAIOperationRapidResponse@@QAE@XZ		; CvAIOperationRapidResponse::CvAIOperationRapidResponse
PUBLIC	??_R4CvAIOperationRapidResponse@@6B@		; CvAIOperationRapidResponse::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvAIOperationRapidResponse@@@8		; CvAIOperationRapidResponse `RTTI Type Descriptor'
PUBLIC	??_R3CvAIOperationRapidResponse@@8		; CvAIOperationRapidResponse::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvAIOperationRapidResponse@@8		; CvAIOperationRapidResponse::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvAIOperationRapidResponse@@8	; CvAIOperationRapidResponse::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?Init@CvAIOperationRapidResponse@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ; CvAIOperationRapidResponse::Init
PUBLIC	?GetOperationType@CvAIOperationRapidResponse@@UBEHXZ ; CvAIOperationRapidResponse::GetOperationType
PUBLIC	?GetFormation@CvAIOperationRapidResponse@@UBE?AW4MultiunitFormationTypes@@XZ ; CvAIOperationRapidResponse::GetFormation
PUBLIC	?Read@CvAIOperationRapidResponse@@UAEXAAVFDataStream@@@Z ; CvAIOperationRapidResponse::Read
PUBLIC	?GetOperationName@CvAIOperationRapidResponse@@UBE?AVCvString@@XZ ; CvAIOperationRapidResponse::GetOperationName
EXTRN	??_ECvAIOperationRapidResponse@@UAEPAXI@Z:PROC	; CvAIOperationRapidResponse::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvAIOperationRapidResponse@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvAIOperationRapidResponse@@8 DD FLAT:??_R0?AVCvAIOperationRapidResponse@@@8 ; CvAIOperationRapidResponse::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvAIOperationRapidResponse@@8
rdata$r	ENDS
;	COMDAT ??_R2CvAIOperationRapidResponse@@8
rdata$r	SEGMENT
??_R2CvAIOperationRapidResponse@@8 DD FLAT:??_R1A@?0A@EA@CvAIOperationRapidResponse@@8 ; CvAIOperationRapidResponse::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvAIOperation@@8
rdata$r	ENDS
;	COMDAT ??_R3CvAIOperationRapidResponse@@8
rdata$r	SEGMENT
??_R3CvAIOperationRapidResponse@@8 DD 00H		; CvAIOperationRapidResponse::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvAIOperationRapidResponse@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvAIOperationRapidResponse@@@8
_DATA	SEGMENT
??_R0?AVCvAIOperationRapidResponse@@@8 DD FLAT:??_7type_info@@6B@ ; CvAIOperationRapidResponse `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvAIOperationRapidResponse@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvAIOperationRapidResponse@@6B@
rdata$r	SEGMENT
??_R4CvAIOperationRapidResponse@@6B@ DD 00H		; CvAIOperationRapidResponse::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvAIOperationRapidResponse@@@8
	DD	FLAT:??_R3CvAIOperationRapidResponse@@8
rdata$r	ENDS
;	COMDAT ??_7CvAIOperationRapidResponse@@6B@
CONST	SEGMENT
??_7CvAIOperationRapidResponse@@6B@ DD FLAT:??_R4CvAIOperationRapidResponse@@6B@ ; CvAIOperationRapidResponse::`vftable'
	DD	FLAT:??_ECvAIOperationRapidResponse@@UAEPAXI@Z
	DD	FLAT:?Init@CvAIOperationRapidResponse@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAIOperationRapidResponse@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAIOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAIOperationRapidResponse@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAIOperation@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:?ArmyInPosition@CvAIOperationRapidResponse@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?ArmyMoved@CvAIOperationRapidResponse@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperation@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAIOperation@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAIOperationRapidResponse@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAIOperationRapidResponse@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAIOperationRapidResponse@@UBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAIOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvAIOperationRapidResponse@@QAE@XZ
_TEXT	SEGMENT
??0CvAIOperationRapidResponse@@QAE@XZ PROC		; CvAIOperationRapidResponse::CvAIOperationRapidResponse, COMDAT
; _this$ = ecx

; 4881 : {

	push	esi
	mov	esi, ecx
	call	??0CvAIOperation@@QAE@XZ		; CvAIOperation::CvAIOperation
	mov	DWORD PTR [esi], OFFSET ??_7CvAIOperationRapidResponse@@6B@

; 4882 : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvAIOperationRapidResponse@@QAE@XZ ENDP		; CvAIOperationRapidResponse::CvAIOperationRapidResponse
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
_TEXT	ENDS
;	COMDAT ?GetOperationType@CvAIOperationRapidResponse@@UBEHXZ
_TEXT	SEGMENT
?GetOperationType@CvAIOperationRapidResponse@@UBEHXZ PROC ; CvAIOperationRapidResponse::GetOperationType, COMDAT
; _this$ = ecx

; 854  : 		return AI_OPERATION_RAPID_RESPONSE;

	mov	eax, 1

; 855  : 	}

	ret	0
?GetOperationType@CvAIOperationRapidResponse@@UBEHXZ ENDP ; CvAIOperationRapidResponse::GetOperationType
_TEXT	ENDS
PUBLIC	??_C@_0BM@EJFGNPII@AI_OPERATION_RAPID_RESPONSE?$AA@ ; `string'
;	COMDAT ??_C@_0BM@EJFGNPII@AI_OPERATION_RAPID_RESPONSE?$AA@
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BM@EJFGNPII@AI_OPERATION_RAPID_RESPONSE?$AA@ DB 'AI_OPERATION_RAPI'
	DB	'D_RESPONSE', 00H				; `string'
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
CONST	ENDS
;	COMDAT ?GetOperationName@CvAIOperationRapidResponse@@UBE?AVCvString@@XZ
_TEXT	SEGMENT
$T247423 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetOperationName@CvAIOperationRapidResponse@@UBE?AVCvString@@XZ PROC ; CvAIOperationRapidResponse::GetOperationName, COMDAT
; _this$ = ecx

; 857  : 	{

	push	ecx
	push	esi

; 858  : 		return CvString("AI_OPERATION_RAPID_RESPONSE");

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	push	OFFSET ??_C@_0BM@EJFGNPII@AI_OPERATION_RAPID_RESPONSE?$AA@
	mov	ecx, esi
	mov	DWORD PTR $T247423[esp+12], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi

; 859  : 	}

	pop	ecx
	ret	4
?GetOperationName@CvAIOperationRapidResponse@@UBE?AVCvString@@XZ ENDP ; CvAIOperationRapidResponse::GetOperationName
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetFormation@CvAIOperationRapidResponse@@UBE?AW4MultiunitFormationTypes@@XZ
_TEXT	SEGMENT
?GetFormation@CvAIOperationRapidResponse@@UBE?AW4MultiunitFormationTypes@@XZ PROC ; CvAIOperationRapidResponse::GetFormation, COMDAT
; _this$ = ecx

; 862  : 		return MUFORMATION_RAPID_RESPONSE_FORCE;

	mov	eax, 4

; 863  : 	}

	ret	0
?GetFormation@CvAIOperationRapidResponse@@UBE?AW4MultiunitFormationTypes@@XZ ENDP ; CvAIOperationRapidResponse::GetFormation
_TEXT	ENDS
PUBLIC	??1CvAIOperationRapidResponse@@UAE@XZ		; CvAIOperationRapidResponse::~CvAIOperationRapidResponse
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
;	COMDAT ??1CvAIOperationRapidResponse@@UAE@XZ
_TEXT	SEGMENT
??1CvAIOperationRapidResponse@@UAE@XZ PROC		; CvAIOperationRapidResponse::~CvAIOperationRapidResponse, COMDAT
; _this$ = ecx

; 4886 : {

	mov	DWORD PTR [ecx], OFFSET ??_7CvAIOperationRapidResponse@@6B@

; 4887 : }

	jmp	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
??1CvAIOperationRapidResponse@@UAE@XZ ENDP		; CvAIOperationRapidResponse::~CvAIOperationRapidResponse
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Init@CvAIOperationRapidResponse@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
_TEXT	SEGMENT
$T247444 = 8						; size = 4
_iID$ = 8						; size = 4
_eOwner$ = 12						; size = 4
_eEnemy$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 4
?Init@CvAIOperationRapidResponse@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z PROC ; CvAIOperationRapidResponse::Init, COMDAT
; _this$ = ecx

; 4891 : {

	push	esi
	mov	esi, ecx

; 4892 : 	Reset();

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+12]
	call	edx

; 4893 : 	m_iID = iID;

	mov	ecx, DWORD PTR _iID$[esp]

; 4894 : 	m_eOwner = eOwner;

	mov	eax, DWORD PTR _eOwner$[esp]

; 4895 : 	m_eEnemy = eEnemy;

	mov	edx, DWORD PTR _eEnemy$[esp]
	mov	DWORD PTR [esi+52], ecx
	mov	DWORD PTR [esi+72], eax
	mov	DWORD PTR [esi+76], edx

; 4896 : 
; 4897 : 	if(iID != -1)

	cmp	ecx, -1
	je	$LN3@Init@8

; 4898 : 	{
; 4899 : 		// create the armies that are needed and set the state to ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE
; 4900 : 		CvArmyAI* pArmyAI = GET_PLAYER(m_eOwner).addArmyAI();

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edi
	mov	ecx, eax
	call	?addArmyAI@CvPlayer@@QAEPAVCvArmyAI@@XZ	; CvPlayer::addArmyAI
	mov	edi, eax

; 4901 : 		if(pArmyAI)

	test	edi, edi
	je	$LN30@Init@8
	push	ebx

; 4902 : 		{
; 4903 : 			m_viArmyIDs.push_back(pArmyAI->GetID());

	mov	ecx, edi
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	mov	DWORD PTR $T247444[esp+8], eax
	lea	eax, DWORD PTR $T247444[esp+8]
	push	eax
	lea	ecx, DWORD PTR [esi+4]
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 4904 : 			pArmyAI->Init(pArmyAI->GetID(),m_eOwner,m_iID);

	mov	ecx, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [esi+72]
	push	ecx
	push	edx
	mov	ecx, edi
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	push	eax
	mov	ecx, edi
	call	?Init@CvArmyAI@@QAEXHW4PlayerTypes@@H@Z	; CvArmyAI::Init

; 4905 : 			pArmyAI->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE);

	push	0
	mov	ecx, edi
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 4906 : 			pArmyAI->SetFormationIndex(GetFormation());

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+32]
	mov	ecx, esi
	call	edx
	push	eax
	mov	ecx, edi
	call	?SetFormationIndex@CvArmyAI@@QAEXH@Z	; CvArmyAI::SetFormationIndex

; 4907 : 
; 4908 : 			CvPlot* pTargetPlot = FindBestTarget();

	mov	ecx, esi
	call	?FindBestTarget@CvAIOperationRapidResponse@@AAEPAVCvPlot@@XZ ; CvAIOperationRapidResponse::FindBestTarget
	mov	ebx, eax

; 4909 : 			if(pTargetPlot != NULL)

	test	ebx, ebx
	je	$LN31@Init@8

; 4910 : 			{
; 4911 : 				SetTargetPlot(pTargetPlot);

	movsx	eax, WORD PTR [ebx]
	mov	DWORD PTR [esi+104], eax
	movsx	ecx, WORD PTR [ebx+2]
	mov	DWORD PTR [esi+108], ecx

; 4912 : 				pArmyAI->SetGoalPlot(pTargetPlot);

	push	ebx
	mov	ecx, edi
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 4913 : 				SetMusterPlot(pTargetPlot);  // Gather directly at the point we're trying to defend

	movsx	edx, WORD PTR [ebx]
	mov	DWORD PTR [esi+96], edx
	movsx	eax, WORD PTR [ebx+2]

; 4914 : 				pArmyAI->SetXY(GetMusterPlot()->getX(), GetMusterPlot()->getY());

	mov	ecx, esi
	mov	DWORD PTR [esi+100], eax
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	ecx, esi
	mov	ebx, eax
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	movsx	ecx, WORD PTR [eax+2]
	movsx	edx, WORD PTR [ebx]
	push	ecx
	push	edx
	mov	ecx, edi
	call	?SetXY@CvArmyAI@@QAEXHH@Z		; CvArmyAI::SetXY

; 4915 : 				SetDefaultArea(GetMusterPlot()->getArea());

	mov	ecx, esi
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	eax, DWORD PTR [eax+356]

; 4916 : 
; 4917 : 				// Find the list of units we need to build before starting this operation in earnest
; 4918 : 				BuildListOfUnitsWeStillNeedToBuild();

	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [esi+64], eax
	mov	eax, DWORD PTR [edx+92]
	mov	ecx, esi
	call	eax

; 4919 : 
; 4920 : 				// Try to get as many units as possible from existing units that are waiting around
; 4921 : 				if(GrabUnitsFromTheReserves(GetMusterPlot(), NULL))

	mov	ebx, DWORD PTR [esi]
	push	0
	mov	ecx, esi
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	edx, DWORD PTR [ebx+112]
	push	eax
	mov	ecx, esi
	call	edx
	test	al, al
	je	SHORT $LN2@Init@8

; 4922 : 				{
; 4923 : 					pArmyAI->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_CATCH_UP);

	push	1
	mov	ecx, edi
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 4924 : 					m_eCurrentState = AI_OPERATION_STATE_GATHERING_FORCES;
; 4925 : 				}
; 4926 : 				else
; 4927 : 				{
; 4928 : 					m_eCurrentState = AI_OPERATION_STATE_RECRUITING_UNITS;
; 4929 : 				}
; 4930 : 
; 4931 : 				LogOperationStart();

	mov	ecx, esi
	mov	DWORD PTR [esi+56], 2
	call	?LogOperationStart@CvAIOperation@@QAEXXZ ; CvAIOperation::LogOperationStart
	pop	ebx
	pop	edi
	pop	esi

; 4932 : 			}
; 4933 : 		}
; 4934 : 	}
; 4935 : }

	ret	24					; 00000018H
$LN2@Init@8:

; 4924 : 					m_eCurrentState = AI_OPERATION_STATE_GATHERING_FORCES;
; 4925 : 				}
; 4926 : 				else
; 4927 : 				{
; 4928 : 					m_eCurrentState = AI_OPERATION_STATE_RECRUITING_UNITS;
; 4929 : 				}
; 4930 : 
; 4931 : 				LogOperationStart();

	mov	ecx, esi
	mov	DWORD PTR [esi+56], 1
	call	?LogOperationStart@CvAIOperation@@QAEXXZ ; CvAIOperation::LogOperationStart
$LN31@Init@8:
	pop	ebx
$LN30@Init@8:
	pop	edi
$LN3@Init@8:
	pop	esi

; 4932 : 			}
; 4933 : 		}
; 4934 : 	}
; 4935 : }

	ret	24					; 00000018H
?Init@CvAIOperationRapidResponse@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ENDP ; CvAIOperationRapidResponse::Init
_TEXT	ENDS
PUBLIC	??_7CvAINavalEscortedOperation@@6B@		; CvAINavalEscortedOperation::`vftable'
PUBLIC	??0CvAINavalEscortedOperation@@QAE@XZ		; CvAINavalEscortedOperation::CvAINavalEscortedOperation
PUBLIC	??_R4CvAINavalEscortedOperation@@6B@		; CvAINavalEscortedOperation::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvAINavalEscortedOperation@@@8		; CvAINavalEscortedOperation `RTTI Type Descriptor'
PUBLIC	??_R3CvAINavalEscortedOperation@@8		; CvAINavalEscortedOperation::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvAINavalEscortedOperation@@8		; CvAINavalEscortedOperation::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvAINavalEscortedOperation@@8	; CvAINavalEscortedOperation::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?Init@CvAINavalEscortedOperation@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ; CvAINavalEscortedOperation::Init
PUBLIC	?GetOperationType@CvAINavalEscortedOperation@@UBEHXZ ; CvAINavalEscortedOperation::GetOperationType
PUBLIC	?GetFormation@CvAINavalEscortedOperation@@UBE?AW4MultiunitFormationTypes@@XZ ; CvAINavalEscortedOperation::GetFormation
PUBLIC	?IsMixedLandNavalOperation@CvAINavalEscortedOperation@@UBE_NXZ ; CvAINavalEscortedOperation::IsMixedLandNavalOperation
PUBLIC	?Read@CvAINavalEscortedOperation@@UAEXAAVFDataStream@@@Z ; CvAINavalEscortedOperation::Read
PUBLIC	?GetOperationName@CvAINavalEscortedOperation@@UBE?AVCvString@@XZ ; CvAINavalEscortedOperation::GetOperationName
PUBLIC	?IsCivilianRequired@CvAINavalEscortedOperation@@UBE_NXZ ; CvAINavalEscortedOperation::IsCivilianRequired
EXTRN	??_ECvAINavalEscortedOperation@@UAEPAXI@Z:PROC	; CvAINavalEscortedOperation::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvAINavalEscortedOperation@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvAINavalEscortedOperation@@8 DD FLAT:??_R0?AVCvAINavalEscortedOperation@@@8 ; CvAINavalEscortedOperation::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvAINavalEscortedOperation@@8
rdata$r	ENDS
;	COMDAT ??_R2CvAINavalEscortedOperation@@8
rdata$r	SEGMENT
??_R2CvAINavalEscortedOperation@@8 DD FLAT:??_R1A@?0A@EA@CvAINavalEscortedOperation@@8 ; CvAINavalEscortedOperation::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvAIOperation@@8
rdata$r	ENDS
;	COMDAT ??_R3CvAINavalEscortedOperation@@8
rdata$r	SEGMENT
??_R3CvAINavalEscortedOperation@@8 DD 00H		; CvAINavalEscortedOperation::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvAINavalEscortedOperation@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvAINavalEscortedOperation@@@8
_DATA	SEGMENT
??_R0?AVCvAINavalEscortedOperation@@@8 DD FLAT:??_7type_info@@6B@ ; CvAINavalEscortedOperation `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvAINavalEscortedOperation@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvAINavalEscortedOperation@@6B@
rdata$r	SEGMENT
??_R4CvAINavalEscortedOperation@@6B@ DD 00H		; CvAINavalEscortedOperation::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvAINavalEscortedOperation@@@8
	DD	FLAT:??_R3CvAINavalEscortedOperation@@8
rdata$r	ENDS
;	COMDAT ??_7CvAINavalEscortedOperation@@6B@
CONST	SEGMENT
??_7CvAINavalEscortedOperation@@6B@ DD FLAT:??_R4CvAINavalEscortedOperation@@6B@ ; CvAINavalEscortedOperation::`vftable'
	DD	FLAT:??_ECvAINavalEscortedOperation@@UAEPAXI@Z
	DD	FLAT:?Init@CvAINavalEscortedOperation@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAINavalEscortedOperation@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAIOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAINavalEscortedOperation@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAINavalEscortedOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAINavalEscortedOperation@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:?ArmyInPosition@CvAINavalEscortedOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperation@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAINavalEscortedOperation@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAINavalEscortedOperation@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAINavalEscortedOperation@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAINavalEscortedOperation@@UBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAIOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	DD	FLAT:?IsCivilianRequired@CvAINavalEscortedOperation@@UBE_NXZ
	DD	FLAT:?FindBestCivilian@CvAINavalEscortedOperation@@UAEPAVCvUnit@@XZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvAINavalEscortedOperation@@QAE@XZ
_TEXT	SEGMENT
??0CvAINavalEscortedOperation@@QAE@XZ PROC		; CvAINavalEscortedOperation::CvAINavalEscortedOperation, COMDAT
; _this$ = ecx

; 5077 : {

	push	esi
	mov	esi, ecx
	call	??0CvAIOperation@@QAE@XZ		; CvAIOperation::CvAIOperation
	mov	DWORD PTR [esi], OFFSET ??_7CvAINavalEscortedOperation@@6B@

; 5078 : 	// *** Move into subclass later?
; 5079 : 	m_eCivilianType = UNITAI_SETTLE;

	mov	DWORD PTR [esi+112], 1

; 5080 : 	m_iInitialAreaID = -1;

	mov	DWORD PTR [esi+116], -1

; 5081 : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvAINavalEscortedOperation@@QAE@XZ ENDP		; CvAINavalEscortedOperation::CvAINavalEscortedOperation
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
_TEXT	ENDS
;	COMDAT ?GetOperationType@CvAINavalEscortedOperation@@UBEHXZ
_TEXT	SEGMENT
?GetOperationType@CvAINavalEscortedOperation@@UBEHXZ PROC ; CvAINavalEscortedOperation::GetOperationType, COMDAT
; _this$ = ecx

; 890  : 		return AI_OPERATION_COLONIZE;

	mov	eax, 11					; 0000000bH

; 891  : 	}

	ret	0
?GetOperationType@CvAINavalEscortedOperation@@UBEHXZ ENDP ; CvAINavalEscortedOperation::GetOperationType
_TEXT	ENDS
PUBLIC	??_C@_0BG@GPOEJGIB@AI_OPERATION_COLONIZE?$AA@	; `string'
;	COMDAT ??_C@_0BG@GPOEJGIB@AI_OPERATION_COLONIZE?$AA@
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BG@GPOEJGIB@AI_OPERATION_COLONIZE?$AA@ DB 'AI_OPERATION_COLONIZE', 00H ; `string'
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
CONST	ENDS
;	COMDAT ?GetOperationName@CvAINavalEscortedOperation@@UBE?AVCvString@@XZ
_TEXT	SEGMENT
$T247502 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetOperationName@CvAINavalEscortedOperation@@UBE?AVCvString@@XZ PROC ; CvAINavalEscortedOperation::GetOperationName, COMDAT
; _this$ = ecx

; 893  : 	{

	push	ecx
	push	esi

; 894  : 		return CvString("AI_OPERATION_COLONIZE");

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	push	OFFSET ??_C@_0BG@GPOEJGIB@AI_OPERATION_COLONIZE?$AA@
	mov	ecx, esi
	mov	DWORD PTR $T247502[esp+12], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi

; 895  : 	}

	pop	ecx
	ret	4
?GetOperationName@CvAINavalEscortedOperation@@UBE?AVCvString@@XZ ENDP ; CvAINavalEscortedOperation::GetOperationName
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetFormation@CvAINavalEscortedOperation@@UBE?AW4MultiunitFormationTypes@@XZ
_TEXT	SEGMENT
?GetFormation@CvAINavalEscortedOperation@@UBE?AW4MultiunitFormationTypes@@XZ PROC ; CvAINavalEscortedOperation::GetFormation, COMDAT
; _this$ = ecx

; 898  : 		return MUFORMATION_COLONIZATION_PARTY;

	mov	eax, 10					; 0000000aH

; 899  : 	}

	ret	0
?GetFormation@CvAINavalEscortedOperation@@UBE?AW4MultiunitFormationTypes@@XZ ENDP ; CvAINavalEscortedOperation::GetFormation
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?IsMixedLandNavalOperation@CvAINavalEscortedOperation@@UBE_NXZ
_TEXT	SEGMENT
?IsMixedLandNavalOperation@CvAINavalEscortedOperation@@UBE_NXZ PROC ; CvAINavalEscortedOperation::IsMixedLandNavalOperation, COMDAT
; _this$ = ecx

; 903  : 		return true;

	mov	al, 1

; 904  : 	};

	ret	0
?IsMixedLandNavalOperation@CvAINavalEscortedOperation@@UBE_NXZ ENDP ; CvAINavalEscortedOperation::IsMixedLandNavalOperation
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?IsCivilianRequired@CvAINavalEscortedOperation@@UBE_NXZ
_TEXT	SEGMENT
?IsCivilianRequired@CvAINavalEscortedOperation@@UBE_NXZ PROC ; CvAINavalEscortedOperation::IsCivilianRequired, COMDAT
; _this$ = ecx

; 907  : 		return true;

	mov	al, 1

; 908  : 	};

	ret	0
?IsCivilianRequired@CvAINavalEscortedOperation@@UBE_NXZ ENDP ; CvAINavalEscortedOperation::IsCivilianRequired
_TEXT	ENDS
PUBLIC	??1CvAINavalEscortedOperation@@UAE@XZ		; CvAINavalEscortedOperation::~CvAINavalEscortedOperation
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
;	COMDAT ??1CvAINavalEscortedOperation@@UAE@XZ
_TEXT	SEGMENT
??1CvAINavalEscortedOperation@@UAE@XZ PROC		; CvAINavalEscortedOperation::~CvAINavalEscortedOperation, COMDAT
; _this$ = ecx

; 5084 : {

	mov	DWORD PTR [ecx], OFFSET ??_7CvAINavalEscortedOperation@@6B@

; 5085 : }

	jmp	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
??1CvAINavalEscortedOperation@@UAE@XZ ENDP		; CvAINavalEscortedOperation::~CvAINavalEscortedOperation
_TEXT	ENDS
EXTRN	?getArea@CvUnit@@QBEHXZ:PROC			; CvUnit::getArea
; Function compile flags: /Ogtpy
;	COMDAT ?Init@CvAINavalEscortedOperation@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
_TEXT	SEGMENT
$T247531 = 8						; size = 4
_iID$ = 8						; size = 4
_pStartCity$ = 12					; size = 4
_eOwner$ = 12						; size = 4
___formal$ = 16						; size = 4
_iDefaultArea$ = 20					; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 4
?Init@CvAINavalEscortedOperation@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z PROC ; CvAINavalEscortedOperation::Init, COMDAT
; _this$ = ecx

; 5089 : {

	push	ebp
	push	esi
	mov	esi, ecx

; 5090 : 	Reset();

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+12]
	push	edi
	call	edx

; 5091 : 	m_eMoveType = AI_OPERATION_MOVETYPE_NAVAL_ESCORT;
; 5092 : 	m_iID = iID;
; 5093 : 	m_eOwner = eOwner;

	mov	eax, DWORD PTR _eOwner$[esp+8]

; 5094 : 	SetDefaultArea(iDefaultArea);   // Area settler starts in

	mov	ecx, DWORD PTR _iDefaultArea$[esp+8]

; 5095 : 
; 5096 : 	// Find the free civilian (that triggered this operation)
; 5097 : 	CvUnit* pOurCivilian = FindBestCivilian();

	mov	edx, DWORD PTR [esi]
	mov	edi, DWORD PTR _iID$[esp+8]
	mov	DWORD PTR [esi+72], eax
	mov	eax, DWORD PTR [edx+148]
	mov	DWORD PTR [esi+64], ecx
	mov	ecx, esi
	mov	DWORD PTR [esi+84], 2
	mov	DWORD PTR [esi+52], edi
	call	eax
	mov	ebp, eax

; 5098 : 	m_iInitialAreaID = (pOurCivilian != NULL)? pOurCivilian->getArea() : -1;

	test	ebp, ebp
	je	SHORT $LN9@Init@9
	mov	ecx, ebp
	call	?getArea@CvUnit@@QBEHXZ			; CvUnit::getArea
	jmp	SHORT $LN10@Init@9
$LN9@Init@9:
	or	eax, -1
$LN10@Init@9:

; 5099 : 
; 5100 : 	CvCity* pStartCity = GetOperationStartCity();

	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [esi+116], eax
	mov	eax, DWORD PTR [edx+52]
	mov	ecx, esi
	call	eax
	mov	DWORD PTR _pStartCity$[esp+8], eax

; 5101 : 
; 5102 : 	if(pOurCivilian != NULL && iID != -1 && pStartCity)

	test	ebp, ebp
	je	$LN1@Init@9
	cmp	edi, -1
	je	$LN1@Init@9
	test	eax, eax
	je	$LN1@Init@9

; 5103 : 	{
; 5104 : 		// Find a destination (not worrying about safe paths)
; 5105 : 		CvPlot* pTargetSite = FindBestTarget(pOurCivilian);

	mov	ecx, DWORD PTR [esi+72]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebx
	push	-1
	push	1
	push	ebp
	call	?GetBestSettlePlot@CvPlayer@@QBEPAVCvPlot@@PAVCvUnit@@_NH@Z ; CvPlayer::GetBestSettlePlot
	mov	ebx, eax

; 5106 : 
; 5107 : 		if(pTargetSite != NULL)

	test	ebx, ebx
	je	$LN5@Init@9

; 5108 : 		{
; 5109 : 			SetTargetPlot(pTargetSite);

	movsx	ecx, WORD PTR [ebx]
	mov	DWORD PTR [esi+104], ecx

; 5110 : 
; 5111 : 			// create the armies that are needed and set the state to ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE
; 5112 : 			CvArmyAI* pArmyAI = GET_PLAYER(m_eOwner).addArmyAI();

	mov	ecx, DWORD PTR [esi+72]
	movsx	edx, WORD PTR [ebx+2]
	imul	ecx, 63236				; 0000f704H
	mov	DWORD PTR [esi+108], edx
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?addArmyAI@CvPlayer@@QAEPAVCvArmyAI@@XZ	; CvPlayer::addArmyAI
	mov	edi, eax

; 5113 : 			if(pArmyAI)

	test	edi, edi
	je	$LN39@Init@9

; 5114 : 			{
; 5115 : 				m_viArmyIDs.push_back(pArmyAI->GetID());

	mov	ecx, edi
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	mov	DWORD PTR $T247531[esp+12], eax
	lea	eax, DWORD PTR $T247531[esp+12]
	push	eax
	lea	ecx, DWORD PTR [esi+4]
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 5116 : 				pArmyAI->Init(pArmyAI->GetID(),m_eOwner,m_iID);

	mov	ecx, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [esi+72]
	push	ecx
	push	edx
	mov	ecx, edi
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	push	eax
	mov	ecx, edi
	call	?Init@CvArmyAI@@QAEXHW4PlayerTypes@@H@Z	; CvArmyAI::Init

; 5117 : 				pArmyAI->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE);

	push	0
	mov	ecx, edi
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 5118 : 				pArmyAI->SetFormationIndex(GetFormation());

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+32]
	mov	ecx, esi
	call	edx
	push	eax
	mov	ecx, edi
	call	?SetFormationIndex@CvArmyAI@@QAEXH@Z	; CvArmyAI::SetFormationIndex

; 5119 : 
; 5120 : 				pArmyAI->SetGoalPlot(pTargetSite);

	push	ebx
	mov	ecx, edi
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 5121 : 				CvPlot* pMusterPt = pStartCity->plot();

	mov	ecx, DWORD PTR _pStartCity$[esp+12]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot

; 5122 : 				SetMusterPlot(pMusterPt);

	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR [esi+96], ecx
	movsx	edx, WORD PTR [eax+2]
	mov	DWORD PTR [esi+100], edx

; 5123 : 				pArmyAI->SetXY(pMusterPt->getX(), pMusterPt->getY());

	movsx	ecx, WORD PTR [eax+2]
	movsx	edx, WORD PTR [eax]
	push	ecx
	push	edx
	mov	ecx, edi
	call	?SetXY@CvArmyAI@@QAEXHH@Z		; CvArmyAI::SetXY

; 5124 : 
; 5125 : 				// Add the settler to our army
; 5126 : 				pArmyAI->AddUnit(pOurCivilian->GetID(), 0);

	mov	eax, DWORD PTR [ebp+100]
	push	0
	push	eax
	mov	ecx, edi
	call	?AddUnit@CvArmyAI@@QAEXHH@Z		; CvArmyAI::AddUnit

; 5127 : 
; 5128 : 				// try to get the escort from existing units that are waiting around
; 5129 : 				BuildListOfUnitsWeStillNeedToBuild();

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+92]
	mov	ecx, esi
	call	eax

; 5130 : 
; 5131 : 				// Try to get as many units as possible from existing units that are waiting around
; 5132 : 				if(GrabUnitsFromTheReserves(GetMusterPlot(), NULL))

	mov	ebx, DWORD PTR [esi]
	push	0
	mov	ecx, esi
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	edx, DWORD PTR [ebx+112]
	push	eax
	mov	ecx, esi
	call	edx
	test	al, al
	je	SHORT $LN3@Init@9

; 5133 : 				{
; 5134 : 					pArmyAI->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_CATCH_UP);

	push	1
	mov	ecx, edi
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 5135 : 					m_eCurrentState = AI_OPERATION_STATE_GATHERING_FORCES;
; 5136 : 				}
; 5137 : 				else
; 5138 : 				{
; 5139 : 					m_eCurrentState = AI_OPERATION_STATE_RECRUITING_UNITS;
; 5140 : 				}
; 5141 : 				LogOperationStart();

	mov	ecx, esi
	mov	DWORD PTR [esi+56], 2
	call	?LogOperationStart@CvAIOperation@@QAEXXZ ; CvAIOperation::LogOperationStart
	pop	ebx
	pop	edi
	pop	esi
	pop	ebp

; 5150 : 		}
; 5151 : 	}
; 5152 : }

	ret	24					; 00000018H
$LN3@Init@9:

; 5135 : 					m_eCurrentState = AI_OPERATION_STATE_GATHERING_FORCES;
; 5136 : 				}
; 5137 : 				else
; 5138 : 				{
; 5139 : 					m_eCurrentState = AI_OPERATION_STATE_RECRUITING_UNITS;
; 5140 : 				}
; 5141 : 				LogOperationStart();

	mov	ecx, esi
	mov	DWORD PTR [esi+56], 1
	call	?LogOperationStart@CvAIOperation@@QAEXXZ ; CvAIOperation::LogOperationStart
	pop	ebx
	pop	edi
	pop	esi
	pop	ebp

; 5150 : 		}
; 5151 : 	}
; 5152 : }

	ret	24					; 00000018H
$LN5@Init@9:

; 5142 : 			}
; 5143 : 		}
; 5144 : 
; 5145 : 		else
; 5146 : 		{
; 5147 : 			// Lost our target, abort
; 5148 : 			m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	DWORD PTR [esi+56], 0

; 5149 : 			m_eAbortReason = AI_ABORT_LOST_TARGET;

	mov	DWORD PTR [esi+60], 3
$LN39@Init@9:
	pop	ebx
$LN1@Init@9:
	pop	edi
	pop	esi
	pop	ebp

; 5150 : 		}
; 5151 : 	}
; 5152 : }

	ret	24					; 00000018H
?Init@CvAINavalEscortedOperation@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ENDP ; CvAINavalEscortedOperation::Init
_TEXT	ENDS
PUBLIC	??_7CvAIOperationNavalAttack@@6B@		; CvAIOperationNavalAttack::`vftable'
PUBLIC	??0CvAIOperationNavalAttack@@QAE@XZ		; CvAIOperationNavalAttack::CvAIOperationNavalAttack
PUBLIC	??_R4CvAIOperationNavalAttack@@6B@		; CvAIOperationNavalAttack::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvAIOperationNavalAttack@@@8		; CvAIOperationNavalAttack `RTTI Type Descriptor'
PUBLIC	??_R3CvAIOperationNavalAttack@@8		; CvAIOperationNavalAttack::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvAIOperationNavalAttack@@8		; CvAIOperationNavalAttack::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvAIOperationNavalAttack@@8	; CvAIOperationNavalAttack::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?Init@CvAIOperationNavalAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ; CvAIOperationNavalAttack::Init
PUBLIC	?GetOperationType@CvAIOperationNavalAttack@@UBEHXZ ; CvAIOperationNavalAttack::GetOperationType
PUBLIC	?GetFormation@CvAIOperationNavalAttack@@UBE?AW4MultiunitFormationTypes@@XZ ; CvAIOperationNavalAttack::GetFormation
PUBLIC	?UnitWasRemoved@CvAIOperationNavalAttack@@UAEXHH@Z ; CvAIOperationNavalAttack::UnitWasRemoved
PUBLIC	?Read@CvAIOperationNavalAttack@@UAEXAAVFDataStream@@@Z ; CvAIOperationNavalAttack::Read
PUBLIC	?GetOperationName@CvAIOperationNavalAttack@@UBE?AVCvString@@XZ ; CvAIOperationNavalAttack::GetOperationName
PUBLIC	?IsCivilianRequired@CvAIOperationNavalAttack@@UBE_NXZ ; CvAIOperationNavalAttack::IsCivilianRequired
EXTRN	??_ECvAIOperationNavalAttack@@UAEPAXI@Z:PROC	; CvAIOperationNavalAttack::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvAIOperationNavalAttack@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvAIOperationNavalAttack@@8 DD FLAT:??_R0?AVCvAIOperationNavalAttack@@@8 ; CvAIOperationNavalAttack::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvAIOperationNavalAttack@@8
rdata$r	ENDS
;	COMDAT ??_R2CvAIOperationNavalAttack@@8
rdata$r	SEGMENT
??_R2CvAIOperationNavalAttack@@8 DD FLAT:??_R1A@?0A@EA@CvAIOperationNavalAttack@@8 ; CvAIOperationNavalAttack::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvAINavalEscortedOperation@@8
	DD	FLAT:??_R1A@?0A@EA@CvAIOperation@@8
rdata$r	ENDS
;	COMDAT ??_R3CvAIOperationNavalAttack@@8
rdata$r	SEGMENT
??_R3CvAIOperationNavalAttack@@8 DD 00H			; CvAIOperationNavalAttack::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CvAIOperationNavalAttack@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvAIOperationNavalAttack@@@8
_DATA	SEGMENT
??_R0?AVCvAIOperationNavalAttack@@@8 DD FLAT:??_7type_info@@6B@ ; CvAIOperationNavalAttack `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvAIOperationNavalAttack@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvAIOperationNavalAttack@@6B@
rdata$r	SEGMENT
??_R4CvAIOperationNavalAttack@@6B@ DD 00H		; CvAIOperationNavalAttack::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvAIOperationNavalAttack@@@8
	DD	FLAT:??_R3CvAIOperationNavalAttack@@8
rdata$r	ENDS
;	COMDAT ??_7CvAIOperationNavalAttack@@6B@
CONST	SEGMENT
??_7CvAIOperationNavalAttack@@6B@ DD FLAT:??_R4CvAIOperationNavalAttack@@6B@ ; CvAIOperationNavalAttack::`vftable'
	DD	FLAT:??_ECvAIOperationNavalAttack@@UAEPAXI@Z
	DD	FLAT:?Init@CvAIOperationNavalAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAIOperationNavalAttack@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAIOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAIOperationNavalAttack@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAINavalEscortedOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAIOperationNavalAttack@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:?ArmyInPosition@CvAIOperationNavalAttack@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperation@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAIOperationNavalAttack@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAIOperationNavalAttack@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAIOperationNavalAttack@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAIOperationNavalAttack@@UBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAIOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	DD	FLAT:?IsCivilianRequired@CvAIOperationNavalAttack@@UBE_NXZ
	DD	FLAT:?FindBestCivilian@CvAINavalEscortedOperation@@UAEPAVCvUnit@@XZ
	DD	FLAT:?FindBestTarget@CvAIOperationNavalAttack@@MAEPAVCvPlot@@XZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvAIOperationNavalAttack@@QAE@XZ
_TEXT	SEGMENT
??0CvAIOperationNavalAttack@@QAE@XZ PROC		; CvAIOperationNavalAttack::CvAIOperationNavalAttack, COMDAT
; _this$ = ecx

; 5372 : {

	push	esi
	mov	esi, ecx
	call	??0CvAIOperation@@QAE@XZ		; CvAIOperation::CvAIOperation
	or	eax, -1
	mov	DWORD PTR [esi+116], eax

; 5373 : 	m_eCivilianType = NO_UNITAI;

	mov	DWORD PTR [esi+112], eax
	mov	DWORD PTR [esi], OFFSET ??_7CvAIOperationNavalAttack@@6B@

; 5374 : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvAIOperationNavalAttack@@QAE@XZ ENDP		; CvAIOperationNavalAttack::CvAIOperationNavalAttack
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
_TEXT	ENDS
;	COMDAT ?GetOperationType@CvAIOperationNavalAttack@@UBEHXZ
_TEXT	SEGMENT
?GetOperationType@CvAIOperationNavalAttack@@UBEHXZ PROC	; CvAIOperationNavalAttack::GetOperationType, COMDAT
; _this$ = ecx

; 939  : 		return AI_OPERATION_NAVAL_ATTACK;

	mov	eax, 13					; 0000000dH

; 940  : 	}

	ret	0
?GetOperationType@CvAIOperationNavalAttack@@UBEHXZ ENDP	; CvAIOperationNavalAttack::GetOperationType
_TEXT	ENDS
PUBLIC	??_C@_0BK@BPCLKIF@AI_OPERATION_NAVAL_ATTACK?$AA@ ; `string'
;	COMDAT ??_C@_0BK@BPCLKIF@AI_OPERATION_NAVAL_ATTACK?$AA@
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BK@BPCLKIF@AI_OPERATION_NAVAL_ATTACK?$AA@ DB 'AI_OPERATION_NAVAL_A'
	DB	'TTACK', 00H					; `string'
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
CONST	ENDS
;	COMDAT ?GetOperationName@CvAIOperationNavalAttack@@UBE?AVCvString@@XZ
_TEXT	SEGMENT
$T247605 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetOperationName@CvAIOperationNavalAttack@@UBE?AVCvString@@XZ PROC ; CvAIOperationNavalAttack::GetOperationName, COMDAT
; _this$ = ecx

; 942  : 	{

	push	ecx
	push	esi

; 943  : 		return CvString("AI_OPERATION_NAVAL_ATTACK");

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	push	OFFSET ??_C@_0BK@BPCLKIF@AI_OPERATION_NAVAL_ATTACK?$AA@
	mov	ecx, esi
	mov	DWORD PTR $T247605[esp+12], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi

; 944  : 	}

	pop	ecx
	ret	4
?GetOperationName@CvAIOperationNavalAttack@@UBE?AVCvString@@XZ ENDP ; CvAIOperationNavalAttack::GetOperationName
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetFormation@CvAIOperationNavalAttack@@UBE?AW4MultiunitFormationTypes@@XZ
_TEXT	SEGMENT
?GetFormation@CvAIOperationNavalAttack@@UBE?AW4MultiunitFormationTypes@@XZ PROC ; CvAIOperationNavalAttack::GetFormation, COMDAT
; _this$ = ecx

; 947  : 		return MUFORMATION_NAVAL_INVASION;

	mov	eax, 12					; 0000000cH

; 948  : 	}

	ret	0
?GetFormation@CvAIOperationNavalAttack@@UBE?AW4MultiunitFormationTypes@@XZ ENDP ; CvAIOperationNavalAttack::GetFormation
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?IsCivilianRequired@CvAIOperationNavalAttack@@UBE_NXZ
_TEXT	SEGMENT
?IsCivilianRequired@CvAIOperationNavalAttack@@UBE_NXZ PROC ; CvAIOperationNavalAttack::IsCivilianRequired, COMDAT
; _this$ = ecx

; 952  : 		return false;

	xor	al, al

; 953  : 	};

	ret	0
?IsCivilianRequired@CvAIOperationNavalAttack@@UBE_NXZ ENDP ; CvAIOperationNavalAttack::IsCivilianRequired
_TEXT	ENDS
PUBLIC	??1CvAIOperationNavalAttack@@UAE@XZ		; CvAIOperationNavalAttack::~CvAIOperationNavalAttack
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
;	COMDAT ??1CvAIOperationNavalAttack@@UAE@XZ
_TEXT	SEGMENT
??1CvAIOperationNavalAttack@@UAE@XZ PROC		; CvAIOperationNavalAttack::~CvAIOperationNavalAttack, COMDAT
; _this$ = ecx

; 5378 : }

	mov	DWORD PTR [ecx], OFFSET ??_7CvAINavalEscortedOperation@@6B@
	jmp	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
??1CvAIOperationNavalAttack@@UAE@XZ ENDP		; CvAIOperationNavalAttack::~CvAIOperationNavalAttack
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Init@CvAIOperationNavalAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
_TEXT	SEGMENT
$T247633 = 8						; size = 4
_iID$ = 8						; size = 4
_eOwner$ = 12						; size = 4
_eEnemy$ = 16						; size = 4
_iDefaultArea$ = 20					; size = 4
_pTarget$ = 24						; size = 4
_pMuster$ = 28						; size = 4
?Init@CvAIOperationNavalAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z PROC ; CvAIOperationNavalAttack::Init, COMDAT
; _this$ = ecx

; 5382 : {

	push	esi
	mov	esi, ecx

; 5383 : 	Reset();

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+12]
	push	edi
	call	edx

; 5384 : 	m_eMoveType = AI_OPERATION_MOVETYPE_NAVAL_ESCORT;
; 5385 : 	m_iID = iID;
; 5386 : 	m_eOwner = eOwner;
; 5387 : 	m_eEnemy = eEnemy;

	mov	ecx, DWORD PTR _eEnemy$[esp+4]
	mov	eax, DWORD PTR _eOwner$[esp+4]

; 5388 : 	SetDefaultArea(iDefaultArea);

	mov	edx, DWORD PTR _iDefaultArea$[esp+4]
	mov	edi, DWORD PTR _iID$[esp+4]
	mov	DWORD PTR [esi+76], ecx

; 5389 : 
; 5390 : 	SetStartCityPlot(pMuster->plot());

	mov	ecx, DWORD PTR _pMuster$[esp+4]
	mov	DWORD PTR [esi+84], 2
	mov	DWORD PTR [esi+52], edi
	mov	DWORD PTR [esi+72], eax
	mov	DWORD PTR [esi+64], edx
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR [esi+88], ecx
	movsx	edx, WORD PTR [eax+2]
	mov	DWORD PTR [esi+92], edx

; 5391 : 
; 5392 : 	if(iID != -1)

	cmp	edi, -1
	je	$LN1@Init@10

; 5393 : 	{
; 5394 : 		if(pTarget)

	mov	ecx, DWORD PTR _pTarget$[esp+4]
	test	ecx, ecx
	je	$LN5@Init@10

; 5395 : 		{
; 5396 : 			SetTargetPlot(pTarget->plot());

	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR [esi+104], ecx

; 5397 : 
; 5398 : 			// create the armies that are needed and set the state to ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE
; 5399 : 			CvArmyAI* pArmyAI = GET_PLAYER(m_eOwner).addArmyAI();

	mov	ecx, DWORD PTR [esi+72]
	movsx	edx, WORD PTR [eax+2]
	imul	ecx, 63236				; 0000f704H
	mov	DWORD PTR [esi+108], edx
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?addArmyAI@CvPlayer@@QAEPAVCvArmyAI@@XZ	; CvPlayer::addArmyAI
	mov	edi, eax

; 5400 : 			if(pArmyAI)

	test	edi, edi
	je	$LN1@Init@10
	push	ebx

; 5401 : 			{
; 5402 : 				m_viArmyIDs.push_back(pArmyAI->GetID());

	mov	ecx, edi
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	mov	DWORD PTR $T247633[esp+8], eax
	lea	eax, DWORD PTR $T247633[esp+8]
	push	eax
	lea	ecx, DWORD PTR [esi+4]
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 5403 : 				pArmyAI->Init(pArmyAI->GetID(),m_eOwner,m_iID);

	mov	ecx, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [esi+72]
	push	ecx
	push	edx
	mov	ecx, edi
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	push	eax
	mov	ecx, edi
	call	?Init@CvArmyAI@@QAEXHW4PlayerTypes@@H@Z	; CvArmyAI::Init

; 5404 : 				pArmyAI->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE);

	push	0
	mov	ecx, edi
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 5405 : 				pArmyAI->SetFormationIndex(GetFormation());

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+32]
	mov	ecx, esi
	call	edx
	push	eax
	mov	ecx, edi
	call	?SetFormationIndex@CvArmyAI@@QAEXH@Z	; CvArmyAI::SetFormationIndex

; 5406 : 
; 5407 : 				pArmyAI->SetGoalPlot(GetTargetPlot());

	mov	ecx, esi
	call	?GetTargetPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetTargetPlot
	push	eax
	mov	ecx, edi
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 5408 : 				SetMusterPlot(GetStartCityPlot());

	mov	ecx, esi
	call	?GetStartCityPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetStartCityPlot
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR [esi+96], ecx
	movsx	edx, WORD PTR [eax+2]

; 5409 : 				pArmyAI->SetXY(GetStartCityPlot()->getX(), GetStartCityPlot()->getY());

	mov	ecx, esi
	mov	DWORD PTR [esi+100], edx
	call	?GetStartCityPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetStartCityPlot
	mov	ecx, esi
	mov	ebx, eax
	call	?GetStartCityPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetStartCityPlot
	movsx	eax, WORD PTR [eax+2]
	movsx	ecx, WORD PTR [ebx]
	push	eax
	push	ecx
	mov	ecx, edi
	call	?SetXY@CvArmyAI@@QAEXHH@Z		; CvArmyAI::SetXY

; 5410 : 
; 5411 : 				BuildListOfUnitsWeStillNeedToBuild();

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+92]
	mov	ecx, esi
	call	eax

; 5412 : 
; 5413 : 				// Try to get as many units as possible from existing units that are waiting around
; 5414 : 				if(GrabUnitsFromTheReserves(GetMusterPlot(), NULL))

	mov	ebx, DWORD PTR [esi]
	push	0
	mov	ecx, esi
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	edx, DWORD PTR [ebx+112]
	push	eax
	mov	ecx, esi
	call	edx
	pop	ebx
	test	al, al
	je	SHORT $LN3@Init@10

; 5415 : 				{
; 5416 : 					pArmyAI->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_CATCH_UP);

	push	1
	mov	ecx, edi
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 5417 : 					m_eCurrentState = AI_OPERATION_STATE_GATHERING_FORCES;
; 5418 : 				}
; 5419 : 				else
; 5420 : 				{
; 5421 : 					m_eCurrentState = AI_OPERATION_STATE_RECRUITING_UNITS;
; 5422 : 				}
; 5423 : 				LogOperationStart();

	mov	ecx, esi
	mov	DWORD PTR [esi+56], 2
	call	?LogOperationStart@CvAIOperation@@QAEXXZ ; CvAIOperation::LogOperationStart
	pop	edi
	pop	esi

; 5432 : 		}
; 5433 : 	}
; 5434 : }

	ret	24					; 00000018H
$LN3@Init@10:

; 5417 : 					m_eCurrentState = AI_OPERATION_STATE_GATHERING_FORCES;
; 5418 : 				}
; 5419 : 				else
; 5420 : 				{
; 5421 : 					m_eCurrentState = AI_OPERATION_STATE_RECRUITING_UNITS;
; 5422 : 				}
; 5423 : 				LogOperationStart();

	mov	ecx, esi
	mov	DWORD PTR [esi+56], 1
	call	?LogOperationStart@CvAIOperation@@QAEXXZ ; CvAIOperation::LogOperationStart
	pop	edi
	pop	esi

; 5432 : 		}
; 5433 : 	}
; 5434 : }

	ret	24					; 00000018H
$LN5@Init@10:

; 5424 : 			}
; 5425 : 		}
; 5426 : 
; 5427 : 		else
; 5428 : 		{
; 5429 : 			// Lost our target, abort
; 5430 : 			m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	DWORD PTR [esi+56], 0

; 5431 : 			m_eAbortReason = AI_ABORT_LOST_TARGET;

	mov	DWORD PTR [esi+60], 3
$LN1@Init@10:
	pop	edi
	pop	esi

; 5432 : 		}
; 5433 : 	}
; 5434 : }

	ret	24					; 00000018H
?Init@CvAIOperationNavalAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ENDP ; CvAIOperationNavalAttack::Init
_TEXT	ENDS
PUBLIC	??_7CvAIOperationNavalSneakAttack@@6B@		; CvAIOperationNavalSneakAttack::`vftable'
PUBLIC	??0CvAIOperationNavalSneakAttack@@QAE@XZ	; CvAIOperationNavalSneakAttack::CvAIOperationNavalSneakAttack
PUBLIC	??_R4CvAIOperationNavalSneakAttack@@6B@		; CvAIOperationNavalSneakAttack::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvAIOperationNavalSneakAttack@@@8	; CvAIOperationNavalSneakAttack `RTTI Type Descriptor'
PUBLIC	??_R3CvAIOperationNavalSneakAttack@@8		; CvAIOperationNavalSneakAttack::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvAIOperationNavalSneakAttack@@8		; CvAIOperationNavalSneakAttack::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvAIOperationNavalSneakAttack@@8	; CvAIOperationNavalSneakAttack::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?GetOperationType@CvAIOperationNavalSneakAttack@@UBEHXZ ; CvAIOperationNavalSneakAttack::GetOperationType
PUBLIC	?GetFormation@CvAIOperationNavalSneakAttack@@UBE?AW4MultiunitFormationTypes@@XZ ; CvAIOperationNavalSneakAttack::GetFormation
PUBLIC	?GetOperationName@CvAIOperationNavalSneakAttack@@UBE?AVCvString@@XZ ; CvAIOperationNavalSneakAttack::GetOperationName
EXTRN	??_ECvAIOperationNavalSneakAttack@@UAEPAXI@Z:PROC ; CvAIOperationNavalSneakAttack::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvAIOperationNavalSneakAttack@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvAIOperationNavalSneakAttack@@8 DD FLAT:??_R0?AVCvAIOperationNavalSneakAttack@@@8 ; CvAIOperationNavalSneakAttack::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvAIOperationNavalSneakAttack@@8
rdata$r	ENDS
;	COMDAT ??_R2CvAIOperationNavalSneakAttack@@8
rdata$r	SEGMENT
??_R2CvAIOperationNavalSneakAttack@@8 DD FLAT:??_R1A@?0A@EA@CvAIOperationNavalSneakAttack@@8 ; CvAIOperationNavalSneakAttack::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvAIOperationNavalAttack@@8
	DD	FLAT:??_R1A@?0A@EA@CvAINavalEscortedOperation@@8
	DD	FLAT:??_R1A@?0A@EA@CvAIOperation@@8
rdata$r	ENDS
;	COMDAT ??_R3CvAIOperationNavalSneakAttack@@8
rdata$r	SEGMENT
??_R3CvAIOperationNavalSneakAttack@@8 DD 00H		; CvAIOperationNavalSneakAttack::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2CvAIOperationNavalSneakAttack@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvAIOperationNavalSneakAttack@@@8
_DATA	SEGMENT
??_R0?AVCvAIOperationNavalSneakAttack@@@8 DD FLAT:??_7type_info@@6B@ ; CvAIOperationNavalSneakAttack `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvAIOperationNavalSneakAttack@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvAIOperationNavalSneakAttack@@6B@
rdata$r	SEGMENT
??_R4CvAIOperationNavalSneakAttack@@6B@ DD 00H		; CvAIOperationNavalSneakAttack::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvAIOperationNavalSneakAttack@@@8
	DD	FLAT:??_R3CvAIOperationNavalSneakAttack@@8
rdata$r	ENDS
;	COMDAT ??_7CvAIOperationNavalSneakAttack@@6B@
CONST	SEGMENT
??_7CvAIOperationNavalSneakAttack@@6B@ DD FLAT:??_R4CvAIOperationNavalSneakAttack@@6B@ ; CvAIOperationNavalSneakAttack::`vftable'
	DD	FLAT:??_ECvAIOperationNavalSneakAttack@@UAEPAXI@Z
	DD	FLAT:?Init@CvAIOperationNavalAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAIOperationNavalSneakAttack@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAIOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAIOperationNavalSneakAttack@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAINavalEscortedOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAIOperationNavalAttack@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:?ArmyInPosition@CvAIOperationNavalAttack@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperation@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAIOperationNavalAttack@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAIOperationNavalAttack@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAIOperationNavalAttack@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAIOperationNavalSneakAttack@@UBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAIOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	DD	FLAT:?IsCivilianRequired@CvAIOperationNavalAttack@@UBE_NXZ
	DD	FLAT:?FindBestCivilian@CvAINavalEscortedOperation@@UAEPAVCvUnit@@XZ
	DD	FLAT:?FindBestTarget@CvAIOperationNavalAttack@@MAEPAVCvPlot@@XZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvAIOperationNavalSneakAttack@@QAE@XZ
_TEXT	SEGMENT
??0CvAIOperationNavalSneakAttack@@QAE@XZ PROC		; CvAIOperationNavalSneakAttack::CvAIOperationNavalSneakAttack, COMDAT
; _this$ = ecx

; 5533 : {

	push	esi
	mov	esi, ecx
	call	??0CvAIOperation@@QAE@XZ		; CvAIOperation::CvAIOperation
	or	eax, -1
	mov	DWORD PTR [esi+116], eax
	mov	DWORD PTR [esi+112], eax
	mov	DWORD PTR [esi], OFFSET ??_7CvAIOperationNavalSneakAttack@@6B@

; 5534 : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvAIOperationNavalSneakAttack@@QAE@XZ ENDP		; CvAIOperationNavalSneakAttack::CvAIOperationNavalSneakAttack
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
_TEXT	ENDS
;	COMDAT ?GetOperationType@CvAIOperationNavalSneakAttack@@UBEHXZ
_TEXT	SEGMENT
?GetOperationType@CvAIOperationNavalSneakAttack@@UBEHXZ PROC ; CvAIOperationNavalSneakAttack::GetOperationType, COMDAT
; _this$ = ecx

; 973  : 		return AI_OPERATION_NAVAL_SNEAK_ATTACK;

	mov	eax, 14					; 0000000eH

; 974  : 	}

	ret	0
?GetOperationType@CvAIOperationNavalSneakAttack@@UBEHXZ ENDP ; CvAIOperationNavalSneakAttack::GetOperationType
_TEXT	ENDS
PUBLIC	??_C@_0CA@NNILHGCD@AI_OPERATION_NAVAL_SNEAK_ATTACK?$AA@ ; `string'
;	COMDAT ??_C@_0CA@NNILHGCD@AI_OPERATION_NAVAL_SNEAK_ATTACK?$AA@
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0CA@NNILHGCD@AI_OPERATION_NAVAL_SNEAK_ATTACK?$AA@ DB 'AI_OPERATION_'
	DB	'NAVAL_SNEAK_ATTACK', 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
CONST	ENDS
;	COMDAT ?GetOperationName@CvAIOperationNavalSneakAttack@@UBE?AVCvString@@XZ
_TEXT	SEGMENT
$T247711 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetOperationName@CvAIOperationNavalSneakAttack@@UBE?AVCvString@@XZ PROC ; CvAIOperationNavalSneakAttack::GetOperationName, COMDAT
; _this$ = ecx

; 976  : 	{

	push	ecx
	push	esi

; 977  : 		return CvString("AI_OPERATION_NAVAL_SNEAK_ATTACK");

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	push	OFFSET ??_C@_0CA@NNILHGCD@AI_OPERATION_NAVAL_SNEAK_ATTACK?$AA@
	mov	ecx, esi
	mov	DWORD PTR $T247711[esp+12], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi

; 978  : 	}

	pop	ecx
	ret	4
?GetOperationName@CvAIOperationNavalSneakAttack@@UBE?AVCvString@@XZ ENDP ; CvAIOperationNavalSneakAttack::GetOperationName
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetFormation@CvAIOperationNavalSneakAttack@@UBE?AW4MultiunitFormationTypes@@XZ
_TEXT	SEGMENT
?GetFormation@CvAIOperationNavalSneakAttack@@UBE?AW4MultiunitFormationTypes@@XZ PROC ; CvAIOperationNavalSneakAttack::GetFormation, COMDAT
; _this$ = ecx

; 981  : 		return MUFORMATION_NAVAL_INVASION;

	mov	eax, 12					; 0000000cH

; 982  : 	}

	ret	0
?GetFormation@CvAIOperationNavalSneakAttack@@UBE?AW4MultiunitFormationTypes@@XZ ENDP ; CvAIOperationNavalSneakAttack::GetFormation
_TEXT	ENDS
PUBLIC	??1CvAIOperationNavalSneakAttack@@UAE@XZ	; CvAIOperationNavalSneakAttack::~CvAIOperationNavalSneakAttack
; Function compile flags: /Ogtpy
;	COMDAT ??1CvAIOperationNavalSneakAttack@@UAE@XZ
_TEXT	SEGMENT
??1CvAIOperationNavalSneakAttack@@UAE@XZ PROC		; CvAIOperationNavalSneakAttack::~CvAIOperationNavalSneakAttack, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], OFFSET ??_7CvAINavalEscortedOperation@@6B@
	jmp	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
??1CvAIOperationNavalSneakAttack@@UAE@XZ ENDP		; CvAIOperationNavalSneakAttack::~CvAIOperationNavalSneakAttack
_TEXT	ENDS
PUBLIC	??_7CvAIOperationNavalCityStateAttack@@6B@	; CvAIOperationNavalCityStateAttack::`vftable'
PUBLIC	??0CvAIOperationNavalCityStateAttack@@QAE@XZ	; CvAIOperationNavalCityStateAttack::CvAIOperationNavalCityStateAttack
PUBLIC	??_R4CvAIOperationNavalCityStateAttack@@6B@	; CvAIOperationNavalCityStateAttack::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvAIOperationNavalCityStateAttack@@@8	; CvAIOperationNavalCityStateAttack `RTTI Type Descriptor'
PUBLIC	??_R3CvAIOperationNavalCityStateAttack@@8	; CvAIOperationNavalCityStateAttack::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvAIOperationNavalCityStateAttack@@8	; CvAIOperationNavalCityStateAttack::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvAIOperationNavalCityStateAttack@@8 ; CvAIOperationNavalCityStateAttack::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?GetOperationType@CvAIOperationNavalCityStateAttack@@UBEHXZ ; CvAIOperationNavalCityStateAttack::GetOperationType
PUBLIC	?GetFormation@CvAIOperationNavalCityStateAttack@@UBE?AW4MultiunitFormationTypes@@XZ ; CvAIOperationNavalCityStateAttack::GetFormation
PUBLIC	?GetOperationName@CvAIOperationNavalCityStateAttack@@UBE?AVCvString@@XZ ; CvAIOperationNavalCityStateAttack::GetOperationName
EXTRN	??_ECvAIOperationNavalCityStateAttack@@UAEPAXI@Z:PROC ; CvAIOperationNavalCityStateAttack::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvAIOperationNavalCityStateAttack@@8
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@CvAIOperationNavalCityStateAttack@@8 DD FLAT:??_R0?AVCvAIOperationNavalCityStateAttack@@@8 ; CvAIOperationNavalCityStateAttack::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvAIOperationNavalCityStateAttack@@8
rdata$r	ENDS
;	COMDAT ??_R2CvAIOperationNavalCityStateAttack@@8
rdata$r	SEGMENT
??_R2CvAIOperationNavalCityStateAttack@@8 DD FLAT:??_R1A@?0A@EA@CvAIOperationNavalCityStateAttack@@8 ; CvAIOperationNavalCityStateAttack::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvAIOperationNavalAttack@@8
	DD	FLAT:??_R1A@?0A@EA@CvAINavalEscortedOperation@@8
	DD	FLAT:??_R1A@?0A@EA@CvAIOperation@@8
rdata$r	ENDS
;	COMDAT ??_R3CvAIOperationNavalCityStateAttack@@8
rdata$r	SEGMENT
??_R3CvAIOperationNavalCityStateAttack@@8 DD 00H	; CvAIOperationNavalCityStateAttack::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2CvAIOperationNavalCityStateAttack@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvAIOperationNavalCityStateAttack@@@8
_DATA	SEGMENT
??_R0?AVCvAIOperationNavalCityStateAttack@@@8 DD FLAT:??_7type_info@@6B@ ; CvAIOperationNavalCityStateAttack `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvAIOperationNavalCityStateAttack@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvAIOperationNavalCityStateAttack@@6B@
rdata$r	SEGMENT
??_R4CvAIOperationNavalCityStateAttack@@6B@ DD 00H	; CvAIOperationNavalCityStateAttack::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvAIOperationNavalCityStateAttack@@@8
	DD	FLAT:??_R3CvAIOperationNavalCityStateAttack@@8
rdata$r	ENDS
;	COMDAT ??_7CvAIOperationNavalCityStateAttack@@6B@
CONST	SEGMENT
??_7CvAIOperationNavalCityStateAttack@@6B@ DD FLAT:??_R4CvAIOperationNavalCityStateAttack@@6B@ ; CvAIOperationNavalCityStateAttack::`vftable'
	DD	FLAT:??_ECvAIOperationNavalCityStateAttack@@UAEPAXI@Z
	DD	FLAT:?Init@CvAIOperationNavalAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAIOperationNavalCityStateAttack@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAIOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAIOperationNavalCityStateAttack@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAINavalEscortedOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAIOperationNavalAttack@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:?ArmyInPosition@CvAIOperationNavalAttack@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperation@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAIOperationNavalAttack@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAIOperationNavalAttack@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAIOperationNavalAttack@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAIOperationNavalCityStateAttack@@UBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAIOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	DD	FLAT:?IsCivilianRequired@CvAIOperationNavalAttack@@UBE_NXZ
	DD	FLAT:?FindBestCivilian@CvAINavalEscortedOperation@@UAEPAVCvUnit@@XZ
	DD	FLAT:?FindBestTarget@CvAIOperationNavalAttack@@MAEPAVCvPlot@@XZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvAIOperationNavalCityStateAttack@@QAE@XZ
_TEXT	SEGMENT
??0CvAIOperationNavalCityStateAttack@@QAE@XZ PROC	; CvAIOperationNavalCityStateAttack::CvAIOperationNavalCityStateAttack, COMDAT
; _this$ = ecx

; 5542 : {

	push	esi
	mov	esi, ecx
	call	??0CvAIOperation@@QAE@XZ		; CvAIOperation::CvAIOperation
	or	eax, -1
	mov	DWORD PTR [esi+116], eax
	mov	DWORD PTR [esi+112], eax
	mov	DWORD PTR [esi], OFFSET ??_7CvAIOperationNavalCityStateAttack@@6B@

; 5543 : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvAIOperationNavalCityStateAttack@@QAE@XZ ENDP	; CvAIOperationNavalCityStateAttack::CvAIOperationNavalCityStateAttack
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
_TEXT	ENDS
;	COMDAT ?GetOperationType@CvAIOperationNavalCityStateAttack@@UBEHXZ
_TEXT	SEGMENT
?GetOperationType@CvAIOperationNavalCityStateAttack@@UBEHXZ PROC ; CvAIOperationNavalCityStateAttack::GetOperationType, COMDAT
; _this$ = ecx

; 996  : 		return AI_OPERATION_CITY_STATE_NAVAL_ATTACK;

	mov	eax, 16					; 00000010H

; 997  : 	}

	ret	0
?GetOperationType@CvAIOperationNavalCityStateAttack@@UBEHXZ ENDP ; CvAIOperationNavalCityStateAttack::GetOperationType
_TEXT	ENDS
PUBLIC	??_C@_0CF@MIBBKMNF@AI_OPERATION_CITY_STATE_NAVAL_AT@ ; `string'
;	COMDAT ??_C@_0CF@MIBBKMNF@AI_OPERATION_CITY_STATE_NAVAL_AT@
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0CF@MIBBKMNF@AI_OPERATION_CITY_STATE_NAVAL_AT@ DB 'AI_OPERATION_CIT'
	DB	'Y_STATE_NAVAL_ATTACK', 00H			; `string'
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
CONST	ENDS
;	COMDAT ?GetOperationName@CvAIOperationNavalCityStateAttack@@UBE?AVCvString@@XZ
_TEXT	SEGMENT
$T247760 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetOperationName@CvAIOperationNavalCityStateAttack@@UBE?AVCvString@@XZ PROC ; CvAIOperationNavalCityStateAttack::GetOperationName, COMDAT
; _this$ = ecx

; 999  : 	{

	push	ecx
	push	esi

; 1000 : 		return CvString("AI_OPERATION_CITY_STATE_NAVAL_ATTACK");

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	push	OFFSET ??_C@_0CF@MIBBKMNF@AI_OPERATION_CITY_STATE_NAVAL_AT@
	mov	ecx, esi
	mov	DWORD PTR $T247760[esp+12], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi

; 1001 : 	}

	pop	ecx
	ret	4
?GetOperationName@CvAIOperationNavalCityStateAttack@@UBE?AVCvString@@XZ ENDP ; CvAIOperationNavalCityStateAttack::GetOperationName
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetFormation@CvAIOperationNavalCityStateAttack@@UBE?AW4MultiunitFormationTypes@@XZ
_TEXT	SEGMENT
?GetFormation@CvAIOperationNavalCityStateAttack@@UBE?AW4MultiunitFormationTypes@@XZ PROC ; CvAIOperationNavalCityStateAttack::GetFormation, COMDAT
; _this$ = ecx

; 1004 : 		return MUFORMATION_CITY_STATE_INVASION;

	mov	eax, 13					; 0000000dH

; 1005 : 	}

	ret	0
?GetFormation@CvAIOperationNavalCityStateAttack@@UBE?AW4MultiunitFormationTypes@@XZ ENDP ; CvAIOperationNavalCityStateAttack::GetFormation
_TEXT	ENDS
PUBLIC	??1CvAIOperationNavalCityStateAttack@@UAE@XZ	; CvAIOperationNavalCityStateAttack::~CvAIOperationNavalCityStateAttack
; Function compile flags: /Ogtpy
;	COMDAT ??1CvAIOperationNavalCityStateAttack@@UAE@XZ
_TEXT	SEGMENT
??1CvAIOperationNavalCityStateAttack@@UAE@XZ PROC	; CvAIOperationNavalCityStateAttack::~CvAIOperationNavalCityStateAttack, COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], OFFSET ??_7CvAINavalEscortedOperation@@6B@
	jmp	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
??1CvAIOperationNavalCityStateAttack@@UAE@XZ ENDP	; CvAIOperationNavalCityStateAttack::~CvAIOperationNavalCityStateAttack
_TEXT	ENDS
PUBLIC	??_7CvAIOperationNukeAttack@@6B@		; CvAIOperationNukeAttack::`vftable'
PUBLIC	??0CvAIOperationNukeAttack@@QAE@XZ		; CvAIOperationNukeAttack::CvAIOperationNukeAttack
PUBLIC	??_R4CvAIOperationNukeAttack@@6B@		; CvAIOperationNukeAttack::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvAIOperationNukeAttack@@@8		; CvAIOperationNukeAttack `RTTI Type Descriptor'
PUBLIC	??_R3CvAIOperationNukeAttack@@8			; CvAIOperationNukeAttack::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvAIOperationNukeAttack@@8			; CvAIOperationNukeAttack::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvAIOperationNukeAttack@@8	; CvAIOperationNukeAttack::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?Init@CvAIOperationNukeAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ; CvAIOperationNukeAttack::Init
PUBLIC	?GetOperationType@CvAIOperationNukeAttack@@UBEHXZ ; CvAIOperationNukeAttack::GetOperationType
PUBLIC	?NeedToCheckPathToTarget@CvAIOperationNukeAttack@@UBE_NXZ ; CvAIOperationNukeAttack::NeedToCheckPathToTarget
PUBLIC	?GetFormation@CvAIOperationNukeAttack@@UBE?AW4MultiunitFormationTypes@@XZ ; CvAIOperationNukeAttack::GetFormation
PUBLIC	?Read@CvAIOperationNukeAttack@@UAEXAAVFDataStream@@@Z ; CvAIOperationNukeAttack::Read
PUBLIC	?GetOperationName@CvAIOperationNukeAttack@@UBE?AVCvString@@XZ ; CvAIOperationNukeAttack::GetOperationName
PUBLIC	?GetDeployRange@CvAIOperationNukeAttack@@UBEHXZ	; CvAIOperationNukeAttack::GetDeployRange
EXTRN	??_ECvAIOperationNukeAttack@@UAEPAXI@Z:PROC	; CvAIOperationNukeAttack::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvAIOperationNukeAttack@@8
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@CvAIOperationNukeAttack@@8 DD FLAT:??_R0?AVCvAIOperationNukeAttack@@@8 ; CvAIOperationNukeAttack::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvAIOperationNukeAttack@@8
rdata$r	ENDS
;	COMDAT ??_R2CvAIOperationNukeAttack@@8
rdata$r	SEGMENT
??_R2CvAIOperationNukeAttack@@8 DD FLAT:??_R1A@?0A@EA@CvAIOperationNukeAttack@@8 ; CvAIOperationNukeAttack::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvAIOperation@@8
rdata$r	ENDS
;	COMDAT ??_R3CvAIOperationNukeAttack@@8
rdata$r	SEGMENT
??_R3CvAIOperationNukeAttack@@8 DD 00H			; CvAIOperationNukeAttack::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvAIOperationNukeAttack@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvAIOperationNukeAttack@@@8
_DATA	SEGMENT
??_R0?AVCvAIOperationNukeAttack@@@8 DD FLAT:??_7type_info@@6B@ ; CvAIOperationNukeAttack `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvAIOperationNukeAttack@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvAIOperationNukeAttack@@6B@
rdata$r	SEGMENT
??_R4CvAIOperationNukeAttack@@6B@ DD 00H		; CvAIOperationNukeAttack::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvAIOperationNukeAttack@@@8
	DD	FLAT:??_R3CvAIOperationNukeAttack@@8
rdata$r	ENDS
;	COMDAT ??_7CvAIOperationNukeAttack@@6B@
CONST	SEGMENT
??_7CvAIOperationNukeAttack@@6B@ DD FLAT:??_R4CvAIOperationNukeAttack@@6B@ ; CvAIOperationNukeAttack::`vftable'
	DD	FLAT:??_ECvAIOperationNukeAttack@@UAEPAXI@Z
	DD	FLAT:?Init@CvAIOperationNukeAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
	DD	FLAT:?Uninit@CvAIOperation@@UAEXXZ
	DD	FLAT:?Reset@CvAIOperation@@UAEXXZ
	DD	FLAT:?GetOperationType@CvAIOperationNukeAttack@@UBEHXZ
	DD	FLAT:?CanTacticalAIInterruptOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?NeedToCheckPathToTarget@CvAIOperationNukeAttack@@UBE_NXZ
	DD	FLAT:?GetMaximumRecruitTurns@CvAIOperation@@UBEHXZ
	DD	FLAT:?GetFormation@CvAIOperationNukeAttack@@UBE?AW4MultiunitFormationTypes@@XZ
	DD	FLAT:?GetMoveType@CvAIOperation@@UBE?AW4AIOperationMovementType@@XZ
	DD	FLAT:?IsAllNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?IsMixedLandNavalOperation@CvAIOperation@@UBE_NXZ
	DD	FLAT:?GetGatherTolerance@CvAIOperation@@UBEHPAVCvArmyAI@@PAVCvPlot@@@Z
	DD	FLAT:?GetOperationStartCity@CvAIOperationNukeAttack@@UBEPAVCvCity@@XZ
	DD	FLAT:?CheckOnTarget@CvAIOperation@@UAE_NXZ
	DD	FLAT:?ArmyInPosition@CvAIOperationNukeAttack@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?ArmyMoved@CvAIOperation@@UAE_NPAVCvArmyAI@@@Z
	DD	FLAT:?PercentFromMusterPointToTarget@CvAIOperation@@UAEHXZ
	DD	FLAT:?ShouldAbort@CvAIOperation@@UAE_NXZ
	DD	FLAT:?SetToAbort@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?Kill@CvAIOperation@@UAEXW4AIOperationAbortReason@@@Z
	DD	FLAT:?DoTurn@CvAIOperation@@UAEXXZ
	DD	FLAT:?DoDelayedDeath@CvAIOperation@@UAE_NXZ
	DD	FLAT:?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
	DD	FLAT:?PeekAtNextUnitToBuild@CvAIOperation@@UAE?AUOperationSlot@@H@Z
	DD	FLAT:?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
	DD	FLAT:?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?FinishedBuilding@CvAIOperation@@UAE_NUOperationSlot@@@Z
	DD	FLAT:?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	FLAT:?UnitWasRemoved@CvAIOperation@@UAEXHH@Z
	DD	FLAT:?ComputeCenterOfMassForTurn@CvAIOperation@@UBEPAVCvPlot@@PAVCvArmyAI@@PAPAV2@@Z
	DD	FLAT:?Read@CvAIOperationNukeAttack@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?Write@CvAIOperationNukeAttack@@UBEXAAVFDataStream@@@Z
	DD	FLAT:?GetOperationName@CvAIOperationNukeAttack@@UBE?AVCvString@@XZ
	DD	FLAT:?SelectInitialMusterPoint@CvAIOperation@@MAEPAVCvPlot@@PAVCvArmyAI@@@Z
	DD	FLAT:?FindBestFitReserveUnit@CvAIOperationNukeAttack@@UAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	DD	FLAT:?GetDeployRange@CvAIOperationNukeAttack@@UBEHXZ
	DD	FLAT:?FindBestTarget@CvAIOperationNukeAttack@@MAEPAVCvPlot@@XZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvAIOperationNukeAttack@@QAE@XZ
_TEXT	SEGMENT
??0CvAIOperationNukeAttack@@QAE@XZ PROC			; CvAIOperationNukeAttack::CvAIOperationNukeAttack, COMDAT
; _this$ = ecx

; 5547 : {

	push	esi
	mov	esi, ecx
	call	??0CvAIOperation@@QAE@XZ		; CvAIOperation::CvAIOperation
	mov	DWORD PTR [esi], OFFSET ??_7CvAIOperationNukeAttack@@6B@

; 5548 : 	m_iBestUnitID = -1;

	mov	DWORD PTR [esi+112], -1

; 5549 : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvAIOperationNukeAttack@@QAE@XZ ENDP			; CvAIOperationNukeAttack::CvAIOperationNukeAttack
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
_TEXT	ENDS
;	COMDAT ?GetOperationType@CvAIOperationNukeAttack@@UBEHXZ
_TEXT	SEGMENT
?GetOperationType@CvAIOperationNukeAttack@@UBEHXZ PROC	; CvAIOperationNukeAttack::GetOperationType, COMDAT
; _this$ = ecx

; 1025 : 		return AI_OPERATION_NUKE_ATTACK;

	mov	eax, 17					; 00000011H

; 1026 : 	}

	ret	0
?GetOperationType@CvAIOperationNukeAttack@@UBEHXZ ENDP	; CvAIOperationNukeAttack::GetOperationType
_TEXT	ENDS
PUBLIC	??_C@_0BJ@GDACEMPM@AI_OPERATION_NUKE_ATTACK?$AA@ ; `string'
;	COMDAT ??_C@_0BJ@GDACEMPM@AI_OPERATION_NUKE_ATTACK?$AA@
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
CONST	SEGMENT
??_C@_0BJ@GDACEMPM@AI_OPERATION_NUKE_ATTACK?$AA@ DB 'AI_OPERATION_NUKE_AT'
	DB	'TACK', 00H					; `string'
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.h
CONST	ENDS
;	COMDAT ?GetOperationName@CvAIOperationNukeAttack@@UBE?AVCvString@@XZ
_TEXT	SEGMENT
$T247799 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?GetOperationName@CvAIOperationNukeAttack@@UBE?AVCvString@@XZ PROC ; CvAIOperationNukeAttack::GetOperationName, COMDAT
; _this$ = ecx

; 1028 : 	{

	push	ecx
	push	esi

; 1029 : 		return CvString("AI_OPERATION_NUKE_ATTACK");

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	push	OFFSET ??_C@_0BJ@GDACEMPM@AI_OPERATION_NUKE_ATTACK?$AA@
	mov	ecx, esi
	mov	DWORD PTR $T247799[esp+12], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi

; 1030 : 	}

	pop	ecx
	ret	4
?GetOperationName@CvAIOperationNukeAttack@@UBE?AVCvString@@XZ ENDP ; CvAIOperationNukeAttack::GetOperationName
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?NeedToCheckPathToTarget@CvAIOperationNukeAttack@@UBE_NXZ
_TEXT	SEGMENT
?NeedToCheckPathToTarget@CvAIOperationNukeAttack@@UBE_NXZ PROC ; CvAIOperationNukeAttack::NeedToCheckPathToTarget, COMDAT
; _this$ = ecx

; 1033 : 		return false;

	xor	al, al

; 1034 : 	}

	ret	0
?NeedToCheckPathToTarget@CvAIOperationNukeAttack@@UBE_NXZ ENDP ; CvAIOperationNukeAttack::NeedToCheckPathToTarget
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetFormation@CvAIOperationNukeAttack@@UBE?AW4MultiunitFormationTypes@@XZ
_TEXT	SEGMENT
?GetFormation@CvAIOperationNukeAttack@@UBE?AW4MultiunitFormationTypes@@XZ PROC ; CvAIOperationNukeAttack::GetFormation, COMDAT
; _this$ = ecx

; 1037 : 		return MUFORMATION_NUKE_ATTACK;

	mov	eax, 14					; 0000000eH

; 1038 : 	}

	ret	0
?GetFormation@CvAIOperationNukeAttack@@UBE?AW4MultiunitFormationTypes@@XZ ENDP ; CvAIOperationNukeAttack::GetFormation
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetDeployRange@CvAIOperationNukeAttack@@UBEHXZ
_TEXT	SEGMENT
?GetDeployRange@CvAIOperationNukeAttack@@UBEHXZ PROC	; CvAIOperationNukeAttack::GetDeployRange, COMDAT
; _this$ = ecx

; 1041 : 		return 10;

	mov	eax, 10					; 0000000aH

; 1042 : 	}

	ret	0
?GetDeployRange@CvAIOperationNukeAttack@@UBEHXZ ENDP	; CvAIOperationNukeAttack::GetDeployRange
_TEXT	ENDS
PUBLIC	??1CvAIOperationNukeAttack@@UAE@XZ		; CvAIOperationNukeAttack::~CvAIOperationNukeAttack
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
;	COMDAT ??1CvAIOperationNukeAttack@@UAE@XZ
_TEXT	SEGMENT
??1CvAIOperationNukeAttack@@UAE@XZ PROC			; CvAIOperationNukeAttack::~CvAIOperationNukeAttack, COMDAT
; _this$ = ecx

; 5552 : {

	mov	DWORD PTR [ecx], OFFSET ??_7CvAIOperationNukeAttack@@6B@

; 5553 : }

	jmp	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
??1CvAIOperationNukeAttack@@UAE@XZ ENDP			; CvAIOperationNukeAttack::~CvAIOperationNukeAttack
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Init@CvAIOperationNukeAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
_TEXT	SEGMENT
$T247826 = 8						; size = 4
_iID$ = 8						; size = 4
_eOwner$ = 12						; size = 4
_eEnemy$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 4
?Init@CvAIOperationNukeAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z PROC ; CvAIOperationNukeAttack::Init, COMDAT
; _this$ = ecx

; 5556 : {

	push	esi
	mov	esi, ecx

; 5557 : 	Reset();

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+12]
	call	edx

; 5558 : 	m_eMoveType = AI_OPERATION_MOVETYPE_STATIC; // this operation will only work when the units are already in place
; 5559 : 	m_iID = iID;

	mov	ecx, DWORD PTR _iID$[esp]

; 5560 : 	m_eOwner = eOwner;

	mov	eax, DWORD PTR _eOwner$[esp]

; 5561 : 	m_eEnemy = eEnemy;

	mov	edx, DWORD PTR _eEnemy$[esp]
	mov	DWORD PTR [esi+84], 5
	mov	DWORD PTR [esi+52], ecx
	mov	DWORD PTR [esi+72], eax
	mov	DWORD PTR [esi+76], edx

; 5562 : 
; 5563 : 	if(iID != -1)

	cmp	ecx, -1
	je	$LN1@Init@11

; 5564 : 	{
; 5565 : 		// create the armies that are needed and set the state to ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE
; 5566 : 		CvPlayer& kPlayer = GET_PLAYER(m_eOwner);

	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edi

; 5567 : 		CvArmyAI* pArmyAI = kPlayer.addArmyAI();

	mov	ecx, eax
	call	?addArmyAI@CvPlayer@@QAEPAVCvArmyAI@@XZ	; CvPlayer::addArmyAI
	mov	edi, eax

; 5568 : 		if(pArmyAI)

	test	edi, edi
	je	$LN27@Init@11
	push	ebx

; 5569 : 		{
; 5570 : 			m_viArmyIDs.push_back(pArmyAI->GetID());

	mov	ecx, edi
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	mov	DWORD PTR $T247826[esp+8], eax
	lea	eax, DWORD PTR $T247826[esp+8]
	push	eax
	lea	ecx, DWORD PTR [esi+4]
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 5571 : 			pArmyAI->Init(pArmyAI->GetID(), m_eOwner, m_iID);

	mov	ecx, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [esi+72]
	push	ecx
	push	edx
	mov	ecx, edi
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	push	eax
	mov	ecx, edi
	call	?Init@CvArmyAI@@QAEXHW4PlayerTypes@@H@Z	; CvArmyAI::Init

; 5572 : 			pArmyAI->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE);

	push	0
	mov	ecx, edi
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 5573 : 			pArmyAI->SetFormationIndex(GetFormation());

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+32]
	mov	ecx, esi
	call	edx
	push	eax
	mov	ecx, edi
	call	?SetFormationIndex@CvArmyAI@@QAEXH@Z	; CvArmyAI::SetFormationIndex

; 5574 : 
; 5575 : 			// Figure out the target spot
; 5576 : 			CvPlot* pTargetPlot = FindBestTarget();

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+148]
	mov	ecx, esi
	call	edx
	mov	ebx, eax

; 5577 : 			if(pTargetPlot != NULL)

	test	ebx, ebx
	je	$LN4@Init@11

; 5578 : 			{
; 5579 : 				SetTargetPlot(pTargetPlot);

	movsx	eax, WORD PTR [ebx]
	mov	DWORD PTR [esi+104], eax
	movsx	ecx, WORD PTR [ebx+2]
	mov	DWORD PTR [esi+108], ecx

; 5580 : 				pArmyAI->SetGoalPlot(pTargetPlot);

	push	ebx
	mov	ecx, edi
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 5581 : 				// Find the list of units we need to build before starting this operation in earnest
; 5582 : 				BuildListOfUnitsWeStillNeedToBuild();

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+92]
	mov	ecx, esi
	call	eax

; 5583 : 				// try to get as many units as possible from existing units that are waiting around
; 5584 : 				if(GrabUnitsFromTheReserves(GC.getMap().plotCheckInvalid(m_iMusterX, m_iMusterY), pTargetPlot))

	mov	ecx, DWORD PTR [esi+96]
	mov	edx, DWORD PTR [esi+100]
	cmp	ecx, -2147483647			; 80000001H
	je	SHORT $LN19@Init@11
	cmp	edx, -2147483647			; 80000001H
	je	SHORT $LN19@Init@11
	push	ebp
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	eax, DWORD PTR [ebp+4020]
	imul	eax, edx
	add	eax, ecx
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ebp+4068]
	pop	ebp
	jmp	SHORT $LN21@Init@11
$LN19@Init@11:
	xor	eax, eax
$LN21@Init@11:
	mov	edx, DWORD PTR [esi]
	push	ebx
	push	eax
	mov	eax, DWORD PTR [edx+112]
	mov	ecx, esi
	call	eax
	test	al, al
	je	SHORT $LN3@Init@11

; 5585 : 				{
; 5586 : 					pArmyAI->SetArmyAIState(ARMYAISTATE_AT_DESTINATION);

	push	3
	mov	ecx, edi
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 5587 : 					m_eCurrentState = AI_OPERATION_STATE_AT_TARGET;
; 5588 : 					LogOperationStart();

	mov	ecx, esi
	mov	DWORD PTR [esi+56], 4
	call	?LogOperationStart@CvAIOperation@@QAEXXZ ; CvAIOperation::LogOperationStart

; 5589 : 					ArmyInPosition(pArmyAI);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+60]
	push	edi
	mov	ecx, esi
	call	eax
	pop	ebx
	pop	edi
	pop	esi

; 5604 : 			}
; 5605 : 		}
; 5606 : 	}
; 5607 : }

	ret	24					; 00000018H
$LN3@Init@11:
	pop	ebx
	pop	edi

; 5590 : 				}
; 5591 : 				else
; 5592 : 				{
; 5593 : 					// No nukes, abort
; 5594 : 					m_eCurrentState = AI_OPERATION_STATE_ABORTED;
; 5595 : 					m_eAbortReason = AI_ABORT_NO_NUKES;

	mov	DWORD PTR [esi+60], 10			; 0000000aH

; 5596 : 				}
; 5597 : 			}
; 5598 : 
; 5599 : 			else
; 5600 : 			{
; 5601 : 				// No target, abort
; 5602 : 				m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	DWORD PTR [esi+56], 0
	pop	esi

; 5604 : 			}
; 5605 : 		}
; 5606 : 	}
; 5607 : }

	ret	24					; 00000018H
$LN4@Init@11:

; 5603 : 				m_eAbortReason = AI_ABORT_LOST_TARGET;

	mov	DWORD PTR [esi+60], 3
	mov	DWORD PTR [esi+56], 0
	pop	ebx
$LN27@Init@11:
	pop	edi
$LN1@Init@11:
	pop	esi

; 5604 : 			}
; 5605 : 		}
; 5606 : 	}
; 5607 : }

	ret	24					; 00000018H
?Init@CvAIOperationNukeAttack@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ENDP ; CvAIOperationNukeAttack::Init
_TEXT	ENDS
PUBLIC	?push_back@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXABUOperationSlot@@@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::push_back
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?push_back@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXABUOperationSlot@@@Z
_TEXT	SEGMENT
$T247905 = -4						; size = 1
__Cat$247909 = 8					; size = 1
$T247876 = 8						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXABUOperationSlot@@@Z PROC ; std::vector<OperationSlot,std::allocator<OperationSlot> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx

; 810  : 		if (size() < capacity())

	mov	ebx, DWORD PTR [esi+4]
	push	edi
	test	ebx, ebx
	jne	SHORT $LN9@push_back@6
	xor	ecx, ecx
	jmp	SHORT $LN10@push_back@6
$LN9@push_back@6:
	mov	ecx, DWORD PTR [esi+12]
	sub	ecx, ebx
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
$LN10@push_back@6:
	mov	edi, DWORD PTR [esi+8]
	mov	edx, edi
	sub	edx, ebx
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, ecx
	jae	SHORT $LN2@push_back@6

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR __Cat$247909[esp+12]
	mov	eax, DWORD PTR __Val$[esp+12]
	mov	BYTE PTR $T247905[esp+16], 0
	mov	ecx, DWORD PTR $T247905[esp+16]
	push	ecx
	push	edx
	push	esi
	push	eax
	push	1
	push	edi
	call	??$_Uninit_fill_n@PAUOperationSlot@@IU1@V?$allocator@UOperationSlot@@@std@@@std@@YAXPAUOperationSlot@@IABU1@AAV?$allocator@UOperationSlot@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<OperationSlot *,unsigned int,OperationSlot,std::allocator<OperationSlot> >
	add	esp, 24					; 00000018H
	add	edi, 12					; 0000000cH
	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi
	pop	ebx

; 824  : 		}

	pop	ecx
	ret	4
$LN2@push_back@6:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	mov	ecx, DWORD PTR __Val$[esp+12]
	push	ecx
	push	edi
	lea	edx, DWORD PTR $T247876[esp+20]
	push	edx
	mov	ecx, esi
	call	?insert@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@ABUOperationSlot@@@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::insert
	pop	edi
	pop	esi
	pop	ebx

; 824  : 		}

	pop	ecx
	ret	4
?push_back@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXABUOperationSlot@@@Z ENDP ; std::vector<OperationSlot,std::allocator<OperationSlot> >::push_back
_TEXT	ENDS
PUBLIC	?SortItems@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAEXXZ ; CvWeightedVector<CvPlot *,1,1>::SortItems
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvweightedvector.h
;	COMDAT ?SortItems@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAEXXZ
_TEXT	SEGMENT
?SortItems@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAEXXZ PROC ; CvWeightedVector<CvPlot *,1,1>::SortItems, COMDAT
; _this$ = ecx

; 140  : 		std::sort(m_pItems.begin(), m_pItems.end());

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	edx, ecx
	sub	edx, eax
	sar	edx, 3
	push	edx
	push	ecx
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0H@Z ; std::_Sort<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 141  : 	}

	ret	0
?SortItems@?$CvWeightedVector@PAVCvPlot@@$00$00@@QAEXXZ ENDP ; CvWeightedVector<CvPlot *,1,1>::SortItems
_TEXT	ENDS
PUBLIC	??$SerializeToSequenceContainer@UOperationSlot@@V?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@Z ; SerializeToSequenceContainer<OperationSlot,std::vector<OperationSlot,std::allocator<OperationSlot> > >
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$SerializeToSequenceContainer@UOperationSlot@@V?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@Z
_TEXT	SEGMENT
$T247989 = -16						; size = 4
_v$227957 = -12						; size = 12
_loadFrom$ = 8						; size = 4
_count$ = 12						; size = 4
_container$ = 12					; size = 4
??$SerializeToSequenceContainer@UOperationSlot@@V?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@Z PROC ; SerializeToSequenceContainer<OperationSlot,std::vector<OperationSlot,std::allocator<OperationSlot> > >, COMDAT

; 83   : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi

; 84   : 	container.clear();

	mov	edi, DWORD PTR _container$[esp+24]
	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR [edi+4]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T247989[esp+36]
	push	eax
	mov	ecx, edi
	call	?erase@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@0@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::erase

; 85   : 	ContainerType::size_type count = 0;
; 86   : 	loadFrom >> count;

	mov	esi, DWORD PTR _loadFrom$[esp+24]
	lea	ecx, DWORD PTR _count$[esp+24]
	push	ecx
	xor	ebx, ebx
	mov	ecx, esi
	mov	DWORD PTR _count$[esp+28], ebx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 87   : 	ContainerType::size_type i = 0;
; 88   : 	for(i = 0; i < count; ++i)

	cmp	DWORD PTR _count$[esp+24], ebx
	jbe	SHORT $LN1@SerializeT
	push	ebp
	or	ebp, -1
	npad	2
$LL3@SerializeT:

; 89   : 	{
; 90   : 		ElementType v;
; 91   : 		loadFrom >> v;

	lea	edx, DWORD PTR _v$227957[esp+32]
	push	edx
	mov	ecx, esi
	mov	DWORD PTR _v$227957[esp+36], ebp
	mov	DWORD PTR _v$227957[esp+40], ebp
	mov	DWORD PTR _v$227957[esp+44], ebp
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	lea	eax, DWORD PTR _v$227957[esp+36]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	lea	ecx, DWORD PTR _v$227957[esp+40]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 92   : 		container.push_back(v);

	lea	edx, DWORD PTR _v$227957[esp+32]
	push	edx
	mov	ecx, edi
	call	?push_back@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXABUOperationSlot@@@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::push_back
	inc	ebx
	cmp	ebx, DWORD PTR _count$[esp+28]
	jb	SHORT $LL3@SerializeT
	pop	ebp
$LN1@SerializeT:
	pop	edi
	pop	esi
	pop	ebx

; 93   : 	}
; 94   : }

	add	esp, 16					; 00000010H
	ret	0
??$SerializeToSequenceContainer@UOperationSlot@@V?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@Z ENDP ; SerializeToSequenceContainer<OperationSlot,std::vector<OperationSlot,std::allocator<OperationSlot> > >
_TEXT	ENDS
PUBLIC	??$_Stable_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0HAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z ; std::_Stable_sort<CvOperationSearchUnit *,int,CvOperationSearchUnit>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Stable_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0HAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Count$ = 16						; size = 4
__Tempbuf$ = 20						; size = 4
??$_Stable_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0HAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z PROC ; std::_Stable_sort<CvOperationSearchUnit *,int,CvOperationSearchUnit>, COMDAT

; 3381 : 	{	//  sort preserving order of equivalents, using operator<

	push	edi

; 3382 : 	if (_Count <= _ISORT_MAX)

	mov	edi, DWORD PTR __Count$[esp]
	cmp	edi, 32					; 00000020H
	jg	SHORT $LN4@Stable_sor

; 3383 : 		std::_Insertion_sort(_First, _Last);	// small

	mov	eax, DWORD PTR __Last$[esp]
	mov	ecx, DWORD PTR __First$[esp]
	push	0
	push	eax
	push	ecx
	call	??$_Insertion_sort1@PAVCvOperationSearchUnit@@V1@@std@@YAXPAVCvOperationSearchUnit@@00@Z ; std::_Insertion_sort1<CvOperationSearchUnit *,CvOperationSearchUnit>
	add	esp, 12					; 0000000cH
	pop	edi

; 3403 : 		}
; 3404 : 	}

	ret	0
$LN4@Stable_sor:
	push	ebx

; 3384 : 	else
; 3385 : 		{	// sort halves and merge
; 3386 : 		_Diff _Count2 = (_Count + 1) / 2;

	lea	eax, DWORD PTR [edi+1]
	cdq
	push	ebp

; 3387 : 		_BidIt _Mid = _First;
; 3388 : 		std::advance(_Mid, _Count2);
; 3389 : 
; 3390 : 		if (_Count2 <= _Tempbuf._Maxlen())

	mov	ebp, DWORD PTR __Tempbuf$[esp+8]
	sub	eax, edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	esi
	mov	esi, eax
	sar	esi, 1
	mov	ecx, ebp
	lea	ebx, DWORD PTR [edx+esi*8]
	call	?_Maxlen@?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAEHXZ ; std::_Temp_iterator<CvOperationSearchUnit>::_Maxlen
	cmp	esi, eax

; 3391 : 			{	// temp buffer big enough, sort each half using buffer
; 3392 : 			_Buffered_merge_sort(_First, _Mid, _Count2, _Tempbuf);

	push	ebp
	push	esi
	push	ebx
	jg	SHORT $LN2@Stable_sor
	mov	eax, DWORD PTR __First$[esp+24]
	push	eax
	call	??$_Buffered_merge_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0HAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z ; std::_Buffered_merge_sort<CvOperationSearchUnit *,int,CvOperationSearchUnit>

; 3393 : 			_Buffered_merge_sort(_Mid, _Last, _Count - _Count2, _Tempbuf);

	mov	ecx, DWORD PTR __Last$[esp+28]
	push	ebp
	sub	edi, esi
	push	edi
	push	ecx
	push	ebx
	call	??$_Buffered_merge_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0HAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z ; std::_Buffered_merge_sort<CvOperationSearchUnit *,int,CvOperationSearchUnit>

; 3394 : 			}
; 3395 : 		else

	jmp	SHORT $LN17@Stable_sor
$LN2@Stable_sor:

; 3396 : 			{	// temp buffer not big enough, divide and conquer
; 3397 : 			_Stable_sort(_First, _Mid, _Count2, _Tempbuf);

	mov	edx, DWORD PTR __First$[esp+24]
	push	edx
	call	??$_Stable_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0HAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z ; std::_Stable_sort<CvOperationSearchUnit *,int,CvOperationSearchUnit>

; 3398 : 			_Stable_sort(_Mid, _Last, _Count - _Count2, _Tempbuf);

	mov	eax, DWORD PTR __Last$[esp+28]
	push	ebp
	sub	edi, esi
	push	edi
	push	eax
	push	ebx
	call	??$_Stable_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0HAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z ; std::_Stable_sort<CvOperationSearchUnit *,int,CvOperationSearchUnit>
$LN17@Stable_sor:

; 3399 : 			}
; 3400 : 
; 3401 : 		_Buffered_merge(_First, _Mid, _Last,
; 3402 : 			_Count2, _Count - _Count2, _Tempbuf);	// merge sorted halves

	mov	ecx, DWORD PTR __Last$[esp+44]
	mov	edx, DWORD PTR __First$[esp+44]
	add	esp, 32					; 00000020H
	push	ebp
	push	edi
	push	esi
	push	ecx
	push	ebx
	push	edx
	call	??$_Buffered_merge@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@00HHAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z ; std::_Buffered_merge<CvOperationSearchUnit *,int,CvOperationSearchUnit>
	add	esp, 24					; 00000018H
	pop	esi
	pop	ebp
	pop	ebx
	pop	edi

; 3403 : 		}
; 3404 : 	}

	ret	0
??$_Stable_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0HAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z ENDP ; std::_Stable_sort<CvOperationSearchUnit *,int,CvOperationSearchUnit>
_TEXT	ENDS
PUBLIC	??$SerializeToSequenceContainer@HV?$vector@HV?$allocator@H@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ; SerializeToSequenceContainer<int,std::vector<int,std::allocator<int> > >
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$SerializeToSequenceContainer@HV?$vector@HV?$allocator@H@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z
_TEXT	SEGMENT
_v$214337 = -4						; size = 4
_loadFrom$ = 8						; size = 4
_count$ = 12						; size = 4
_container$ = 12					; size = 4
??$SerializeToSequenceContainer@HV?$vector@HV?$allocator@H@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z PROC ; SerializeToSequenceContainer<int,std::vector<int,std::allocator<int> > >, COMDAT

; 83   : {

	push	ecx
	push	ebx
	push	esi

; 84   : 	container.clear();

	mov	esi, DWORD PTR _container$[esp+8]
	mov	ecx, DWORD PTR [esi+8]
	push	edi
	mov	edi, DWORD PTR [esi+4]
	cmp	edi, ecx
	je	SHORT $LN20@SerializeT@2
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	ebx, DWORD PTR [edx+edi]
	test	eax, eax
	jle	SHORT $LN45@SerializeT@2
	push	edx
	push	ecx
	push	edx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN45@SerializeT@2:
	mov	DWORD PTR [esi+8], ebx
$LN20@SerializeT@2:

; 85   : 	ContainerType::size_type count = 0;
; 86   : 	loadFrom >> count;

	mov	edi, DWORD PTR _loadFrom$[esp+12]
	lea	eax, DWORD PTR _count$[esp+12]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR _count$[esp+16], 0
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 87   : 	ContainerType::size_type i = 0;
; 88   : 	for(i = 0; i < count; ++i)

	xor	ebx, ebx
	cmp	DWORD PTR _count$[esp+12], ebx
	jbe	SHORT $LN1@SerializeT@2
	push	ebp
$LL117@SerializeT@2:

; 89   : 	{
; 90   : 		ElementType v;
; 91   : 		loadFrom >> v;

	lea	ecx, DWORD PTR _v$214337[esp+20]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 92   : 		container.push_back(v);

	mov	edx, DWORD PTR [esi+4]
	test	edx, edx
	jne	SHORT $LN60@SerializeT@2
	xor	eax, eax
	jmp	SHORT $LN61@SerializeT@2
$LN60@SerializeT@2:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 2
$LN61@SerializeT@2:
	mov	ecx, DWORD PTR [esi+8]
	mov	ebp, ecx
	sub	ebp, edx
	sar	ebp, 2
	cmp	ebp, eax
	jae	SHORT $LN53@SerializeT@2
	mov	edx, DWORD PTR _v$214337[esp+20]
	mov	DWORD PTR [ecx], edx
	add	ecx, 4
	mov	DWORD PTR [esi+8], ecx
	jmp	SHORT $LN2@SerializeT@2
$LN53@SerializeT@2:
	lea	eax, DWORD PTR _v$214337[esp+20]
	push	eax
	push	1
	push	ecx
	mov	ecx, esi
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
$LN2@SerializeT@2:
	inc	ebx
	cmp	ebx, DWORD PTR _count$[esp+16]
	jb	SHORT $LL117@SerializeT@2
	pop	ebp
$LN1@SerializeT@2:
	pop	edi
	pop	esi
	pop	ebx

; 93   : 	}
; 94   : }

	pop	ecx
	ret	0
??$SerializeToSequenceContainer@HV?$vector@HV?$allocator@H@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ENDP ; SerializeToSequenceContainer<int,std::vector<int,std::allocator<int> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GCvAIOperation@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvAIOperation@@UAEPAXI@Z PROC			; CvAIOperation::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@4
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@4:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvAIOperation@@UAEPAXI@Z ENDP			; CvAIOperation::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z ; CvAIOperation::CreateOperation
EXTRN	?GetBoldness@CvDiplomacyAI@@QBEHXZ:PROC		; CvDiplomacyAI::GetBoldness
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
xdata$x	SEGMENT
__ehfuncinfo$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z DD 019930522H
	DD	015H
	DD	FLAT:__unwindtable$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$9
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$10
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$11
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$12
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$13
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$14
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$15
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$16
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$17
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$18
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$19
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$20
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
xdata$x	ENDS
;	COMDAT ?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
$T248693 = 8						; size = 4
$T248689 = 8						; size = 4
$T248685 = 8						; size = 4
$T248681 = 8						; size = 4
$T248677 = 8						; size = 4
$T248673 = 8						; size = 4
$T248669 = 8						; size = 4
$T248665 = 8						; size = 4
$T248661 = 8						; size = 4
$T248657 = 8						; size = 4
$T248653 = 8						; size = 4
$T248649 = 8						; size = 4
$T248645 = 8						; size = 4
$T248641 = 8						; size = 4
$T248637 = 8						; size = 4
$T248633 = 8						; size = 4
$T248629 = 8						; size = 4
$T248625 = 8						; size = 4
$T248621 = 8						; size = 4
$T248617 = 8						; size = 4
$T248613 = 8						; size = 4
_eAIOperationType$ = 8					; size = 4
_ePlayer$ = 12						; size = 4
?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z PROC ; CvAIOperation::CreateOperation, COMDAT

; 280  : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp

; 281  : 	switch(eAIOperationType)

	mov	eax, DWORD PTR _eAIOperationType$[esp+8]
	cmp	eax, 19					; 00000013H
	ja	$LN22@CreateOper
	jmp	DWORD PTR $LN94@CreateOper[eax*4]
$LN21@CreateOper:

; 282  : 	{
; 283  : 	case AI_OPERATION_BASIC_CITY_ATTACK:
; 284  : 		return FNEW(CvAIOperationBasicCityAttack(), c_eCiv5GameplayDLL, 0);

	push	112					; 00000070H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T248613[esp+8], eax
	mov	DWORD PTR __$EHRec$[esp+20], 0
	test	eax, eax
	je	$LN22@CreateOper
	mov	ecx, eax
	call	??0CvAIOperationBasicCityAttack@@QAE@XZ	; CvAIOperationBasicCityAttack::CvAIOperationBasicCityAttack

; 329  : 	}
; 330  : 
; 331  : 	return 0;
; 332  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+12]
	mov	DWORD PTR fs:0, ecx
	add	esp, 12					; 0000000cH
	ret	0
$LN20@CreateOper:

; 285  : 	case AI_OPERATION_DESTROY_BARBARIAN_CAMP:
; 286  : 		return FNEW(CvAIOperationDestroyBarbarianCamp(), c_eCiv5GameplayDLL, 0);

	push	120					; 00000078H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T248617[esp+8], eax
	mov	DWORD PTR __$EHRec$[esp+20], 1
	test	eax, eax
	je	$LN22@CreateOper
	mov	ecx, eax
	call	??0CvAIOperationDestroyBarbarianCamp@@QAE@XZ ; CvAIOperationDestroyBarbarianCamp::CvAIOperationDestroyBarbarianCamp

; 329  : 	}
; 330  : 
; 331  : 	return 0;
; 332  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+12]
	mov	DWORD PTR fs:0, ecx
	add	esp, 12					; 0000000cH
	ret	0
$LN19@CreateOper:

; 287  : 	case AI_OPERATION_FOUND_CITY:
; 288  : 		return FNEW(CvAIOperationFoundCity(), c_eCiv5GameplayDLL, 0);

	push	124					; 0000007cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T248621[esp+8], eax
	mov	DWORD PTR __$EHRec$[esp+20], 2
	test	eax, eax
	je	$LN22@CreateOper
	mov	ecx, eax
	call	??0CvAIOperationFoundCity@@QAE@XZ	; CvAIOperationFoundCity::CvAIOperationFoundCity

; 329  : 	}
; 330  : 
; 331  : 	return 0;
; 332  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+12]
	mov	DWORD PTR fs:0, ecx
	add	esp, 12					; 0000000cH
	ret	0
$LN18@CreateOper:

; 289  : 	case AI_OPERATION_MERCHANT_DELEGATION:
; 290  : 		return FNEW(CvAIOperationMerchantDelegation(), c_eCiv5GameplayDLL, 0);

	push	124					; 0000007cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T248625[esp+8], eax
	mov	DWORD PTR __$EHRec$[esp+20], 3
	test	eax, eax
	je	$LN22@CreateOper
	mov	ecx, eax
	call	??0CvAIOperationMerchantDelegation@@QAE@XZ ; CvAIOperationMerchantDelegation::CvAIOperationMerchantDelegation

; 329  : 	}
; 330  : 
; 331  : 	return 0;
; 332  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+12]
	mov	DWORD PTR fs:0, ecx
	add	esp, 12					; 0000000cH
	ret	0
$LN17@CreateOper:

; 291  : 	case AI_OPERATION_CONCERT_TOUR:
; 292  : 		return FNEW(CvAIOperationConcertTour(), c_eCiv5GameplayDLL, 0);

	push	124					; 0000007cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T248629[esp+8], eax
	mov	DWORD PTR __$EHRec$[esp+20], 4
	test	eax, eax
	je	$LN22@CreateOper
	mov	ecx, eax
	call	??0CvAIOperationConcertTour@@QAE@XZ	; CvAIOperationConcertTour::CvAIOperationConcertTour

; 329  : 	}
; 330  : 
; 331  : 	return 0;
; 332  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+12]
	mov	DWORD PTR fs:0, ecx
	add	esp, 12					; 0000000cH
	ret	0
$LN16@CreateOper:

; 293  : 	case AI_OPERATION_NAVAL_BOMBARDMENT:
; 294  : 		return FNEW(CvAIOperationNavalBombardment(), c_eCiv5GameplayDLL, 0);

	push	112					; 00000070H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T248633[esp+8], eax
	mov	DWORD PTR __$EHRec$[esp+20], 5
	test	eax, eax
	je	$LN22@CreateOper
	mov	ecx, eax
	call	??0CvAIOperationNavalBombardment@@QAE@XZ ; CvAIOperationNavalBombardment::CvAIOperationNavalBombardment

; 329  : 	}
; 330  : 
; 331  : 	return 0;
; 332  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+12]
	mov	DWORD PTR fs:0, ecx
	add	esp, 12					; 0000000cH
	ret	0
$LN15@CreateOper:

; 295  : 	case AI_OPERATION_NAVAL_SUPERIORITY:
; 296  : 		return FNEW(CvAIOperationNavalSuperiority(), c_eCiv5GameplayDLL, 0);

	push	112					; 00000070H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T248637[esp+8], eax
	mov	DWORD PTR __$EHRec$[esp+20], 6
	test	eax, eax
	je	$LN22@CreateOper
	mov	ecx, eax
	call	??0CvAIOperationNavalSuperiority@@QAE@XZ ; CvAIOperationNavalSuperiority::CvAIOperationNavalSuperiority

; 329  : 	}
; 330  : 
; 331  : 	return 0;
; 332  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+12]
	mov	DWORD PTR fs:0, ecx
	add	esp, 12					; 0000000cH
	ret	0
$LN14@CreateOper:

; 297  : 	case AI_OPERATION_PURE_NAVAL_CITY_ATTACK:
; 298  : 		return FNEW(CvAIOperationPureNavalCityAttack(), c_eCiv5GameplayDLL, 0);

	push	112					; 00000070H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T248641[esp+8], eax
	mov	DWORD PTR __$EHRec$[esp+20], 7
	test	eax, eax
	je	$LN22@CreateOper
	mov	ecx, eax
	call	??0CvAIOperationPureNavalCityAttack@@QAE@XZ ; CvAIOperationPureNavalCityAttack::CvAIOperationPureNavalCityAttack

; 329  : 	}
; 330  : 
; 331  : 	return 0;
; 332  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+12]
	mov	DWORD PTR fs:0, ecx
	add	esp, 12					; 0000000cH
	ret	0
$LN13@CreateOper:

; 299  : 	case AI_OPERATION_COLONIZE:
; 300  : 		return FNEW(CvAINavalEscortedOperation(), c_eCiv5GameplayDLL, 0);

	push	120					; 00000078H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T248645[esp+8], eax
	mov	DWORD PTR __$EHRec$[esp+20], 8
	test	eax, eax
	je	$LN22@CreateOper
	mov	ecx, eax
	call	??0CvAINavalEscortedOperation@@QAE@XZ	; CvAINavalEscortedOperation::CvAINavalEscortedOperation

; 329  : 	}
; 330  : 
; 331  : 	return 0;
; 332  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+12]
	mov	DWORD PTR fs:0, ecx
	add	esp, 12					; 0000000cH
	ret	0
$LN12@CreateOper:

; 301  : 	case AI_OPERATION_QUICK_COLONIZE:
; 302  : 		return FNEW(CvAIOperationQuickColonize(), c_eCiv5GameplayDLL, 0);

	push	124					; 0000007cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T248649[esp+8], eax
	mov	DWORD PTR __$EHRec$[esp+20], 9
	test	eax, eax
	je	$LN22@CreateOper
	mov	ecx, eax
	call	??0CvAIOperationQuickColonize@@QAE@XZ	; CvAIOperationQuickColonize::CvAIOperationQuickColonize

; 329  : 	}
; 330  : 
; 331  : 	return 0;
; 332  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+12]
	mov	DWORD PTR fs:0, ecx
	add	esp, 12					; 0000000cH
	ret	0
$LN11@CreateOper:

; 303  : 	case AI_OPERATION_PILLAGE_ENEMY:
; 304  : 		return FNEW(CvAIOperationPillageEnemy(), c_eCiv5GameplayDLL, 0);

	push	112					; 00000070H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T248653[esp+8], eax
	mov	DWORD PTR __$EHRec$[esp+20], 10		; 0000000aH
	test	eax, eax
	je	$LN22@CreateOper
	mov	ecx, eax
	call	??0CvAIOperationPillageEnemy@@QAE@XZ	; CvAIOperationPillageEnemy::CvAIOperationPillageEnemy

; 329  : 	}
; 330  : 
; 331  : 	return 0;
; 332  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+12]
	mov	DWORD PTR fs:0, ecx
	add	esp, 12					; 0000000cH
	ret	0
$LN10@CreateOper:

; 305  : 	case AI_OPERATION_CITY_CLOSE_DEFENSE:
; 306  : 		return FNEW(CvAIOperationCityCloseDefense(), c_eCiv5GameplayDLL, 0);

	push	112					; 00000070H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T248657[esp+8], eax
	mov	DWORD PTR __$EHRec$[esp+20], 11		; 0000000bH
	test	eax, eax
	je	$LN22@CreateOper
	mov	ecx, eax
	call	??0CvAIOperationCityCloseDefense@@QAE@XZ ; CvAIOperationCityCloseDefense::CvAIOperationCityCloseDefense

; 329  : 	}
; 330  : 
; 331  : 	return 0;
; 332  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+12]
	mov	DWORD PTR fs:0, ecx
	add	esp, 12					; 0000000cH
	ret	0
$LN9@CreateOper:

; 307  : 	case AI_OPERATION_RAPID_RESPONSE:
; 308  : 		return FNEW(CvAIOperationRapidResponse(), c_eCiv5GameplayDLL, 0);

	push	112					; 00000070H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T248661[esp+8], eax
	mov	DWORD PTR __$EHRec$[esp+20], 12		; 0000000cH
	test	eax, eax
	je	$LN22@CreateOper
	mov	ecx, eax
	call	??0CvAIOperationRapidResponse@@QAE@XZ	; CvAIOperationRapidResponse::CvAIOperationRapidResponse

; 329  : 	}
; 330  : 
; 331  : 	return 0;
; 332  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+12]
	mov	DWORD PTR fs:0, ecx
	add	esp, 12					; 0000000cH
	ret	0
$LN8@CreateOper:

; 309  : 	case AI_OPERATION_SNEAK_CITY_ATTACK:
; 310  : 	{
; 311  : 		if(GC.getGame().getGameTurn() < 50 && GET_PLAYER(ePlayer).GetDiplomacyAI()->GetBoldness() >= 5)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	cmp	eax, 50					; 00000032H
	jge	SHORT $LN7@CreateOper
	mov	ecx, DWORD PTR _ePlayer$[esp+8]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetBoldness@CvDiplomacyAI@@QBEHXZ	; CvDiplomacyAI::GetBoldness
	cmp	eax, 5
	jl	SHORT $LN7@CreateOper

; 312  : 		{
; 313  : 			return FNEW(CvAIOperationQuickSneakCityAttack(), c_eCiv5GameplayDLL, 0);

	push	112					; 00000070H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T248665[esp+8], eax
	mov	DWORD PTR __$EHRec$[esp+20], 13		; 0000000dH
	test	eax, eax
	je	$LN22@CreateOper
	mov	ecx, eax
	call	??0CvAIOperationQuickSneakCityAttack@@QAE@XZ ; CvAIOperationQuickSneakCityAttack::CvAIOperationQuickSneakCityAttack

; 329  : 	}
; 330  : 
; 331  : 	return 0;
; 332  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+12]
	mov	DWORD PTR fs:0, ecx
	add	esp, 12					; 0000000cH
	ret	0
$LN7@CreateOper:

; 314  : 		}
; 315  : 		return FNEW(CvAIOperationSneakCityAttack(), c_eCiv5GameplayDLL, 0);

	push	112					; 00000070H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T248669[esp+8], eax
	mov	DWORD PTR __$EHRec$[esp+20], 14		; 0000000eH
	test	eax, eax
	je	$LN22@CreateOper
	mov	ecx, eax
	call	??0CvAIOperationSneakCityAttack@@QAE@XZ	; CvAIOperationSneakCityAttack::CvAIOperationSneakCityAttack

; 329  : 	}
; 330  : 
; 331  : 	return 0;
; 332  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+12]
	mov	DWORD PTR fs:0, ecx
	add	esp, 12					; 0000000cH
	ret	0
$LN6@CreateOper:

; 316  : 	}
; 317  : 	case AI_OPERATION_SMALL_CITY_ATTACK:
; 318  : 		return FNEW(CvAIOperationSmallCityAttack(), c_eCiv5GameplayDLL, 0);

	push	112					; 00000070H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T248673[esp+8], eax
	mov	DWORD PTR __$EHRec$[esp+20], 15		; 0000000fH
	test	eax, eax
	je	$LN22@CreateOper
	mov	ecx, eax
	call	??0CvAIOperationSmallCityAttack@@QAE@XZ	; CvAIOperationSmallCityAttack::CvAIOperationSmallCityAttack

; 329  : 	}
; 330  : 
; 331  : 	return 0;
; 332  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+12]
	mov	DWORD PTR fs:0, ecx
	add	esp, 12					; 0000000cH
	ret	0
$LN5@CreateOper:

; 319  : 	case AI_OPERATION_CITY_STATE_ATTACK:
; 320  : 		return FNEW(CvAIOperationCityStateAttack(), c_eCiv5GameplayDLL, 0);

	push	112					; 00000070H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T248677[esp+8], eax
	mov	DWORD PTR __$EHRec$[esp+20], 16		; 00000010H
	test	eax, eax
	je	$LN22@CreateOper
	mov	ecx, eax
	call	??0CvAIOperationCityStateAttack@@QAE@XZ	; CvAIOperationCityStateAttack::CvAIOperationCityStateAttack

; 329  : 	}
; 330  : 
; 331  : 	return 0;
; 332  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+12]
	mov	DWORD PTR fs:0, ecx
	add	esp, 12					; 0000000cH
	ret	0
$LN4@CreateOper:

; 321  : 	case AI_OPERATION_NAVAL_ATTACK:
; 322  : 		return FNEW(CvAIOperationNavalAttack(), c_eCiv5GameplayDLL, 0);

	push	120					; 00000078H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T248681[esp+8], eax
	mov	DWORD PTR __$EHRec$[esp+20], 17		; 00000011H
	test	eax, eax
	je	$LN22@CreateOper
	mov	ecx, eax
	call	??0CvAIOperationNavalAttack@@QAE@XZ	; CvAIOperationNavalAttack::CvAIOperationNavalAttack

; 329  : 	}
; 330  : 
; 331  : 	return 0;
; 332  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+12]
	mov	DWORD PTR fs:0, ecx
	add	esp, 12					; 0000000cH
	ret	0
$LN3@CreateOper:

; 323  : 	case AI_OPERATION_NAVAL_SNEAK_ATTACK:
; 324  : 		return FNEW(CvAIOperationNavalSneakAttack(), c_eCiv5GameplayDLL, 0);

	push	120					; 00000078H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T248685[esp+8], eax
	mov	DWORD PTR __$EHRec$[esp+20], 18		; 00000012H
	test	eax, eax
	je	SHORT $LN22@CreateOper
	mov	ecx, eax
	call	??0CvAIOperationNavalSneakAttack@@QAE@XZ ; CvAIOperationNavalSneakAttack::CvAIOperationNavalSneakAttack

; 329  : 	}
; 330  : 
; 331  : 	return 0;
; 332  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+12]
	mov	DWORD PTR fs:0, ecx
	add	esp, 12					; 0000000cH
	ret	0
$LN2@CreateOper:

; 325  : 	case AI_OPERATION_CITY_STATE_NAVAL_ATTACK:
; 326  : 		return FNEW(CvAIOperationNavalCityStateAttack(), c_eCiv5GameplayDLL, 0);

	push	120					; 00000078H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T248689[esp+8], eax
	mov	DWORD PTR __$EHRec$[esp+20], 19		; 00000013H
	test	eax, eax
	je	SHORT $LN22@CreateOper
	mov	ecx, eax
	call	??0CvAIOperationNavalCityStateAttack@@QAE@XZ ; CvAIOperationNavalCityStateAttack::CvAIOperationNavalCityStateAttack

; 329  : 	}
; 330  : 
; 331  : 	return 0;
; 332  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+12]
	mov	DWORD PTR fs:0, ecx
	add	esp, 12					; 0000000cH
	ret	0
$LN1@CreateOper:

; 327  : 	case AI_OPERATION_NUKE_ATTACK:
; 328  : 		return FNEW(CvAIOperationNukeAttack(), c_eCiv5GameplayDLL, 0);

	push	116					; 00000074H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T248693[esp+8], eax
	mov	DWORD PTR __$EHRec$[esp+20], 20		; 00000014H
	test	eax, eax
	je	SHORT $LN22@CreateOper
	mov	ecx, eax
	call	??0CvAIOperationNukeAttack@@QAE@XZ	; CvAIOperationNukeAttack::CvAIOperationNukeAttack

; 329  : 	}
; 330  : 
; 331  : 	return 0;
; 332  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+12]
	mov	DWORD PTR fs:0, ecx
	add	esp, 12					; 0000000cH
	ret	0
$LN22@CreateOper:
	mov	ecx, DWORD PTR __$EHRec$[esp+12]
	xor	eax, eax
	mov	DWORD PTR fs:0, ecx
	add	esp, 12					; 0000000cH
	ret	0
	npad	3
$LN94@CreateOper:
	DD	$LN10@CreateOper
	DD	$LN9@CreateOper
	DD	$LN21@CreateOper
	DD	$LN20@CreateOper
	DD	$LN19@CreateOper
	DD	$LN11@CreateOper
	DD	$LN8@CreateOper
	DD	$LN6@CreateOper
	DD	$LN18@CreateOper
	DD	$LN16@CreateOper
	DD	$LN15@CreateOper
	DD	$LN13@CreateOper
	DD	$LN12@CreateOper
	DD	$LN4@CreateOper
	DD	$LN3@CreateOper
	DD	$LN5@CreateOper
	DD	$LN2@CreateOper
	DD	$LN1@CreateOper
	DD	$LN14@CreateOper
	DD	$LN17@CreateOper
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$0:
	mov	eax, DWORD PTR $T248613[ebp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$1:
	mov	eax, DWORD PTR $T248617[ebp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$2:
	mov	eax, DWORD PTR $T248621[ebp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$3:
	mov	eax, DWORD PTR $T248625[ebp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$4:
	mov	eax, DWORD PTR $T248629[ebp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$5:
	mov	eax, DWORD PTR $T248633[ebp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$6:
	mov	eax, DWORD PTR $T248637[ebp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$7:
	mov	eax, DWORD PTR $T248641[ebp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$8:
	mov	eax, DWORD PTR $T248645[ebp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$9:
	mov	eax, DWORD PTR $T248649[ebp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$10:
	mov	eax, DWORD PTR $T248653[ebp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$11:
	mov	eax, DWORD PTR $T248657[ebp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$12:
	mov	eax, DWORD PTR $T248661[ebp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$13:
	mov	eax, DWORD PTR $T248665[ebp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$14:
	mov	eax, DWORD PTR $T248669[ebp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$15:
	mov	eax, DWORD PTR $T248673[ebp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$16:
	mov	eax, DWORD PTR $T248677[ebp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$17:
	mov	eax, DWORD PTR $T248681[ebp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$18:
	mov	eax, DWORD PTR $T248685[ebp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$19:
	mov	eax, DWORD PTR $T248689[ebp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z$20:
	mov	eax, DWORD PTR $T248693[ebp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CreateOperation@CvAIOperation@@SAPAV1@W4AIOperationTypes@@W4PlayerTypes@@@Z ENDP ; CvAIOperation::CreateOperation
EXTRN	?getNumFormationSlotEntries@CvMultiUnitFormationInfo@@QBEHXZ:PROC ; CvMultiUnitFormationInfo::getNumFormationSlotEntries
EXTRN	?GetArmyAIState@CvArmyAI@@QBE?AW4ArmyAIState@@XZ:PROC ; CvArmyAI::GetArmyAIState
; Function compile flags: /Ogtpy
;	COMDAT ?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ
_TEXT	SEGMENT
_uiI$224034 = -20					; size = 4
$T248837 = -16						; size = 4
$T248779 = -16						; size = 4
_thisPlayer$ = -16					; size = 4
_thisOperationSlot$224049 = -12				; size = 12
?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ PROC ; CvAIOperation::BuildListOfUnitsWeStillNeedToBuild, COMDAT
; _this$ = ecx

; 336  : {

	sub	esp, 20					; 00000014H
	push	ebp
	push	esi
	mov	esi, ecx

; 337  : 	m_viListOfUnitsCitiesHaveCommittedToBuild.clear();

	mov	eax, DWORD PTR [esi+44]
	mov	edx, DWORD PTR [esi+40]
	lea	ecx, DWORD PTR [esi+36]
	push	edi
	push	eax
	push	edx
	lea	eax, DWORD PTR $T248779[esp+40]
	push	eax
	call	?erase@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@0@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::erase

; 338  : 	m_viListOfUnitsWeStillNeedToBuild.clear();

	mov	eax, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR [esi+24]
	lea	ebp, DWORD PTR [esi+20]
	push	eax
	push	ecx
	lea	ecx, DWORD PTR $T248837[esp+40]
	push	ecx
	mov	ecx, ebp
	call	?erase@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@0@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::erase

; 339  : 	CvPlayer& thisPlayer = GET_PLAYER(m_eOwner);

	mov	edi, DWORD PTR [esi+72]

; 340  : 	for(unsigned int uiI = 0; uiI < m_viArmyIDs.size(); uiI++)

	mov	edx, DWORD PTR [esi+12]
	imul	edi, 63236				; 0000f704H
	sub	edx, DWORD PTR [esi+8]
	add	edi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	sar	edx, 2
	mov	DWORD PTR _thisPlayer$[esp+32], edi
	mov	DWORD PTR _uiI$224034[esp+32], 0
	test	edx, edx
	jbe	$LN9@BuildListO
	push	ebx
$LL58@BuildListO:
	mov	ecx, DWORD PTR _uiI$224034[esp+36]
	mov	eax, DWORD PTR [esi+8]
	add	ecx, ecx
	add	ecx, ecx
	add	eax, ecx

; 341  : 	{
; 342  : 		CvArmyAI* pThisArmy = thisPlayer.getArmyAI(m_viArmyIDs[uiI]);

	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, edi
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI
	mov	ebx, eax

; 343  : 		// if it is still waiting on initial units
; 344  : 		if(pThisArmy)

	test	ebx, ebx
	je	SHORT $LN10@BuildListO

; 345  : 		{
; 346  : 			if(pThisArmy->GetArmyAIState() == ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE)

	mov	ecx, ebx
	call	?GetArmyAIState@CvArmyAI@@QBE?AW4ArmyAIState@@XZ ; CvArmyAI::GetArmyAIState
	test	eax, eax
	jne	SHORT $LN10@BuildListO

; 347  : 			{
; 348  : 				int iThisFormationIndex = pThisArmy->GetFormationIndex();

	mov	ecx, ebx
	call	?GetFormationIndex@CvArmyAI@@QBEHXZ	; CvArmyAI::GetFormationIndex

; 349  : 				if(iThisFormationIndex != NO_MUFORMATION)

	cmp	eax, -1
	je	SHORT $LN10@BuildListO

; 350  : 				{
; 351  : 					CvMultiUnitFormationInfo* thisFormation = GC.getMultiUnitFormationInfo(iThisFormationIndex);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMultiUnitFormationInfo@CvGlobals@@QAEPAVCvMultiUnitFormationInfo@@H@Z ; CvGlobals::getMultiUnitFormationInfo
	mov	ebx, eax

; 352  : 					if(thisFormation)

	test	ebx, ebx
	je	SHORT $LN10@BuildListO

; 353  : 					{
; 354  : 						for(int iThisSlotIndex = 0; iThisSlotIndex < thisFormation->getNumFormationSlotEntries(); iThisSlotIndex++)

	mov	ecx, ebx
	xor	edi, edi
	call	?getNumFormationSlotEntries@CvMultiUnitFormationInfo@@QBEHXZ ; CvMultiUnitFormationInfo::getNumFormationSlotEntries
	test	eax, eax
	jle	SHORT $LN56@BuildListO
$LL4@BuildListO:

; 355  : 						{
; 356  : 							OperationSlot thisOperationSlot;
; 357  : 							thisOperationSlot.m_iOperationID = m_iID;

	mov	ecx, DWORD PTR [esi+52]

; 358  : 							thisOperationSlot.m_iArmyID = m_viArmyIDs[uiI];

	mov	eax, DWORD PTR _uiI$224034[esp+36]
	mov	edx, DWORD PTR [esi+8]
	add	eax, eax
	mov	DWORD PTR _thisOperationSlot$224049[esp+36], ecx
	add	eax, eax
	mov	eax, DWORD PTR [eax+edx]

; 359  : 							thisOperationSlot.m_iSlotID = iThisSlotIndex;
; 360  : 							m_viListOfUnitsWeStillNeedToBuild.push_back(thisOperationSlot);

	lea	ecx, DWORD PTR _thisOperationSlot$224049[esp+36]
	push	ecx
	mov	ecx, ebp
	mov	DWORD PTR _thisOperationSlot$224049[esp+44], eax
	mov	DWORD PTR _thisOperationSlot$224049[esp+48], edi
	call	?push_back@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXABUOperationSlot@@@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::push_back
	mov	ecx, ebx
	inc	edi
	call	?getNumFormationSlotEntries@CvMultiUnitFormationInfo@@QBEHXZ ; CvMultiUnitFormationInfo::getNumFormationSlotEntries
	cmp	edi, eax
	jl	SHORT $LL4@BuildListO
$LN56@BuildListO:

; 353  : 					{
; 354  : 						for(int iThisSlotIndex = 0; iThisSlotIndex < thisFormation->getNumFormationSlotEntries(); iThisSlotIndex++)

	mov	edi, DWORD PTR _thisPlayer$[esp+36]
$LN10@BuildListO:

; 340  : 	for(unsigned int uiI = 0; uiI < m_viArmyIDs.size(); uiI++)

	mov	edx, DWORD PTR [esi+12]
	sub	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR _uiI$224034[esp+36]
	inc	eax
	sar	edx, 2
	mov	DWORD PTR _uiI$224034[esp+36], eax
	cmp	eax, edx
	jb	$LL58@BuildListO
	pop	ebx
$LN9@BuildListO:
	pop	edi
	pop	esi
	pop	ebp

; 361  : 						}
; 362  : 					}
; 363  : 				}
; 364  : 				else
; 365  : 				{
; 366  : 					// punt -- sub-class should be taking care of this
; 367  : 					CvAssertMsg(false,"A sub-class should have dealt with this");
; 368  : 				}
; 369  : 			}
; 370  : 		}
; 371  : 	}
; 372  : }

	add	esp, 20					; 00000014H
	ret	0
?BuildListOfUnitsWeStillNeedToBuild@CvAIOperation@@UAEXXZ ENDP ; CvAIOperation::BuildListOfUnitsWeStillNeedToBuild
_TEXT	ENDS
EXTRN	?SetEstimatedTurn@CvArmyAI@@QAEXHH@Z:PROC	; CvArmyAI::SetEstimatedTurn
; Function compile flags: /Ogtpy
;	COMDAT ?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_iAreaID$ = 12						; size = 4
_iTurns$ = 16						; size = 4
_pCity$ = 20						; size = 4
?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z PROC ; CvAIOperation::CommitToBuildNextUnit, COMDAT
; _this$ = ecx

; 388  : 	OperationSlot thisSlot;

	or	eax, -1
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax

; 389  : 	if(iAreaID == m_iDefaultArea && !m_viListOfUnitsWeStillNeedToBuild.empty())

	mov	eax, DWORD PTR _iAreaID$[esp]
	push	edi
	mov	edi, ecx
	cmp	eax, DWORD PTR [edi+64]
	jne	$LN49@CommitToBu
	mov	ecx, DWORD PTR [edi+28]
	sub	ecx, DWORD PTR [edi+24]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	je	$LN49@CommitToBu

; 390  : 	{
; 391  : 		thisSlot = m_viListOfUnitsWeStillNeedToBuild.back();

	mov	eax, DWORD PTR [edi+28]
	mov	edx, DWORD PTR [eax-12]
	sub	eax, 12					; 0000000cH
	mov	DWORD PTR [esi], edx
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+4], ecx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [esi+8], edx
	push	ebx

; 392  : 		m_viListOfUnitsWeStillNeedToBuild.pop_back();

	mov	ebx, DWORD PTR [edi+28]
	mov	ecx, ebx
	sub	ecx, DWORD PTR [edi+24]
	mov	eax, 715827883				; 2aaaaaabH
	imul	ecx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	je	SHORT $LN31@CommitToBu
	add	ebx, -12				; fffffff4H
	mov	DWORD PTR [edi+28], ebx
$LN31@CommitToBu:

; 393  : 		m_viListOfUnitsCitiesHaveCommittedToBuild.push_back(thisSlot);

	push	esi
	lea	ecx, DWORD PTR [edi+36]
	call	?push_back@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXABUOperationSlot@@@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::push_back

; 394  : 
; 395  : 		CvArmyAI* pArmy = GET_PLAYER(m_eOwner).getArmyAI(thisSlot.m_iArmyID);

	mov	ecx, DWORD PTR [edi+72]
	mov	edx, DWORD PTR [esi+4]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI
	mov	edi, eax

; 396  : 		if(pArmy)

	test	edi, edi
	je	SHORT $LN48@CommitToBu

; 397  : 		{
; 398  : 			int iTurnsFromCityToMusterGuess;
; 399  : 			iTurnsFromCityToMusterGuess = plotDistance(pCity->getX(), pCity->getY(), pArmy->GetX(), pArmy->GetY()) / 2;

	mov	eax, DWORD PTR _pCity$[esp+8]
	mov	ebx, DWORD PTR [eax+108]
	push	ebp
	mov	ebp, DWORD PTR [eax+96]
	mov	ecx, edi
	call	?GetY@CvArmyAI@@QBEHXZ			; CvArmyAI::GetY
	push	eax
	mov	ecx, edi
	call	?GetX@CvArmyAI@@QBEHXZ			; CvArmyAI::GetX
	push	eax
	push	ebx
	push	ebp
	call	?plotDistance@@YAHHHHH@Z		; plotDistance

; 400  : 			pArmy->SetEstimatedTurn(thisSlot.m_iSlotID, iTurns + iTurnsFromCityToMusterGuess);

	mov	ecx, DWORD PTR _iTurns$[esp+28]
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR [esi+8]
	sar	eax, 1
	add	esp, 16					; 00000010H
	add	eax, ecx
	push	eax
	push	edx
	mov	ecx, edi
	call	?SetEstimatedTurn@CvArmyAI@@QAEXHH@Z	; CvArmyAI::SetEstimatedTurn
	pop	ebp
	pop	ebx
	pop	edi

; 401  : 		}
; 402  : 	}
; 403  : 	return thisSlot;

	mov	eax, esi
	pop	esi

; 404  : }

	ret	16					; 00000010H
$LN48@CommitToBu:
	pop	ebx
	pop	edi

; 401  : 		}
; 402  : 	}
; 403  : 	return thisSlot;

	mov	eax, esi
	pop	esi

; 404  : }

	ret	16					; 00000010H
$LN49@CommitToBu:
	pop	edi

; 401  : 		}
; 402  : 	}
; 403  : 	return thisSlot;

	mov	eax, esi
	pop	esi

; 404  : }

	ret	16					; 00000010H
?CommitToBuildNextUnit@CvAIOperation@@UAE?AUOperationSlot@@HHPAVCvCity@@@Z ENDP ; CvAIOperation::CommitToBuildNextUnit
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z
_TEXT	SEGMENT
$T249051 = -4						; size = 4
$T249015 = -4						; size = 4
_thisOperationSlot$ = 8					; size = 12
?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z PROC ; CvAIOperation::UncommitToBuild, COMDAT
; _this$ = ecx

; 412  : {

	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	esi, ecx

; 413  : 	// find the operation in the list of committed units
; 414  : 	std::vector<OperationSlot>::iterator iter = find(m_viListOfUnitsCitiesHaveCommittedToBuild.begin(),m_viListOfUnitsCitiesHaveCommittedToBuild.end(),thisOperationSlot);

	mov	edi, DWORD PTR [esi+44]
	mov	eax, DWORD PTR [esi+40]
	lea	ecx, DWORD PTR _thisOperationSlot$[esp+12]
	push	ecx
	push	edi
	push	eax
	lea	edx, DWORD PTR $T249051[esp+28]
	push	edx
	call	??$_Find@V?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@UOperationSlot@@@std@@YA?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@0@V10@0ABUOperationSlot@@@Z ; std::_Find<std::_Vector_iterator<OperationSlot,std::allocator<OperationSlot> >,OperationSlot>
	mov	ebx, DWORD PTR [eax]
	add	esp, 16					; 00000010H

; 415  : 	// if we found it
; 416  : 	if(iter != m_viListOfUnitsCitiesHaveCommittedToBuild.end())

	cmp	ebx, edi
	je	SHORT $LN1@UncommitTo

; 417  : 	{
; 418  : 		// add it to the list of stuff that needs to be built
; 419  : 		m_viListOfUnitsWeStillNeedToBuild.push_back(*iter);

	push	ebx
	lea	ecx, DWORD PTR [esi+20]
	call	?push_back@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXABUOperationSlot@@@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::push_back

; 420  : 		// remove it from the list of committed units
; 421  : 		m_viListOfUnitsCitiesHaveCommittedToBuild.erase(iter);

	push	ebx
	lea	eax, DWORD PTR $T249015[esp+20]
	push	eax
	lea	ecx, DWORD PTR [esi+36]
	call	?erase@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::erase
	pop	edi
	pop	esi

; 422  : 		return true;

	mov	al, 1
	pop	ebx

; 425  : }

	pop	ecx
	ret	12					; 0000000cH
$LN1@UncommitTo:
	pop	edi
	pop	esi

; 423  : 	}
; 424  : 	return false;

	xor	al, al
	pop	ebx

; 425  : }

	pop	ecx
	ret	12					; 0000000cH
?UncommitToBuild@CvAIOperation@@UAE_NUOperationSlot@@@Z ENDP ; CvAIOperation::UncommitToBuild
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z$0
__ehfuncinfo$?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
xdata$x	ENDS
;	COMDAT ?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
_TEXT	SEGMENT
_rtnValue$ = -30					; size = 1
_bRequired$ = -29					; size = 1
_secondList$ = -28					; size = 16
__$EHRec$ = -12						; size = 12
_pMusterPlot$ = 8					; size = 4
_pTargetPlot$ = 12					; size = 4
?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z PROC ; CvAIOperation::GrabUnitsFromTheReserves, COMDAT
; _this$ = ecx

; 463  : {

	push	-1
	push	__ehhandler$?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp

; 464  : 	bool rtnValue = true;
; 465  : 	bool success;
; 466  : 	std::vector<OperationSlot>::iterator it;
; 467  : 	bool bRequired;
; 468  : 
; 469  : 	// Copy over the list
; 470  : 	std::vector<OperationSlot> secondList;

	xor	ebx, ebx
	push	esi
	push	edi
	mov	edi, ecx
	mov	BYTE PTR _rtnValue$[esp+48], 1
	mov	DWORD PTR _secondList$[esp+52], ebx
	mov	DWORD PTR _secondList$[esp+56], ebx
	mov	DWORD PTR _secondList$[esp+60], ebx

; 471  : 	for(it = m_viListOfUnitsWeStillNeedToBuild.begin(); it != m_viListOfUnitsWeStillNeedToBuild.end(); ++it)

	mov	esi, DWORD PTR [edi+24]
	mov	DWORD PTR __$EHRec$[esp+56], ebx
	cmp	esi, DWORD PTR [edi+28]
	je	SHORT $LN8@GrabUnitsF
	npad	3
$LL63@GrabUnitsF:

; 472  : 	{
; 473  : 		secondList.push_back(*it);

	push	esi
	lea	ecx, DWORD PTR _secondList$[esp+52]
	call	?push_back@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXABUOperationSlot@@@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::push_back
	add	esi, 12					; 0000000cH
	cmp	esi, DWORD PTR [edi+28]
	jne	SHORT $LL63@GrabUnitsF

; 471  : 	for(it = m_viListOfUnitsWeStillNeedToBuild.begin(); it != m_viListOfUnitsWeStillNeedToBuild.end(); ++it)

	mov	ebx, DWORD PTR _secondList$[esp+52]
$LN8@GrabUnitsF:

; 474  : 	}
; 475  : 
; 476  : 	// Clear main list
; 477  : 	m_viListOfUnitsWeStillNeedToBuild.clear();

	mov	ecx, DWORD PTR [edi+24]
	mov	edx, DWORD PTR [edi+28]
	lea	ebp, DWORD PTR [edi+20]
	cmp	ecx, edx
	je	SHORT $LN93@GrabUnitsF
	mov	eax, edx
	cmp	edx, edx
	je	SHORT $LN118@GrabUnitsF
	npad	7
$LL120@GrabUnitsF:
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [ecx], esi
	mov	esi, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], esi
	mov	esi, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], esi
	add	eax, 12					; 0000000cH
	add	ecx, 12					; 0000000cH
	cmp	eax, edx
	jne	SHORT $LL120@GrabUnitsF
$LN118@GrabUnitsF:
	mov	DWORD PTR [ebp+8], ecx
$LN93@GrabUnitsF:

; 478  : 
; 479  : 	for(it = secondList.begin(); it != secondList.end(); ++it)

	mov	esi, ebx
	cmp	ebx, DWORD PTR _secondList$[esp+56]
	je	$LN5@GrabUnitsF
	mov	ebx, DWORD PTR _pTargetPlot$[esp+44]
	npad	3
$LL131@GrabUnitsF:

; 480  : 	{
; 481  : 		success = FindBestFitReserveUnit(*it, pMusterPlot, pTargetPlot, &bRequired);

	mov	ecx, DWORD PTR _pMusterPlot$[esp+44]
	mov	edx, DWORD PTR [edi]
	mov	edx, DWORD PTR [edx+140]
	lea	eax, DWORD PTR _bRequired$[esp+48]
	push	eax
	push	ebx
	push	ecx
	mov	ecx, DWORD PTR [esi]
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, edi
	call	edx

; 482  : 
; 483  : 		// If any fail, check to see if they were required
; 484  : 		if(!success)

	test	al, al
	jne	SHORT $LN6@GrabUnitsF

; 485  : 		{
; 486  : 			if(bRequired)

	cmp	BYTE PTR _bRequired$[esp+48], al
	je	SHORT $LN3@GrabUnitsF

; 487  : 			{
; 488  : 				// Return false to say that operation is not ready to roll yet
; 489  : 				rtnValue = false;
; 490  : 
; 491  : 				// And add them back to the list of units needed
; 492  : 				m_viListOfUnitsWeStillNeedToBuild.push_back(*it);

	push	esi
	mov	ecx, ebp
	mov	BYTE PTR _rtnValue$[esp+52], al
	call	?push_back@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXABUOperationSlot@@@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::push_back

; 493  : 			}
; 494  : 			else

	jmp	SHORT $LN6@GrabUnitsF
$LN3@GrabUnitsF:

; 495  : 			{
; 496  : 				CvArmyAI* pArmy;
; 497  : 				pArmy = GET_PLAYER(m_eOwner).getArmyAI(it->m_iArmyID);

	mov	ecx, DWORD PTR [edi+72]
	mov	eax, DWORD PTR [esi+4]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI

; 498  : 				if(pArmy)

	test	eax, eax
	je	SHORT $LN6@GrabUnitsF

; 499  : 				{
; 500  : 					pArmy->SetEstimatedTurn(it->m_iSlotID, ARMYSLOT_NOT_INCLUDING_IN_OPERATION);

	mov	ecx, DWORD PTR [esi+8]
	push	-2					; fffffffeH
	push	ecx
	mov	ecx, eax
	call	?SetEstimatedTurn@CvArmyAI@@QAEXHH@Z	; CvArmyAI::SetEstimatedTurn
$LN6@GrabUnitsF:
	add	esi, 12					; 0000000cH
	cmp	esi, DWORD PTR _secondList$[esp+56]
	jne	SHORT $LL131@GrabUnitsF

; 478  : 
; 479  : 	for(it = secondList.begin(); it != secondList.end(); ++it)

	mov	ebx, DWORD PTR _secondList$[esp+52]
$LN5@GrabUnitsF:

; 501  : 				}
; 502  : 			}
; 503  : 		}
; 504  : 	}
; 505  : 
; 506  : 	return rtnValue;

	test	ebx, ebx
	je	SHORT $LN178@GrabUnitsF
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN178@GrabUnitsF:

; 507  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	mov	al, BYTE PTR _rtnValue$[esp+48]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 32					; 00000020H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z$0:
	lea	ecx, DWORD PTR _secondList$[ebp]
	jmp	??1?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE@XZ ; std::vector<OperationSlot,std::allocator<OperationSlot> >::~vector<OperationSlot,std::allocator<OperationSlot> >
__ehhandler$?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z:
	mov	eax, OFFSET __ehfuncinfo$?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GrabUnitsFromTheReserves@CvAIOperation@@UAE_NPAVCvPlot@@0@Z ENDP ; CvAIOperation::GrabUnitsFromTheReserves
; Function compile flags: /Ogtpy
;	COMDAT ?UnitWasRemoved@CvAIOperation@@UAEXHH@Z
_TEXT	SEGMENT
_slotToFill$224510 = -12				; size = 12
_iArmyID$ = 8						; size = 4
_iSlotID$ = 12						; size = 4
?UnitWasRemoved@CvAIOperation@@UAEXHH@Z PROC		; CvAIOperation::UnitWasRemoved, COMDAT
; _this$ = ecx

; 981  : {

	sub	esp, 12					; 0000000cH
	push	ebx
	mov	ebx, ecx

; 982  : 	// For now, response is based on phase of operation
; 983  : 	switch(m_eCurrentState)

	mov	eax, DWORD PTR [ebx+56]
	cmp	eax, 1
	je	SHORT $LN5@UnitWasRem@3
	add	eax, -2					; fffffffeH
	cmp	eax, 2
	ja	SHORT $LN7@UnitWasRem@3

; 998  : 	}
; 999  : 	break;
; 1000 : 
; 1001 : 	case AI_OPERATION_STATE_GATHERING_FORCES:
; 1002 : 	case AI_OPERATION_STATE_MOVING_TO_TARGET:
; 1003 : 	case AI_OPERATION_STATE_AT_TARGET:
; 1004 : 	{
; 1005 : 		// If down below half strength, abort
; 1006 : 		CvArmyAI* pThisArmy = GET_PLAYER(m_eOwner).getArmyAI(iArmyID);

	mov	ecx, DWORD PTR [ebx+72]
	mov	eax, DWORD PTR _iArmyID$[esp+12]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	esi
	push	edi
	push	eax
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI
	mov	esi, eax

; 1007 : 		CvMultiUnitFormationInfo* pkFormation = GC.getMultiUnitFormationInfo(pThisArmy->GetFormationIndex());

	mov	ecx, esi
	call	?GetFormationIndex@CvArmyAI@@QBEHXZ	; CvArmyAI::GetFormationIndex
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMultiUnitFormationInfo@CvGlobals@@QAEPAVCvMultiUnitFormationInfo@@H@Z ; CvGlobals::getMultiUnitFormationInfo
	mov	edi, eax

; 1008 : 		if(pkFormation)

	test	edi, edi
	je	SHORT $LN15@UnitWasRem@3

; 1009 : 		{
; 1010 : 			if(pThisArmy->GetNumSlotsFilled() <=0 ||
; 1011 : 			        pThisArmy->GetNumSlotsFilled() < pkFormation->getNumFormationSlotEntries() / 2)

	mov	ecx, esi
	call	?GetNumSlotsFilled@CvArmyAI@@QBEHXZ	; CvArmyAI::GetNumSlotsFilled
	test	eax, eax
	jle	SHORT $LN1@UnitWasRem@3
	mov	ecx, edi
	call	?getNumFormationSlotEntries@CvMultiUnitFormationInfo@@QBEHXZ ; CvMultiUnitFormationInfo::getNumFormationSlotEntries
	cdq
	sub	eax, edx
	mov	edi, eax
	mov	ecx, esi
	sar	edi, 1
	call	?GetNumSlotsFilled@CvArmyAI@@QBEHXZ	; CvArmyAI::GetNumSlotsFilled
	cmp	eax, edi
	jge	SHORT $LN15@UnitWasRem@3
$LN1@UnitWasRem@3:

; 1012 : 			{
; 1013 : 				// Abort
; 1014 : 				m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	DWORD PTR [ebx+56], 0

; 1015 : 				m_eAbortReason = AI_ABORT_HALF_STRENGTH;

	mov	DWORD PTR [ebx+60], 6
$LN15@UnitWasRem@3:
	pop	edi
	pop	esi
$LN7@UnitWasRem@3:
	pop	ebx

; 1016 : 			}
; 1017 : 		}
; 1018 : 	}
; 1019 : 	break;
; 1020 : 	};
; 1021 : }

	add	esp, 12					; 0000000cH
	ret	8
$LN5@UnitWasRem@3:

; 984  : 	{
; 985  : 	case AI_OPERATION_STATE_ABORTED:
; 986  : 	case AI_OPERATION_STATE_SUCCESSFUL_FINISH:
; 987  : 		break;
; 988  : 
; 989  : 	case AI_OPERATION_STATE_RECRUITING_UNITS:
; 990  : 	{
; 991  : 		// If recruiting units, read this unit to the list of what we need
; 992  : 		OperationSlot slotToFill;
; 993  : 
; 994  : 		slotToFill.m_iOperationID = m_iID;

	mov	ecx, DWORD PTR [ebx+52]

; 995  : 		slotToFill.m_iArmyID = iArmyID;

	mov	edx, DWORD PTR _iArmyID$[esp+12]

; 996  : 		slotToFill.m_iSlotID = iSlotID;

	mov	eax, DWORD PTR _iSlotID$[esp+12]
	mov	DWORD PTR _slotToFill$224510[esp+16], ecx

; 997  : 		m_viListOfUnitsWeStillNeedToBuild.push_back(slotToFill);

	lea	ecx, DWORD PTR _slotToFill$224510[esp+16]
	push	ecx
	lea	ecx, DWORD PTR [ebx+20]
	mov	DWORD PTR _slotToFill$224510[esp+24], edx
	mov	DWORD PTR _slotToFill$224510[esp+28], eax
	call	?push_back@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXABUOperationSlot@@@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::push_back
	pop	ebx

; 1016 : 			}
; 1017 : 		}
; 1018 : 	}
; 1019 : 	break;
; 1020 : 	};
; 1021 : }

	add	esp, 12					; 0000000cH
	ret	8
?UnitWasRemoved@CvAIOperation@@UAEXHH@Z ENDP		; CvAIOperation::UnitWasRemoved
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GCvAIEnemyTerritoryOperation@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvAIEnemyTerritoryOperation@@UAEPAXI@Z PROC		; CvAIEnemyTerritoryOperation::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvAIEnemyTerritoryOperation@@6B@
	call	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN7@scalar@5
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN7@scalar@5:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvAIEnemyTerritoryOperation@@UAEPAXI@Z ENDP		; CvAIEnemyTerritoryOperation::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GCvAIOperationBasicCityAttack@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvAIOperationBasicCityAttack@@UAEPAXI@Z PROC	; CvAIOperationBasicCityAttack::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvAIEnemyTerritoryOperation@@6B@
	call	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN10@scalar@6
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN10@scalar@6:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvAIOperationBasicCityAttack@@UAEPAXI@Z ENDP	; CvAIOperationBasicCityAttack::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GCvAIOperationSneakCityAttack@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvAIOperationSneakCityAttack@@UAEPAXI@Z PROC	; CvAIOperationSneakCityAttack::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvAIEnemyTerritoryOperation@@6B@
	call	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN13@scalar@7
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN13@scalar@7:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvAIOperationSneakCityAttack@@UAEPAXI@Z ENDP	; CvAIOperationSneakCityAttack::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GCvAIOperationQuickSneakCityAttack@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvAIOperationQuickSneakCityAttack@@UAEPAXI@Z PROC	; CvAIOperationQuickSneakCityAttack::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvAIEnemyTerritoryOperation@@6B@
	call	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN16@scalar@8
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN16@scalar@8:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvAIOperationQuickSneakCityAttack@@UAEPAXI@Z ENDP	; CvAIOperationQuickSneakCityAttack::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GCvAIOperationSmallCityAttack@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvAIOperationSmallCityAttack@@UAEPAXI@Z PROC	; CvAIOperationSmallCityAttack::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvAIEnemyTerritoryOperation@@6B@
	call	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN13@scalar@9
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN13@scalar@9:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvAIOperationSmallCityAttack@@UAEPAXI@Z ENDP	; CvAIOperationSmallCityAttack::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GCvAIOperationCityStateAttack@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvAIOperationCityStateAttack@@UAEPAXI@Z PROC	; CvAIOperationCityStateAttack::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvAIEnemyTerritoryOperation@@6B@
	call	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN13@scalar@10
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN13@scalar@10:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvAIOperationCityStateAttack@@UAEPAXI@Z ENDP	; CvAIOperationCityStateAttack::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GCvAIOperationDestroyBarbarianCamp@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvAIOperationDestroyBarbarianCamp@@UAEPAXI@Z PROC	; CvAIOperationDestroyBarbarianCamp::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvAIEnemyTerritoryOperation@@6B@
	call	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN10@scalar@11
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN10@scalar@11:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvAIOperationDestroyBarbarianCamp@@UAEPAXI@Z ENDP	; CvAIOperationDestroyBarbarianCamp::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GCvAIOperationPillageEnemy@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvAIOperationPillageEnemy@@UAEPAXI@Z PROC		; CvAIOperationPillageEnemy::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvAIEnemyTerritoryOperation@@6B@
	call	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN10@scalar@12
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN10@scalar@12:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvAIOperationPillageEnemy@@UAEPAXI@Z ENDP		; CvAIOperationPillageEnemy::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GCvAIEscortedOperation@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvAIEscortedOperation@@UAEPAXI@Z PROC		; CvAIEscortedOperation::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvAIEscortedOperation@@6B@
	call	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN7@scalar@13
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN7@scalar@13:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvAIEscortedOperation@@UAEPAXI@Z ENDP		; CvAIEscortedOperation::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Init@CvAIEscortedOperation@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
_TEXT	SEGMENT
_thisOperationSlot2$225673 = -12			; size = 12
_thisOperationSlot$225668 = -12				; size = 12
_pOurCivilian$ = 8					; size = 4
_iID$ = 8						; size = 4
$T249871 = 12						; size = 4
$T249815 = 12						; size = 4
_eOwner$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 4
?Init@CvAIEscortedOperation@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z PROC ; CvAIEscortedOperation::Init, COMDAT
; _this$ = ecx

; 2802 : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 2803 : 	CvUnit* pOurCivilian;
; 2804 : 	CvPlot* pTargetSite, *pNewTarget;
; 2805 : 
; 2806 : 	Reset();

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+12]
	push	edi
	call	edx

; 2807 : 	m_eMoveType = AI_OPERATION_MOVETYPE_SINGLE_HEX;
; 2808 : 	m_iID = iID;
; 2809 : 	m_eOwner = eOwner;

	mov	eax, DWORD PTR _eOwner$[esp+24]

; 2810 : 
; 2811 : 	// Find the free civilian (that triggered this operation)
; 2812 : 	pOurCivilian = FindBestCivilian();

	mov	edx, DWORD PTR [esi]
	mov	ebx, DWORD PTR _iID$[esp+24]
	mov	DWORD PTR [esi+72], eax
	mov	eax, DWORD PTR [edx+144]
	xor	edi, edi
	mov	ecx, esi
	mov	DWORD PTR [esi+84], edi
	mov	DWORD PTR [esi+52], ebx
	call	eax
	mov	ebp, eax
	mov	DWORD PTR _pOurCivilian$[esp+24], ebp

; 2813 : 
; 2814 : 	if(pOurCivilian != NULL && iID != -1)

	cmp	ebp, edi
	je	$LN1@Init@12
	cmp	ebx, -1
	je	$LN1@Init@12

; 2815 : 	{
; 2816 : 		// Find a destination (not worrying about safe paths)
; 2817 : 		pTargetSite = FindBestTarget(pOurCivilian, false);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+148]
	push	edi
	push	ebp
	mov	ecx, esi
	call	eax
	mov	ebx, eax

; 2818 : 
; 2819 : 		if(pTargetSite != NULL)

	cmp	ebx, edi
	je	$LN10@Init@12

; 2820 : 		{
; 2821 : 			SetTargetPlot(pTargetSite);

	movsx	ecx, WORD PTR [ebx]
	mov	DWORD PTR [esi+104], ecx

; 2822 : 
; 2823 : 			// create the armies that are needed and set the state to ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE
; 2824 : 			CvArmyAI* pArmyAI = GET_PLAYER(m_eOwner).addArmyAI();

	mov	ecx, DWORD PTR [esi+72]
	movsx	edx, WORD PTR [ebx+2]
	imul	ecx, 63236				; 0000f704H
	mov	DWORD PTR [esi+108], edx
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?addArmyAI@CvPlayer@@QAEPAVCvArmyAI@@XZ	; CvPlayer::addArmyAI
	mov	edi, eax

; 2825 : 			if(pArmyAI)

	test	edi, edi
	je	$LN1@Init@12

; 2826 : 			{
; 2827 : 				m_viArmyIDs.push_back(pArmyAI->GetID());

	mov	ecx, edi
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	mov	DWORD PTR $T249815[esp+24], eax
	lea	eax, DWORD PTR $T249815[esp+24]
	push	eax
	lea	ecx, DWORD PTR [esi+4]
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 2828 : 				pArmyAI->Init(pArmyAI->GetID(),m_eOwner,m_iID);

	mov	ecx, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [esi+72]
	push	ecx
	push	edx
	mov	ecx, edi
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	push	eax
	mov	ecx, edi
	call	?Init@CvArmyAI@@QAEXHW4PlayerTypes@@H@Z	; CvArmyAI::Init

; 2829 : 				pArmyAI->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE);

	push	0
	mov	ecx, edi
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 2830 : 				pArmyAI->SetFormationIndex(GetFormation());

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+32]
	mov	ecx, esi
	call	edx
	push	eax
	mov	ecx, edi
	call	?SetFormationIndex@CvArmyAI@@QAEXH@Z	; CvArmyAI::SetFormationIndex

; 2831 : 
; 2832 : 				// Figure out the initial rally point - for this operation it is wherever our civilian is standing
; 2833 : 				pArmyAI->SetGoalPlot(pTargetSite);

	push	ebx
	mov	ecx, edi
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 2834 : 				CvPlot* pMusterPt = pOurCivilian->plot();

	mov	ecx, ebp
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ebp, eax

; 2835 : 				SetMusterPlot(pMusterPt);

	movsx	eax, WORD PTR [ebp]
	mov	DWORD PTR [esi+96], eax
	movsx	ecx, WORD PTR [ebp+2]
	mov	DWORD PTR [esi+100], ecx

; 2836 : 				pArmyAI->SetXY(pMusterPt->getX(), pMusterPt->getY());

	movsx	edx, WORD PTR [ebp+2]
	movsx	eax, WORD PTR [ebp]
	push	edx
	push	eax
	mov	ecx, edi
	call	?SetXY@CvArmyAI@@QAEXHH@Z		; CvArmyAI::SetXY

; 2837 : 				SetDefaultArea(pMusterPt->getArea());

	mov	ecx, DWORD PTR [ebp+356]

; 2838 : 
; 2839 : 				// Add the civilian to our army
; 2840 : 				pArmyAI->AddUnit(pOurCivilian->GetID(), 0);

	mov	edx, DWORD PTR _pOurCivilian$[esp+24]
	mov	DWORD PTR [esi+64], ecx
	mov	eax, DWORD PTR [edx+100]
	push	0
	push	eax
	mov	ecx, edi
	call	?AddUnit@CvArmyAI@@QAEXHH@Z		; CvArmyAI::AddUnit

; 2841 : 
; 2842 : 				// Skip escorting if this operation has to go across water
; 2843 : 				if (pTargetSite->getArea() != pOurCivilian->getArea())

	mov	ecx, DWORD PTR [ebx+356]
	mov	DWORD PTR $T249871[esp+24], ecx
	mov	ecx, DWORD PTR _pOurCivilian$[esp+24]
	call	?getArea@CvUnit@@QBEHXZ			; CvUnit::getArea
	cmp	DWORD PTR $T249871[esp+24], eax
	je	SHORT $LN8@Init@12

; 2844 : 				{
; 2845 : 					m_bEscorted = false;

	mov	BYTE PTR [esi+112], 0
$LN8@Init@12:

; 2846 : 				}
; 2847 : 
; 2848 : 				if (m_bEscorted)

	cmp	BYTE PTR [esi+112], 0
	je	SHORT $LN58@Init@12

; 2849 : 				{
; 2850 : 					m_viListOfUnitsWeStillNeedToBuild.clear();

	lea	ecx, DWORD PTR [esi+20]
	call	?clear@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXXZ ; std::vector<OperationSlot,std::allocator<OperationSlot> >::clear

; 2851 : 					OperationSlot thisOperationSlot;
; 2852 : 					thisOperationSlot.m_iOperationID = m_iID;

	mov	edx, DWORD PTR [esi+52]

; 2853 : 					thisOperationSlot.m_iArmyID = pArmyAI->GetID();

	mov	ecx, edi
	mov	DWORD PTR _thisOperationSlot$225668[esp+28], edx
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	mov	DWORD PTR _thisOperationSlot$225668[esp+32], eax

; 2854 : 					thisOperationSlot.m_iSlotID = 1;
; 2855 : 					m_viListOfUnitsWeStillNeedToBuild.push_back(thisOperationSlot);

	lea	eax, DWORD PTR _thisOperationSlot$225668[esp+28]
	push	eax
	lea	ecx, DWORD PTR [esi+20]
	mov	DWORD PTR _thisOperationSlot$225668[esp+40], 1
	call	?push_back@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXABUOperationSlot@@@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::push_back

; 2856 : 
; 2857 : 					// try to get the escort from existing units that are waiting around
; 2858 : 					GrabUnitsFromTheReserves(pMusterPt, pTargetSite);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+112]
	push	ebx
	push	ebp
	mov	ecx, esi
	call	eax

; 2859 : 					if(pArmyAI->GetNumSlotsFilled() > 1)

	mov	ecx, edi
	call	?GetNumSlotsFilled@CvArmyAI@@QBEHXZ	; CvArmyAI::GetNumSlotsFilled
	cmp	eax, 1
	jle	SHORT $LN6@Init@12

; 2860 : 					{
; 2861 : 						pArmyAI->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_CATCH_UP);

	push	1
	mov	ecx, edi
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 2862 : 						m_eCurrentState = AI_OPERATION_STATE_GATHERING_FORCES;

	mov	DWORD PTR [esi+56], 2

; 2863 : 					}
; 2864 : 					else

	jmp	SHORT $LN56@Init@12
$LN6@Init@12:

; 2865 : 					{
; 2866 : 						m_bEscorted = false;

	mov	BYTE PTR [esi+112], 0
$LN56@Init@12:

; 2867 : 					}
; 2868 : 				}
; 2869 : 
; 2870 : 				if (!m_bEscorted)

	cmp	BYTE PTR [esi+112], 0
	jne	$LN2@Init@12
$LN58@Init@12:

; 2871 : 				{
; 2872 : 					// There was no escort immediately available.  Let's look for a "safe" city site instead
; 2873 : 					pNewTarget = FindBestTarget(pOurCivilian, true);

	mov	edx, DWORD PTR [esi]
	mov	ebp, DWORD PTR _pOurCivilian$[esp+24]
	mov	eax, DWORD PTR [edx+148]
	push	1
	push	ebp
	mov	ecx, esi
	call	eax
	mov	ebx, eax

; 2874 : 
; 2875 : 					// If no better target, we'll wait it out for an escort
; 2876 : 					if(pNewTarget == NULL)

	test	ebx, ebx
	jne	SHORT $LN3@Init@12

; 2877 : 					{
; 2878 : 						m_bEscorted = true;
; 2879 : 
; 2880 : 						// Need to add it back in to list of what to build (was cleared before since marked optional)
; 2881 : 						m_viListOfUnitsWeStillNeedToBuild.clear();

	lea	ebx, DWORD PTR [esi+20]
	mov	ecx, ebx
	mov	BYTE PTR [esi+112], 1
	call	?clear@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXXZ ; std::vector<OperationSlot,std::allocator<OperationSlot> >::clear

; 2882 : 						OperationSlot thisOperationSlot2;
; 2883 : 						thisOperationSlot2.m_iOperationID = m_iID;

	mov	ecx, DWORD PTR [esi+52]
	mov	DWORD PTR _thisOperationSlot2$225673[esp+28], ecx

; 2884 : 						thisOperationSlot2.m_iArmyID = pArmyAI->GetID();

	mov	ecx, edi
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID

; 2885 : 						thisOperationSlot2.m_iSlotID = 1;
; 2886 : 						m_viListOfUnitsWeStillNeedToBuild.push_back(thisOperationSlot2);

	lea	edx, DWORD PTR _thisOperationSlot2$225673[esp+28]
	mov	edi, 1
	push	edx
	mov	ecx, ebx
	mov	DWORD PTR _thisOperationSlot2$225673[esp+36], eax
	mov	DWORD PTR _thisOperationSlot2$225673[esp+40], edi
	call	?push_back@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXABUOperationSlot@@@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::push_back

; 2904 : 					}
; 2905 : 				}
; 2906 : 				LogOperationStart();

	mov	ecx, esi
	mov	DWORD PTR [esi+56], edi
	call	?LogOperationStart@CvAIOperation@@QAEXXZ ; CvAIOperation::LogOperationStart
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2915 : 		}
; 2916 : 	}
; 2917 : }

	add	esp, 12					; 0000000cH
	ret	24					; 00000018H
$LN3@Init@12:

; 2887 : 						m_eCurrentState = AI_OPERATION_STATE_RECRUITING_UNITS;
; 2888 : 					}
; 2889 : 
; 2890 : 					// Send the civilian by himself to this safe location
; 2891 : 					else
; 2892 : 					{
; 2893 : 						// Clear the list of units we need
; 2894 : 						m_viListOfUnitsWeStillNeedToBuild.clear();

	lea	ecx, DWORD PTR [esi+20]
	call	?clear@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXXZ ; std::vector<OperationSlot,std::allocator<OperationSlot> >::clear

; 2895 : 
; 2896 : 						// Change the muster point
; 2897 : 						pArmyAI->SetGoalPlot(pNewTarget);

	push	ebx
	mov	ecx, edi
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 2898 : 						SetMusterPlot(pOurCivilian->plot());

	mov	ecx, ebp
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR [esi+96], ecx
	movsx	edx, WORD PTR [eax+2]

; 2899 : 						pArmyAI->SetXY(GetMusterPlot()->getX(), GetMusterPlot()->getY());

	mov	ecx, esi
	mov	DWORD PTR [esi+100], edx
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	ecx, esi
	mov	ebx, eax
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	movsx	eax, WORD PTR [eax+2]
	movsx	ecx, WORD PTR [ebx]
	push	eax
	push	ecx
	mov	ecx, edi
	call	?SetXY@CvArmyAI@@QAEXHH@Z		; CvArmyAI::SetXY

; 2900 : 
; 2901 : 						// Send the civilian directly to the target
; 2902 : 						pArmyAI->SetArmyAIState(ARMYAISTATE_MOVING_TO_DESTINATION);

	push	2
	mov	ecx, edi
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 2903 : 						m_eCurrentState = AI_OPERATION_STATE_MOVING_TO_TARGET;

	mov	DWORD PTR [esi+56], 3
$LN2@Init@12:

; 2904 : 					}
; 2905 : 				}
; 2906 : 				LogOperationStart();

	mov	ecx, esi
	call	?LogOperationStart@CvAIOperation@@QAEXXZ ; CvAIOperation::LogOperationStart
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2915 : 		}
; 2916 : 	}
; 2917 : }

	add	esp, 12					; 0000000cH
	ret	24					; 00000018H
$LN10@Init@12:

; 2907 : 			}
; 2908 : 		}
; 2909 : 
; 2910 : 		else
; 2911 : 		{
; 2912 : 			// Lost our target, abort
; 2913 : 			m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	DWORD PTR [esi+56], edi

; 2914 : 			m_eAbortReason = AI_ABORT_LOST_TARGET;

	mov	DWORD PTR [esi+60], 3
$LN1@Init@12:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 2915 : 		}
; 2916 : 	}
; 2917 : }

	add	esp, 12					; 0000000cH
	ret	24					; 00000018H
?Init@CvAIEscortedOperation@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ENDP ; CvAIEscortedOperation::Init
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GCvAIOperationFoundCity@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvAIOperationFoundCity@@UAEPAXI@Z PROC		; CvAIOperationFoundCity::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvAIEscortedOperation@@6B@
	call	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN10@scalar@14
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN10@scalar@14:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvAIOperationFoundCity@@UAEPAXI@Z ENDP		; CvAIOperationFoundCity::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	?getNumCities@CvPlayer@@QBEHXZ:PROC		; CvPlayer::getNumCities
; Function compile flags: /Ogtpy
;	COMDAT ?Init@CvAIOperationFoundCity@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z
_TEXT	SEGMENT
_pTargetSite$ = -16					; size = 4
_thisOperationSlot2$225748 = -12			; size = 12
_thisOperationSlot$225742 = -12				; size = 12
$T250015 = 8						; size = 4
$T249919 = 8						; size = 4
_iID$ = 8						; size = 4
_eOwner$ = 12						; size = 4
___formal$ = 16						; size = 4
_pOurCivilian$ = 20					; size = 4
_iDefaultArea$ = 20					; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 4
?Init@CvAIOperationFoundCity@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z PROC ; CvAIOperationFoundCity::Init, COMDAT
; _this$ = ecx

; 3038 : {

	sub	esp, 16					; 00000010H

; 3039 : 	m_iTargetArea = iDefaultArea;

	mov	eax, DWORD PTR _iDefaultArea$[esp+12]
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 3040 : 	CvUnit* pOurCivilian;
; 3041 : 	CvPlot* pTargetSite = NULL;
; 3042 : 	CvPlot* pNewTarget = NULL;
; 3043 : 
; 3044 : 	Reset();

	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [esi+120], eax
	mov	eax, DWORD PTR [edx+12]
	push	edi
	call	eax

; 3045 : 	m_eMoveType = AI_OPERATION_MOVETYPE_SINGLE_HEX;
; 3046 : 	m_iID = iID;
; 3047 : 	m_eOwner = eOwner;

	mov	ecx, DWORD PTR _eOwner$[esp+28]

; 3048 : 
; 3049 : 	// Find the free civilian (that triggered this operation)
; 3050 : 	pOurCivilian = FindBestCivilian();

	mov	edx, DWORD PTR [esi]
	mov	ebp, DWORD PTR _iID$[esp+28]
	mov	eax, DWORD PTR [edx+144]
	mov	DWORD PTR [esi+72], ecx
	xor	edi, edi
	mov	ecx, esi
	mov	DWORD PTR [esi+84], edi
	mov	DWORD PTR [esi+52], ebp
	call	eax
	mov	ebx, eax
	mov	DWORD PTR _pOurCivilian$[esp+28], ebx

; 3051 : 
; 3052 : 	if(pOurCivilian != NULL && iID != -1)

	cmp	ebx, edi
	je	$LN1@Init@13
	cmp	ebp, -1
	je	$LN1@Init@13

; 3053 : 	{
; 3054 : 		// Find a destination (not worrying about safe paths)
; 3055 : 		pTargetSite = FindBestTarget(pOurCivilian, false);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+148]
	push	edi
	push	ebx
	mov	ecx, esi
	call	eax
	mov	ebp, eax
	mov	DWORD PTR _pTargetSite$[esp+32], ebp

; 3056 : 
; 3057 : 		if(pTargetSite != NULL)

	cmp	ebp, edi
	je	$LN9@Init@13

; 3058 : 		{
; 3059 : 			SetTargetPlot(pTargetSite);

	movsx	ecx, WORD PTR [ebp]
	mov	DWORD PTR [esi+104], ecx

; 3060 : 
; 3061 : 			// create the armies that are needed and set the state to ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE
; 3062 : 			CvArmyAI* pArmyAI = GET_PLAYER(m_eOwner).addArmyAI();

	mov	ecx, DWORD PTR [esi+72]
	movsx	edx, WORD PTR [ebp+2]
	imul	ecx, 63236				; 0000f704H
	mov	DWORD PTR [esi+108], edx
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?addArmyAI@CvPlayer@@QAEPAVCvArmyAI@@XZ	; CvPlayer::addArmyAI
	mov	edi, eax

; 3063 : 			if(pArmyAI)

	test	edi, edi
	je	$LN1@Init@13

; 3064 : 			{
; 3065 : 				m_viArmyIDs.push_back(pArmyAI->GetID());

	mov	ecx, edi
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	mov	DWORD PTR $T249919[esp+28], eax
	lea	eax, DWORD PTR $T249919[esp+28]
	push	eax
	lea	ecx, DWORD PTR [esi+4]
	call	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back

; 3066 : 				pArmyAI->Init(pArmyAI->GetID(),m_eOwner,m_iID);

	mov	ecx, DWORD PTR [esi+52]
	mov	edx, DWORD PTR [esi+72]
	push	ecx
	push	edx
	mov	ecx, edi
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID
	push	eax
	mov	ecx, edi
	call	?Init@CvArmyAI@@QAEXHW4PlayerTypes@@H@Z	; CvArmyAI::Init

; 3067 : 				pArmyAI->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_REINFORCE);

	push	0
	mov	ecx, edi
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 3068 : 				pArmyAI->SetFormationIndex(GetFormation());

	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+32]
	mov	ecx, esi
	call	edx
	push	eax
	mov	ecx, edi
	call	?SetFormationIndex@CvArmyAI@@QAEXH@Z	; CvArmyAI::SetFormationIndex

; 3069 : 
; 3070 : 				// Figure out the initial rally point - for this operation it is wherever our civilian is standing
; 3071 : 				pArmyAI->SetGoalPlot(pTargetSite);

	push	ebp
	mov	ecx, edi
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 3072 : 				CvPlot* pMusterPt = pOurCivilian->plot();

	mov	ecx, ebx
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	ebp, eax

; 3073 : 				SetMusterPlot(pMusterPt);

	movsx	eax, WORD PTR [ebp]
	mov	DWORD PTR [esi+96], eax
	movsx	ecx, WORD PTR [ebp+2]
	mov	DWORD PTR [esi+100], ecx

; 3074 : 				pArmyAI->SetXY(pMusterPt->getX(), pMusterPt->getY());

	movsx	edx, WORD PTR [ebp+2]
	movsx	eax, WORD PTR [ebp]
	push	edx
	push	eax
	mov	ecx, edi
	call	?SetXY@CvArmyAI@@QAEXHH@Z		; CvArmyAI::SetXY

; 3075 : 				SetDefaultArea(pMusterPt->getArea());

	mov	ecx, DWORD PTR [ebp+356]
	mov	DWORD PTR [esi+64], ecx

; 3076 : 
; 3077 : 				// Add the settler to our army
; 3078 : 				pArmyAI->AddUnit(pOurCivilian->GetID(), 0);

	mov	edx, DWORD PTR [ebx+100]
	push	0
	push	edx
	mov	ecx, edi
	call	?AddUnit@CvArmyAI@@QAEXHH@Z		; CvArmyAI::AddUnit

; 3079 : 
; 3080 : 				// Add the escort as a unit we need to build
; 3081 : 				m_viListOfUnitsWeStillNeedToBuild.clear();

	mov	eax, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR [esi+24]
	lea	ebx, DWORD PTR [esi+20]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T250015[esp+36]
	push	eax
	mov	ecx, ebx
	call	?erase@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAE?AV?$_Vector_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@V?$_Vector_const_iterator@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@2@0@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::erase

; 3082 : 				OperationSlot thisOperationSlot;
; 3083 : 				thisOperationSlot.m_iOperationID = m_iID;

	mov	ecx, DWORD PTR [esi+52]
	mov	DWORD PTR _thisOperationSlot$225742[esp+32], ecx

; 3084 : 				thisOperationSlot.m_iArmyID = pArmyAI->GetID();

	mov	ecx, edi
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID

; 3085 : 				thisOperationSlot.m_iSlotID = 1;
; 3086 : 				m_viListOfUnitsWeStillNeedToBuild.push_back(thisOperationSlot);

	lea	edx, DWORD PTR _thisOperationSlot$225742[esp+32]
	push	edx
	mov	ecx, ebx
	mov	DWORD PTR _thisOperationSlot$225742[esp+40], eax
	mov	DWORD PTR _thisOperationSlot$225742[esp+44], 1
	call	?push_back@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXABUOperationSlot@@@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::push_back

; 3087 : 
; 3088 : 				// try to get the escort from existing units that are waiting around
; 3089 : 				GrabUnitsFromTheReserves(pMusterPt, pTargetSite);

	mov	ecx, DWORD PTR _pTargetSite$[esp+32]
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [eax+112]
	push	ecx
	push	ebp
	mov	ecx, esi
	call	edx

; 3090 : 				if(pArmyAI->GetNumSlotsFilled() > 1)

	mov	ecx, edi
	call	?GetNumSlotsFilled@CvArmyAI@@QBEHXZ	; CvArmyAI::GetNumSlotsFilled
	cmp	eax, 1
	jle	SHORT $LN7@Init@13

; 3091 : 				{
; 3092 : 					pArmyAI->SetArmyAIState(ARMYAISTATE_WAITING_FOR_UNITS_TO_CATCH_UP);

	push	1
	mov	ecx, edi
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 3132 : 						m_eCurrentState = AI_OPERATION_STATE_MOVING_TO_TARGET;
; 3133 : 					}
; 3134 : 				}
; 3135 : 				LogOperationStart();

	mov	ecx, esi
	mov	DWORD PTR [esi+56], 2
	call	?LogOperationStart@CvAIOperation@@QAEXXZ ; CvAIOperation::LogOperationStart
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3144 : 		}
; 3145 : 	}
; 3146 : }

	add	esp, 16					; 00000010H
	ret	24					; 00000018H
$LN7@Init@13:

; 3093 : 					m_eCurrentState = AI_OPERATION_STATE_GATHERING_FORCES;
; 3094 : 				}
; 3095 : 				else
; 3096 : 				{
; 3097 : 					// There was no escort immediately available.  Let's look for a "safe" city site instead
; 3098 : 
; 3099 : 					if (eOwner == -1 || GET_PLAYER(eOwner).getNumCities() > 1 || GET_PLAYER(eOwner).GetDiplomacyAI()->GetBoldness() > 5) // unless we'd rather play it safe

	mov	ebp, DWORD PTR _eOwner$[esp+28]
	cmp	ebp, -1
	je	SHORT $LN72@Init@13
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	ebp, 63236				; 0000f704H
	lea	ecx, DWORD PTR [eax+ebp]
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	cmp	eax, 1
	jg	SHORT $LN72@Init@13
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, ebp
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetBoldness@CvDiplomacyAI@@QBEHXZ	; CvDiplomacyAI::GetBoldness
	cmp	eax, 5
	jle	SHORT $LN73@Init@13
$LN72@Init@13:

; 3100 : 					{
; 3101 : 						pNewTarget = FindBestTarget(pOurCivilian, true);

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR _pOurCivilian$[esp+28]
	mov	edx, DWORD PTR [edx+148]
	push	1
	push	eax
	mov	ecx, esi
	call	edx
	mov	ebp, eax

; 3102 : 					}
; 3103 : 
; 3104 : 					// If no better target, we'll wait it out for an escort
; 3105 : 					if(pNewTarget == NULL)

	test	ebp, ebp
	jne	SHORT $LN3@Init@13
$LN73@Init@13:

; 3106 : 					{
; 3107 : 						// Need to add it back in to list of what to build (was cleared before since marked optional)
; 3108 : 						m_viListOfUnitsWeStillNeedToBuild.clear();

	mov	ecx, ebx
	call	?clear@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXXZ ; std::vector<OperationSlot,std::allocator<OperationSlot> >::clear

; 3109 : 						OperationSlot thisOperationSlot2;
; 3110 : 						thisOperationSlot2.m_iOperationID = m_iID;

	mov	eax, DWORD PTR [esi+52]

; 3111 : 						thisOperationSlot2.m_iArmyID = pArmyAI->GetID();

	mov	ecx, edi
	mov	DWORD PTR _thisOperationSlot2$225748[esp+32], eax
	call	?GetID@CvArmyAI@@QAEHXZ			; CvArmyAI::GetID

; 3112 : 						thisOperationSlot2.m_iSlotID = 1;
; 3113 : 						m_viListOfUnitsWeStillNeedToBuild.push_back(thisOperationSlot2);

	lea	ecx, DWORD PTR _thisOperationSlot2$225748[esp+32]
	push	ecx
	mov	edi, 1
	mov	ecx, ebx
	mov	DWORD PTR _thisOperationSlot2$225748[esp+40], eax
	mov	DWORD PTR _thisOperationSlot2$225748[esp+44], edi
	call	?push_back@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXABUOperationSlot@@@Z ; std::vector<OperationSlot,std::allocator<OperationSlot> >::push_back

; 3132 : 						m_eCurrentState = AI_OPERATION_STATE_MOVING_TO_TARGET;
; 3133 : 					}
; 3134 : 				}
; 3135 : 				LogOperationStart();

	mov	ecx, esi
	mov	DWORD PTR [esi+56], edi
	call	?LogOperationStart@CvAIOperation@@QAEXXZ ; CvAIOperation::LogOperationStart
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3144 : 		}
; 3145 : 	}
; 3146 : }

	add	esp, 16					; 00000010H
	ret	24					; 00000018H
$LN3@Init@13:

; 3114 : 						m_eCurrentState = AI_OPERATION_STATE_RECRUITING_UNITS;
; 3115 : 					}
; 3116 : 
; 3117 : 					// Send the settler by himself to this safe location
; 3118 : 					else
; 3119 : 					{
; 3120 : 						m_bEscorted = false;
; 3121 : 
; 3122 : 						// Clear the list of units we need
; 3123 : 						m_viListOfUnitsWeStillNeedToBuild.clear();

	mov	ecx, ebx
	mov	BYTE PTR [esi+112], 0
	call	?clear@?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@QAEXXZ ; std::vector<OperationSlot,std::allocator<OperationSlot> >::clear

; 3124 : 
; 3125 : 						// Change the muster point
; 3126 : 						pArmyAI->SetGoalPlot(pNewTarget);

	push	ebp
	mov	ecx, edi
	call	?SetGoalPlot@CvArmyAI@@QAEXPAVCvPlot@@@Z ; CvArmyAI::SetGoalPlot

; 3127 : 						SetMusterPlot(pOurCivilian->plot());

	mov	ecx, DWORD PTR _pOurCivilian$[esp+28]
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	movsx	edx, WORD PTR [eax]
	mov	DWORD PTR [esi+96], edx
	movsx	eax, WORD PTR [eax+2]

; 3128 : 						pArmyAI->SetXY(GetMusterPlot()->getX(), GetMusterPlot()->getY());

	mov	ecx, esi
	mov	DWORD PTR [esi+100], eax
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	mov	ecx, esi
	mov	ebx, eax
	call	?GetMusterPlot@CvAIOperation@@QBEPAVCvPlot@@XZ ; CvAIOperation::GetMusterPlot
	movsx	ecx, WORD PTR [eax+2]
	movsx	edx, WORD PTR [ebx]
	push	ecx
	push	edx
	mov	ecx, edi
	call	?SetXY@CvArmyAI@@QAEXHH@Z		; CvArmyAI::SetXY

; 3129 : 
; 3130 : 						// Send the settler directly to the target
; 3131 : 						pArmyAI->SetArmyAIState(ARMYAISTATE_MOVING_TO_DESTINATION);

	push	2
	mov	ecx, edi
	call	?SetArmyAIState@CvArmyAI@@QAEXW4ArmyAIState@@@Z ; CvArmyAI::SetArmyAIState

; 3132 : 						m_eCurrentState = AI_OPERATION_STATE_MOVING_TO_TARGET;
; 3133 : 					}
; 3134 : 				}
; 3135 : 				LogOperationStart();

	mov	ecx, esi
	mov	DWORD PTR [esi+56], 3
	call	?LogOperationStart@CvAIOperation@@QAEXXZ ; CvAIOperation::LogOperationStart
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3144 : 		}
; 3145 : 	}
; 3146 : }

	add	esp, 16					; 00000010H
	ret	24					; 00000018H
$LN9@Init@13:

; 3136 : 			}
; 3137 : 		}
; 3138 : 
; 3139 : 		else
; 3140 : 		{
; 3141 : 			// Lost our target, abort
; 3142 : 			m_eCurrentState = AI_OPERATION_STATE_ABORTED;

	mov	DWORD PTR [esi+56], edi

; 3143 : 			m_eAbortReason = AI_ABORT_LOST_TARGET;

	mov	DWORD PTR [esi+60], 3
$LN1@Init@13:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3144 : 		}
; 3145 : 	}
; 3146 : }

	add	esp, 16					; 00000010H
	ret	24					; 00000018H
?Init@CvAIOperationFoundCity@@UAEXHW4PlayerTypes@@0HPAVCvCity@@1@Z ENDP ; CvAIOperationFoundCity::Init
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GCvAIOperationQuickColonize@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvAIOperationQuickColonize@@UAEPAXI@Z PROC		; CvAIOperationQuickColonize::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvAIEscortedOperation@@6B@
	call	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN13@scalar@15
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN13@scalar@15:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvAIOperationQuickColonize@@UAEPAXI@Z ENDP		; CvAIOperationQuickColonize::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GCvAIOperationMerchantDelegation@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvAIOperationMerchantDelegation@@UAEPAXI@Z PROC	; CvAIOperationMerchantDelegation::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvAIEscortedOperation@@6B@
	call	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN10@scalar@16
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN10@scalar@16:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvAIOperationMerchantDelegation@@UAEPAXI@Z ENDP	; CvAIOperationMerchantDelegation::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GCvAIOperationConcertTour@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvAIOperationConcertTour@@UAEPAXI@Z PROC		; CvAIOperationConcertTour::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvAIEscortedOperation@@6B@
	call	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN10@scalar@17
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN10@scalar@17:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvAIOperationConcertTour@@UAEPAXI@Z ENDP		; CvAIOperationConcertTour::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GCvAINavalOperation@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvAINavalOperation@@UAEPAXI@Z PROC			; CvAINavalOperation::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvAIEnemyTerritoryOperation@@6B@
	call	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN10@scalar@18
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN10@scalar@18:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvAINavalOperation@@UAEPAXI@Z ENDP			; CvAINavalOperation::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GCvAIOperationNavalBombardment@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvAIOperationNavalBombardment@@UAEPAXI@Z PROC	; CvAIOperationNavalBombardment::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvAIEnemyTerritoryOperation@@6B@
	call	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN13@scalar@19
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN13@scalar@19:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvAIOperationNavalBombardment@@UAEPAXI@Z ENDP	; CvAIOperationNavalBombardment::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GCvAIOperationNavalSuperiority@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvAIOperationNavalSuperiority@@UAEPAXI@Z PROC	; CvAIOperationNavalSuperiority::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvAIEnemyTerritoryOperation@@6B@
	call	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN13@scalar@20
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN13@scalar@20:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvAIOperationNavalSuperiority@@UAEPAXI@Z ENDP	; CvAIOperationNavalSuperiority::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z:PROC ; TurnsToReachTarget
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fobjecthandle.h
xdata$x	SEGMENT
__unwindtable$?GetReachablePlot@@YAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@AAV?$CvWeightedVector@PAVCvPlot@@$00$00@@PAH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetReachablePlot@@YAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@AAV?$CvWeightedVector@PAVCvPlot@@$00$00@@PAH@Z$0
__ehfuncinfo$?GetReachablePlot@@YAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@AAV?$CvWeightedVector@PAVCvPlot@@$00$00@@PAH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetReachablePlot@@YAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@AAV?$CvWeightedVector@PAVCvPlot@@$00$00@@PAH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
xdata$x	ENDS
;	COMDAT ?GetReachablePlot@@YAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@AAV?$CvWeightedVector@PAVCvPlot@@$00$00@@PAH@Z
_TEXT	SEGMENT
_iFoundTurns$ = -28					; size = 4
_i$226452 = -24						; size = 4
_elem$250236 = -20					; size = 8
$T250180 = -20						; size = 4
$T250179 = -20						; size = 4
__$EHRec$ = -12						; size = 12
_pUnit$ = 8						; size = 8
_aPlots$ = 16						; size = 4
_iTurns$ = 20						; size = 4
?GetReachablePlot@@YAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@AAV?$CvWeightedVector@PAVCvPlot@@$00$00@@PAH@Z PROC ; GetReachablePlot, COMDAT

; 4355 : {

	push	-1
	push	__ehhandler$?GetReachablePlot@@YAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@AAV?$CvWeightedVector@PAVCvPlot@@$00$00@@PAH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 4356 : 	CvPlot *pFoundPlot = NULL;
; 4357 : 	int iFoundWeight = 0;
; 4358 : 	int iFoundTurns = 0;
; 4359 : 	uint uiListSize;	
; 4360 : 	if ((uiListSize = aPlots.size()) > 0)

	mov	edi, DWORD PTR _aPlots$[esp+40]
	mov	esi, DWORD PTR [edi+4]
	xor	ebx, ebx
	xor	ebp, ebp
	mov	DWORD PTR __$EHRec$[esp+52], ebx
	mov	DWORD PTR _iFoundTurns$[esp+44], ebx
	cmp	esi, ebx
	jbe	$LN2@GetReachab

; 4361 : 	{
; 4362 : 		aPlots.SortItems();

	mov	eax, DWORD PTR [edi]
	lea	ecx, DWORD PTR [eax+esi*8]
	mov	edx, ecx
	sub	edx, eax
	sar	edx, 3
	push	edx
	push	ecx
	push	eax
	call	??$_Sort@PAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@H@std@@YAXPAUWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@0H@Z ; std::_Sort<CvWeightedVector<CvPlot *,1,1>::WeightedElement *,int>
	add	esp, 12					; 0000000cH

; 4363 : 
; 4364 : 		// This will check all the plots that have the same weight.  It will mean a few more path-finds, but it will
; 4365 : 		// be more accurate.
; 4366 : 		for (uint i = uiListSize; i--; )		// Go backward, the CvWeightedVector sorts highest to lowest

	jmp	SHORT $LN12@GetReachab
$LL66@GetReachab:
	mov	edi, DWORD PTR _aPlots$[esp+40]
	mov	esi, DWORD PTR _i$226452[esp+44]
$LN12@GetReachab:
	mov	eax, DWORD PTR [edi]
	dec	esi

; 4367 : 		{
; 4368 : 			CvPlot* pPlot = aPlots.GetElement(i);
; 4369 : 			int iWeight = aPlots.GetWeight(i);

	mov	edi, DWORD PTR [eax+esi*8+4]
	lea	eax, DWORD PTR [eax+esi*8]
	mov	DWORD PTR _i$226452[esp+44], esi
	mov	esi, DWORD PTR [eax]
	mov	ecx, esi
	mov	DWORD PTR _elem$250236[esp+44], ecx

; 4370 : 
; 4371 : 			if (pFoundPlot)

	test	ebx, ebx
	je	SHORT $LN10@GetReachab

; 4372 : 			{
; 4373 : 				if (iWeight > iFoundWeight)

	cmp	edi, ebp
	jg	$LN62@GetReachab

; 4374 : 					break;		// Already found one of a lower weight
; 4375 : 			
; 4376 : 				int iTurnsCalculated = TurnsToReachTarget(pUnit, pPlot, true /*bReusePaths*/, false);

	mov	edx, DWORD PTR _pUnit$[esp+40]
	push	0
	push	0
	push	1
	push	esi
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR [eax], edx
	mov	cl, BYTE PTR _pUnit$[esp+68]
	mov	BYTE PTR [eax+4], cl
	mov	eax, edx
	mov	DWORD PTR $T250179[esp+68], esp
	test	eax, eax
	je	SHORT $LN44@GetReachab
	mov	ecx, eax
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN44@GetReachab:
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H

; 4377 : 				if (iTurnsCalculated != MAX_INT)

	cmp	eax, 2147483647				; 7fffffffH
	je	SHORT $LN3@GetReachab

; 4378 : 				{
; 4379 : 					if (iTurnsCalculated < iFoundTurns)

	cmp	eax, DWORD PTR _iFoundTurns$[esp+44]
	jge	SHORT $LN3@GetReachab

; 4380 : 					{
; 4381 : 						iFoundWeight = iWeight;
; 4382 : 						pFoundPlot = pPlot;
; 4383 : 						iFoundTurns = iTurnsCalculated;
; 4384 : 						if (iFoundTurns == 1)
; 4385 : 							break;		// Not getting better than this
; 4386 : 					}
; 4387 : 				}
; 4388 : 			}
; 4389 : 			else

	jmp	SHORT $LN74@GetReachab
$LN10@GetReachab:

; 4390 : 			{
; 4391 : 				int iTurnsCalculated = TurnsToReachTarget(pUnit, pPlot, true /*bReusePaths*/, false);

	mov	edx, DWORD PTR _pUnit$[esp+40]
	push	0
	push	0
	push	1
	push	esi
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR [eax], edx
	mov	cl, BYTE PTR _pUnit$[esp+68]
	mov	BYTE PTR [eax+4], cl
	mov	eax, edx
	mov	DWORD PTR $T250180[esp+68], esp
	test	eax, eax
	je	SHORT $LN49@GetReachab
	mov	ecx, eax
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN49@GetReachab:
	call	?TurnsToReachTarget@@YAHV?$FObjectHandle@VCvUnit@@@@PAVCvPlot@@_N22@Z ; TurnsToReachTarget
	add	esp, 24					; 00000018H

; 4392 : 				if (iTurnsCalculated != MAX_INT)

	cmp	eax, 2147483647				; 7fffffffH
	je	SHORT $LN3@GetReachab
$LN74@GetReachab:

; 4393 : 				{
; 4394 : 					iFoundWeight = iWeight;
; 4395 : 					pFoundPlot = pPlot;
; 4396 : 					iFoundTurns = iTurnsCalculated;

	mov	DWORD PTR _iFoundTurns$[esp+44], eax
	mov	ebx, esi
	mov	ebp, edi

; 4397 : 					if (iFoundTurns == 1)

	cmp	eax, 1
	je	SHORT $LN62@GetReachab
$LN3@GetReachab:

; 4363 : 
; 4364 : 		// This will check all the plots that have the same weight.  It will mean a few more path-finds, but it will
; 4365 : 		// be more accurate.
; 4366 : 		for (uint i = uiListSize; i--; )		// Go backward, the CvWeightedVector sorts highest to lowest

	cmp	DWORD PTR _i$226452[esp+44], 0
	jne	$LL66@GetReachab
$LN62@GetReachab:

; 4398 : 						break;		// Not getting better than this
; 4399 : 				}
; 4400 : 			}
; 4401 : 		}
; 4402 : 	}
; 4403 : 
; 4404 : 	if (pFoundPlot)

	test	ebx, ebx
	je	SHORT $LN2@GetReachab

; 4405 : 	{
; 4406 : 		if (iTurns)

	mov	eax, DWORD PTR _iTurns$[esp+40]
	test	eax, eax
	je	SHORT $LN1@GetReachab

; 4407 : 			*iTurns = iFoundTurns;

	mov	edx, DWORD PTR _iFoundTurns$[esp+44]
	mov	DWORD PTR [eax], edx
$LN1@GetReachab:

; 4408 : 		return pFoundPlot;

	mov	ecx, DWORD PTR _pUnit$[esp+40]
	mov	DWORD PTR __$EHRec$[esp+52], -1
	test	ecx, ecx
	je	SHORT $LN54@GetReachab
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN54@GetReachab:
	mov	eax, ebx

; 4412 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 28					; 0000001cH
	ret	0
$LN2@GetReachab:

; 4409 : 	}
; 4410 : 
; 4411 : 	return NULL;

	mov	ecx, DWORD PTR _pUnit$[esp+40]
	mov	DWORD PTR __$EHRec$[esp+52], -1
	test	ecx, ecx
	je	SHORT $LN59@GetReachab
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
$LN59@GetReachab:

; 4412 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	pop	edi
	pop	esi
	pop	ebp
	xor	eax, eax
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 28					; 0000001cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetReachablePlot@@YAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@AAV?$CvWeightedVector@PAVCvPlot@@$00$00@@PAH@Z$0:
	lea	ecx, DWORD PTR _pUnit$[ebp-4]
	jmp	??1?$FObjectHandle@VCvUnit@@@@QAE@XZ	; FObjectHandle<CvUnit>::~FObjectHandle<CvUnit>
__ehhandler$?GetReachablePlot@@YAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@AAV?$CvWeightedVector@PAVCvPlot@@$00$00@@PAH@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetReachablePlot@@YAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@AAV?$CvWeightedVector@PAVCvPlot@@$00$00@@PAH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetReachablePlot@@YAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@AAV?$CvWeightedVector@PAVCvPlot@@$00$00@@PAH@Z ENDP ; GetReachablePlot
EXTRN	?atWar@@YA_NW4TeamTypes@@0@Z:PROC		; atWar
EXTRN	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ:PROC	; CvCity::getTeam
EXTRN	?isTrade@CvUnit@@QBE_NXZ:PROC			; CvUnit::isTrade
EXTRN	?isEnemy@CvUnit@@QBE_NW4TeamTypes@@PBVCvPlot@@@Z:PROC ; CvUnit::isEnemy
EXTRN	?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z:PROC	; CvPlot::getUnitByIndex
EXTRN	?getNumUnits@CvPlot@@QBEHXZ:PROC		; CvPlot::getNumUnits
EXTRN	?baseMoves@CvUnit@@QBEHW4DomainTypes@@@Z:PROC	; CvUnit::baseMoves
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$?FindBestTarget@CvAIOperationNavalSuperiority@@MAEPAVCvPlot@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindBestTarget@CvAIOperationNavalSuperiority@@MAEPAVCvPlot@@XZ$0
__ehfuncinfo$?FindBestTarget@CvAIOperationNavalSuperiority@@MAEPAVCvPlot@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?FindBestTarget@CvAIOperationNavalSuperiority@@MAEPAVCvPlot@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
xdata$x	ENDS
;	COMDAT ?FindBestTarget@CvAIOperationNavalSuperiority@@MAEPAVCvPlot@@XZ
_TEXT	SEGMENT
_pInitialUnit$ = -84					; size = 4
_pEnemyCoastalCity$ = -80				; size = 4
_owningPlayer$ = -76					; size = 4
tv1198 = -72						; size = 4
_pCoastalBarbarianCamp$ = -68				; size = 4
_iClosestEnemyDistance$ = -64				; size = 4
_iClosestCampDistance$ = -60				; size = 4
_iPlotLoop$ = -56					; size = 4
_iUnitY$226498 = -52					; size = 4
_iUnitX$226497 = -48					; size = 4
_iPlotDistance$226506 = -44				; size = 4
$T250297 = -40						; size = 4
_iBestTurns$226523 = -40				; size = 4
_iBaseMoves$226499 = -40				; size = 4
_aPlotList$226496 = -36					; size = 24
__$EHRec$ = -12						; size = 12
?FindBestTarget@CvAIOperationNavalSuperiority@@MAEPAVCvPlot@@XZ PROC ; CvAIOperationNavalSuperiority::FindBestTarget, COMDAT
; _this$ = ecx

; 4416 : {

	push	-1
	push	__ehhandler$?FindBestTarget@CvAIOperationNavalSuperiority@@MAEPAVCvPlot@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 4417 : #ifdef AUI_WARNING_FIXES
; 4418 : 	uint iPlotLoop, iUnitLoop;
; 4419 : #else
; 4420 : 	int iPlotLoop, iUnitLoop;
; 4421 : #endif
; 4422 : 	CvPlot* pPlot;
; 4423 : 	CvPlot* pBestPlot = NULL;
; 4424 : 	CvUnit* pInitialUnit;
; 4425 : 	CvCity* pCity;
; 4426 : 	CvCity* pEnemyCoastalCity = NULL;
; 4427 : 	CvPlot* pCoastalBarbarianCamp = NULL;
; 4428 : 	int iClosestEnemyDistance = MAX_INT;
; 4429 : 	int iClosestCampDistance = MAX_INT;
; 4430 : 	int iDistance;
; 4431 : 	CvPlayer& owningPlayer = GET_PLAYER(m_eOwner);

	mov	ebx, DWORD PTR [esi+72]
	imul	ebx, 63236				; 0000f704H
	add	ebx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, 2147483647				; 7fffffffH
	mov	DWORD PTR _iClosestEnemyDistance$[esp+96], eax
	mov	DWORD PTR _iClosestCampDistance$[esp+96], eax

; 4432 : 
; 4433 : 	if(GetFirstArmyID() == -1)

	mov	eax, DWORD PTR [esi+12]
	sub	eax, DWORD PTR [esi+8]
	push	edi
	xor	edi, edi
	mov	DWORD PTR _pEnemyCoastalCity$[esp+100], edi
	mov	DWORD PTR _pCoastalBarbarianCamp$[esp+100], edi
	mov	DWORD PTR _owningPlayer$[esp+100], ebx
	test	eax, -4					; fffffffcH
	je	SHORT $LN228@FindBestTa@11
	mov	eax, DWORD PTR [esi+8]
	cmp	DWORD PTR [eax], -1
	jne	SHORT $LN39@FindBestTa@11
$LN228@FindBestTa@11:

; 4434 : 	{
; 4435 : 		pInitialUnit = FindInitialUnit();

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+152]
	call	eax
	mov	ebp, eax
	mov	DWORD PTR _pInitialUnit$[esp+100], ebp

; 4436 : 	}
; 4437 : 	else

	jmp	SHORT $LN36@FindBestTa@11
$LN39@FindBestTa@11:

; 4438 : 	{
; 4439 : 		CvArmyAI* pThisArmy = owningPlayer.getArmyAI(m_viArmyIDs[0]);

	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, ebx
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI

; 4440 : 		int iUnitID = pThisArmy->GetFirstUnitID();

	mov	ecx, eax
	call	?GetFirstUnitID@CvArmyAI@@QAEHXZ	; CvArmyAI::GetFirstUnitID

; 4441 : 		if(iUnitID != -1)

	cmp	eax, -1
	je	SHORT $LN37@FindBestTa@11

; 4442 : 		{
; 4443 : 			pInitialUnit = owningPlayer.getUnit(iUnitID);

	push	eax
	mov	ecx, ebx
	call	?getUnit@CvPlayer@@QAEPAVCvUnit@@H@Z	; CvPlayer::getUnit

; 4444 : 		}
; 4445 : 		else

	jmp	SHORT $LN244@FindBestTa@11
$LN37@FindBestTa@11:

; 4446 : 		{
; 4447 : 			pInitialUnit = FindInitialUnit();

	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+152]
	mov	ecx, esi
	call	eax
$LN244@FindBestTa@11:
	mov	ebp, eax
	mov	DWORD PTR _pInitialUnit$[esp+100], eax
$LN36@FindBestTa@11:

; 4448 : 		}
; 4449 : 	}
; 4450 : 
; 4451 : 	if(pInitialUnit != NULL)

	xor	eax, eax
	cmp	ebp, eax
	je	$LN230@FindBestTa@11

; 4452 : 	{
; 4453 : 		WeightedPlotVector aPlotList;

	lea	ecx, DWORD PTR _aPlotList$226496[esp+112]
	mov	DWORD PTR _aPlotList$226496[esp+104], eax
	mov	DWORD PTR _aPlotList$226496[esp+100], ecx

; 4454 : 		aPlotList.reserve(64);

	push	798					; 0000031eH
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	push	4
	mov	edi, 64					; 00000040H
	push	512					; 00000200H
	mov	DWORD PTR __$EHRec$[esp+124], eax
	mov	DWORD PTR _aPlotList$226496[esp+124], edi
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	mov	edx, DWORD PTR _aPlotList$226496[esp+120]
	mov	ecx, DWORD PTR _aPlotList$226496[esp+116]
	mov	esi, eax
	lea	eax, DWORD PTR [edx*8]
	push	eax
	push	ecx
	push	esi
	mov	DWORD PTR _aPlotList$226496[esp+136], edi
	call	_memcpy
	mov	eax, DWORD PTR _aPlotList$226496[esp+128]
	lea	edx, DWORD PTR _aPlotList$226496[esp+140]
	add	esp, 28					; 0000001cH
	cmp	eax, edx
	je	SHORT $LN92@FindBestTa@11
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN92@FindBestTa@11:

; 4455 : 
; 4456 : 		int iUnitX = pInitialUnit->getX();
; 4457 : 		int iUnitY = pInitialUnit->getY();

	mov	ecx, DWORD PTR [ebp+88]
	mov	eax, DWORD PTR [ebp+76]
	mov	DWORD PTR _iUnitY$226498[esp+100], ecx

; 4458 : 		int iBaseMoves = pInitialUnit->baseMoves();

	push	-1
	mov	ecx, ebp
	mov	DWORD PTR _aPlotList$226496[esp+104], esi
	mov	BYTE PTR _aPlotList$226496[esp+124], 1
	mov	DWORD PTR _iUnitX$226497[esp+104], eax
	call	?baseMoves@CvUnit@@QBEHW4DomainTypes@@@Z ; CvUnit::baseMoves

; 4459 : 
; 4460 : 		// Look at map for enemy naval units
; 4461 : 		for(iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	DWORD PTR _iBaseMoves$226499[esp+100], eax
	mov	eax, DWORD PTR [ecx+4028]
	xor	edx, edx
	cmp	eax, edx
	mov	DWORD PTR _iPlotLoop$[esp+100], edx
	jle	$LN32@FindBestTa@11

; 4454 : 		aPlotList.reserve(64);

	mov	DWORD PTR tv1198[esp+100], edx
$LN34@FindBestTa@11:

; 4462 : 		{
; 4463 : 			pPlot = GC.getMap().plotByIndexUnchecked(iPlotLoop);

	mov	esi, DWORD PTR [ecx+4068]
	add	esi, DWORD PTR tv1198[esp+100]

; 4464 : 
; 4465 : 			if(pPlot->isRevealed(owningPlayer.getTeam()))

	mov	ecx, ebx
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	mov	edx, eax
	shr	edx, 5
	mov	ecx, edx
	shl	ecx, 5
	mov	edi, ecx
	mov	ecx, eax
	sub	ecx, edi
	mov	eax, 1
	shl	eax, cl
	test	eax, DWORD PTR [esi+edx*4+8]
	je	$LN33@FindBestTa@11

; 4466 : 			{
; 4467 : 				if(pPlot->isWater())

	cmp	BYTE PTR [esi+5], 3
	jne	$LN30@FindBestTa@11

; 4468 : 				{
; 4469 : 					if(pPlot->getNumUnits() > 0)

	mov	ecx, esi
	call	?getNumUnits@CvPlot@@QBEHXZ		; CvPlot::getNumUnits
	test	eax, eax
	jle	$LN33@FindBestTa@11

; 4470 : 					{
; 4471 : 						int iPlotDistance = plotDistance(iUnitX, iUnitY, pPlot->getX(), pPlot->getY());

	movsx	ecx, WORD PTR [esi+2]
	movsx	edx, WORD PTR [esi]
	mov	eax, DWORD PTR _iUnitY$226498[esp+100]
	push	ecx
	mov	ecx, DWORD PTR _iUnitX$226497[esp+104]
	push	edx
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H

; 4472 : 						for(iUnitLoop = 0; iUnitLoop < pPlot->getNumUnits(); iUnitLoop++)

	mov	ecx, esi
	mov	DWORD PTR _iPlotDistance$226506[esp+100], eax
	xor	ebx, ebx
	call	?getNumUnits@CvPlot@@QBEHXZ		; CvPlot::getNumUnits
	test	eax, eax
	jle	$LN236@FindBestTa@11
$LN28@FindBestTa@11:

; 4473 : 						{
; 4474 : 							CvUnit* pLoopUnit = pPlot->getUnitByIndex(iUnitLoop);

	push	ebx
	mov	ecx, esi
	call	?getUnitByIndex@CvPlot@@QBEPAVCvUnit@@H@Z ; CvPlot::getUnitByIndex

; 4475 : 							{
; 4476 : 								if(pLoopUnit->isEnemy(owningPlayer.getTeam()))

	mov	ecx, DWORD PTR _owningPlayer$[esp+100]
	push	0
	mov	ebp, eax
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	push	eax
	mov	ecx, ebp
	call	?isEnemy@CvUnit@@QBE_NW4TeamTypes@@PBVCvPlot@@@Z ; CvUnit::isEnemy
	test	al, al
	je	SHORT $LN27@FindBestTa@11

; 4477 : 								{
; 4478 : 									int iScore = iBaseMoves * iPlotDistance;

	mov	edi, DWORD PTR _iPlotDistance$226506[esp+100]
	imul	edi, DWORD PTR _iBaseMoves$226499[esp+100]

; 4479 : 									if (pLoopUnit->isTrade()) // we want to plunder trade routes of possible

	mov	ecx, ebp
	call	?isTrade@CvUnit@@QBE_NXZ		; CvUnit::isTrade
	test	al, al
	je	SHORT $LN24@FindBestTa@11

; 4480 : 									{
; 4481 : 										iScore /= 3;

	mov	eax, 1431655766				; 55555556H
	imul	edi
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	edi, eax
$LN24@FindBestTa@11:

; 4482 : 									}
; 4483 : 									if (pLoopUnit->isEmbarked()) // we want to take out embarked units more than ships

	cmp	BYTE PTR [ebp+1652], 0
	je	SHORT $LN23@FindBestTa@11

; 4484 : 									{
; 4485 : 										iScore = (iScore * 2) / 3;

	lea	ecx, DWORD PTR [edi+edi]
	mov	eax, 1431655766				; 55555556H
	imul	ecx
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	edi, ecx
$LN23@FindBestTa@11:

; 4486 : 									}
; 4487 : 
; 4488 : 									aPlotList.push_back(pPlot, iScore);

	mov	eax, DWORD PTR _aPlotList$226496[esp+108]
	mov	BYTE PTR _aPlotList$226496[esp+120], 0
	cmp	DWORD PTR _aPlotList$226496[esp+104], eax
	jne	SHORT $LN136@FindBestTa@11
	push	eax
	lea	ecx, DWORD PTR _aPlotList$226496[esp+104]
	call	?GrowSize@?$FStaticVector@UWeightedElement@?$CvWeightedVector@PAVCvPlot@@$00$00@@$00$00$0A@$0A@@@IAEXI@Z ; FStaticVector<CvWeightedVector<CvPlot *,1,1>::WeightedElement,1,1,0,0>::GrowSize
$LN136@FindBestTa@11:
	mov	edx, DWORD PTR _aPlotList$226496[esp+100]
	mov	eax, DWORD PTR _aPlotList$226496[esp+104]
	lea	eax, DWORD PTR [edx+eax*8]
	test	eax, eax
	je	SHORT $LN139@FindBestTa@11
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], edi
$LN139@FindBestTa@11:
	inc	DWORD PTR _aPlotList$226496[esp+104]
$LN27@FindBestTa@11:

; 4472 : 						for(iUnitLoop = 0; iUnitLoop < pPlot->getNumUnits(); iUnitLoop++)

	mov	ecx, esi
	inc	ebx
	call	?getNumUnits@CvPlot@@QBEHXZ		; CvPlot::getNumUnits
	cmp	ebx, eax
	jl	$LN28@FindBestTa@11

; 4489 : 								}
; 4490 : 							}
; 4491 : 						}
; 4492 : 					}
; 4493 : 				}

	mov	ebp, DWORD PTR _pInitialUnit$[esp+100]
$LN236@FindBestTa@11:

; 4519 : 						pCoastalBarbarianCamp = pPlot;

	mov	ebx, DWORD PTR _owningPlayer$[esp+100]
$LN33@FindBestTa@11:

; 4459 : 
; 4460 : 		// Look at map for enemy naval units
; 4461 : 		for(iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)

	mov	eax, DWORD PTR _iPlotLoop$[esp+100]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	DWORD PTR tv1198[esp+100], 484		; 000001e4H
	inc	eax
	cmp	eax, DWORD PTR [ecx+4028]
	mov	DWORD PTR _iPlotLoop$[esp+100], eax
	jl	$LN34@FindBestTa@11
$LN32@FindBestTa@11:

; 4520 : 					}
; 4521 : 				}
; 4522 : 			}
; 4523 : 		}
; 4524 : 
; 4525 : 		int iBestTurns;
; 4526 : 		pBestPlot = GetReachablePlot(pInitialUnit, aPlotList, &iBestTurns);

	lea	eax, DWORD PTR _iBestTurns$226523[esp+100]
	push	eax
	lea	ecx, DWORD PTR _aPlotList$226496[esp+104]
	push	ecx
	sub	esp, 8
	mov	eax, esp
	mov	ecx, ebp
	mov	DWORD PTR $T250297[esp+116], esp
	mov	DWORD PTR [eax], ebp
	mov	BYTE PTR [eax+4], 0
	call	?getDestructionNotification@CvUnit@@QAEAAU?$DestructionNotification@V?$FObjectHandle@VCvUnit@@@@@@XZ ; CvUnit::getDestructionNotification
	call	?GetReachablePlot@@YAPAVCvPlot@@V?$FObjectHandle@VCvUnit@@@@AAV?$CvWeightedVector@PAVCvPlot@@$00$00@@PAH@Z ; GetReachablePlot
	mov	ebx, eax
	add	esp, 16					; 00000010H

; 4527 : 
; 4528 : 		// None found, patrol over near closest enemy coastal city, or if not that a water tile adjacent to a camp
; 4529 : 		if(pBestPlot == NULL)

	test	ebx, ebx
	jne	$LN3@FindBestTa@11

; 4530 : 		{
; 4531 : 			if(pEnemyCoastalCity != NULL)

	cmp	DWORD PTR _pEnemyCoastalCity$[esp+100], eax
	je	$LN13@FindBestTa@11

; 4532 : 			{
; 4533 : 				// Find a coastal water tile adjacent to enemy city
; 4534 : 				for(int iDirectionLoop = 0; iDirectionLoop < NUM_DIRECTION_TYPES; ++iDirectionLoop)

	xor	edi, edi
$LN12@FindBestTa@11:

; 4535 : 				{
; 4536 : 					CvPlot* pAdjacentPlot = plotDirection(pEnemyCoastalCity->plot()->getX(), pEnemyCoastalCity->plot()->getY(), ((DirectionTypes)iDirectionLoop));

	mov	ecx, DWORD PTR _pEnemyCoastalCity$[esp+100]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	ecx, DWORD PTR _pEnemyCoastalCity$[esp+100]
	movsx	esi, WORD PTR [eax+2]
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	movsx	edx, WORD PTR [eax]
	push	edi
	push	esi
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 4537 : 					if(pAdjacentPlot != NULL && pAdjacentPlot->isWater() && pAdjacentPlot->isShallowWater())

	test	esi, esi
	je	SHORT $LN11@FindBestTa@11
	cmp	BYTE PTR [esi+5], 3
	jne	SHORT $LN11@FindBestTa@11
	mov	ecx, esi
	call	?isShallowWater@CvPlot@@QBE_NXZ		; CvPlot::isShallowWater
	test	al, al
	je	SHORT $LN11@FindBestTa@11

; 4538 : 					{
; 4539 : 						if(pInitialUnit->GeneratePath(pAdjacentPlot))

	push	0
	push	0
	push	0
	push	esi
	mov	ecx, ebp
	call	?GeneratePath@CvUnit@@QBE_NPBVCvPlot@@H_NPAH@Z ; CvUnit::GeneratePath
	test	al, al
	je	SHORT $LN11@FindBestTa@11

; 4540 : 						{
; 4541 : 							pBestPlot = pAdjacentPlot;

	mov	ebx, esi
$LN11@FindBestTa@11:

; 4532 : 			{
; 4533 : 				// Find a coastal water tile adjacent to enemy city
; 4534 : 				for(int iDirectionLoop = 0; iDirectionLoop < NUM_DIRECTION_TYPES; ++iDirectionLoop)

	inc	edi
	cmp	edi, 6
	jl	SHORT $LN12@FindBestTa@11

; 4542 : 						}
; 4543 : 					}
; 4544 : 				}
; 4545 : 			}
; 4546 : 
; 4547 : 			else

	jmp	$LN3@FindBestTa@11
$LN30@FindBestTa@11:

; 4494 : 
; 4495 : 				// Backup plan is a coastal enemy city
; 4496 : 				else if(pPlot->isCity() && pPlot->isCoastalLand())

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	$LN21@FindBestTa@11
	cmp	eax, 64					; 00000040H
	jge	$LN21@FindBestTa@11
	mov	ecx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ecx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	test	eax, eax
	setne	al
	test	al, al
	je	$LN21@FindBestTa@11
	push	-1
	mov	ecx, esi
	call	?isCoastalLand@CvPlot@@QBE_NH@Z		; CvPlot::isCoastalLand
	test	al, al
	je	$LN21@FindBestTa@11

; 4497 : 				{
; 4498 : 					pCity = pPlot->getPlotCity();

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	jl	$LN33@FindBestTa@11
	cmp	eax, 64					; 00000040H
	jge	$LN33@FindBestTa@11
	mov	edx, DWORD PTR [esi+108]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	edx
	mov	ecx, eax
	call	?getCity@CvPlayer@@QAEPAVCvCity@@H@Z	; CvPlayer::getCity
	mov	esi, eax

; 4499 : 					if(pCity)

	test	esi, esi
	je	$LN33@FindBestTa@11

; 4500 : 					{
; 4501 : 						if(atWar(owningPlayer.getTeam(), pCity->getTeam()))

	mov	ecx, esi
	call	?getTeam@CvCity@@QBE?AW4TeamTypes@@XZ	; CvCity::getTeam
	push	eax
	mov	ecx, ebx
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	push	eax
	call	?atWar@@YA_NW4TeamTypes@@0@Z		; atWar
	add	esp, 8
	test	al, al
	je	$LN33@FindBestTa@11

; 4502 : 						{
; 4503 : 							iDistance = plotDistance(pInitialUnit->getX(), pInitialUnit->getY(), pCity->getX(), pCity->getY());

	mov	eax, DWORD PTR [esi+108]
	mov	ecx, DWORD PTR [esi+96]
	mov	edx, DWORD PTR [ebp+88]
	mov	edi, DWORD PTR [ebp+76]
	push	eax
	push	ecx
	push	edx
	push	edi
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H

; 4504 : 							if(iDistance < iClosestEnemyDistance)

	cmp	eax, DWORD PTR _iClosestEnemyDistance$[esp+100]
	jge	$LN33@FindBestTa@11

; 4505 : 							{
; 4506 : 								iClosestEnemyDistance = iDistance;

	mov	DWORD PTR _iClosestEnemyDistance$[esp+100], eax

; 4507 : 								pEnemyCoastalCity = pCity;

	mov	DWORD PTR _pEnemyCoastalCity$[esp+100], esi

; 4508 : 							}
; 4509 : 						}
; 4510 : 					}
; 4511 : 				}

	jmp	$LN33@FindBestTa@11
$LN21@FindBestTa@11:

; 4512 : 
; 4513 : 				else if(pPlot->isCoastalLand() && pPlot->getImprovementType() == GC.getBARBARIAN_CAMP_IMPROVEMENT())

	push	-1
	mov	ecx, esi
	call	?isCoastalLand@CvPlot@@QBE_NH@Z		; CvPlot::isCoastalLand
	test	al, al
	je	$LN33@FindBestTa@11
	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8548
	mov	ecx, esi
	call	?getImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@XZ ; CvPlot::getImprovementType
	cmp	eax, edi
	jne	$LN33@FindBestTa@11

; 4514 : 				{
; 4515 : 					iDistance = plotDistance(pInitialUnit->getX(), pInitialUnit->getY(), pPlot->getX(), pPlot->getY());

	movsx	edx, WORD PTR [esi+2]
	mov	eax, DWORD PTR [ebp+88]
	mov	ecx, DWORD PTR [ebp+76]
	push	edx
	movsx	edx, WORD PTR [esi]
	push	edx
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H

; 4516 : 					if(iDistance < iClosestCampDistance)

	cmp	eax, DWORD PTR _iClosestCampDistance$[esp+100]
	jge	$LN33@FindBestTa@11

; 4517 : 					{
; 4518 : 						iClosestCampDistance = iDistance;

	mov	DWORD PTR _iClosestCampDistance$[esp+100], eax

; 4519 : 						pCoastalBarbarianCamp = pPlot;

	mov	DWORD PTR _pCoastalBarbarianCamp$[esp+100], esi
	jmp	$LN33@FindBestTa@11
$LN13@FindBestTa@11:

; 4548 : 			{
; 4549 : 				if(pCoastalBarbarianCamp != NULL)

	mov	eax, DWORD PTR _pCoastalBarbarianCamp$[esp+100]
	test	eax, eax
	je	SHORT $LN3@FindBestTa@11

; 4550 : 				{
; 4551 : 					// Find a coastal water tile adjacent to camp
; 4552 : 					for(int iDirectionLoop = 0; iDirectionLoop < NUM_DIRECTION_TYPES; ++iDirectionLoop)

	xor	edi, edi
	jmp	SHORT $LN5@FindBestTa@11
$LL239@FindBestTa@11:
	mov	eax, DWORD PTR _pCoastalBarbarianCamp$[esp+100]
$LN5@FindBestTa@11:

; 4553 : 					{
; 4554 : 						CvPlot* pAdjacentPlot = plotDirection(pCoastalBarbarianCamp->getX(), pCoastalBarbarianCamp->getY(), ((DirectionTypes)iDirectionLoop));

	movsx	ecx, WORD PTR [eax+2]
	movsx	edx, WORD PTR [eax]
	push	edi
	push	ecx
	push	edx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 4555 : 						if(pAdjacentPlot != NULL && pAdjacentPlot->isWater() && pAdjacentPlot->isShallowWater())

	test	esi, esi
	je	SHORT $LN4@FindBestTa@11
	cmp	BYTE PTR [esi+5], 3
	jne	SHORT $LN4@FindBestTa@11
	mov	ecx, esi
	call	?isShallowWater@CvPlot@@QBE_NXZ		; CvPlot::isShallowWater
	test	al, al
	je	SHORT $LN4@FindBestTa@11

; 4556 : 						{
; 4557 : 							if(pInitialUnit->GeneratePath(pAdjacentPlot))

	push	0
	push	0
	push	0
	push	esi
	mov	ecx, ebp
	call	?GeneratePath@CvUnit@@QBE_NPBVCvPlot@@H_NPAH@Z ; CvUnit::GeneratePath
	test	al, al
	je	SHORT $LN4@FindBestTa@11

; 4558 : 							{
; 4559 : 								pBestPlot = pAdjacentPlot;

	mov	ebx, esi
$LN4@FindBestTa@11:

; 4550 : 				{
; 4551 : 					// Find a coastal water tile adjacent to camp
; 4552 : 					for(int iDirectionLoop = 0; iDirectionLoop < NUM_DIRECTION_TYPES; ++iDirectionLoop)

	inc	edi
	cmp	edi, 6
	jl	SHORT $LL239@FindBestTa@11
$LN3@FindBestTa@11:

; 4560 : 							}
; 4561 : 						}
; 4562 : 					}
; 4563 : 				}
; 4564 : 			}
; 4565 : 		}
; 4566 : 	}

	mov	eax, DWORD PTR _aPlotList$226496[esp+100]
	lea	ecx, DWORD PTR _aPlotList$226496[esp+112]
	mov	DWORD PTR __$EHRec$[esp+108], -1
	cmp	eax, ecx
	je	SHORT $LN229@FindBestTa@11
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN229@FindBestTa@11:

; 4567 : 
; 4568 : 	return pBestPlot;

	mov	eax, ebx

; 4569 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+100]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 84					; 00000054H
	ret	0
$LN230@FindBestTa@11:
	mov	ecx, DWORD PTR __$EHRec$[esp+100]
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 84					; 00000054H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FindBestTarget@CvAIOperationNavalSuperiority@@MAEPAVCvPlot@@XZ$0:
	lea	ecx, DWORD PTR _aPlotList$226496[ebp]
	jmp	??1?$CvWeightedVector@PAVCvPlot@@$00$00@@QAE@XZ ; CvWeightedVector<CvPlot *,1,1>::~CvWeightedVector<CvPlot *,1,1>
__ehhandler$?FindBestTarget@CvAIOperationNavalSuperiority@@MAEPAVCvPlot@@XZ:
	mov	eax, OFFSET __ehfuncinfo$?FindBestTarget@CvAIOperationNavalSuperiority@@MAEPAVCvPlot@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?FindBestTarget@CvAIOperationNavalSuperiority@@MAEPAVCvPlot@@XZ ENDP ; CvAIOperationNavalSuperiority::FindBestTarget
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvAIOperationPureNavalCityAttack@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvAIOperationPureNavalCityAttack@@UAEPAXI@Z PROC	; CvAIOperationPureNavalCityAttack::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvAIEnemyTerritoryOperation@@6B@
	call	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN13@scalar@21
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN13@scalar@21:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvAIOperationPureNavalCityAttack@@UAEPAXI@Z ENDP	; CvAIOperationPureNavalCityAttack::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GCvAIOperationCityCloseDefense@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvAIOperationCityCloseDefense@@UAEPAXI@Z PROC	; CvAIOperationCityCloseDefense::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvAIOperationCityCloseDefense@@6B@
	call	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN7@scalar@22
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN7@scalar@22:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvAIOperationCityCloseDefense@@UAEPAXI@Z ENDP	; CvAIOperationCityCloseDefense::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GCvAIOperationRapidResponse@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvAIOperationRapidResponse@@UAEPAXI@Z PROC		; CvAIOperationRapidResponse::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvAIOperationRapidResponse@@6B@
	call	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN7@scalar@23
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN7@scalar@23:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvAIOperationRapidResponse@@UAEPAXI@Z ENDP		; CvAIOperationRapidResponse::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GCvAINavalEscortedOperation@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvAINavalEscortedOperation@@UAEPAXI@Z PROC		; CvAINavalEscortedOperation::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvAINavalEscortedOperation@@6B@
	call	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN7@scalar@24
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN7@scalar@24:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvAINavalEscortedOperation@@UAEPAXI@Z ENDP		; CvAINavalEscortedOperation::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GCvAIOperationNavalAttack@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvAIOperationNavalAttack@@UAEPAXI@Z PROC		; CvAIOperationNavalAttack::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvAINavalEscortedOperation@@6B@
	call	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN10@scalar@25
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN10@scalar@25:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvAIOperationNavalAttack@@UAEPAXI@Z ENDP		; CvAIOperationNavalAttack::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?UnitWasRemoved@CvAIOperationNavalAttack@@UAEXHH@Z
_TEXT	SEGMENT
_iArmyID$ = 8						; size = 4
_iSlotID$ = 12						; size = 4
?UnitWasRemoved@CvAIOperationNavalAttack@@UAEXHH@Z PROC	; CvAIOperationNavalAttack::UnitWasRemoved, COMDAT
; _this$ = ecx

; 5439 : 	// Call root class version
; 5440 : 	CvAIOperation::UnitWasRemoved(iArmyID, iSlotID);

	jmp	?UnitWasRemoved@CvAIOperation@@UAEXHH@Z	; CvAIOperation::UnitWasRemoved
?UnitWasRemoved@CvAIOperationNavalAttack@@UAEXHH@Z ENDP	; CvAIOperationNavalAttack::UnitWasRemoved
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GCvAIOperationNavalSneakAttack@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvAIOperationNavalSneakAttack@@UAEPAXI@Z PROC	; CvAIOperationNavalSneakAttack::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvAINavalEscortedOperation@@6B@
	call	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN13@scalar@26
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN13@scalar@26:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvAIOperationNavalSneakAttack@@UAEPAXI@Z ENDP	; CvAIOperationNavalSneakAttack::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GCvAIOperationNavalCityStateAttack@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvAIOperationNavalCityStateAttack@@UAEPAXI@Z PROC	; CvAIOperationNavalCityStateAttack::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvAINavalEscortedOperation@@6B@
	call	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN13@scalar@27
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN13@scalar@27:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvAIOperationNavalCityStateAttack@@UAEPAXI@Z ENDP	; CvAIOperationNavalCityStateAttack::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GCvAIOperationNukeAttack@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvAIOperationNukeAttack@@UAEPAXI@Z PROC		; CvAIOperationNukeAttack::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvAIOperationNukeAttack@@6B@
	call	??1CvAIOperation@@UAE@XZ		; CvAIOperation::~CvAIOperation
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN7@scalar@28
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN7@scalar@28:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvAIOperationNukeAttack@@UAEPAXI@Z ENDP		; CvAIOperationNukeAttack::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??$?5UOperationSlot@@@@YAAAVFDataStream@@AAV0@AAV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@Z ; operator>><OperationSlot>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$?5UOperationSlot@@@@YAAAVFDataStream@@AAV0@AAV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5UOperationSlot@@@@YAAAVFDataStream@@AAV0@AAV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@Z PROC ; operator>><OperationSlot>, COMDAT

; 226  : 	// The functor needs to be instantiated to properly resize the container based 
; 227  : 	// on how many elements the stream says it should have before passing it along
; 228  : 	// to std::for_each
; 229  : 	SerializeToSequenceContainer<ElementType, std::vector<ElementType> >(loadFrom, writeTo);

	mov	eax, DWORD PTR _writeTo$[esp-4]
	push	esi
	mov	esi, DWORD PTR _loadFrom$[esp]
	push	eax
	push	esi
	call	??$SerializeToSequenceContainer@UOperationSlot@@V?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@Z ; SerializeToSequenceContainer<OperationSlot,std::vector<OperationSlot,std::allocator<OperationSlot> > >
	add	esp, 8

; 230  : 
; 231  : 	//std::for_each(writeTo.begin(), writeTo.end(), func);
; 232  : 	return loadFrom;

	mov	eax, esi
	pop	esi

; 233  : }

	ret	0
??$?5UOperationSlot@@@@YAAAVFDataStream@@AAV0@AAV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@Z ENDP ; operator>><OperationSlot>
_TEXT	ENDS
PUBLIC	??$_Stable_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0PAH0@Z ; std::_Stable_sort<CvOperationSearchUnit *,int,CvOperationSearchUnit>
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Stable_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0PAH0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Stable_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0PAH0@Z$0
__ehfuncinfo$??$_Stable_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0PAH0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Stable_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0PAH0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
xdata$x	ENDS
;	COMDAT ??$_Stable_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0PAH0@Z
_TEXT	SEGMENT
__Tempbuf$ = -32					; size = 20
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Stable_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0PAH0@Z PROC ; std::_Stable_sort<CvOperationSearchUnit *,int,CvOperationSearchUnit>, COMDAT

; 3410 : 	{	// sort preserving order of equivalents, using operator<

	push	-1
	push	__ehhandler$??$_Stable_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0PAH0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi

; 3411 : 	_Diff _Count = 0;
; 3412 : 	_Distance(_First, _Last, _Count);

	mov	esi, DWORD PTR __Last$[esp+36]
	push	edi
	mov	edi, DWORD PTR __First$[esp+40]
	mov	ecx, esi
	sub	ecx, edi
	sar	ecx, 3

; 3413 : 	_Temp_iterator<_Ty> _Tempbuf((_Count + 1) / 2);

	lea	eax, DWORD PTR [ecx+1]
	cdq
	sub	eax, edx
	sar	eax, 1
	xor	ebx, ebx
	mov	DWORD PTR __Tempbuf$[esp+56], eax
	lea	eax, DWORD PTR __Tempbuf$[esp+44]
	mov	DWORD PTR __Tempbuf$[esp+44], ebx
	mov	DWORD PTR __Tempbuf$[esp+48], ebx
	mov	DWORD PTR __Tempbuf$[esp+52], ebx
	mov	DWORD PTR __Tempbuf$[esp+60], eax

; 3414 : 	_Stable_sort(_First, _Last, _Count, _Tempbuf);

	mov	edx, eax
	push	edx
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[esp+68], ebx
	call	??$_Stable_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0HAAV?$_Temp_iterator@VCvOperationSearchUnit@@@0@@Z ; std::_Stable_sort<CvOperationSearchUnit *,int,CvOperationSearchUnit>

; 3415 : 	}

	mov	eax, DWORD PTR __Tempbuf$[esp+60]
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi
	cmp	eax, ebx
	pop	ebx
	je	SHORT $LN20@Stable_sor@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN20@Stable_sor@2:
	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR fs:0, ecx
	add	esp, 32					; 00000020H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Stable_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0PAH0@Z$0:
	lea	ecx, DWORD PTR __Tempbuf$[ebp]
	jmp	??1?$_Temp_iterator@VCvOperationSearchUnit@@@std@@QAE@XZ ; std::_Temp_iterator<CvOperationSearchUnit>::~_Temp_iterator<CvOperationSearchUnit>
__ehhandler$??$_Stable_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0PAH0@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Stable_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0PAH0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Stable_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0PAH0@Z ENDP ; std::_Stable_sort<CvOperationSearchUnit *,int,CvOperationSearchUnit>
PUBLIC	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ; operator>><int>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fstlcontainerserialization.h
;	COMDAT ??$?5H@@YAAAVFDataStream@@AAV0@AAV?$vector@HV?$allocator@H@std@@@std@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5H@@YAAAVFDataStream@@AAV0@AAV?$vector@HV?$allocator@H@std@@@std@@@Z PROC ; operator>><int>, COMDAT

; 226  : 	// The functor needs to be instantiated to properly resize the container based 
; 227  : 	// on how many elements the stream says it should have before passing it along
; 228  : 	// to std::for_each
; 229  : 	SerializeToSequenceContainer<ElementType, std::vector<ElementType> >(loadFrom, writeTo);

	mov	eax, DWORD PTR _writeTo$[esp-4]
	push	esi
	mov	esi, DWORD PTR _loadFrom$[esp]
	push	eax
	push	esi
	call	??$SerializeToSequenceContainer@HV?$vector@HV?$allocator@H@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ; SerializeToSequenceContainer<int,std::vector<int,std::allocator<int> > >
	add	esp, 8

; 230  : 
; 231  : 	//std::for_each(writeTo.begin(), writeTo.end(), func);
; 232  : 	return loadFrom;

	mov	eax, esi
	pop	esi

; 233  : }

	ret	0
??$?5H@@YAAAVFDataStream@@AAV0@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ENDP ; operator>><int>
_TEXT	ENDS
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z:PROC ; operator>>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
;	COMDAT ?Read@CvAIOperation@@UAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
_v$251034 = 8						; size = 4
_v$251019 = 8						; size = 4
_kStream$ = 8						; size = 4
?Read@CvAIOperation@@UAEXAAVFDataStream@@@Z PROC	; CvAIOperation::Read, COMDAT
; _this$ = ecx

; 1170 : {

	push	ecx
	push	esi
	push	edi

; 1171 : 	// Version number to maintain backwards compatibility
; 1172 : 	uint uiVersion;
; 1173 : 	kStream >> uiVersion;

	mov	edi, DWORD PTR _kStream$[esp+8]
	lea	eax, DWORD PTR _uiVersion$[esp+12]
	mov	esi, ecx
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 1174 : 
; 1175 : 	kStream >> m_iID;

	lea	ecx, DWORD PTR [esi+52]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1176 : 	kStream >> m_eOwner;

	lea	edx, DWORD PTR [esi+72]
	push	edx
	push	edi
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>

; 1177 : 	kStream >> m_eEnemy;

	lea	eax, DWORD PTR [esi+76]
	push	eax
	push	edi
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 16					; 00000010H

; 1178 : 	kStream >> m_eCurrentState;

	lea	ecx, DWORD PTR _v$251019[esp+8]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	mov	edx, DWORD PTR _v$251019[esp+8]

; 1179 : 	kStream >> m_iDefaultArea;

	lea	eax, DWORD PTR [esi+64]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR [esi+56], edx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1180 : 	kStream >> m_bShouldReplaceLossesWithReinforcements;

	lea	ecx, DWORD PTR [esi+80]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 1181 : 	kStream >> m_eMoveType;

	lea	edx, DWORD PTR _v$251034[esp+8]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	mov	eax, DWORD PTR _v$251034[esp+8]

; 1182 : 	kStream >> m_iTargetX;

	lea	ecx, DWORD PTR [esi+104]
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR [esi+84], eax
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1183 : 	kStream >> m_iTargetY;

	lea	edx, DWORD PTR [esi+108]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1184 : 	kStream >> m_iMusterX;

	lea	eax, DWORD PTR [esi+96]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1185 : 	kStream >> m_iMusterY;

	lea	ecx, DWORD PTR [esi+100]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1186 : 	kStream >> m_iStartCityX;

	lea	edx, DWORD PTR [esi+88]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1187 : 	kStream >> m_iStartCityY;

	lea	eax, DWORD PTR [esi+92]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1188 : 	kStream >> m_iLastTurnMoved;

	lea	ecx, DWORD PTR [esi+68]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1189 : 	kStream >> m_viArmyIDs;

	lea	edx, DWORD PTR [esi+4]
	push	edx
	push	edi
	call	??$SerializeToSequenceContainer@HV?$vector@HV?$allocator@H@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@HV?$allocator@H@std@@@std@@@Z ; SerializeToSequenceContainer<int,std::vector<int,std::allocator<int> > >

; 1190 : 	kStream >> m_viListOfUnitsWeStillNeedToBuild;

	lea	eax, DWORD PTR [esi+20]
	push	eax
	push	edi
	call	??$SerializeToSequenceContainer@UOperationSlot@@V?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@Z ; SerializeToSequenceContainer<OperationSlot,std::vector<OperationSlot,std::allocator<OperationSlot> > >

; 1191 : 	kStream >> m_viListOfUnitsCitiesHaveCommittedToBuild;

	add	esi, 36					; 00000024H
	push	esi
	push	edi
	call	??$SerializeToSequenceContainer@UOperationSlot@@V?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@@YAXAAVFDataStream@@AAV?$vector@UOperationSlot@@V?$allocator@UOperationSlot@@@std@@@std@@@Z ; SerializeToSequenceContainer<OperationSlot,std::vector<OperationSlot,std::allocator<OperationSlot> > >
	add	esp, 24					; 00000018H
	pop	edi
	pop	esi

; 1192 : }

	pop	ecx
	ret	4
?Read@CvAIOperation@@UAEXAAVFDataStream@@@Z ENDP	; CvAIOperation::Read
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Read@CvAIOperationBasicCityAttack@@UAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = 8						; size = 4
_kStream$ = 8						; size = 4
?Read@CvAIOperationBasicCityAttack@@UAEXAAVFDataStream@@@Z PROC ; CvAIOperationBasicCityAttack::Read, COMDAT
; _this$ = ecx

; 2188 : {

	push	esi

; 2189 : 	// read the base class' entries
; 2190 : 	CvAIOperation::Read(kStream);

	mov	esi, DWORD PTR _kStream$[esp]
	push	esi
	call	?Read@CvAIOperation@@UAEXAAVFDataStream@@@Z ; CvAIOperation::Read

; 2191 : 
; 2192 : 	// Version number to maintain backwards compatibility
; 2193 : 	uint uiVersion;
; 2194 : 	kStream >> uiVersion;

	lea	eax, DWORD PTR _uiVersion$[esp]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read
	pop	esi

; 2195 : }

	ret	4
?Read@CvAIOperationBasicCityAttack@@UAEXAAVFDataStream@@@Z ENDP ; CvAIOperationBasicCityAttack::Read
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Read@CvAIOperationDestroyBarbarianCamp@@UAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = 8						; size = 4
_kStream$ = 8						; size = 4
?Read@CvAIOperationDestroyBarbarianCamp@@UAEXAAVFDataStream@@@Z PROC ; CvAIOperationDestroyBarbarianCamp::Read, COMDAT
; _this$ = ecx

; 2361 : {

	push	esi
	push	edi

; 2362 : 	// read the base class' entries
; 2363 : 	CvAIOperation::Read(kStream);

	mov	edi, DWORD PTR _kStream$[esp+4]
	push	edi
	mov	esi, ecx
	call	?Read@CvAIOperation@@UAEXAAVFDataStream@@@Z ; CvAIOperation::Read

; 2364 : 
; 2365 : 	// Version number to maintain backwards compatibility
; 2366 : 	uint uiVersion;
; 2367 : 	kStream >> uiVersion;

	lea	eax, DWORD PTR _uiVersion$[esp+4]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 2368 : 	m_bCivilianRescue = false;

	lea	eax, DWORD PTR [esi+112]

; 2369 : 	kStream >> m_bCivilianRescue;

	push	eax
	mov	ecx, edi
	mov	BYTE PTR [eax], 0
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 2370 : 	kStream >> m_iUnitToRescue;

	add	esi, 116				; 00000074H
	push	esi
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	pop	edi
	pop	esi

; 2371 : }

	ret	4
?Read@CvAIOperationDestroyBarbarianCamp@@UAEXAAVFDataStream@@@Z ENDP ; CvAIOperationDestroyBarbarianCamp::Read
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Read@CvAIOperationPillageEnemy@@UAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = 8						; size = 4
_kStream$ = 8						; size = 4
?Read@CvAIOperationPillageEnemy@@UAEXAAVFDataStream@@@Z PROC ; CvAIOperationPillageEnemy::Read, COMDAT
; _this$ = ecx

; 2633 : {

	push	esi

; 2634 : 	// read the base class' entries
; 2635 : 	CvAIOperation::Read(kStream);

	mov	esi, DWORD PTR _kStream$[esp]
	push	esi
	call	?Read@CvAIOperation@@UAEXAAVFDataStream@@@Z ; CvAIOperation::Read

; 2636 : 
; 2637 : 	// Version number to maintain backwards compatibility
; 2638 : 	uint uiVersion;
; 2639 : 	kStream >> uiVersion;

	lea	eax, DWORD PTR _uiVersion$[esp]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read
	pop	esi

; 2640 : }

	ret	4
?Read@CvAIOperationPillageEnemy@@UAEXAAVFDataStream@@@Z ENDP ; CvAIOperationPillageEnemy::Read
_TEXT	ENDS
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4UnitAITypes@@@Z:PROC ; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ?Read@CvAIEscortedOperation@@UAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = 8						; size = 4
_kStream$ = 8						; size = 4
?Read@CvAIEscortedOperation@@UAEXAAVFDataStream@@@Z PROC ; CvAIEscortedOperation::Read, COMDAT
; _this$ = ecx

; 2921 : {

	push	esi
	push	edi

; 2922 : 	// read the base class' entries
; 2923 : 	CvAIOperation::Read(kStream);

	mov	edi, DWORD PTR _kStream$[esp+4]
	push	edi
	mov	esi, ecx
	call	?Read@CvAIOperation@@UAEXAAVFDataStream@@@Z ; CvAIOperation::Read

; 2924 : 
; 2925 : 	// Version number to maintain backwards compatibility
; 2926 : 	uint uiVersion;
; 2927 : 	kStream >> uiVersion;

	lea	eax, DWORD PTR _uiVersion$[esp+4]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 2928 : 
; 2929 : 	kStream >> m_bEscorted;

	lea	ecx, DWORD PTR [esi+112]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 2930 : 	kStream >> m_eCivilianType;

	lea	edx, DWORD PTR [esi+116]
	push	edx
	push	edi
	call	??5@YAAAVFDataStream@@AAV0@AAW4UnitAITypes@@@Z ; operator>>

; 2931 : 	m_iTargetArea = -1;

	lea	eax, DWORD PTR [esi+120]
	add	esp, 8

; 2932 : 	kStream >> m_iTargetArea;

	push	eax
	mov	ecx, edi
	mov	DWORD PTR [eax], -1
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	pop	edi
	pop	esi

; 2933 : }

	ret	4
?Read@CvAIEscortedOperation@@UAEXAAVFDataStream@@@Z ENDP ; CvAIEscortedOperation::Read
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Read@CvAINavalOperation@@UAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = 8						; size = 4
_kStream$ = 8						; size = 4
?Read@CvAINavalOperation@@UAEXAAVFDataStream@@@Z PROC	; CvAINavalOperation::Read, COMDAT
; _this$ = ecx

; 3805 : {

	push	esi

; 3806 : 	// read the base class' entries
; 3807 : 	CvAIOperation::Read(kStream);

	mov	esi, DWORD PTR _kStream$[esp]
	push	esi
	call	?Read@CvAIOperation@@UAEXAAVFDataStream@@@Z ; CvAIOperation::Read

; 3808 : 
; 3809 : 	// Version number to maintain backwards compatibility
; 3810 : 	uint uiVersion;
; 3811 : 	kStream >> uiVersion;

	lea	eax, DWORD PTR _uiVersion$[esp]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read
	pop	esi

; 3812 : }

	ret	4
?Read@CvAINavalOperation@@UAEXAAVFDataStream@@@Z ENDP	; CvAINavalOperation::Read
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Read@CvAIOperationNavalBombardment@@UAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
_uiVersion$251118 = 8					; size = 4
_kStream$ = 8						; size = 4
?Read@CvAIOperationNavalBombardment@@UAEXAAVFDataStream@@@Z PROC ; CvAIOperationNavalBombardment::Read, COMDAT
; _this$ = ecx

; 4034 : {

	push	ecx
	push	esi

; 4035 : 	// read the base class' entries
; 4036 : 	CvAINavalOperation::Read(kStream);

	mov	esi, DWORD PTR _kStream$[esp+4]
	push	esi
	call	?Read@CvAIOperation@@UAEXAAVFDataStream@@@Z ; CvAIOperation::Read
	lea	eax, DWORD PTR _uiVersion$251118[esp+4]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 4037 : 
; 4038 : 	// Version number to maintain backwards compatibility
; 4039 : 	uint uiVersion;
; 4040 : 	kStream >> uiVersion;

	lea	ecx, DWORD PTR _uiVersion$[esp+8]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read
	pop	esi

; 4041 : }

	pop	ecx
	ret	4
?Read@CvAIOperationNavalBombardment@@UAEXAAVFDataStream@@@Z ENDP ; CvAIOperationNavalBombardment::Read
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Read@CvAIOperationNavalSuperiority@@UAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
_uiVersion$251133 = 8					; size = 4
_kStream$ = 8						; size = 4
?Read@CvAIOperationNavalSuperiority@@UAEXAAVFDataStream@@@Z PROC ; CvAIOperationNavalSuperiority::Read, COMDAT
; _this$ = ecx

; 4279 : {

	push	ecx
	push	esi

; 4280 : 	// read the base class' entries
; 4281 : 	CvAINavalOperation::Read(kStream);

	mov	esi, DWORD PTR _kStream$[esp+4]
	push	esi
	call	?Read@CvAIOperation@@UAEXAAVFDataStream@@@Z ; CvAIOperation::Read
	lea	eax, DWORD PTR _uiVersion$251133[esp+4]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 4282 : 
; 4283 : 	// Version number to maintain backwards compatibility
; 4284 : 	uint uiVersion;
; 4285 : 	kStream >> uiVersion;

	lea	ecx, DWORD PTR _uiVersion$[esp+8]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read
	pop	esi

; 4286 : }

	pop	ecx
	ret	4
?Read@CvAIOperationNavalSuperiority@@UAEXAAVFDataStream@@@Z ENDP ; CvAIOperationNavalSuperiority::Read
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Read@CvAIOperationPureNavalCityAttack@@UAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
_uiVersion$251148 = 8					; size = 4
_kStream$ = 8						; size = 4
?Read@CvAIOperationPureNavalCityAttack@@UAEXAAVFDataStream@@@Z PROC ; CvAIOperationPureNavalCityAttack::Read, COMDAT
; _this$ = ecx

; 4656 : {

	push	ecx
	push	esi

; 4657 : 	// read the base class' entries
; 4658 : 	CvAINavalOperation::Read(kStream);

	mov	esi, DWORD PTR _kStream$[esp+4]
	push	esi
	call	?Read@CvAIOperation@@UAEXAAVFDataStream@@@Z ; CvAIOperation::Read
	lea	eax, DWORD PTR _uiVersion$251148[esp+4]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 4659 : 
; 4660 : 	// Version number to maintain backwards compatibility
; 4661 : 	uint uiVersion;
; 4662 : 	kStream >> uiVersion;

	lea	ecx, DWORD PTR _uiVersion$[esp+8]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read
	pop	esi

; 4663 : }

	pop	ecx
	ret	4
?Read@CvAIOperationPureNavalCityAttack@@UAEXAAVFDataStream@@@Z ENDP ; CvAIOperationPureNavalCityAttack::Read
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Read@CvAIOperationCityCloseDefense@@UAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = 8						; size = 4
_kStream$ = 8						; size = 4
?Read@CvAIOperationCityCloseDefense@@UAEXAAVFDataStream@@@Z PROC ; CvAIOperationCityCloseDefense::Read, COMDAT
; _this$ = ecx

; 4825 : {

	push	esi

; 4826 : 	// read the base class' entries
; 4827 : 	CvAIOperation::Read(kStream);

	mov	esi, DWORD PTR _kStream$[esp]
	push	esi
	call	?Read@CvAIOperation@@UAEXAAVFDataStream@@@Z ; CvAIOperation::Read

; 4828 : 
; 4829 : 	// Version number to maintain backwards compatibility
; 4830 : 	uint uiVersion;
; 4831 : 	kStream >> uiVersion;

	lea	eax, DWORD PTR _uiVersion$[esp]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read
	pop	esi

; 4832 : }

	ret	4
?Read@CvAIOperationCityCloseDefense@@UAEXAAVFDataStream@@@Z ENDP ; CvAIOperationCityCloseDefense::Read
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Read@CvAIOperationRapidResponse@@UAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = 8						; size = 4
_kStream$ = 8						; size = 4
?Read@CvAIOperationRapidResponse@@UAEXAAVFDataStream@@@Z PROC ; CvAIOperationRapidResponse::Read, COMDAT
; _this$ = ecx

; 4939 : {

	push	esi

; 4940 : 	// read the base class' entries
; 4941 : 	CvAIOperation::Read(kStream);

	mov	esi, DWORD PTR _kStream$[esp]
	push	esi
	call	?Read@CvAIOperation@@UAEXAAVFDataStream@@@Z ; CvAIOperation::Read

; 4942 : 
; 4943 : 	// Version number to maintain backwards compatibility
; 4944 : 	uint uiVersion;
; 4945 : 	kStream >> uiVersion;

	lea	eax, DWORD PTR _uiVersion$[esp]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read
	pop	esi

; 4946 : }

	ret	4
?Read@CvAIOperationRapidResponse@@UAEXAAVFDataStream@@@Z ENDP ; CvAIOperationRapidResponse::Read
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Read@CvAINavalEscortedOperation@@UAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = 8						; size = 4
_kStream$ = 8						; size = 4
?Read@CvAINavalEscortedOperation@@UAEXAAVFDataStream@@@Z PROC ; CvAINavalEscortedOperation::Read, COMDAT
; _this$ = ecx

; 5219 : {

	push	esi
	push	edi

; 5220 : 	// read the base class' entries
; 5221 : 	CvAIOperation::Read(kStream);

	mov	edi, DWORD PTR _kStream$[esp+4]
	push	edi
	mov	esi, ecx
	call	?Read@CvAIOperation@@UAEXAAVFDataStream@@@Z ; CvAIOperation::Read

; 5222 : 
; 5223 : 	// Version number to maintain backwards compatibility
; 5224 : 	uint uiVersion;
; 5225 : 	kStream >> uiVersion;

	lea	eax, DWORD PTR _uiVersion$[esp+4]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 5226 : 
; 5227 : 	kStream >> m_eCivilianType;

	add	esi, 112				; 00000070H
	push	esi
	push	edi
	call	??5@YAAAVFDataStream@@AAV0@AAW4UnitAITypes@@@Z ; operator>>
	add	esp, 8
	pop	edi
	pop	esi

; 5228 : }

	ret	4
?Read@CvAINavalEscortedOperation@@UAEXAAVFDataStream@@@Z ENDP ; CvAINavalEscortedOperation::Read
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Read@CvAIOperationNavalAttack@@UAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
_uiVersion$251181 = 8					; size = 4
_kStream$ = 8						; size = 4
?Read@CvAIOperationNavalAttack@@UAEXAAVFDataStream@@@Z PROC ; CvAIOperationNavalAttack::Read, COMDAT
; _this$ = ecx

; 5445 : {

	push	ecx
	push	esi

; 5446 : 	// read the base class' entries
; 5447 : 	CvAINavalEscortedOperation::Read(kStream);

	mov	esi, DWORD PTR _kStream$[esp+4]
	push	edi
	push	esi
	mov	edi, ecx
	call	?Read@CvAIOperation@@UAEXAAVFDataStream@@@Z ; CvAIOperation::Read
	lea	eax, DWORD PTR _uiVersion$251181[esp+8]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read
	add	edi, 112				; 00000070H
	push	edi
	push	esi
	call	??5@YAAAVFDataStream@@AAV0@AAW4UnitAITypes@@@Z ; operator>>
	add	esp, 8

; 5448 : 
; 5449 : 	// Version number to maintain backwards compatibility
; 5450 : 	uint uiVersion;
; 5451 : 	kStream >> uiVersion;

	lea	ecx, DWORD PTR _uiVersion$[esp+12]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read
	pop	edi
	pop	esi

; 5452 : }

	pop	ecx
	ret	4
?Read@CvAIOperationNavalAttack@@UAEXAAVFDataStream@@@Z ENDP ; CvAIOperationNavalAttack::Read
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Read@CvAIOperationNukeAttack@@UAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = 8						; size = 4
_kStream$ = 8						; size = 4
?Read@CvAIOperationNukeAttack@@UAEXAAVFDataStream@@@Z PROC ; CvAIOperationNukeAttack::Read, COMDAT
; _this$ = ecx

; 5612 : {

	push	esi
	push	edi

; 5613 : 	// read the base class' entries
; 5614 : 	CvAIOperation::Read(kStream);

	mov	edi, DWORD PTR _kStream$[esp+4]
	push	edi
	mov	esi, ecx
	call	?Read@CvAIOperation@@UAEXAAVFDataStream@@@Z ; CvAIOperation::Read

; 5615 : 
; 5616 : 	// Version number to maintain backwards compatibility
; 5617 : 	uint uiVersion;
; 5618 : 	kStream >> uiVersion;

	lea	eax, DWORD PTR _uiVersion$[esp+4]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 5619 : 
; 5620 : 	kStream >> m_iBestUnitID;

	add	esi, 112				; 00000070H
	push	esi
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	pop	edi
	pop	esi

; 5621 : }

	ret	4
?Read@CvAIOperationNukeAttack@@UAEXAAVFDataStream@@@Z ENDP ; CvAIOperationNukeAttack::Read
_TEXT	ENDS
PUBLIC	??$stable_sort@PAVCvOperationSearchUnit@@@std@@YAXPAVCvOperationSearchUnit@@0@Z ; std::stable_sort<CvOperationSearchUnit *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$stable_sort@PAVCvOperationSearchUnit@@@std@@YAXPAVCvOperationSearchUnit@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$stable_sort@PAVCvOperationSearchUnit@@@std@@YAXPAVCvOperationSearchUnit@@0@Z PROC ; std::stable_sort<CvOperationSearchUnit *>, COMDAT

; 3420 : 	_DEBUG_RANGE(_First, _Last);
; 3421 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@stable_sor

; 3422 : 		{
; 3423 : 		_Stable_sort(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dist_type(_First), _Val_type(_First));

	push	0
	push	0
	push	ecx
	push	eax
	call	??$_Stable_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0PAH0@Z ; std::_Stable_sort<CvOperationSearchUnit *,int,CvOperationSearchUnit>
	add	esp, 16					; 00000010H
$LN1@stable_sor:

; 3424 : 		}
; 3425 : 	}

	ret	0
??$stable_sort@PAVCvOperationSearchUnit@@@std@@YAXPAVCvOperationSearchUnit@@0@Z ENDP ; std::stable_sort<CvOperationSearchUnit *>
_TEXT	ENDS
EXTRN	?GetPathLength@CvIgnoreUnitsPathFinder@@QAEHXZ:PROC ; CvIgnoreUnitsPathFinder::GetPathLength
EXTRN	?DoesPathExist@CvIgnoreUnitsPathFinder@@QAE_NAAVCvUnit@@PAVCvPlot@@1@Z:PROC ; CvIgnoreUnitsPathFinder::DoesPathExist
EXTRN	?getIgnoreUnitsPathFinder@CvGlobals@@QAEAAVCvIgnoreUnitsPathFinder@@XZ:PROC ; CvGlobals::getIgnoreUnitsPathFinder
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
;	COMDAT ?GetClosestUnit@@YAPAVCvUnit@@AAV?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@PAVCvPlot@@1_N@Z
_TEXT	SEGMENT
_iBestDistance$225156 = -12				; size = 4
_pkBestUnit$ = -8					; size = 4
_iDistance$225163 = -4					; size = 4
_kSearchList$ = 8					; size = 4
_pkMusterPlot$ = 12					; size = 4
_pkTarget$ = 16						; size = 4
_bNeedToCheckTarget$ = 20				; size = 1
?GetClosestUnit@@YAPAVCvUnit@@AAV?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@PAVCvPlot@@1_N@Z PROC ; GetClosestUnit, COMDAT

; 1622 : {

	sub	esp, 12					; 0000000cH
	push	esi

; 1623 : 	CvUnit* pkBestUnit = NULL;
; 1624 : 	if (kSearchList.size())

	mov	esi, DWORD PTR _kSearchList$[esp+12]
	mov	eax, DWORD PTR [esi+4]
	push	edi
	xor	edi, edi
	mov	DWORD PTR _pkBestUnit$[esp+20], edi
	test	eax, eax
	je	$LN44@GetClosest

; 1625 : 	{
; 1626 : 		std::stable_sort(kSearchList.begin(), kSearchList.end());

	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*8]
	cmp	ecx, eax
	je	SHORT $LN21@GetClosest
	push	edi
	push	edi
	push	eax
	push	ecx
	call	??$_Stable_sort@PAVCvOperationSearchUnit@@HV1@@std@@YAXPAVCvOperationSearchUnit@@0PAH0@Z ; std::_Stable_sort<CvOperationSearchUnit *,int,CvOperationSearchUnit>
	add	esp, 16					; 00000010H
$LN21@GetClosest:
	push	ebx
	push	ebp

; 1627 : 
; 1628 : 		int iBestDistance = MAX_INT;
; 1629 : 		CvIgnoreUnitsPathFinder& kPathFinder = GC.getIgnoreUnitsPathFinder();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iBestDistance$225156[esp+28], 2147483647 ; 7fffffffH
	call	?getIgnoreUnitsPathFinder@CvGlobals@@QAEAAVCvIgnoreUnitsPathFinder@@XZ ; CvGlobals::getIgnoreUnitsPathFinder

; 1630 : 		for (CvOperationSearchUnitList::iterator itr = kSearchList.begin(); itr != kSearchList.end(); ++itr)

	mov	ebp, DWORD PTR [esi]
	mov	ebx, eax
	mov	eax, DWORD PTR [esi+4]
	lea	ecx, DWORD PTR [ebp+eax*8]
	cmp	ebp, ecx
	je	$LN39@GetClosest
$LL47@GetClosest:

; 1631 : 		{
; 1632 : 			CvUnit *pkLoopUnit = (*itr).GetUnit();
; 1633 : #ifdef AUI_WARNING_FIXES
; 1634 : 			if (!pkLoopUnit)
; 1635 : 				continue;
; 1636 : #endif
; 1637 : 			int iDistance = (*itr).GetDistance();
; 1638 : 
; 1639 : 			int iPathDistance = MAX_INT;
; 1640 : 			// Now loop through the units, using the pathfinder to do the final evaluation
; 1641 : 			if (pkMusterPlot != NULL)

	mov	eax, DWORD PTR _pkMusterPlot$[esp+24]
	mov	edx, DWORD PTR [ebp]
	mov	edi, DWORD PTR [ebp+4]
	mov	DWORD PTR _iDistance$225163[esp+28], edx
	mov	esi, 2147483647				; 7fffffffH
	test	eax, eax
	je	SHORT $LN8@GetClosest

; 1642 : 			{
; 1643 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 1644 : 				if (!kPathFinder.DoesPathExist(pkLoopUnit, pkLoopUnit->plot(), pkMusterPlot))
; 1645 : #else
; 1646 : 				if (!kPathFinder.DoesPathExist(*pkLoopUnit, pkLoopUnit->plot(), pkMusterPlot))

	push	eax
	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	push	edi
	mov	ecx, ebx
	call	?DoesPathExist@CvIgnoreUnitsPathFinder@@QAE_NAAVCvUnit@@PAVCvPlot@@1@Z ; CvIgnoreUnitsPathFinder::DoesPathExist
	test	al, al
	je	SHORT $LN10@GetClosest

; 1647 : #endif
; 1648 : 					continue;
; 1649 : 
; 1650 : 				iPathDistance = kPathFinder.GetPathLength();

	mov	ecx, ebx
	call	?GetPathLength@CvIgnoreUnitsPathFinder@@QAEHXZ ; CvIgnoreUnitsPathFinder::GetPathLength
	mov	esi, eax
$LN8@GetClosest:

; 1651 : 			}
; 1652 : 
; 1653 : 			if(pkTarget != NULL && bNeedToCheckTarget)

	mov	eax, DWORD PTR _pkTarget$[esp+24]
	test	eax, eax
	je	SHORT $LN45@GetClosest
	cmp	BYTE PTR _bNeedToCheckTarget$[esp+24], 0
	je	SHORT $LN45@GetClosest

; 1654 : 			{
; 1655 : #ifdef AUI_ASTAR_MINOR_OPTIMIZATION
; 1656 : 				if (!kPathFinder.DoesPathExist(pkLoopUnit, pkLoopUnit->plot(), pkTarget))
; 1657 : #else
; 1658 : 				if (!kPathFinder.DoesPathExist(*pkLoopUnit, pkLoopUnit->plot(), pkTarget))

	push	eax
	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	push	eax
	push	edi
	mov	ecx, ebx
	call	?DoesPathExist@CvIgnoreUnitsPathFinder@@QAE_NAAVCvUnit@@PAVCvPlot@@1@Z ; CvIgnoreUnitsPathFinder::DoesPathExist
	test	al, al
	je	SHORT $LN10@GetClosest

; 1659 : #endif
; 1660 : 					continue;
; 1661 : 
; 1662 : 				if (pkMusterPlot == NULL)

	cmp	DWORD PTR _pkMusterPlot$[esp+24], 0
	jne	SHORT $LN45@GetClosest

; 1663 : 					iPathDistance = kPathFinder.GetPathLength();

	mov	ecx, ebx
	call	?GetPathLength@CvIgnoreUnitsPathFinder@@QAEHXZ ; CvIgnoreUnitsPathFinder::GetPathLength
	mov	esi, eax
$LN45@GetClosest:

; 1664 : 			}
; 1665 : 
; 1666 : 			// Reasonably close?
; 1667 : 			if (iPathDistance <= iDistance && iPathDistance <= iBestDistance)

	mov	eax, DWORD PTR _iDistance$225163[esp+28]
	cmp	esi, eax
	jg	SHORT $LN48@GetClosest
	cmp	esi, DWORD PTR _iBestDistance$225156[esp+28]
	jle	SHORT $LN39@GetClosest
$LN48@GetClosest:

; 1668 : 			{
; 1669 : 				pkBestUnit = pkLoopUnit;
; 1670 : 				break;
; 1671 : 			}
; 1672 : 
; 1673 : 			if (iPathDistance < iBestDistance)

	cmp	esi, DWORD PTR _iBestDistance$225156[esp+28]
	jge	SHORT $LN49@GetClosest

; 1674 : 			{
; 1675 : 				pkBestUnit = pkLoopUnit;

	mov	DWORD PTR _pkBestUnit$[esp+28], edi

; 1676 : 				iBestDistance = iPathDistance;

	mov	DWORD PTR _iBestDistance$225156[esp+28], esi
$LN49@GetClosest:

; 1677 : 			}
; 1678 : 
; 1679 : 			// Were we far away?  If so, this is probably the best we are going to do
; 1680 : 			if (iDistance >= GC.getAI_HOMELAND_ESTIMATE_TURNS_DISTANCE())

	cmp	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2572
	jge	SHORT $LN42@GetClosest
$LN10@GetClosest:

; 1630 : 		for (CvOperationSearchUnitList::iterator itr = kSearchList.begin(); itr != kSearchList.end(); ++itr)

	mov	eax, DWORD PTR _kSearchList$[esp+24]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax]
	add	ebp, 8
	lea	eax, DWORD PTR [edx+ecx*8]
	cmp	ebp, eax
	jne	$LL47@GetClosest
$LN42@GetClosest:

; 1681 : 				break;
; 1682 : 		}
; 1683 : 	}
; 1684 : 
; 1685 : 	return pkBestUnit;

	mov	eax, DWORD PTR _pkBestUnit$[esp+28]
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi

; 1686 : }

	add	esp, 12					; 0000000cH
	ret	0
$LN39@GetClosest:
	pop	ebp
	pop	ebx

; 1681 : 				break;
; 1682 : 		}
; 1683 : 	}
; 1684 : 
; 1685 : 	return pkBestUnit;

	mov	eax, edi
	pop	edi
	pop	esi

; 1686 : }

	add	esp, 12					; 0000000cH
	ret	0
$LN44@GetClosest:

; 1681 : 				break;
; 1682 : 		}
; 1683 : 	}
; 1684 : 
; 1685 : 	return pkBestUnit;

	mov	eax, edi
	pop	edi
	pop	esi

; 1686 : }

	add	esp, 12					; 0000000cH
	ret	0
?GetClosestUnit@@YAPAVCvUnit@@AAV?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@PAVCvPlot@@1_N@Z ENDP ; GetClosestUnit
_TEXT	ENDS
EXTRN	?CanEverEmbark@CvUnit@@QBE_NXZ:PROC		; CvUnit::CanEverEmbark
EXTRN	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ:PROC ; CvUnit::getDomainType
EXTRN	?GetCurrHitPoints@CvUnit@@QBEHXZ:PROC		; CvUnit::GetCurrHitPoints
EXTRN	?GetMaxHitPoints@CvUnit@@QBEHXZ:PROC		; CvUnit::GetMaxHitPoints
EXTRN	?getDropRange@CvUnit@@QBEHXZ:PROC		; CvUnit::getDropRange
EXTRN	?canRecruitFromTacticalAI@CvUnit@@QBE_NXZ:PROC	; CvUnit::canRecruitFromTacticalAI
EXTRN	?IsRequiresNavalUnitConsistency@CvMultiUnitFormationInfo@@QBE_NXZ:PROC ; CvMultiUnitFormationInfo::IsRequiresNavalUnitConsistency
EXTRN	?canEmbarkAllWaterPassage@CvTeam@@QBE_NXZ:PROC	; CvTeam::canEmbarkAllWaterPassage
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z$1
__ehfuncinfo$?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvaioperation.cpp
xdata$x	ENDS
;	COMDAT ?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
_TEXT	SEGMENT
_bMustBeDeepWaterNaval$225192 = -1113			; size = 1
_pTargetToUse$ = -1112					; size = 4
_iLoop$225193 = -1108					; size = 4
_this$ = -1104						; size = 4
_thisSlotEntry$225191 = -1100				; size = 4
$T251277 = -1096					; size = 8
$T251267 = -1096					; size = 8
_ownerPlayer$ = -1088					; size = 4
_pThisArmy$ = -1084					; size = 4
_strMsg$ = -1080					; size = 28
_kSearchList$ = -1052					; size = 1040
__$EHRec$ = -12						; size = 12
_thisOperationSlot$ = 8					; size = 12
_pMusterPlot$ = 20					; size = 4
_pTargetPlot$ = 24					; size = 4
_bRequired$ = 28					; size = 4
?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z PROC ; CvAIOperation::FindBestFitReserveUnit, COMDAT
; _this$ = ecx

; 1694 : {

	push	-1
	push	__ehhandler$?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 1104				; 00000450H

; 1695 : 	CvUnit* pBestUnit = NULL;
; 1696 : 	CvPlayerAI& ownerPlayer = GET_PLAYER(m_eOwner);
; 1697 : 	CvArmyAI* pThisArmy = ownerPlayer.getArmyAI(thisOperationSlot.m_iArmyID);

	mov	eax, DWORD PTR _thisOperationSlot$[esp+1116]
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	ebp, ecx
	mov	edi, DWORD PTR [ebp+72]
	imul	edi, 63236				; 0000f704H
	add	edi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	eax
	mov	ecx, edi
	mov	DWORD PTR _this$[esp+1136], ebp
	mov	DWORD PTR _ownerPlayer$[esp+1136], edi
	call	?getArmyAI@CvPlayer@@QAEPAVCvArmyAI@@H@Z ; CvPlayer::getArmyAI
	mov	ebx, eax

; 1698 : 	CvString strMsg;

	lea	ecx, DWORD PTR _strMsg$[esp+1132]
	mov	DWORD PTR _pThisArmy$[esp+1132], ebx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1699 : 	CvPlot *pTargetToUse = pTargetPlot;

	mov	esi, DWORD PTR _pTargetPlot$[esp+1128]
	xor	eax, eax

; 1700 : 
; 1701 : 	CvOperationSearchUnitList kSearchList;

	lea	ecx, DWORD PTR _kSearchList$[esp+1144]
	mov	DWORD PTR __$EHRec$[esp+1140], eax
	mov	DWORD PTR _pTargetToUse$[esp+1132], esi
	mov	DWORD PTR _kSearchList$[esp+1136], eax
	mov	DWORD PTR _kSearchList$[esp+1140], 128	; 00000080H
	mov	DWORD PTR _kSearchList$[esp+1132], ecx

; 1702 : 
; 1703 : 	*bRequired = true;

	mov	edx, DWORD PTR _bRequired$[esp+1128]
	mov	BYTE PTR __$EHRec$[esp+1140], 1
	mov	BYTE PTR [edx], 1

; 1704 : 
; 1705 : 	// All naval operation targeting a city?   Change target
; 1706 : 	if (pTargetToUse && !pTargetToUse->isWater() && IsAllNavalOperation())

	cmp	esi, eax
	je	SHORT $LN48@FindBestFi
	cmp	BYTE PTR [esi+5], 3
	je	SHORT $LN48@FindBestFi
	mov	eax, DWORD PTR [ebp]
	mov	edx, DWORD PTR [eax+40]
	mov	ecx, ebp
	call	edx
	test	al, al
	je	SHORT $LN48@FindBestFi

; 1707 : 	{
; 1708 : 		pTargetToUse = ownerPlayer.GetMilitaryAI()->GetCoastalPlotAdjacentToTarget(pTargetToUse, pThisArmy);

	push	ebx
	push	esi
	mov	ecx, edi
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	mov	ecx, eax
	call	?GetCoastalPlotAdjacentToTarget@CvMilitaryAI@@QBEPAVCvPlot@@PAV2@PAVCvArmyAI@@@Z ; CvMilitaryAI::GetCoastalPlotAdjacentToTarget
	mov	DWORD PTR _pTargetToUse$[esp+1132], eax
$LN48@FindBestFi:

; 1709 : 	}
; 1710 : 
; 1711 : 	int iThisFormationIndex = pThisArmy->GetFormationIndex();

	mov	ecx, ebx
	call	?GetFormationIndex@CvArmyAI@@QBEHXZ	; CvArmyAI::GetFormationIndex

; 1712 : 	if(iThisFormationIndex != NO_MUFORMATION)

	cmp	eax, -1
	je	$LN1@FindBestFi

; 1713 : 	{
; 1714 : 		CvMultiUnitFormationInfo* thisFormation = GC.getMultiUnitFormationInfo(iThisFormationIndex);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getMultiUnitFormationInfo@CvGlobals@@QAEPAVCvMultiUnitFormationInfo@@H@Z ; CvGlobals::getMultiUnitFormationInfo
	mov	esi, eax

; 1715 : 		if(thisFormation)

	test	esi, esi
	je	$LN1@FindBestFi

; 1716 : 		{
; 1717 : 			const CvFormationSlotEntry& thisSlotEntry = thisFormation->getFormationSlotEntry(thisOperationSlot.m_iSlotID);

	mov	eax, DWORD PTR _thisOperationSlot$[esp+1136]
	push	eax
	mov	ecx, esi
	call	?getFormationSlotEntry@CvMultiUnitFormationInfo@@QBEABVCvFormationSlotEntry@@H@Z ; CvMultiUnitFormationInfo::getFormationSlotEntry
	mov	DWORD PTR _thisSlotEntry$225191[esp+1132], eax

; 1718 : 			bool bMustBeDeepWaterNaval = GET_TEAM(ownerPlayer.getTeam()).canEmbarkAllWaterPassage() && thisFormation->IsRequiresNavalUnitConsistency();

	mov	eax, DWORD PTR [edi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN90@FindBestFi
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN91@FindBestFi
$LN90@FindBestFi:
	or	eax, -1
$LN91@FindBestFi:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?canEmbarkAllWaterPassage@CvTeam@@QBE_NXZ ; CvTeam::canEmbarkAllWaterPassage
	test	al, al
	je	SHORT $LN51@FindBestFi
	mov	ecx, esi
	call	?IsRequiresNavalUnitConsistency@CvMultiUnitFormationInfo@@QBE_NXZ ; CvMultiUnitFormationInfo::IsRequiresNavalUnitConsistency
	mov	BYTE PTR _bMustBeDeepWaterNaval$225192[esp+1132], 1
	test	al, al
	jne	SHORT $LN52@FindBestFi
$LN51@FindBestFi:
	mov	BYTE PTR _bMustBeDeepWaterNaval$225192[esp+1132], 0
$LN52@FindBestFi:

; 1719 : 
; 1720 : 			int iLoop = 0;
; 1721 : 			for(CvUnit* pLoopUnit = ownerPlayer.firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = ownerPlayer.nextUnit(&iLoop))

	push	0
	lea	eax, DWORD PTR _iLoop$225193[esp+1136]
	push	eax
	mov	ecx, edi
	mov	DWORD PTR _iLoop$225193[esp+1140], 0
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	ebx, DWORD PTR _pMusterPlot$[esp+1128]
	mov	esi, eax
	test	esi, esi
	je	$LN270@FindBestFi
$LL268@FindBestFi:

; 1722 : 			{
; 1723 : 				const UnitAITypes eLoopUnitAIType = pLoopUnit->AI_getUnitAIType();

	mov	ecx, esi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType

; 1724 : 
; 1725 : 				// Make sure he's not needed by the tactical AI or already in an army or scouting
; 1726 : 				if(pLoopUnit->canRecruitFromTacticalAI() && pLoopUnit->getArmyID() == FFreeList::INVALID_INDEX &&
; 1727 : 				        eLoopUnitAIType != UNITAI_EXPLORE && eLoopUnitAIType != UNITAI_EXPLORE_SEA && pLoopUnit->getDropRange() == 0 /* no paratroopers */)

	mov	ecx, esi
	mov	edi, eax
	call	?canRecruitFromTacticalAI@CvUnit@@QBE_NXZ ; CvUnit::canRecruitFromTacticalAI
	test	al, al
	je	$LN44@FindBestFi
	mov	ecx, esi
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	cmp	eax, -1
	jne	$LN44@FindBestFi
	cmp	edi, 10					; 0000000aH
	je	$LN44@FindBestFi
	cmp	edi, 21					; 00000015H
	je	$LN44@FindBestFi
	mov	ecx, esi
	call	?getDropRange@CvUnit@@QBEHXZ		; CvUnit::getDropRange
	test	eax, eax
	jne	$LN44@FindBestFi

; 1728 : 				{
; 1729 : 					// Is this unit one of the requested types?
; 1730 : 					CvUnitEntry* unitInfo = GC.getUnitInfo(pLoopUnit->getUnitType());

	mov	ecx, esi
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo

; 1731 : 					if(unitInfo == NULL)

	test	eax, eax
	je	$LN44@FindBestFi

; 1732 : 						continue;
; 1733 : 
; 1734 : 					// PRIMARY UNIT TYPE (ONLY)
; 1735 : 
; 1736 : 					if(unitInfo->GetUnitAIType((UnitAITypes)thisSlotEntry.m_primaryUnitType))

	mov	ecx, DWORD PTR _thisSlotEntry$225191[esp+1132]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, eax
	call	?GetUnitAIType@CvUnitEntry@@QBE_NH@Z	; CvUnitEntry::GetUnitAIType
	test	al, al
	je	$LN44@FindBestFi

; 1737 : 					{
; 1738 : 						// Is his health okay?
; 1739 : 						if(!pLoopUnit->IsCombatUnit() || pLoopUnit->GetCurrHitPoints() >= pLoopUnit->GetMaxHitPoints() * GC.getAI_OPERATIONAL_PERCENT_HEALTH_FOR_OPERATION() / 100)

	cmp	DWORD PTR [esi+1044], 0
	jle	SHORT $LN38@FindBestFi
	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2436
	mov	ecx, esi
	call	?GetMaxHitPoints@CvUnit@@QBEHXZ		; CvUnit::GetMaxHitPoints
	mov	ecx, eax
	imul	ecx, edi
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	mov	ecx, esi
	add	edi, edx
	call	?GetCurrHitPoints@CvUnit@@QBEHXZ	; CvUnit::GetCurrHitPoints
	cmp	eax, edi
	jl	$LN44@FindBestFi
$LN38@FindBestFi:

; 1740 : 						{
; 1741 : 							// Not finishing up an operation?
; 1742 : 							if(pLoopUnit->GetDeployFromOperationTurn() + GC.getAI_TACTICAL_MAP_TEMP_ZONE_TURNS() < GC.getGame().getGameTurn())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	edi, DWORD PTR [esi+124]
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2452
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	add	ebp, edi
	cmp	ebp, eax
	jge	$LN44@FindBestFi

; 1743 : 							{
; 1744 : 								if((!IsAllNavalOperation() && !IsMixedLandNavalOperation()) || pLoopUnit->getDomainType() == DOMAIN_SEA || pLoopUnit->CanEverEmbark())

	mov	edi, DWORD PTR _this$[esp+1132]
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+40]
	mov	ecx, edi
	call	edx
	test	al, al
	jne	SHORT $LN34@FindBestFi
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+44]
	mov	ecx, edi
	call	edx
	test	al, al
	je	SHORT $LN35@FindBestFi
$LN34@FindBestFi:
	mov	ecx, esi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	je	SHORT $LN35@FindBestFi
	mov	ecx, esi
	call	?CanEverEmbark@CvUnit@@QBE_NXZ		; CvUnit::CanEverEmbark
	test	al, al
	je	$LN44@FindBestFi
$LN35@FindBestFi:

; 1745 : 								{
; 1746 : 									if (!bMustBeDeepWaterNaval || pLoopUnit->getDomainType() != DOMAIN_SEA || !pLoopUnit->isTerrainImpassable(TERRAIN_OCEAN))

	cmp	BYTE PTR _bMustBeDeepWaterNaval$225192[esp+1132], 0
	je	SHORT $LN32@FindBestFi
	mov	ecx, esi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	jne	SHORT $LN32@FindBestFi
	mov	eax, DWORD PTR [esi+1996]
	cmp	DWORD PTR [eax+24], 0
	jg	$LN44@FindBestFi
$LN32@FindBestFi:

; 1747 : 									{
; 1748 : 										// Get raw distance to the muster point or target
; 1749 : 										CvPlot* pkLoopUnitPlot = pLoopUnit->plot();

	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	edi, eax

; 1750 : 										int iDistance;
; 1751 : 										if(pMusterPlot != NULL)

	test	ebx, ebx
	je	SHORT $LN31@FindBestFi

; 1752 : 										{
; 1753 : 											iDistance = plotDistance(pkLoopUnitPlot->getX(), pkLoopUnitPlot->getY(), pMusterPlot->getX(), pMusterPlot->getY());

	movsx	ecx, WORD PTR [ebx+2]
	movsx	edx, WORD PTR [ebx]
	movsx	eax, WORD PTR [edi+2]
	push	ecx
	movsx	ecx, WORD PTR [edi]
	push	edx
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H

; 1754 : 											// Double the distance if this is a land unit on a different landmass (it's dangerous to go over water!)
; 1755 : 											if(pMusterPlot != NULL && pLoopUnit->getDomainType() == DOMAIN_LAND && pkLoopUnitPlot->getArea() != pMusterPlot->getArea())

	mov	ecx, esi
	mov	ebp, eax
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	SHORT $LN27@FindBestFi
	mov	edi, DWORD PTR [edi+356]
	cmp	edi, DWORD PTR [ebx+356]
	je	SHORT $LN27@FindBestFi

; 1756 : 											{
; 1757 : 												iDistance *= 2;

	add	ebp, ebp

; 1758 : 											}
; 1759 : 										}
; 1760 : 										else

	jmp	SHORT $LN27@FindBestFi
$LN31@FindBestFi:

; 1761 : 										{
; 1762 : 											if (pTargetToUse != NULL)

	cmp	DWORD PTR _pTargetToUse$[esp+1132], 0
	je	SHORT $LN28@FindBestFi

; 1763 : 												iDistance = plotDistance(pkLoopUnitPlot->getX(), pkLoopUnitPlot->getY(), pTargetToUse->getX(), pTargetToUse->getY());

	mov	eax, DWORD PTR _pTargetToUse$[esp+1132]
	movsx	edx, WORD PTR [eax+2]
	movsx	eax, WORD PTR [eax]
	movsx	ecx, WORD PTR [edi+2]
	push	edx
	movsx	edx, WORD PTR [edi]
	push	eax
	push	ecx
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	ebp, eax

; 1764 : 											else

	jmp	SHORT $LN27@FindBestFi
$LN28@FindBestFi:

; 1765 : 											{
; 1766 : 												CvAssertMsg(0, "No muster or target!");
; 1767 : 												iDistance = MAX_INT;

	mov	ebp, 2147483647				; 7fffffffH
$LN27@FindBestFi:

; 1768 : 											}
; 1769 : 										}
; 1770 : 
; 1771 : 										kSearchList.push_back(CvOperationSearchUnit(pLoopUnit, iDistance));

	lea	eax, DWORD PTR $T251267[esp+1132]
	push	eax
	lea	ecx, DWORD PTR _kSearchList$[esp+1136]
	mov	DWORD PTR $T251267[esp+1140], esi
	mov	DWORD PTR $T251267[esp+1136], ebp
	call	?push_back@?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAEIABVCvOperationSearchUnit@@@Z ; FStaticVector<CvOperationSearchUnit,128,1,297,0>::push_back
$LN44@FindBestFi:
	mov	edi, DWORD PTR _ownerPlayer$[esp+1132]
	push	0
	lea	ecx, DWORD PTR _iLoop$225193[esp+1136]
	push	ecx
	mov	ecx, edi
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	esi, eax
	test	esi, esi
	jne	$LL268@FindBestFi

; 1719 : 
; 1720 : 			int iLoop = 0;
; 1721 : 			for(CvUnit* pLoopUnit = ownerPlayer.firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = ownerPlayer.nextUnit(&iLoop))

	mov	ebp, DWORD PTR _this$[esp+1132]
$LN270@FindBestFi:

; 1772 : 									}
; 1773 : 								}
; 1774 : 							}
; 1775 : 						}
; 1776 : 					}
; 1777 : 				}
; 1778 : 			}
; 1779 : 
; 1780 : 			pBestUnit = GetClosestUnit(kSearchList, pMusterPlot, pTargetToUse, NeedToCheckPathToTarget());

	mov	edx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, ebp
	call	eax
	mov	esi, DWORD PTR _pTargetToUse$[esp+1132]
	movzx	ecx, al
	push	ecx
	push	esi
	lea	edx, DWORD PTR _kSearchList$[esp+1140]
	push	ebx
	push	edx
	call	?GetClosestUnit@@YAPAVCvUnit@@AAV?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@PAVCvPlot@@1_N@Z ; GetClosestUnit
	add	esp, 16					; 00000010H

; 1781 : 
; 1782 : 			// Did we find one?
; 1783 : 			if(pBestUnit != NULL)

	test	eax, eax
	je	SHORT $LN26@FindBestFi

; 1784 : 			{
; 1785 : 				pThisArmy->AddUnit(pBestUnit->GetID(), thisOperationSlot.m_iSlotID);

	mov	ecx, DWORD PTR _thisOperationSlot$[esp+1136]
	mov	eax, DWORD PTR [eax+100]
	push	ecx
	mov	ecx, DWORD PTR _pThisArmy$[esp+1136]
	push	eax
	call	?AddUnit@CvArmyAI@@QAEXHH@Z		; CvArmyAI::AddUnit

; 1786 : 				return true;

	mov	eax, DWORD PTR _kSearchList$[esp+1132]
	lea	edx, DWORD PTR _kSearchList$[esp+1144]
	mov	BYTE PTR __$EHRec$[esp+1140], 0
	cmp	eax, edx
	je	SHORT $LN145@FindBestFi
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN145@FindBestFi:
	lea	ecx, DWORD PTR _strMsg$[esp+1132]
	mov	DWORD PTR __$EHRec$[esp+1140], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, 1
	jmp	$LN49@FindBestFi
$LN26@FindBestFi:

; 1787 : 			}
; 1788 : 			else
; 1789 : 			{
; 1790 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN24@FindBestFi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN24@FindBestFi

; 1791 : 				{
; 1792 : 					strMsg.Format("Could not recruit from primary units for muster at x=%d y=%d, target of x=%d y=%d", (pMusterPlot)?pMusterPlot->getX():-1, (pMusterPlot)?pMusterPlot->getY():-1, (pTargetToUse)?pTargetToUse->getX():-1, (pTargetToUse)?pTargetToUse->getY():-1);

	test	esi, esi
	je	SHORT $LN53@FindBestFi
	mov	eax, DWORD PTR _pTargetToUse$[esp+1132]
	movsx	esi, WORD PTR [eax+2]
	movsx	edx, WORD PTR [eax]
	jmp	SHORT $LN56@FindBestFi
$LN53@FindBestFi:
	or	esi, -1
	or	edx, esi
$LN56@FindBestFi:
	test	ebx, ebx
	je	SHORT $LN57@FindBestFi
	movsx	ecx, WORD PTR [ebx+2]
	movsx	eax, WORD PTR [ebx]
	jmp	SHORT $LN60@FindBestFi
$LN57@FindBestFi:
	or	ecx, -1
	or	eax, ecx
$LN60@FindBestFi:
	push	esi
	push	edx
	push	ecx
	push	eax
	lea	eax, DWORD PTR _strMsg$[esp+1148]
	push	OFFSET $SG225224
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 24					; 00000018H

; 1793 : 					LogOperationSpecialMessage(strMsg);

	lea	ecx, DWORD PTR _strMsg$[esp+1132]
	push	ecx
	mov	ecx, ebp
	call	?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z ; CvAIOperation::LogOperationSpecialMessage
$LN24@FindBestFi:

; 1794 : 				}
; 1795 : 			}
; 1796 : 
; 1797 : 			kSearchList.clear();
; 1798 : 			// Loop again this time through secondary units
; 1799 : 			for(CvUnit* pLoopUnit = ownerPlayer.firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = ownerPlayer.nextUnit(&iLoop))

	push	0
	lea	edx, DWORD PTR _iLoop$225193[esp+1136]
	push	edx
	mov	ecx, edi
	mov	DWORD PTR _kSearchList$[esp+1144], 0
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	esi, eax
	test	esi, esi
	je	$LN271@FindBestFi
$LL269@FindBestFi:

; 1800 : 			{
; 1801 : 				const UnitAITypes eLoopUnitAIType = pLoopUnit->AI_getUnitAIType();

	mov	ecx, esi
	call	?AI_getUnitAIType@CvUnit@@QBE?AW4UnitAITypes@@XZ ; CvUnit::AI_getUnitAIType

; 1802 : 
; 1803 : 				// Make sure he's not needed by the tactical AI or already in an army or scouting
; 1804 : 				if(pLoopUnit->canRecruitFromTacticalAI() && pLoopUnit->getArmyID() == FFreeList::INVALID_INDEX &&
; 1805 : 				        eLoopUnitAIType != UNITAI_EXPLORE && eLoopUnitAIType != UNITAI_EXPLORE_SEA && pLoopUnit->getDropRange() == 0 /* no paratroopers */)

	mov	ecx, esi
	mov	edi, eax
	call	?canRecruitFromTacticalAI@CvUnit@@QBE_NXZ ; CvUnit::canRecruitFromTacticalAI
	test	al, al
	je	$LN22@FindBestFi
	mov	ecx, esi
	call	?getArmyID@CvUnit@@QBEHXZ		; CvUnit::getArmyID
	cmp	eax, -1
	jne	$LN22@FindBestFi
	cmp	edi, 10					; 0000000aH
	je	$LN22@FindBestFi
	cmp	edi, 21					; 00000015H
	je	$LN22@FindBestFi
	mov	ecx, esi
	call	?getDropRange@CvUnit@@QBEHXZ		; CvUnit::getDropRange
	test	eax, eax
	jne	$LN22@FindBestFi

; 1806 : 				{
; 1807 : 					// Is this unit one of the requested types?
; 1808 : 					CvUnitEntry* unitInfo = GC.getUnitInfo(pLoopUnit->getUnitType());

	mov	ecx, esi
	call	?getUnitType@CvUnit@@QBE?BW4UnitTypes@@XZ ; CvUnit::getUnitType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo

; 1809 : 					if(unitInfo == NULL)

	test	eax, eax
	je	$LN22@FindBestFi

; 1810 : 						continue;
; 1811 : 
; 1812 : 					// SECONDARY UNIT TYPE (ONLY)
; 1813 : 
; 1814 : 					if(unitInfo->GetUnitAIType((UnitAITypes)thisSlotEntry.m_secondaryUnitType))

	mov	ecx, DWORD PTR _thisSlotEntry$225191[esp+1132]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, eax
	call	?GetUnitAIType@CvUnitEntry@@QBE_NH@Z	; CvUnitEntry::GetUnitAIType
	test	al, al
	je	$LN22@FindBestFi

; 1815 : 					{
; 1816 : 						// Is his health okay?
; 1817 : 						if(!pLoopUnit->IsCombatUnit() || pLoopUnit->GetCurrHitPoints() >= pLoopUnit->GetMaxHitPoints() * GC.getAI_OPERATIONAL_PERCENT_HEALTH_FOR_OPERATION() / 100)

	cmp	DWORD PTR [esi+1044], 0
	jle	SHORT $LN16@FindBestFi
	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2436
	mov	ecx, esi
	call	?GetMaxHitPoints@CvUnit@@QBEHXZ		; CvUnit::GetMaxHitPoints
	mov	ecx, eax
	imul	ecx, edi
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	mov	ecx, esi
	add	edi, edx
	call	?GetCurrHitPoints@CvUnit@@QBEHXZ	; CvUnit::GetCurrHitPoints
	cmp	eax, edi
	jl	$LN22@FindBestFi
$LN16@FindBestFi:

; 1818 : 						{
; 1819 : 							// Not finishing up an operation?
; 1820 : 							if(pLoopUnit->GetDeployFromOperationTurn() + GC.getAI_TACTICAL_MAP_TEMP_ZONE_TURNS() < GC.getGame().getGameTurn())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	edi, DWORD PTR [esi+124]
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2452
	call	?getGameTurn@CvGame@@QAEHXZ		; CvGame::getGameTurn
	add	ebp, edi
	cmp	ebp, eax
	jge	$LN22@FindBestFi

; 1821 : 							{
; 1822 : 								if((!IsAllNavalOperation() && !IsMixedLandNavalOperation()) || pLoopUnit->getDomainType() == DOMAIN_SEA || pLoopUnit->CanEverEmbark())

	mov	edi, DWORD PTR _this$[esp+1132]
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+40]
	mov	ecx, edi
	call	edx
	test	al, al
	jne	SHORT $LN12@FindBestFi
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+44]
	mov	ecx, edi
	call	edx
	test	al, al
	je	SHORT $LN13@FindBestFi
$LN12@FindBestFi:
	mov	ecx, esi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	je	SHORT $LN13@FindBestFi
	mov	ecx, esi
	call	?CanEverEmbark@CvUnit@@QBE_NXZ		; CvUnit::CanEverEmbark
	test	al, al
	je	$LN22@FindBestFi
$LN13@FindBestFi:

; 1823 : 								{
; 1824 : 									if (!bMustBeDeepWaterNaval || pLoopUnit->getDomainType() != DOMAIN_SEA || !pLoopUnit->isTerrainImpassable(TERRAIN_OCEAN))

	cmp	BYTE PTR _bMustBeDeepWaterNaval$225192[esp+1132], 0
	je	SHORT $LN10@FindBestFi
	mov	ecx, esi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	test	eax, eax
	jne	SHORT $LN10@FindBestFi
	mov	eax, DWORD PTR [esi+1996]
	cmp	DWORD PTR [eax+24], 0
	jg	$LN22@FindBestFi
$LN10@FindBestFi:

; 1825 : 									{
; 1826 : 										// Get raw distance to the muster point or target
; 1827 : 										CvPlot* pkLoopUnitPlot = pLoopUnit->plot();

	mov	ecx, esi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	mov	edi, eax

; 1828 : 										int iDistance;
; 1829 : 										if(pMusterPlot != NULL)

	test	ebx, ebx
	je	SHORT $LN9@FindBestFi

; 1830 : 										{
; 1831 : 											iDistance = plotDistance(pkLoopUnitPlot->getX(), pkLoopUnitPlot->getY(), pMusterPlot->getX(), pMusterPlot->getY());

	movsx	ecx, WORD PTR [ebx+2]
	movsx	edx, WORD PTR [ebx]
	movsx	eax, WORD PTR [edi+2]
	push	ecx
	movsx	ecx, WORD PTR [edi]
	push	edx
	push	eax
	push	ecx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H

; 1832 : 											// Double the distance if this is a land unit on a different landmass (it's dangerous to go over water!)
; 1833 : 											if(pMusterPlot != NULL && pLoopUnit->getDomainType() == DOMAIN_LAND && pkLoopUnitPlot->getArea() != pMusterPlot->getArea())

	mov	ecx, esi
	mov	ebp, eax
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	cmp	eax, 2
	jne	SHORT $LN5@FindBestFi
	mov	edi, DWORD PTR [edi+356]
	cmp	edi, DWORD PTR [ebx+356]
	je	SHORT $LN5@FindBestFi

; 1834 : 											{
; 1835 : 												iDistance *= 2;

	add	ebp, ebp

; 1836 : 											}
; 1837 : 										}
; 1838 : 										else

	jmp	SHORT $LN5@FindBestFi
$LN9@FindBestFi:

; 1839 : 										{
; 1840 : 											if (pTargetToUse != NULL)

	cmp	DWORD PTR _pTargetToUse$[esp+1132], 0
	je	SHORT $LN6@FindBestFi

; 1841 : 												iDistance = plotDistance(pkLoopUnitPlot->getX(), pkLoopUnitPlot->getY(), pTargetToUse->getX(), pTargetToUse->getY());

	mov	eax, DWORD PTR _pTargetToUse$[esp+1132]
	movsx	edx, WORD PTR [eax+2]
	movsx	eax, WORD PTR [eax]
	movsx	ecx, WORD PTR [edi+2]
	push	edx
	movsx	edx, WORD PTR [edi]
	push	eax
	push	ecx
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	mov	ebp, eax

; 1842 : 											else

	jmp	SHORT $LN5@FindBestFi
$LN6@FindBestFi:

; 1843 : 											{
; 1844 : 												CvAssertMsg(0, "No muster or target!");
; 1845 : 												iDistance = MAX_INT;

	mov	ebp, 2147483647				; 7fffffffH
$LN5@FindBestFi:

; 1846 : 											}
; 1847 : 										}
; 1848 : 
; 1849 : 										kSearchList.push_back(CvOperationSearchUnit(pLoopUnit, iDistance));

	lea	eax, DWORD PTR $T251277[esp+1132]
	push	eax
	lea	ecx, DWORD PTR _kSearchList$[esp+1136]
	mov	DWORD PTR $T251277[esp+1140], esi
	mov	DWORD PTR $T251277[esp+1136], ebp
	call	?push_back@?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAEIABVCvOperationSearchUnit@@@Z ; FStaticVector<CvOperationSearchUnit,128,1,297,0>::push_back
$LN22@FindBestFi:
	push	0
	lea	ecx, DWORD PTR _iLoop$225193[esp+1136]
	push	ecx
	mov	ecx, DWORD PTR _ownerPlayer$[esp+1140]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	esi, eax
	test	esi, esi
	jne	$LL269@FindBestFi

; 1794 : 				}
; 1795 : 			}
; 1796 : 
; 1797 : 			kSearchList.clear();
; 1798 : 			// Loop again this time through secondary units
; 1799 : 			for(CvUnit* pLoopUnit = ownerPlayer.firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = ownerPlayer.nextUnit(&iLoop))

	mov	ebp, DWORD PTR _this$[esp+1132]
$LN271@FindBestFi:

; 1850 : 									}
; 1851 : 								}
; 1852 : 							}
; 1853 : 						}
; 1854 : 					}
; 1855 : 				}
; 1856 : 			}
; 1857 : 
; 1858 : 			pBestUnit = GetClosestUnit(kSearchList, pMusterPlot, pTargetToUse, NeedToCheckPathToTarget());

	mov	edx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	edi, DWORD PTR _pTargetToUse$[esp+1132]
	mov	ecx, ebp
	call	eax
	movzx	ecx, al
	push	ecx
	push	edi
	lea	edx, DWORD PTR _kSearchList$[esp+1140]
	push	ebx
	push	edx
	call	?GetClosestUnit@@YAPAVCvUnit@@AAV?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@PAVCvPlot@@1_N@Z ; GetClosestUnit
	add	esp, 16					; 00000010H

; 1859 : 
; 1860 : 			// Did we find one?
; 1861 : 			if(pBestUnit != NULL)

	test	eax, eax
	je	SHORT $LN4@FindBestFi

; 1862 : 			{
; 1863 : 				pThisArmy->AddUnit(pBestUnit->GetID(), thisOperationSlot.m_iSlotID);

	mov	ecx, DWORD PTR _thisOperationSlot$[esp+1136]
	mov	eax, DWORD PTR [eax+100]
	push	ecx
	mov	ecx, DWORD PTR _pThisArmy$[esp+1136]
	push	eax
	call	?AddUnit@CvArmyAI@@QAEXHH@Z		; CvArmyAI::AddUnit

; 1864 : 				return true;

	mov	eax, DWORD PTR _kSearchList$[esp+1132]
	lea	edx, DWORD PTR _kSearchList$[esp+1144]
	mov	BYTE PTR __$EHRec$[esp+1140], 0
	cmp	eax, edx
	je	SHORT $LN224@FindBestFi
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN224@FindBestFi:
	lea	ecx, DWORD PTR _strMsg$[esp+1132]
	mov	DWORD PTR __$EHRec$[esp+1140], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, 1
	jmp	$LN49@FindBestFi
$LN4@FindBestFi:

; 1865 : 			}
; 1866 : 			else
; 1867 : 			{
; 1868 : 				if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	SHORT $LN2@FindBestFi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	SHORT $LN2@FindBestFi

; 1869 : 				{
; 1870 : 					strMsg.Format("Could not recruit from secondary units for muster at x=%d y=%d, target of x=%d y=%d", (pMusterPlot)?pMusterPlot->getX():-1, (pMusterPlot)?pMusterPlot->getY():-1, (pTargetToUse)?pTargetToUse->getX():-1, (pTargetToUse)?pTargetToUse->getY():-1);

	test	edi, edi
	je	SHORT $LN61@FindBestFi
	movsx	esi, WORD PTR [edi+2]
	movsx	edx, WORD PTR [edi]
	jmp	SHORT $LN64@FindBestFi
$LN61@FindBestFi:
	or	esi, -1
	or	edx, esi
$LN64@FindBestFi:
	test	ebx, ebx
	je	SHORT $LN65@FindBestFi
	movsx	ecx, WORD PTR [ebx+2]
	movsx	eax, WORD PTR [ebx]
	jmp	SHORT $LN68@FindBestFi
$LN65@FindBestFi:
	or	ecx, -1
	or	eax, ecx
$LN68@FindBestFi:
	push	esi
	push	edx
	push	ecx
	push	eax
	lea	eax, DWORD PTR _strMsg$[esp+1148]
	push	OFFSET $SG225255
	push	eax
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format
	add	esp, 24					; 00000018H

; 1871 : 					LogOperationSpecialMessage(strMsg);

	lea	ecx, DWORD PTR _strMsg$[esp+1132]
	push	ecx
	mov	ecx, ebp
	call	?LogOperationSpecialMessage@CvAIOperation@@QAEXABVCvString@@@Z ; CvAIOperation::LogOperationSpecialMessage
$LN2@FindBestFi:

; 1872 : 				}
; 1873 : 			}
; 1874 : 
; 1875 : 			// If not required, let our calling routine know that
; 1876 : 			if(!thisSlotEntry.m_requiredSlot)

	mov	edx, DWORD PTR _thisSlotEntry$225191[esp+1132]
	cmp	BYTE PTR [edx+12], 0
	jne	SHORT $LN1@FindBestFi

; 1877 : 			{
; 1878 : 				*bRequired = false;

	mov	eax, DWORD PTR _bRequired$[esp+1128]
	mov	BYTE PTR [eax], 0
$LN1@FindBestFi:

; 1879 : 			}
; 1880 : 		}
; 1881 : 	}
; 1882 : 
; 1883 : 	return false;

	mov	eax, DWORD PTR _kSearchList$[esp+1132]
	lea	ecx, DWORD PTR _kSearchList$[esp+1144]
	mov	BYTE PTR __$EHRec$[esp+1140], 0
	cmp	eax, ecx
	je	SHORT $LN249@FindBestFi
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN249@FindBestFi:
	lea	ecx, DWORD PTR _strMsg$[esp+1132]
	mov	DWORD PTR __$EHRec$[esp+1140], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	xor	al, al
$LN49@FindBestFi:

; 1884 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+1132]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 1116				; 0000045cH
	ret	24					; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z$0:
	lea	ecx, DWORD PTR _strMsg$[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z$1:
	lea	ecx, DWORD PTR _kSearchList$[ebp]
	jmp	??1?$FStaticVector@VCvOperationSearchUnit@@$0IA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<CvOperationSearchUnit,128,1,297,0>::~FStaticVector<CvOperationSearchUnit,128,1,297,0>
__ehhandler$?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?FindBestFitReserveUnit@CvAIOperation@@MAE_NUOperationSlot@@PAVCvPlot@@1PA_N@Z ENDP ; CvAIOperation::FindBestFitReserveUnit
END
