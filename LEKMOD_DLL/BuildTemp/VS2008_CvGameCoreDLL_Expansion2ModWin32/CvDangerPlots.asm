; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	s:\Github\Lekmod\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvDangerPlots.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?NO_QUEST_DATA@CvMinorCivQuest@@2HB		; CvMinorCivQuest::NO_QUEST_DATA
PUBLIC	?NO_TURN@CvMinorCivQuest@@2HB			; CvMinorCivQuest::NO_TURN
;	COMDAT ?NO_TURN@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_TURN@CvMinorCivQuest@@2HB DD 0ffffffffH		; CvMinorCivQuest::NO_TURN
CONST	ENDS
;	COMDAT ?NO_QUEST_DATA@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_QUEST_DATA@CvMinorCivQuest@@2HB DD 0ffffffffH	; CvMinorCivQuest::NO_QUEST_DATA
CONST	ENDS
PUBLIC	?xToHexspaceX@@YAHHH@Z				; xToHexspaceX
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?xToHexspaceX@@YAHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?xToHexspaceX@@YAHHH@Z PROC				; xToHexspaceX, COMDAT

; 86   : 	return iX - ((iY >= 0) ? (iY>>1) : ((iY - 1)/2));

	mov	ecx, DWORD PTR _iY$[esp-4]
	test	ecx, ecx
	jge	SHORT $LN5@xToHexspac
	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
	mov	ecx, eax
$LN5@xToHexspac:
	mov	eax, DWORD PTR _iX$[esp-4]
	sar	ecx, 1
	sub	eax, ecx

; 87   : }

	ret	0
?xToHexspaceX@@YAHHH@Z ENDP				; xToHexspaceX
_TEXT	ENDS
PUBLIC	?hexspaceXToX@@YAHHH@Z				; hexspaceXToX
; Function compile flags: /Ogtpy
;	COMDAT ?hexspaceXToX@@YAHHH@Z
_TEXT	SEGMENT
_iHexspaceX$ = 8					; size = 4
_iHexspaceY$ = 12					; size = 4
?hexspaceXToX@@YAHHH@Z PROC				; hexspaceXToX, COMDAT

; 91   : 	return iHexspaceX + ((iHexspaceY >= 0) ? (iHexspaceY>>1) : ((iHexspaceY - 1)/2));

	mov	eax, DWORD PTR _iHexspaceY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@hexspaceXT
	mov	ecx, DWORD PTR _iHexspaceX$[esp-4]
	sar	eax, 1
	add	eax, ecx

; 92   : }

	ret	0
$LN3@hexspaceXT:

; 91   : 	return iHexspaceX + ((iHexspaceY >= 0) ? (iHexspaceY>>1) : ((iHexspaceY - 1)/2));

	dec	eax
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _iHexspaceX$[esp-4]
	sar	eax, 1
	add	eax, edx

; 92   : }

	ret	0
?hexspaceXToX@@YAHHH@Z ENDP				; hexspaceXToX
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[esp-4]

; 60   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	?SetDirty@CvDangerPlots@@QAEXXZ			; CvDangerPlots::SetDirty
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvdangerplots.cpp
;	COMDAT ?SetDirty@CvDangerPlots@@QAEXXZ
_TEXT	SEGMENT
?SetDirty@CvDangerPlots@@QAEXXZ PROC			; CvDangerPlots::SetDirty, COMDAT
; _this$ = ecx

; 853  : 	m_bDirty = true;

	mov	BYTE PTR [ecx+5], 1

; 854  : }

	ret	0
?SetDirty@CvDangerPlots@@QAEXXZ ENDP			; CvDangerPlots::SetDirty
_TEXT	ENDS
PUBLIC	??A?$BaseVector@I$00@@QAEAAII@Z			; BaseVector<unsigned int,1>::operator[]
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@I$00@@QAEAAII@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@I$00@@QAEAAII@Z PROC			; BaseVector<unsigned int,1>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 131  : 	};

	ret	4
??A?$BaseVector@I$00@@QAEAAII@Z ENDP			; BaseVector<unsigned int,1>::operator[]
_TEXT	ENDS
PUBLIC	??A?$BaseVector@I$00@@QBEABII@Z			; BaseVector<unsigned int,1>::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$BaseVector@I$00@@QBEABII@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@I$00@@QBEABII@Z PROC			; BaseVector<unsigned int,1>::operator[], COMDAT
; _this$ = ecx

; 135  : 		FAssert(ui < m_uiCurrSize);
; 136  : 		return m_pData[ui];

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ui$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 137  : 	};

	ret	4
??A?$BaseVector@I$00@@QBEABII@Z ENDP			; BaseVector<unsigned int,1>::operator[]
_TEXT	ENDS
PUBLIC	??1?$BaseVector@I$00@@QAE@XZ			; BaseVector<unsigned int,1>::~BaseVector<unsigned int,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@I$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@I$00@@QAE@XZ PROC			; BaseVector<unsigned int,1>::~BaseVector<unsigned int,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@I$00@@QAE@XZ ENDP			; BaseVector<unsigned int,1>::~BaseVector<unsigned int,1>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@I$00@@IAE@XZ			; BaseVector<unsigned int,1>::BaseVector<unsigned int,1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@I$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@I$00@@IAE@XZ PROC			; BaseVector<unsigned int,1>::BaseVector<unsigned int,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@I$00@@IAE@XZ ENDP			; BaseVector<unsigned int,1>::BaseVector<unsigned int,1>
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@I$00@@IAEXPAII@Z		; BaseVector<unsigned int,1>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@I$00@@IAEXPAII@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@I$00@@IAEXPAII@Z PROC		; BaseVector<unsigned int,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@I$00@@IAEXPAII@Z ENDP		; BaseVector<unsigned int,1>::Destroy
_TEXT	ENDS
PUBLIC	??_C@_0EG@NKCAPKNA@s?3?2github?2lekmod?2lekmod_dll?2fire@ ; `string'
PUBLIC	?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@I$00@@SAPAXIIII@Z ; BaseVector<unsigned int,1>::FDefaultFastVectorAllocator::AllocAligned
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0EG@NKCAPKNA@s?3?2github?2lekmod?2lekmod_dll?2fire@
CONST	SEGMENT
??_C@_0EG@NKCAPKNA@s?3?2github?2lekmod?2lekmod_dll?2fire@ DB 's:\github\l'
	DB	'ekmod\lekmod_dll\fireplace\include\fireworks\FFastVector.h', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@I$00@@SAPAXIIII@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
_nAlign$ = 12						; size = 4
_nAllocPool$ = 16					; size = 4
_nAllocSubID$ = 20					; size = 4
?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@I$00@@SAPAXIIII@Z PROC ; BaseVector<unsigned int,1>::FDefaultFastVectorAllocator::AllocAligned, COMDAT

; 85   : 			return FMALLOCALIGNED( nBytes, nAlign, nAllocPool, nAllocSubID );

	mov	DWORD PTR _nAllocSubID$[esp-4], 85	; 00000055H
	mov	DWORD PTR _nAllocPool$[esp-4], OFFSET ??_C@_0EG@NKCAPKNA@s?3?2github?2lekmod?2lekmod_dll?2fire@
	jmp	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
?AllocAligned@FDefaultFastVectorAllocator@?$BaseVector@I$00@@SAPAXIIII@Z ENDP ; BaseVector<unsigned int,1>::FDefaultFastVectorAllocator::AllocAligned
_TEXT	ENDS
PUBLIC	?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@I$00@@SAXPAX@Z ; BaseVector<unsigned int,1>::FDefaultFastVectorAllocator::FreeAligned
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
; Function compile flags: /Ogtpy
;	COMDAT ?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@I$00@@SAXPAX@Z
_TEXT	SEGMENT
_pBlock$ = 8						; size = 4
?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@I$00@@SAXPAX@Z PROC ; BaseVector<unsigned int,1>::FDefaultFastVectorAllocator::FreeAligned, COMDAT

; 90   : 			FFREEALIGNED( pBlock );

	jmp	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
?FreeAligned@FDefaultFastVectorAllocator@?$BaseVector@I$00@@SAXPAX@Z ENDP ; BaseVector<unsigned int,1>::FDefaultFastVectorAllocator::FreeAligned
_TEXT	ENDS
PUBLIC	??$max@H@std@@YAABHABH0@Z			; std::max<int>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$max@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@H@std@@YAABHABH0@Z PROC				; std::max<int>, COMDAT

; 3384 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN4@max
	mov	eax, ecx
$LN4@max:

; 3385 : 	}

	ret	0
??$max@H@std@@YAABHABH0@Z ENDP				; std::max<int>
_TEXT	ENDS
PUBLIC	??$min@I@std@@YAABIABI0@Z			; std::min<unsigned int>
; Function compile flags: /Ogtpy
;	COMDAT ??$min@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@I@std@@YAABIABI0@Z PROC				; std::min<unsigned int>, COMDAT

; 3399 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Left$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jb	SHORT $LN4@min
	mov	eax, ecx
$LN4@min:

; 3400 : 	}

	ret	0
??$min@I@std@@YAABIABI0@Z ENDP				; std::min<unsigned int>
_TEXT	ENDS
PUBLIC	?getMap@CvGlobals@@QAEAAVCvMap@@XZ		; CvGlobals::getMap
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMap@CvGlobals@@QAEAAVCvMap@@XZ
_TEXT	SEGMENT
?getMap@CvGlobals@@QAEAAVCvMap@@XZ PROC			; CvGlobals::getMap, COMDAT
; _this$ = ecx

; 175  : 		return *m_map;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+52]

; 176  : 	}

	ret	0
?getMap@CvGlobals@@QAEAAVCvMap@@XZ ENDP			; CvGlobals::getMap
_TEXT	ENDS
PUBLIC	?getPlotDirectionX@CvGlobals@@QAEPAHXZ		; CvGlobals::getPlotDirectionX
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotDirectionX@CvGlobals@@QAEPAHXZ
_TEXT	SEGMENT
?getPlotDirectionX@CvGlobals@@QAEPAHXZ PROC		; CvGlobals::getPlotDirectionX, COMDAT
; _this$ = ecx

; 191  : 		return m_aiPlotDirectionX;

	lea	eax, DWORD PTR [ecx+112]

; 192  : 	}

	ret	0
?getPlotDirectionX@CvGlobals@@QAEPAHXZ ENDP		; CvGlobals::getPlotDirectionX
_TEXT	ENDS
PUBLIC	?getPlotDirectionY@CvGlobals@@QAEPAHXZ		; CvGlobals::getPlotDirectionY
; Function compile flags: /Ogtpy
;	COMDAT ?getPlotDirectionY@CvGlobals@@QAEPAHXZ
_TEXT	SEGMENT
?getPlotDirectionY@CvGlobals@@QAEPAHXZ PROC		; CvGlobals::getPlotDirectionY, COMDAT
; _this$ = ecx

; 195  : 		return m_aiPlotDirectionY;

	lea	eax, DWORD PTR [ecx+136]

; 196  : 	}

	ret	0
?getPlotDirectionY@CvGlobals@@QAEPAHXZ ENDP		; CvGlobals::getPlotDirectionY
_TEXT	ENDS
PUBLIC	?getAI_DIPLO_PLOT_RANGE_FROM_CITY_HOME_FRONT@CvGlobals@@QAEHXZ ; CvGlobals::getAI_DIPLO_PLOT_RANGE_FROM_CITY_HOME_FRONT
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_DIPLO_PLOT_RANGE_FROM_CITY_HOME_FRONT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getAI_DIPLO_PLOT_RANGE_FROM_CITY_HOME_FRONT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getAI_DIPLO_PLOT_RANGE_FROM_CITY_HOME_FRONT, COMDAT
; _this$ = ecx

; 1769 : 		return m_iAI_DIPLO_PLOT_RANGE_FROM_CITY_HOME_FRONT;

	mov	eax, DWORD PTR [ecx+2704]

; 1770 : 	}

	ret	0
?getAI_DIPLO_PLOT_RANGE_FROM_CITY_HOME_FRONT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getAI_DIPLO_PLOT_RANGE_FROM_CITY_HOME_FRONT
_TEXT	ENDS
PUBLIC	?getCITY_ATTACK_RANGE@CvGlobals@@QAEHXZ		; CvGlobals::getCITY_ATTACK_RANGE
; Function compile flags: /Ogtpy
;	COMDAT ?getCITY_ATTACK_RANGE@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getCITY_ATTACK_RANGE@CvGlobals@@QAEHXZ PROC		; CvGlobals::getCITY_ATTACK_RANGE, COMDAT
; _this$ = ecx

; 6617 : 		return m_iCITY_ATTACK_RANGE;

	mov	eax, DWORD PTR [ecx+7488]

; 6618 : 	}

	ret	0
?getCITY_ATTACK_RANGE@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getCITY_ATTACK_RANGE
_TEXT	ENDS
PUBLIC	?getAI_DANGER_MAJOR_APPROACH_WAR@CvGlobals@@QAEMXZ ; CvGlobals::getAI_DANGER_MAJOR_APPROACH_WAR
EXTRN	__fltused:DWORD
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_DANGER_MAJOR_APPROACH_WAR@CvGlobals@@QAEMXZ
_TEXT	SEGMENT
?getAI_DANGER_MAJOR_APPROACH_WAR@CvGlobals@@QAEMXZ PROC	; CvGlobals::getAI_DANGER_MAJOR_APPROACH_WAR, COMDAT
; _this$ = ecx

; 7060 : 		return m_fAI_DANGER_MAJOR_APPROACH_WAR;

	fld	DWORD PTR [ecx+8048]

; 7061 : 	}

	ret	0
?getAI_DANGER_MAJOR_APPROACH_WAR@CvGlobals@@QAEMXZ ENDP	; CvGlobals::getAI_DANGER_MAJOR_APPROACH_WAR
_TEXT	ENDS
PUBLIC	?getAI_DANGER_MAJOR_APPROACH_HOSTILE@CvGlobals@@QAEMXZ ; CvGlobals::getAI_DANGER_MAJOR_APPROACH_HOSTILE
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_DANGER_MAJOR_APPROACH_HOSTILE@CvGlobals@@QAEMXZ
_TEXT	SEGMENT
?getAI_DANGER_MAJOR_APPROACH_HOSTILE@CvGlobals@@QAEMXZ PROC ; CvGlobals::getAI_DANGER_MAJOR_APPROACH_HOSTILE, COMDAT
; _this$ = ecx

; 7064 : 		return m_fAI_DANGER_MAJOR_APPROACH_HOSTILE;

	fld	DWORD PTR [ecx+8052]

; 7065 : 	}

	ret	0
?getAI_DANGER_MAJOR_APPROACH_HOSTILE@CvGlobals@@QAEMXZ ENDP ; CvGlobals::getAI_DANGER_MAJOR_APPROACH_HOSTILE
_TEXT	ENDS
PUBLIC	?getAI_DANGER_MAJOR_APPROACH_DECEPTIVE@CvGlobals@@QAEMXZ ; CvGlobals::getAI_DANGER_MAJOR_APPROACH_DECEPTIVE
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_DANGER_MAJOR_APPROACH_DECEPTIVE@CvGlobals@@QAEMXZ
_TEXT	SEGMENT
?getAI_DANGER_MAJOR_APPROACH_DECEPTIVE@CvGlobals@@QAEMXZ PROC ; CvGlobals::getAI_DANGER_MAJOR_APPROACH_DECEPTIVE, COMDAT
; _this$ = ecx

; 7068 : 		return m_fAI_DANGER_MAJOR_APPROACH_DECEPTIVE;

	fld	DWORD PTR [ecx+8056]

; 7069 : 	}

	ret	0
?getAI_DANGER_MAJOR_APPROACH_DECEPTIVE@CvGlobals@@QAEMXZ ENDP ; CvGlobals::getAI_DANGER_MAJOR_APPROACH_DECEPTIVE
_TEXT	ENDS
PUBLIC	?getAI_DANGER_MAJOR_APPROACH_GUARDED@CvGlobals@@QAEMXZ ; CvGlobals::getAI_DANGER_MAJOR_APPROACH_GUARDED
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_DANGER_MAJOR_APPROACH_GUARDED@CvGlobals@@QAEMXZ
_TEXT	SEGMENT
?getAI_DANGER_MAJOR_APPROACH_GUARDED@CvGlobals@@QAEMXZ PROC ; CvGlobals::getAI_DANGER_MAJOR_APPROACH_GUARDED, COMDAT
; _this$ = ecx

; 7072 : 		return m_fAI_DANGER_MAJOR_APPROACH_GUARDED;

	fld	DWORD PTR [ecx+8060]

; 7073 : 	}

	ret	0
?getAI_DANGER_MAJOR_APPROACH_GUARDED@CvGlobals@@QAEMXZ ENDP ; CvGlobals::getAI_DANGER_MAJOR_APPROACH_GUARDED
_TEXT	ENDS
PUBLIC	?getAI_DANGER_MAJOR_APPROACH_AFRAID@CvGlobals@@QAEMXZ ; CvGlobals::getAI_DANGER_MAJOR_APPROACH_AFRAID
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_DANGER_MAJOR_APPROACH_AFRAID@CvGlobals@@QAEMXZ
_TEXT	SEGMENT
?getAI_DANGER_MAJOR_APPROACH_AFRAID@CvGlobals@@QAEMXZ PROC ; CvGlobals::getAI_DANGER_MAJOR_APPROACH_AFRAID, COMDAT
; _this$ = ecx

; 7076 : 		return m_fAI_DANGER_MAJOR_APPROACH_AFRAID;

	fld	DWORD PTR [ecx+8064]

; 7077 : 	}

	ret	0
?getAI_DANGER_MAJOR_APPROACH_AFRAID@CvGlobals@@QAEMXZ ENDP ; CvGlobals::getAI_DANGER_MAJOR_APPROACH_AFRAID
_TEXT	ENDS
PUBLIC	?getAI_DANGER_MAJOR_APPROACH_FRIENDLY@CvGlobals@@QAEMXZ ; CvGlobals::getAI_DANGER_MAJOR_APPROACH_FRIENDLY
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_DANGER_MAJOR_APPROACH_FRIENDLY@CvGlobals@@QAEMXZ
_TEXT	SEGMENT
?getAI_DANGER_MAJOR_APPROACH_FRIENDLY@CvGlobals@@QAEMXZ PROC ; CvGlobals::getAI_DANGER_MAJOR_APPROACH_FRIENDLY, COMDAT
; _this$ = ecx

; 7080 : 		return m_fAI_DANGER_MAJOR_APPROACH_FRIENDLY;

	fld	DWORD PTR [ecx+8068]

; 7081 : 	}

	ret	0
?getAI_DANGER_MAJOR_APPROACH_FRIENDLY@CvGlobals@@QAEMXZ ENDP ; CvGlobals::getAI_DANGER_MAJOR_APPROACH_FRIENDLY
_TEXT	ENDS
PUBLIC	?getAI_DANGER_MAJOR_APPROACH_NEUTRAL@CvGlobals@@QAEMXZ ; CvGlobals::getAI_DANGER_MAJOR_APPROACH_NEUTRAL
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_DANGER_MAJOR_APPROACH_NEUTRAL@CvGlobals@@QAEMXZ
_TEXT	SEGMENT
?getAI_DANGER_MAJOR_APPROACH_NEUTRAL@CvGlobals@@QAEMXZ PROC ; CvGlobals::getAI_DANGER_MAJOR_APPROACH_NEUTRAL, COMDAT
; _this$ = ecx

; 7084 : 		return m_fAI_DANGER_MAJOR_APPROACH_NEUTRAL;

	fld	DWORD PTR [ecx+8072]

; 7085 : 	}

	ret	0
?getAI_DANGER_MAJOR_APPROACH_NEUTRAL@CvGlobals@@QAEMXZ ENDP ; CvGlobals::getAI_DANGER_MAJOR_APPROACH_NEUTRAL
_TEXT	ENDS
PUBLIC	?getAI_DANGER_MINOR_APPROACH_NEUTRAL@CvGlobals@@QAEMXZ ; CvGlobals::getAI_DANGER_MINOR_APPROACH_NEUTRAL
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_DANGER_MINOR_APPROACH_NEUTRAL@CvGlobals@@QAEMXZ
_TEXT	SEGMENT
?getAI_DANGER_MINOR_APPROACH_NEUTRAL@CvGlobals@@QAEMXZ PROC ; CvGlobals::getAI_DANGER_MINOR_APPROACH_NEUTRAL, COMDAT
; _this$ = ecx

; 7088 : 		return m_fAI_DANGER_MINOR_APPROACH_NEUTRAL;

	fld	DWORD PTR [ecx+8076]

; 7089 : 	}

	ret	0
?getAI_DANGER_MINOR_APPROACH_NEUTRAL@CvGlobals@@QAEMXZ ENDP ; CvGlobals::getAI_DANGER_MINOR_APPROACH_NEUTRAL
_TEXT	ENDS
PUBLIC	?getAI_DANGER_MINOR_APPROACH_FRIENDLY@CvGlobals@@QAEMXZ ; CvGlobals::getAI_DANGER_MINOR_APPROACH_FRIENDLY
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_DANGER_MINOR_APPROACH_FRIENDLY@CvGlobals@@QAEMXZ
_TEXT	SEGMENT
?getAI_DANGER_MINOR_APPROACH_FRIENDLY@CvGlobals@@QAEMXZ PROC ; CvGlobals::getAI_DANGER_MINOR_APPROACH_FRIENDLY, COMDAT
; _this$ = ecx

; 7092 : 		return m_fAI_DANGER_MINOR_APPROACH_FRIENDLY;

	fld	DWORD PTR [ecx+8080]

; 7093 : 	}

	ret	0
?getAI_DANGER_MINOR_APPROACH_FRIENDLY@CvGlobals@@QAEMXZ ENDP ; CvGlobals::getAI_DANGER_MINOR_APPROACH_FRIENDLY
_TEXT	ENDS
PUBLIC	?getAI_DANGER_MINOR_APPROACH_BULLY@CvGlobals@@QAEMXZ ; CvGlobals::getAI_DANGER_MINOR_APPROACH_BULLY
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_DANGER_MINOR_APPROACH_BULLY@CvGlobals@@QAEMXZ
_TEXT	SEGMENT
?getAI_DANGER_MINOR_APPROACH_BULLY@CvGlobals@@QAEMXZ PROC ; CvGlobals::getAI_DANGER_MINOR_APPROACH_BULLY, COMDAT
; _this$ = ecx

; 7096 : 		return m_fAI_DANGER_MINOR_APPROACH_BULLY;

	fld	DWORD PTR [ecx+8084]

; 7097 : 	}

	ret	0
?getAI_DANGER_MINOR_APPROACH_BULLY@CvGlobals@@QAEMXZ ENDP ; CvGlobals::getAI_DANGER_MINOR_APPROACH_BULLY
_TEXT	ENDS
PUBLIC	?getAI_DANGER_MINOR_APPROACH_CONQUEST@CvGlobals@@QAEMXZ ; CvGlobals::getAI_DANGER_MINOR_APPROACH_CONQUEST
; Function compile flags: /Ogtpy
;	COMDAT ?getAI_DANGER_MINOR_APPROACH_CONQUEST@CvGlobals@@QAEMXZ
_TEXT	SEGMENT
?getAI_DANGER_MINOR_APPROACH_CONQUEST@CvGlobals@@QAEMXZ PROC ; CvGlobals::getAI_DANGER_MINOR_APPROACH_CONQUEST, COMDAT
; _this$ = ecx

; 7100 : 		return m_fAI_DANGER_MINOR_APPROACH_CONQUEST;

	fld	DWORD PTR [ecx+8088]

; 7101 : 	}

	ret	0
?getAI_DANGER_MINOR_APPROACH_CONQUEST@CvGlobals@@QAEMXZ ENDP ; CvGlobals::getAI_DANGER_MINOR_APPROACH_CONQUEST
_TEXT	ENDS
PUBLIC	?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z	; CvPlayerAI::getPlayer
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
;	COMDAT ?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z PROC	; CvPlayerAI::getPlayer, COMDAT

; 28   : 		CvAssertMsg(ePlayer != NO_PLAYER, "Player is not assigned a valid value");
; 29   : 		CvAssertMsg(ePlayer < MAX_PLAYERS, "Player is not assigned a valid value");
; 30   : 		return m_aPlayers[ePlayer];

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 31   : 	}

	ret	0
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z ENDP	; CvPlayerAI::getPlayer
_TEXT	ENDS
PUBLIC	?getX@CvPlot@@QBEHXZ				; CvPlot::getX
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?getX@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getX@CvPlot@@QBEHXZ PROC				; CvPlot::getX, COMDAT
; _this$ = ecx

; 307  : 		return m_iX;

	movsx	eax, WORD PTR [ecx]

; 308  : 	}

	ret	0
?getX@CvPlot@@QBEHXZ ENDP				; CvPlot::getX
_TEXT	ENDS
PUBLIC	?getY@CvPlot@@QBEHXZ				; CvPlot::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getY@CvPlot@@QBEHXZ PROC				; CvPlot::getY, COMDAT
; _this$ = ecx

; 312  : 		return m_iY;

	movsx	eax, WORD PTR [ecx+2]

; 313  : 	}

	ret	0
?getY@CvPlot@@QBEHXZ ENDP				; CvPlot::getY
_TEXT	ENDS
PUBLIC	?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ	; CvPlot::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlot::getOwner, COMDAT
; _this$ = ecx

; 387  : 		return (PlayerTypes)m_eOwner;

	movsx	eax, BYTE PTR [ecx+4]

; 388  : 	}

	ret	0
?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlot::getOwner
_TEXT	ENDS
PUBLIC	?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z	; CvPlot::getVisibilityCount
; Function compile flags: /Ogtpy
;	COMDAT ?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z PROC	; CvPlot::getVisibilityCount, COMDAT
; _this$ = ecx

; 588  : 		CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 589  : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 590  : 
; 591  : 		return m_aiVisibilityCount[eTeam];

	mov	eax, DWORD PTR [ecx+156]
	mov	ecx, DWORD PTR _eTeam$[esp-4]
	movsx	eax, WORD PTR [eax+ecx*2]

; 592  : 	}

	ret	4
?getVisibilityCount@CvPlot@@QBEHW4TeamTypes@@@Z ENDP	; CvPlot::getVisibilityCount
_TEXT	ENDS
PUBLIC	?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z		; CvPlot::PlotBoolField::GetBit
; Function compile flags: /Ogtpy
;	COMDAT ?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z
_TEXT	SEGMENT
_uiEntry$ = 8						; size = 4
?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z PROC		; CvPlot::PlotBoolField::GetBit, COMDAT
; _this$ = ecx

; 767  : 		{

	mov	edx, ecx

; 768  : 			const uint uiOffset = uiEntry/eSize;

	mov	ecx, DWORD PTR _uiEntry$[esp-4]
	push	esi
	mov	eax, ecx
	shr	eax, 5

; 769  : 			return m_dwBits[uiOffset] & 1<<(uiEntry-(eSize*uiOffset));

	mov	esi, eax
	shl	esi, 5
	sub	ecx, esi
	mov	esi, 1
	shl	esi, cl
	test	esi, DWORD PTR [edx+eax*4]
	pop	esi
	setne	al

; 770  : 		}

	ret	4
?GetBit@PlotBoolField@CvPlot@@QBE_NI@Z ENDP		; CvPlot::PlotBoolField::GetBit
_TEXT	ENDS
PUBLIC	?coordRange@@YAHHH_N@Z				; coordRange
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?coordRange@@YAHHH_N@Z
_TEXT	SEGMENT
_iCoord$ = 8						; size = 4
_iRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?coordRange@@YAHHH_N@Z PROC				; coordRange, COMDAT

; 88   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iCoord$[esp-4]
	je	SHORT $LN5@coordRange

; 89   : 	{
; 90   : 		if(iCoord < 0)
; 91   : 		{
; 92   : 			return (iRange + (iCoord % iRange));

	mov	ecx, DWORD PTR _iRange$[esp-4]
	test	eax, eax
	jge	SHORT $LN3@coordRange
	cdq
	idiv	ecx
	mov	eax, edx
	add	eax, ecx

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
$LN3@coordRange:

; 93   : 		}
; 94   : 		else if(iCoord >= iRange)

	cmp	eax, ecx
	jl	SHORT $LN5@coordRange

; 95   : 		{
; 96   : 			return (iCoord % iRange);

	cdq
	idiv	ecx
	mov	eax, edx
$LN5@coordRange:

; 97   : 		}
; 98   : 	}
; 99   : 
; 100  : 	return iCoord;
; 101  : }

	ret	0
?coordRange@@YAHHH_N@Z ENDP				; coordRange
_TEXT	ENDS
PUBLIC	?numPlots@CvMap@@QBEHXZ				; CvMap::numPlots
; Function compile flags: /Ogtpy
;	COMDAT ?numPlots@CvMap@@QBEHXZ
_TEXT	SEGMENT
?numPlots@CvMap@@QBEHXZ PROC				; CvMap::numPlots, COMDAT
; _this$ = ecx

; 170  : 		return m_iGridSize;

	mov	eax, DWORD PTR [ecx+4028]

; 171  : 	}

	ret	0
?numPlots@CvMap@@QBEHXZ ENDP				; CvMap::numPlots
_TEXT	ENDS
PUBLIC	?getGridWidth@CvMap@@QBEHXZ			; CvMap::getGridWidth
; Function compile flags: /Ogtpy
;	COMDAT ?getGridWidth@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridWidth@CvMap@@QBEHXZ PROC			; CvMap::getGridWidth, COMDAT
; _this$ = ecx

; 198  : 		return m_iGridWidth;

	mov	eax, DWORD PTR [ecx+4020]

; 199  : 	}

	ret	0
?getGridWidth@CvMap@@QBEHXZ ENDP			; CvMap::getGridWidth
_TEXT	ENDS
PUBLIC	?getGridHeight@CvMap@@QBEHXZ			; CvMap::getGridHeight
; Function compile flags: /Ogtpy
;	COMDAT ?getGridHeight@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridHeight@CvMap@@QBEHXZ PROC			; CvMap::getGridHeight, COMDAT
; _this$ = ecx

; 206  : 		return m_iGridHeight;

	mov	eax, DWORD PTR [ecx+4024]

; 207  : 	}

	ret	0
?getGridHeight@CvMap@@QBEHXZ ENDP			; CvMap::getGridHeight
_TEXT	ENDS
PUBLIC	?isWrapX@CvMap@@QBE_NXZ				; CvMap::isWrapX
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapX@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapX@CvMap@@QBE_NXZ PROC				; CvMap::isWrapX, COMDAT
; _this$ = ecx

; 228  : 		return m_bWrapX;

	mov	al, BYTE PTR [ecx+4056]

; 229  : 	}

	ret	0
?isWrapX@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapX
_TEXT	ENDS
PUBLIC	?isWrapY@CvMap@@QBE_NXZ				; CvMap::isWrapY
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapY@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapY@CvMap@@QBE_NXZ PROC				; CvMap::isWrapY, COMDAT
; _this$ = ecx

; 233  : 		return m_bWrapY;

	mov	al, BYTE PTR [ecx+4057]

; 234  : 	}

	ret	0
?isWrapY@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapY
_TEXT	ENDS
PUBLIC	?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z	; CvMap::plotByIndexUnchecked
; Function compile flags: /Ogtpy
;	COMDAT ?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z PROC	; CvMap::plotByIndexUnchecked, COMDAT
; _this$ = ecx

; 268  : 		return &m_pMapPlots[iIndex];

	mov	eax, DWORD PTR _iIndex$[esp-4]
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]

; 269  : 	}

	ret	4
?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z ENDP	; CvMap::plotByIndexUnchecked
_TEXT	ENDS
PUBLIC	?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z		; CvTeam::getTeam
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.h
;	COMDAT ?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z PROC		; CvTeam::getTeam, COMDAT

; 29   : 		CvAssertMsg(eTeam != NO_TEAM, "eTeam is not assigned a valid value");
; 30   : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is not assigned a valid value");
; 31   : 		return m_aTeams[eTeam];

	mov	eax, DWORD PTR _eTeam$[esp-4]
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 32   : 	}

	ret	0
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z ENDP		; CvTeam::getTeam
_TEXT	ENDS
PUBLIC	?GetLastNode@CvAStar@@QAEPAVCvAStarNode@@XZ	; CvAStar::GetLastNode
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvastar.h
;	COMDAT ?GetLastNode@CvAStar@@QAEPAVCvAStarNode@@XZ
_TEXT	SEGMENT
?GetLastNode@CvAStar@@QAEPAVCvAStarNode@@XZ PROC	; CvAStar::GetLastNode, COMDAT
; _this$ = ecx

; 98   : 		return m_pBest;

	mov	eax, DWORD PTR [ecx+96]

; 99   : 	}

	ret	0
?GetLastNode@CvAStar@@QAEPAVCvAStarNode@@XZ ENDP	; CvAStar::GetLastNode
_TEXT	ENDS
PUBLIC	?SetData@CvAStar@@QAEXPBX@Z			; CvAStar::SetData
; Function compile flags: /Ogtpy
;	COMDAT ?SetData@CvAStar@@QAEXPBX@Z
_TEXT	SEGMENT
_pData$ = 8						; size = 4
?SetData@CvAStar@@QAEXPBX@Z PROC			; CvAStar::SetData, COMDAT
; _this$ = ecx

; 202  : 		if(m_bDataChangeInvalidatesCache && m_pData != pData)

	cmp	BYTE PTR [ecx+80], 0
	mov	eax, DWORD PTR _pData$[esp-4]
	je	SHORT $LN4@SetData
	cmp	DWORD PTR [ecx+44], eax

; 205  : 		m_pData = pData;

	mov	DWORD PTR [ecx+44], eax
	je	SHORT $LN1@SetData

; 203  : #endif
; 204  : 			m_bForceReset = true;

	mov	BYTE PTR [ecx+78], 1

; 206  : #ifdef AUI_ASTAR_TURN_LIMITER
; 207  : 		m_iMaxTurns = iMaxTurns;
; 208  : #endif
; 209  : 	}

	ret	4
$LN4@SetData:

; 205  : 		m_pData = pData;

	mov	DWORD PTR [ecx+44], eax
$LN1@SetData:

; 206  : #ifdef AUI_ASTAR_TURN_LIMITER
; 207  : 		m_iMaxTurns = iMaxTurns;
; 208  : #endif
; 209  : 	}

	ret	4
?SetData@CvAStar@@QAEXPBX@Z ENDP			; CvAStar::SetData
_TEXT	ENDS
PUBLIC	??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z PROC ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ENDP ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
_TEXT	ENDS
PUBLIC	?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvUnit>::get
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvUnit>::get, COMDAT
; _this$ = ecx

; 177  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 178  : }

	ret	0
?get@?$FAutoVariable@W4PlayerTypes@@VCvUnit@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvUnit>::get
_TEXT	ENDS
PUBLIC	?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ	; FAutoVariable<int,CvUnit>::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ
_TEXT	SEGMENT
?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ PROC		; FAutoVariable<int,CvUnit>::get, COMDAT
; _this$ = ecx

; 177  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 178  : }

	ret	0
?get@?$FAutoVariable@HVCvUnit@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvUnit>::get
_TEXT	ENDS
PUBLIC	??$?6H@FDataStream@@QAEAAV0@ABH@Z		; FDataStream::operator<<<int>
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6H@FDataStream@@QAEAAV0@ABH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6H@FDataStream@@QAEAAV0@ABH@Z PROC			; FDataStream::operator<<<int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6H@FDataStream@@QAEAAV0@ABH@Z ENDP			; FDataStream::operator<<<int>
_TEXT	ENDS
PUBLIC	??$?5H@FDataStream@@QAEAAV0@AAH@Z		; FDataStream::operator>><int>
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5H@FDataStream@@QAEAAV0@AAH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5H@FDataStream@@QAEAAV0@AAH@Z PROC			; FDataStream::operator>><int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5H@FDataStream@@QAEAAV0@AAH@Z ENDP			; FDataStream::operator>><int>
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ	; FAutoVariable<bool,CvPlayer>::operator bool const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ
_TEXT	SEGMENT
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ PROC	; FAutoVariable<bool,CvPlayer>::operator bool const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ ENDP	; FAutoVariable<bool,CvPlayer>::operator bool const &
_TEXT	ENDS
PUBLIC	??$?5_N@FDataStream@@QAEAAV0@AA_N@Z		; FDataStream::operator>><bool>
EXTRN	?Read@FDataStream@@IAEXAA_N@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5_N@FDataStream@@QAEAAV0@AA_N@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5_N@FDataStream@@QAEAAV0@AA_N@Z PROC		; FDataStream::operator>><bool>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5_N@FDataStream@@QAEAAV0@AA_N@Z ENDP		; FDataStream::operator>><bool>
_TEXT	ENDS
PUBLIC	??$?6_N@FDataStream@@QAEAAV0@AB_N@Z		; FDataStream::operator<<<bool>
EXTRN	?Write@FDataStream@@IAEXAB_N@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6_N@FDataStream@@QAEAAV0@AB_N@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6_N@FDataStream@@QAEAAV0@AB_N@Z PROC		; FDataStream::operator<<<bool>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6_N@FDataStream@@QAEAAV0@AB_N@Z ENDP		; FDataStream::operator<<<bool>
_TEXT	ENDS
PUBLIC	??$?5I@FDataStream@@QAEAAV0@AAI@Z		; FDataStream::operator>><unsigned int>
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5I@FDataStream@@QAEAAV0@AAI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5I@FDataStream@@QAEAAV0@AAI@Z PROC			; FDataStream::operator>><unsigned int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5I@FDataStream@@QAEAAV0@AAI@Z ENDP			; FDataStream::operator>><unsigned int>
_TEXT	ENDS
PUBLIC	??$?6I@FDataStream@@QAEAAV0@ABI@Z		; FDataStream::operator<<<unsigned int>
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6I@FDataStream@@QAEAAV0@ABI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6I@FDataStream@@QAEAAV0@ABI@Z PROC			; FDataStream::operator<<<unsigned int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6I@FDataStream@@QAEAAV0@ABI@Z ENDP			; FDataStream::operator<<<unsigned int>
_TEXT	ENDS
PUBLIC	?AddDanger@CvDangerPlots@@QAEXHHH_N@Z		; CvDangerPlots::AddDanger
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvdangerplots.cpp
;	COMDAT ?AddDanger@CvDangerPlots@@QAEXHHH_N@Z
_TEXT	SEGMENT
_iPlotX$ = 8						; size = 4
_iPlotY$ = 12						; size = 4
_iValue$ = 16						; size = 4
_bWithinOneMove$ = 20					; size = 1
?AddDanger@CvDangerPlots@@QAEXHHH_N@Z PROC		; CvDangerPlots::AddDanger, COMDAT
; _this$ = ecx

; 282  : 	const int idx = iPlotX + iPlotY * GC.getMap().getGridWidth();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	eax, DWORD PTR [eax+4020]
	imul	eax, DWORD PTR _iPlotY$[esp-4]

; 283  : #ifdef AUI_DANGER_PLOTS_FIX_ADD_DANGER_WITHIN_ONE_MOVE
; 284  : 	iValue &= ~0x1;
; 285  : #else
; 286  : 	if (iValue > 0)

	mov	edx, DWORD PTR _iValue$[esp-4]
	add	eax, DWORD PTR _iPlotX$[esp-4]
	test	edx, edx
	jle	SHORT $LN1@AddDanger

; 287  : 	{
; 288  : 		if (bWithinOneMove)

	cmp	BYTE PTR _bWithinOneMove$[esp-4], 0
	je	SHORT $LN2@AddDanger

; 295  : 		}
; 296  : 	}
; 297  : #endif
; 298  : 
; 299  : 	m_DangerPlots[idx] += iValue;

	mov	ecx, DWORD PTR [ecx+96]
	or	edx, 1
	add	DWORD PTR [ecx+eax*4], edx
	lea	eax, DWORD PTR [ecx+eax*4]

; 300  : #ifdef AUI_DANGER_PLOTS_FIX_ADD_DANGER_WITHIN_ONE_MOVE
; 301  : 	if (bWithinOneMove)
; 302  : 	{
; 303  : 		m_DangerPlots[idx] |= 0x1;
; 304  : 	}
; 305  : #endif
; 306  : }

	ret	16					; 00000010H
$LN2@AddDanger:

; 289  : 		{
; 290  : 			iValue |= 0x1;
; 291  : 		}
; 292  : 		else
; 293  : 		{
; 294  : 			iValue &= ~0x1;

	and	edx, -2					; fffffffeH
$LN1@AddDanger:

; 295  : 		}
; 296  : 	}
; 297  : #endif
; 298  : 
; 299  : 	m_DangerPlots[idx] += iValue;

	mov	ecx, DWORD PTR [ecx+96]
	add	DWORD PTR [ecx+eax*4], edx
	lea	eax, DWORD PTR [ecx+eax*4]

; 300  : #ifdef AUI_DANGER_PLOTS_FIX_ADD_DANGER_WITHIN_ONE_MOVE
; 301  : 	if (bWithinOneMove)
; 302  : 	{
; 303  : 		m_DangerPlots[idx] |= 0x1;
; 304  : 	}
; 305  : #endif
; 306  : }

	ret	16					; 00000010H
?AddDanger@CvDangerPlots@@QAEXHHH_N@Z ENDP		; CvDangerPlots::AddDanger
_TEXT	ENDS
PUBLIC	?GetDanger@CvDangerPlots@@QBEHABVCvPlot@@@Z	; CvDangerPlots::GetDanger
; Function compile flags: /Ogtpy
;	COMDAT ?GetDanger@CvDangerPlots@@QBEHABVCvPlot@@@Z
_TEXT	SEGMENT
_pPlot$ = 8						; size = 4
?GetDanger@CvDangerPlots@@QBEHABVCvPlot@@@Z PROC	; CvDangerPlots::GetDanger, COMDAT
; _this$ = ecx

; 311  : 	const int idx = pPlot.getX() + pPlot.getY() * GC.getMap().getGridWidth();
; 312  : 	return m_DangerPlots[idx];

	mov	eax, DWORD PTR _pPlot$[esp-4]
	movsx	edx, WORD PTR [eax+2]
	movsx	eax, WORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+96]
	push	esi
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	imul	edx, DWORD PTR [esi+4020]
	add	edx, eax
	mov	eax, DWORD PTR [ecx+edx*4]
	pop	esi

; 313  : }

	ret	4
?GetDanger@CvDangerPlots@@QBEHABVCvPlot@@@Z ENDP	; CvDangerPlots::GetDanger
_TEXT	ENDS
PUBLIC	?IsUnderImmediateThreat@CvDangerPlots@@QBE_NABVCvPlot@@@Z ; CvDangerPlots::IsUnderImmediateThreat
; Function compile flags: /Ogtpy
;	COMDAT ?IsUnderImmediateThreat@CvDangerPlots@@QBE_NABVCvPlot@@@Z
_TEXT	SEGMENT
_pPlot$ = 8						; size = 4
?IsUnderImmediateThreat@CvDangerPlots@@QBE_NABVCvPlot@@@Z PROC ; CvDangerPlots::IsUnderImmediateThreat, COMDAT
; _this$ = ecx

; 318  : 	return GetDanger(pPlot) & 0x1;

	mov	eax, DWORD PTR _pPlot$[esp-4]
	movsx	edx, WORD PTR [eax+2]
	movsx	eax, WORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+96]
	push	esi
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	imul	edx, DWORD PTR [esi+4020]
	add	edx, eax
	mov	eax, DWORD PTR [ecx+edx*4]
	and	eax, 1
	pop	esi

; 319  : }

	ret	4
?IsUnderImmediateThreat@CvDangerPlots@@QBE_NABVCvPlot@@@Z ENDP ; CvDangerPlots::IsUnderImmediateThreat
_TEXT	ENDS
PUBLIC	?GetDangerValueOfCitadel@CvDangerPlots@@IBEHXZ	; CvDangerPlots::GetDangerValueOfCitadel
EXTRN	?GetPowerOfStrongestBuildableUnit@CvMilitaryAI@@QAEHW4DomainTypes@@@Z:PROC ; CvMilitaryAI::GetPowerOfStrongestBuildableUnit
EXTRN	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ:PROC ; CvPlayer::GetMilitaryAI
; Function compile flags: /Ogtpy
;	COMDAT ?GetDangerValueOfCitadel@CvDangerPlots@@IBEHXZ
_TEXT	SEGMENT
?GetDangerValueOfCitadel@CvDangerPlots@@IBEHXZ PROC	; CvDangerPlots::GetDangerValueOfCitadel, COMDAT
; _this$ = ecx

; 765  : 	// Compute power of this player's strongest unit
; 766  : 	CvMilitaryAI* pMilitaryAI = GET_PLAYER(m_ePlayer).GetMilitaryAI();

	mov	ecx, DWORD PTR [ecx]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI

; 767  : 	int iPower = pMilitaryAI->GetPowerOfStrongestBuildableUnit(DOMAIN_LAND);

	push	2
	mov	ecx, eax
	call	?GetPowerOfStrongestBuildableUnit@CvMilitaryAI@@QAEHW4DomainTypes@@@Z ; CvMilitaryAI::GetPowerOfStrongestBuildableUnit

; 768  : 
; 769  : 	// Magic number to approximate danger from one turn of citadel damage
; 770  : 	return iPower * 50;

	imul	eax, 50					; 00000032H

; 771  : }

	ret	0
?GetDangerValueOfCitadel@CvDangerPlots@@IBEHXZ ENDP	; CvDangerPlots::GetDangerValueOfCitadel
_TEXT	ENDS
PUBLIC	?Write@CvDangerPlots@@QBEXAAVFDataStream@@@Z	; CvDangerPlots::Write
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z:PROC ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ?Write@CvDangerPlots@@QBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
_iGridSize$ = 8						; size = 4
_kStream$ = 8						; size = 4
?Write@CvDangerPlots@@QBEXAAVFDataStream@@@Z PROC	; CvDangerPlots::Write, COMDAT
; _this$ = ecx

; 813  : {

	push	ecx
	push	ebx
	push	esi

; 814  : 	// Current version number
; 815  : 	uint uiVersion = 1;
; 816  : 	kStream << uiVersion;

	mov	esi, DWORD PTR _kStream$[esp+8]
	push	edi
	lea	eax, DWORD PTR _uiVersion$[esp+16]
	mov	ebx, ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _uiVersion$[esp+20], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 817  : 
; 818  : 	kStream << m_ePlayer;

	push	ebx
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<
	add	esp, 8

; 819  : #ifdef AUI_DANGER_PLOTS_FIX_USE_ARRAY_NOT_FFASTVECTOR
; 820  : 	kStream << (m_DangerPlots != NULL);
; 821  : #else
; 822  : 	kStream << m_bArrayAllocated;

	lea	ecx, DWORD PTR [ebx+4]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 823  : #endif
; 824  : 
; 825  : 	int iGridSize = GC.getMap().getGridWidth() * GC.getMap().getGridHeight();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	edx, DWORD PTR [eax+4024]
	imul	edx, DWORD PTR [eax+4020]

; 826  : 	kStream << iGridSize;

	lea	eax, DWORD PTR _iGridSize$[esp+12]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _iGridSize$[esp+16], edx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 827  : #ifdef AUI_DANGER_PLOTS_FIX_USE_ARRAY_NOT_FFASTVECTOR
; 828  : 	if (m_DangerPlots)
; 829  : 	{
; 830  : 		for (int i = 0; i < iGridSize; i++)
; 831  : 		{
; 832  : 			kStream << m_DangerPlots[i];
; 833  : 		}
; 834  : 	}
; 835  : 	else
; 836  : 	{
; 837  : 		for (int i = 0; i < iGridSize; i++)
; 838  : 		{
; 839  : 			kStream << (uint)0;
; 840  : 		}
; 841  : 	}
; 842  : #else
; 843  : 	for(int i = 0; i < iGridSize; i++)

	xor	edi, edi
	cmp	DWORD PTR _iGridSize$[esp+12], edi
	jle	SHORT $LN1@Write
	npad	3
$LL3@Write:
	mov	ecx, DWORD PTR [ebx+96]
	lea	edx, DWORD PTR [ecx+edi*4]

; 844  : 	{
; 845  : 		kStream << m_DangerPlots[i];

	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	inc	edi
	cmp	edi, DWORD PTR _iGridSize$[esp+12]
	jl	SHORT $LL3@Write
$LN1@Write:
	pop	edi
	pop	esi
	pop	ebx

; 846  : 	}
; 847  : #endif
; 848  : }

	pop	ecx
	ret	4
?Write@CvDangerPlots@@QBEXAAVFDataStream@@@Z ENDP	; CvDangerPlots::Write
_TEXT	ENDS
PUBLIC	?clear@?$BaseVector@I$00@@QAEXXZ		; BaseVector<unsigned int,1>::clear
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?clear@?$BaseVector@I$00@@QAEXXZ
_TEXT	SEGMENT
?clear@?$BaseVector@I$00@@QAEXXZ PROC			; BaseVector<unsigned int,1>::clear, COMDAT
; _this$ = ecx

; 121  : 		Destroy(m_pData, m_uiCurrSize);
; 122  : 		m_uiCurrSize = 0;

	mov	DWORD PTR [ecx+4], 0

; 123  : 	};

	ret	0
?clear@?$BaseVector@I$00@@QAEXXZ ENDP			; BaseVector<unsigned int,1>::clear
_TEXT	ENDS
PUBLIC	?Alloc@?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@IAEPAII@Z ; FFastVector<unsigned int,1,297,0,BaseVector<unsigned int,1>::FDefaultFastVectorAllocator>::Alloc
; Function compile flags: /Ogtpy
;	COMDAT ?Alloc@?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@IAEPAII@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@IAEPAII@Z PROC ; FFastVector<unsigned int,1,297,0,BaseVector<unsigned int,1>::FDefaultFastVectorAllocator>::Alloc, COMDAT
; _this$ = ecx

; 503  : 	T* Alloc( unsigned int uiSize ){

	push	esi

; 504  : 		if( uiSize > 0 ){

	mov	esi, DWORD PTR _uiSize$[esp]
	push	edi
	mov	edi, ecx
	test	esi, esi
	jbe	SHORT $LN1@Alloc

; 505  :             
; 506  :             T* pRet = (T*)FAST_VEC_ALLOC::AllocAligned( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	85					; 00000055H
	push	OFFSET ??_C@_0EG@NKCAPKNA@s?3?2github?2lekmod?2lekmod_dll?2fire@
	lea	eax, DWORD PTR [esi*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 507  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [edi+8], esi
	pop	edi
	pop	esi

; 511  : 	};

	ret	4
$LN1@Alloc:
	pop	edi

; 508  : 			return pRet;
; 509  : 		}
; 510  : 		return NULL;

	xor	eax, eax
	pop	esi

; 511  : 	};

	ret	4
?Alloc@?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@IAEPAII@Z ENDP ; FFastVector<unsigned int,1,297,0,BaseVector<unsigned int,1>::FDefaultFastVectorAllocator>::Alloc
_TEXT	ENDS
PUBLIC	?Free@?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@IAEXPAII@Z ; FFastVector<unsigned int,1,297,0,BaseVector<unsigned int,1>::FDefaultFastVectorAllocator>::Free
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@IAEXPAII@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@IAEXPAII@Z PROC ; FFastVector<unsigned int,1,297,0,BaseVector<unsigned int,1>::FDefaultFastVectorAllocator>::Free, COMDAT
; _this$ = ecx

; 516  : 		if( !bPODType) 
; 517  :             Destroy(pVal, uiNumElements);
; 518  : 
; 519  : 		FAST_VEC_ALLOC::FreeAligned( (void*)pVal );

	mov	eax, DWORD PTR _pVal$[esp-4]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx

; 520  : 	};

	ret	8
?Free@?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@IAEXPAII@Z ENDP ; FFastVector<unsigned int,1,297,0,BaseVector<unsigned int,1>::FDefaultFastVectorAllocator>::Free
_TEXT	ENDS
PUBLIC	?getX@CvUnit@@QBEHXZ				; CvUnit::getX
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvunit.h
;	COMDAT ?getX@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?getX@CvUnit@@QBEHXZ PROC				; CvUnit::getX, COMDAT
; _this$ = ecx

; 673  : 		return m_iX.get();

	mov	eax, DWORD PTR [ecx+76]

; 674  : 	}

	ret	0
?getX@CvUnit@@QBEHXZ ENDP				; CvUnit::getX
_TEXT	ENDS
PUBLIC	?getY@CvUnit@@QBEHXZ				; CvUnit::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvUnit@@QBEHXZ
_TEXT	SEGMENT
?getY@CvUnit@@QBEHXZ PROC				; CvUnit::getY, COMDAT
; _this$ = ecx

; 678  : 		return m_iY.get();

	mov	eax, DWORD PTR [ecx+88]

; 679  : 	}

	ret	0
?getY@CvUnit@@QBEHXZ ENDP				; CvUnit::getY
_TEXT	ENDS
PUBLIC	?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ	; CvUnit::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ PROC		; CvUnit::getOwner, COMDAT
; _this$ = ecx

; 1046 : 		return m_eOwner.get();

	mov	eax, DWORD PTR [ecx+40]

; 1047 : 	}

	ret	0
?getOwner@CvUnit@@QBE?AW4PlayerTypes@@XZ ENDP		; CvUnit::getOwner
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT
; _p$ = eax

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 302  : }

	ret	0
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1

; 302  : }

	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
PUBLIC	?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ	; CvCity::getOwner
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcity.h
;	COMDAT ?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ PROC		; CvCity::getOwner, COMDAT
; _this$ = ecx

; 604  : 		return m_eOwner;

	mov	eax, DWORD PTR [ecx+84]

; 605  : 	}

	ret	0
?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ ENDP		; CvCity::getOwner
_TEXT	ENDS
PUBLIC	?isAlive@CvPlayer@@QBE_NXZ			; CvPlayer::isAlive
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayer.h
;	COMDAT ?isAlive@CvPlayer@@QBE_NXZ
_TEXT	SEGMENT
?isAlive@CvPlayer@@QBE_NXZ PROC				; CvPlayer::isAlive, COMDAT
; _this$ = ecx

; 1092 : 		return m_bAlive;

	mov	al, BYTE PTR [ecx+2256]

; 1093 : 	}

	ret	0
?isAlive@CvPlayer@@QBE_NXZ ENDP				; CvPlayer::isAlive
_TEXT	ENDS
PUBLIC	?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ		; CvPlayer::GetID
; Function compile flags: /Ogtpy
;	COMDAT ?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlayer::GetID, COMDAT
; _this$ = ecx

; 1168 : 		return m_eID;

	mov	eax, DWORD PTR [ecx+44]

; 1169 : 	}

	ret	0
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlayer::GetID
_TEXT	ENDS
PUBLIC	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ		; CvPlayer::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ PROC		; CvPlayer::getTeam, COMDAT
; _this$ = ecx

; 1178 : 		return CvPreGame::teamType(m_eID);

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN5@getTeam
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1179 : 	}

	ret	0

; 1178 : 		return CvPreGame::teamType(m_eID);

$LN5@getTeam:
	or	eax, -1

; 1179 : 	}

	ret	0
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ ENDP		; CvPlayer::getTeam
_TEXT	ENDS
PUBLIC	?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z		; CvPlot::isVisible
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z PROC		; CvPlot::isVisible, COMDAT
; _this$ = ecx

; 210  : 		if(eTeam == NO_TEAM)

	mov	eax, DWORD PTR _eTeam$[esp-4]
	cmp	eax, -1
	jne	SHORT $LN1@isVisible

; 211  : 			return false;

	xor	al, al

; 214  : 	}

	ret	4
$LN1@isVisible:

; 212  : 
; 213  : 		return ((getVisibilityCount(eTeam) > 0));

	mov	ecx, DWORD PTR [ecx+156]
	xor	edx, edx
	cmp	WORD PTR [ecx+eax*2], dx
	setg	dl
	mov	al, dl

; 214  : 	}

	ret	4
?isVisible@CvPlot@@QBE_NW4TeamTypes@@@Z ENDP		; CvPlot::isVisible
_TEXT	ENDS
PUBLIC	?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z	; CvPlot::isRevealed
; Function compile flags: /Ogtpy
;	COMDAT ?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z PROC		; CvPlot::isRevealed, COMDAT
; _this$ = ecx

; 620  : 	{

	mov	edx, ecx

; 621  : 		CvAssertMsg(eTeam >= 0, "eTeam is expected to be non-negative (invalid Index)");
; 622  : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is expected to be within maximum bounds (invalid Index)");
; 623  : 		return m_bfRevealed.GetBit(eTeam);

	mov	ecx, DWORD PTR _eTeam$[esp-4]
	push	esi
	mov	eax, ecx
	shr	eax, 5
	mov	esi, eax
	shl	esi, 5
	sub	ecx, esi
	mov	esi, 1
	shl	esi, cl
	test	esi, DWORD PTR [edx+eax*4+8]
	pop	esi
	setne	al

; 624  : 	}

	ret	4
?isRevealed@CvPlot@@QBE_NW4TeamTypes@@@Z ENDP		; CvPlot::isRevealed
_TEXT	ENDS
PUBLIC	?isPlot@CvMap@@QBEHHH@Z				; CvMap::isPlot
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?isPlot@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?isPlot@CvMap@@QBEHHH@Z PROC				; CvMap::isPlot, COMDAT
; _this$ = ecx

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	mov	eax, DWORD PTR _iX$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4020]
	jge	SHORT $LN3@isPlot
	mov	eax, DWORD PTR _iY$[esp-4]
	test	eax, eax
	jl	SHORT $LN3@isPlot
	cmp	eax, DWORD PTR [ecx+4024]
	jge	SHORT $LN3@isPlot
	mov	eax, 1

; 161  : #endif
; 162  : 	}

	ret	8
$LN3@isPlot:

; 157  : #ifdef AUI_WARNING_FIXES
; 158  : 		return ((iX >= 0) && (uint(iX) < getGridWidth()) && (iY >= 0) && (uint(iY) < getGridHeight()));
; 159  : #else
; 160  : 		return ((iX >= 0) && (iX < getGridWidth()) && (iY >= 0) && (iY < getGridHeight()));

	xor	eax, eax

; 161  : #endif
; 162  : 	}

	ret	8
?isPlot@CvMap@@QBEHHH@Z ENDP				; CvMap::isPlot
_TEXT	ENDS
PUBLIC	?plotNum@CvMap@@QBEHHH@Z			; CvMap::plotNum
; Function compile flags: /Ogtpy
;	COMDAT ?plotNum@CvMap@@QBEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plotNum@CvMap@@QBEHHH@Z PROC				; CvMap::plotNum, COMDAT
; _this$ = ecx

; 183  : 		return ((iY * getGridWidth()) + iX);

	mov	eax, DWORD PTR [ecx+4020]
	imul	eax, DWORD PTR _iY$[esp-4]
	add	eax, DWORD PTR _iX$[esp-4]

; 184  : #endif
; 185  : 	}

	ret	8
?plotNum@CvMap@@QBEHHH@Z ENDP				; CvMap::plotNum
_TEXT	ENDS
PUBLIC	?plot@CvMap@@QBEPAVCvPlot@@HH@Z			; CvMap::plot
; Function compile flags: /Ogtpy
;	COMDAT ?plot@CvMap@@QBEPAVCvPlot@@HH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?plot@CvMap@@QBEPAVCvPlot@@HH@Z PROC			; CvMap::plot, COMDAT
; _this$ = ecx

; 273  : 		if((iX == INVALID_PLOT_COORD) || (iY == INVALID_PLOT_COORD))

	mov	eax, DWORD PTR _iX$[esp-4]
	push	ebp
	cmp	eax, -2147483647			; 80000001H
	je	$LN1@plot
	mov	ebp, DWORD PTR _iY$[esp]
	cmp	ebp, -2147483647			; 80000001H
	je	$LN1@plot

; 276  : 		}
; 277  : 		int iMapX = coordRange(iX, getGridWidth(), isWrapX());

	cmp	BYTE PTR [ecx+4056], 0
	push	ebx
	push	esi
	mov	esi, DWORD PTR [ecx+4020]
	push	edi
	je	SHORT $LN11@plot
	test	eax, eax
	jge	SHORT $LN13@plot
	cdq
	idiv	esi
	mov	edi, edx
	add	edi, esi
	jmp	SHORT $LN15@plot
$LN13@plot:
	cmp	eax, esi
	jl	SHORT $LN11@plot
	cdq
	idiv	esi
	mov	edi, edx
	jmp	SHORT $LN15@plot
$LN11@plot:
	mov	edi, eax
$LN15@plot:

; 278  : 		int iMapY = coordRange(iY, getGridHeight(), isWrapY());

	cmp	BYTE PTR [ecx+4057], 0
	mov	ebx, DWORD PTR [ecx+4024]
	je	SHORT $LN40@plot
	test	ebp, ebp
	jge	SHORT $LN23@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN25@plot
$LN23@plot:
	cmp	ebp, ebx
	jl	SHORT $LN40@plot
	mov	eax, ebp
	cdq
	idiv	ebx
	jmp	SHORT $LN25@plot
$LN40@plot:
	mov	edx, ebp
$LN25@plot:

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	test	edi, edi
	jl	SHORT $LN5@plot
	cmp	edi, esi
	jge	SHORT $LN5@plot
	test	edx, edx
	jl	SHORT $LN5@plot
	cmp	edx, ebx
	jge	SHORT $LN5@plot
	imul	esi, edx
	add	esi, edi
	imul	esi, 484				; 000001e4H
	add	esi, DWORD PTR [ecx+4068]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	pop	ebp

; 280  : 	}

	ret	8
$LN5@plot:
	pop	edi
	pop	esi
	pop	ebx

; 279  : 		return ((isPlot(iMapX, iMapY)) ? &(m_pMapPlots[plotNum(iMapX, iMapY)]) : NULL);

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
$LN1@plot:

; 274  : 		{
; 275  : 			return NULL;

	xor	eax, eax
	pop	ebp

; 280  : 	}

	ret	8
?plot@CvMap@@QBEPAVCvPlot@@HH@Z ENDP			; CvMap::plot
_TEXT	ENDS
PUBLIC	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_eDirection$ = 16					; size = 4
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z PROC ; plotDirection, COMDAT

; 194  : 	if(eDirection == NO_DIRECTION)

	mov	ecx, DWORD PTR _eDirection$[esp-4]
	push	ebx
	push	ebp
	push	esi
	push	edi
	cmp	ecx, -1
	jne	$LN2@plotDirect

; 195  : 	{
; 196  : 		return GC.getMap().plot(iX, iY);

	mov	eax, DWORD PTR _iX$[esp+12]
	cmp	eax, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebx, DWORD PTR _iY$[esp+12]
	cmp	ebx, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN99@plotDirect
	test	eax, eax
	jge	SHORT $LN19@plotDirect
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN21@plotDirect
$LN19@plotDirect:
	cmp	eax, ecx
	jl	SHORT $LN99@plotDirect
	cdq
	idiv	ecx
	mov	esi, edx
	jmp	SHORT $LN21@plotDirect
$LN99@plotDirect:
	mov	esi, eax
$LN21@plotDirect:
	cmp	BYTE PTR [ebp+4057], 0
	mov	edi, DWORD PTR [ebp+4024]
	je	SHORT $LN101@plotDirect
	test	ebx, ebx
	jge	SHORT $LN29@plotDirect
	mov	eax, ebx
	cdq
	idiv	edi
	add	edx, edi
	jmp	SHORT $LN31@plotDirect
$LN29@plotDirect:
	cmp	ebx, edi
	jl	SHORT $LN101@plotDirect
	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN31@plotDirect
$LN101@plotDirect:
	mov	edx, ebx
$LN31@plotDirect:
	test	esi, esi
	jl	$LN59@plotDirect
	cmp	esi, ecx
	jge	$LN59@plotDirect
	test	edx, edx
	jl	$LN59@plotDirect
	cmp	edx, edi
	jge	$LN59@plotDirect
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ecx
	pop	ebx

; 209  : 	}
; 210  : }

	ret	0
$LN2@plotDirect:

; 197  : 	}
; 198  : 	else
; 199  : 	{
; 200  : 		// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 201  : 		iX = xToHexspaceX(iX , iY);

	mov	esi, DWORD PTR _iY$[esp+12]
	test	esi, esi
	jl	SHORT $LN47@plotDirect
	mov	eax, esi
	jmp	SHORT $LN103@plotDirect
$LN47@plotDirect:
	lea	eax, DWORD PTR [esi-1]
	cdq
	sub	eax, edx
$LN103@plotDirect:

; 202  : 		iX += GC.getPlotDirectionX()[eDirection];

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A[ecx*4+112]
	mov	edi, DWORD PTR _iX$[esp+12]
	sar	eax, 1
	sub	edx, eax
	add	edi, edx

; 203  : 		iY += GC.getPlotDirectionY()[eDirection];

	add	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A[ecx*4+136]

; 204  : 
; 205  : 		// convert from hex-space coordinates to the storage array
; 206  : 		iX = hexspaceXToX(iX, iY);

	js	SHORT $LN55@plotDirect
	mov	eax, esi
	jmp	SHORT $LN104@plotDirect
$LN55@plotDirect:
	lea	eax, DWORD PTR [esi-1]
	cdq
	sub	eax, edx
$LN104@plotDirect:
	sar	eax, 1
	add	edi, eax

; 207  : 
; 208  : 		return GC.getMap().plot(iX, iY);

	cmp	edi, -2147483647			; 80000001H
	je	$LN59@plotDirect
	cmp	esi, -2147483647			; 80000001H
	je	$LN59@plotDirect
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN69@plotDirect
	test	edi, edi
	jge	SHORT $LN71@plotDirect
	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, edx
	add	edi, ecx
	jmp	SHORT $LN69@plotDirect
$LN71@plotDirect:
	cmp	edi, ecx
	jl	SHORT $LN69@plotDirect
	mov	eax, edi
	cdq
	idiv	ecx
	mov	edi, edx
$LN69@plotDirect:
	cmp	BYTE PTR [ebp+4057], 0
	mov	ebx, DWORD PTR [ebp+4024]
	je	SHORT $LN100@plotDirect
	test	esi, esi
	jge	SHORT $LN81@plotDirect
	mov	eax, esi
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN83@plotDirect
$LN81@plotDirect:
	cmp	esi, ebx
	jl	SHORT $LN100@plotDirect
	mov	eax, esi
	cdq
	idiv	ebx
	jmp	SHORT $LN83@plotDirect
$LN100@plotDirect:
	mov	edx, esi
$LN83@plotDirect:
	test	edi, edi
	jl	SHORT $LN59@plotDirect
	cmp	edi, ecx
	jge	SHORT $LN59@plotDirect
	test	edx, edx
	jl	SHORT $LN59@plotDirect
	cmp	edx, ebx
	jge	SHORT $LN59@plotDirect
	imul	ecx, edx
	add	ecx, edi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, ecx
	pop	ebx

; 209  : 	}
; 210  : }

	ret	0

; 207  : 
; 208  : 		return GC.getMap().plot(iX, iY);

$LN59@plotDirect:
	pop	edi
	pop	esi
	pop	ebp
	xor	eax, eax
	pop	ebx

; 209  : 	}
; 210  : }

	ret	0
?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ENDP ; plotDirection
_TEXT	ENDS
PUBLIC	?plotXY@@YAPAVCvPlot@@HHHH@Z			; plotXY
; Function compile flags: /Ogtpy
;	COMDAT ?plotXY@@YAPAVCvPlot@@HHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
?plotXY@@YAPAVCvPlot@@HHHH@Z PROC			; plotXY, COMDAT

; 214  : 	// convert the start coord to hex-space coordinates
; 215  : 	int iStartHexX = xToHexspaceX(iX, iY);

	mov	ecx, DWORD PTR _iY$[esp-4]
	test	ecx, ecx
	jl	SHORT $LN5@plotXY
	mov	eax, ecx
	jmp	SHORT $LN55@plotXY
$LN5@plotXY:
	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
$LN55@plotXY:
	push	esi

; 216  : 
; 217  : 	int iPlotHexX = iStartHexX + iDX;

	mov	esi, DWORD PTR _iX$[esp]
	sar	eax, 1
	sub	esi, eax

; 218  : 	int iPlotY = iY + iDY; // Y is the same in both coordinate systems

	mov	eax, DWORD PTR _iDY$[esp]
	add	esi, DWORD PTR _iDX$[esp]
	push	edi
	lea	edi, DWORD PTR [ecx+eax]

; 219  : 
; 220  : 	// convert from hex-space coordinates to the storage array
; 221  : 	iPlotHexX = hexspaceXToX(iPlotHexX, iPlotY);

	test	edi, edi
	jl	SHORT $LN9@plotXY
	mov	eax, edi
	jmp	SHORT $LN56@plotXY
$LN9@plotXY:
	lea	eax, DWORD PTR [edi-1]
	cdq
	sub	eax, edx
$LN56@plotXY:
	sar	eax, 1
	add	esi, eax

; 222  : 
; 223  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

	cmp	esi, -2147483647			; 80000001H
	je	$LN13@plotXY
	cmp	edi, -2147483647			; 80000001H
	je	$LN13@plotXY
	push	ebp
	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [ebp+4056], 0
	mov	ecx, DWORD PTR [ebp+4020]
	je	SHORT $LN23@plotXY
	test	esi, esi
	jge	SHORT $LN25@plotXY
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
	add	esi, ecx
	jmp	SHORT $LN23@plotXY
$LN25@plotXY:
	cmp	esi, ecx
	jl	SHORT $LN23@plotXY
	mov	eax, esi
	cdq
	idiv	ecx
	mov	esi, edx
$LN23@plotXY:
	cmp	BYTE PTR [ebp+4057], 0
	push	ebx
	mov	ebx, DWORD PTR [ebp+4024]
	je	SHORT $LN52@plotXY
	test	edi, edi
	jge	SHORT $LN35@plotXY
	mov	eax, edi
	cdq
	idiv	ebx
	add	edx, ebx
	jmp	SHORT $LN37@plotXY
$LN35@plotXY:
	cmp	edi, ebx
	jl	SHORT $LN52@plotXY
	mov	eax, edi
	cdq
	idiv	ebx
	jmp	SHORT $LN37@plotXY
$LN52@plotXY:
	mov	edx, edi
$LN37@plotXY:
	test	esi, esi
	jl	SHORT $LN17@plotXY
	cmp	esi, ecx
	jge	SHORT $LN17@plotXY
	test	edx, edx
	jl	SHORT $LN17@plotXY
	cmp	edx, ebx
	jge	SHORT $LN17@plotXY
	imul	ecx, edx
	add	ecx, esi
	imul	ecx, 484				; 000001e4H
	add	ecx, DWORD PTR [ebp+4068]
	pop	ebx
	pop	ebp
	pop	edi
	mov	eax, ecx
	pop	esi

; 224  : }

	ret	0

; 222  : 
; 223  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

$LN17@plotXY:
	pop	ebx
	pop	ebp
	pop	edi
	xor	eax, eax
	pop	esi

; 224  : }

	ret	0

; 222  : 
; 223  : 	return GC.getMap().plot(iPlotHexX , iPlotY);

$LN13@plotXY:
	pop	edi
	xor	eax, eax
	pop	esi

; 224  : }

	ret	0
?plotXY@@YAPAVCvPlot@@HHHH@Z ENDP			; plotXY
_TEXT	ENDS
PUBLIC	?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z	; plotXYWithRangeCheck
; Function compile flags: /Ogtpy
;	COMDAT ?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iDX$ = 16						; size = 4
_iDY$ = 20						; size = 4
_iRange$ = 24						; size = 4
?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z PROC	; plotXYWithRangeCheck, COMDAT

; 234  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 235  : 	// I'm assuming iDX and iDY are in hex-space
; 236  : 	if (hexDistance(iDX, iDY) > iRange)
; 237  : #else
; 238  : 	int hexRange;
; 239  : 
; 240  : 	// I'm assuming iDX and iDY are in hex-space
; 241  : 	if((iDX >= 0) == (iDY >= 0))  // the signs match

	mov	edx, DWORD PTR _iDX$[esp-4]
	xor	eax, eax
	test	edx, edx
	setge	al
	xor	ecx, ecx
	push	esi
	mov	esi, DWORD PTR _iDY$[esp]
	test	esi, esi
	setge	cl
	cmp	eax, ecx

; 242  : 	{
; 243  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	mov	ecx, edx
	jne	SHORT $LN3@plotXYWith
	test	edx, edx
	jge	SHORT $LN7@plotXYWith
	neg	ecx
$LN7@plotXYWith:

; 244  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	mov	eax, esi
	test	esi, esi
	jge	SHORT $LN9@plotXYWith
	neg	eax
$LN9@plotXYWith:

; 245  : 		hexRange = iAbsDX + iAbsDY;

	add	eax, ecx

; 246  : 	}
; 247  : 	else

	jmp	SHORT $LN14@plotXYWith
$LN3@plotXYWith:

; 248  : 	{
; 249  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	test	edx, edx
	jge	SHORT $LN11@plotXYWith
	neg	ecx
$LN11@plotXYWith:

; 250  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	mov	eax, esi
	test	esi, esi
	jge	SHORT $LN13@plotXYWith
	neg	eax
$LN13@plotXYWith:

; 251  : 		hexRange = iAbsDX >= iAbsDY ? iAbsDX : iAbsDY;

	cmp	ecx, eax
	jl	SHORT $LN14@plotXYWith
	mov	eax, ecx
$LN14@plotXYWith:

; 252  : 	}
; 253  : 
; 254  : 	if(hexRange > iRange)

	cmp	eax, DWORD PTR _iRange$[esp]
	jle	SHORT $LN1@plotXYWith

; 255  : #endif
; 256  : 	{
; 257  : 		return NULL;

	xor	eax, eax
	pop	esi

; 261  : }

	ret	0
$LN1@plotXYWith:

; 258  : 	}
; 259  : 
; 260  : 	return plotXY(iX, iY, iDX, iDY);

	mov	eax, DWORD PTR _iX$[esp]
	push	esi
	push	edx
	mov	edx, DWORD PTR _iY$[esp+8]
	push	edx
	push	eax
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	add	esp, 16					; 00000010H
	pop	esi

; 261  : }

	ret	0
?plotXYWithRangeCheck@@YAPAVCvPlot@@HHHHH@Z ENDP	; plotXYWithRangeCheck
_TEXT	ENDS
PUBLIC	?Uninit@CvDangerPlots@@QAEXXZ			; CvDangerPlots::Uninit
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvdangerplots.cpp
;	COMDAT ?Uninit@CvDangerPlots@@QAEXXZ
_TEXT	SEGMENT
?Uninit@CvDangerPlots@@QAEXXZ PROC			; CvDangerPlots::Uninit, COMDAT
; _this$ = ecx

; 82   : 	m_ePlayer = NO_PLAYER;
; 83   : #ifdef AUI_DANGER_PLOTS_FIX_USE_ARRAY_NOT_FFASTVECTOR
; 84   : 	if (m_DangerPlots)
; 85   : 		SAFE_DELETE_ARRAY(m_DangerPlots);
; 86   : #else
; 87   : 	m_DangerPlots.clear();

	xor	eax, eax
	mov	DWORD PTR [ecx], -1
	mov	DWORD PTR [ecx+100], eax

; 88   : 	m_bArrayAllocated = false;

	mov	BYTE PTR [ecx+4], al

; 89   : #endif
; 90   : 	m_bDirty = false;

	mov	BYTE PTR [ecx+5], al

; 91   : }

	ret	0
?Uninit@CvDangerPlots@@QAEXXZ ENDP			; CvDangerPlots::Uninit
_TEXT	ENDS
PUBLIC	?GetCityDanger@CvDangerPlots@@QAEHPAVCvCity@@@Z	; CvDangerPlots::GetCityDanger
EXTRN	?plot@CvCity@@QBEPAVCvPlot@@XZ:PROC		; CvCity::plot
; Function compile flags: /Ogtpy
;	COMDAT ?GetCityDanger@CvDangerPlots@@QAEHPAVCvCity@@@Z
_TEXT	SEGMENT
_iDangerValue$ = -20					; size = 4
tv197 = -16						; size = 4
_pPlot$ = -12						; size = 4
_this$ = -8						; size = 4
tv193 = -4						; size = 4
tv294 = 8						; size = 4
_pCity$ = 8						; size = 4
?GetCityDanger@CvDangerPlots@@QAEHPAVCvCity@@@Z PROC	; CvDangerPlots::GetCityDanger, COMDAT
; _this$ = ecx

; 323  : {

	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[esp+20], ecx

; 324  : 	CvAssertMsg(pCity, "pCity is null");
; 325  : 	if(!pCity) return 0;

	mov	ecx, DWORD PTR _pCity$[esp+16]
	test	ecx, ecx
	jne	SHORT $LN8@GetCityDan
	xor	eax, eax

; 360  : }

	add	esp, 20					; 00000014H
	ret	4
$LN8@GetCityDan:
	push	ebp
	push	esi
	push	edi

; 326  : 
; 327  : 	CvAssertMsg(pCity->getOwner() == m_ePlayer, "City does not belong to us");
; 328  : 
; 329  : 	CvPlot* pPlot = pCity->plot();

	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot

; 330  : 	int iEvalRange = GC.getAI_DIPLO_PLOT_RANGE_FROM_CITY_HOME_FRONT();

	mov	ebp, DWORD PTR ?gGlobals@@3VCvGlobals@@A+2704

; 331  : 
; 332  : 	int iDangerValue = 0;
; 333  : 
; 334  : #ifdef AUI_HEXSPACE_DX_LOOPS
; 335  : 	CvPlot* pEvalPlot;
; 336  : 	for (int iDY = -iEvalRange; iDY <= iEvalRange; iDY++)
; 337  : 	{
; 338  : 		int iMaxDX = iEvalRange - MAX(0, iDY);
; 339  : 		for (int iDX = -iEvalRange - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 340  : 		{
; 341  : 			// No need for range check because loops are set up properly
; 342  : 			pEvalPlot = plotXY(pPlot->getX(), pPlot->getY(), iDX, iDY);
; 343  : #else
; 344  : 	for(int iX = -iEvalRange; iX <= iEvalRange; iX++)

	mov	esi, ebp
	neg	esi
	mov	edi, esi
	cmp	edi, ebp
	mov	DWORD PTR _pPlot$[esp+32], eax
	mov	DWORD PTR _iDangerValue$[esp+32], 0
	mov	DWORD PTR tv193[esp+32], esi
	jg	$LN5@GetCityDan
	mov	edx, edi
	neg	edx
	mov	DWORD PTR tv294[esp+28], edx
	push	ebx
	npad	4
$LL50@GetCityDan:

; 345  : 	{
; 346  : 		for(int iY = -iEvalRange; iY <= iEvalRange; iY++)

	cmp	esi, ebp
	jg	$LN6@GetCityDan

; 347  : 		{
; 348  : 			CvPlot* pEvalPlot = plotXYWithRangeCheck(pPlot->getX(), pPlot->getY(), iX, iY, iEvalRange);

	xor	eax, eax
	test	edi, edi
	setge	al
	mov	ebx, esi
	neg	ebx
	mov	DWORD PTR tv197[esp+36], eax
$LL49@GetCityDan:
	xor	ecx, ecx
	test	esi, esi
	setge	cl
	cmp	DWORD PTR tv197[esp+36], ecx
	mov	ecx, edi
	jne	SHORT $LN19@GetCityDan
	test	edi, edi
	jge	SHORT $LN23@GetCityDan
	mov	ecx, edx
$LN23@GetCityDan:
	mov	eax, esi
	test	esi, esi
	jge	SHORT $LN25@GetCityDan
	mov	eax, ebx
$LN25@GetCityDan:
	add	eax, ecx
	jmp	SHORT $LN30@GetCityDan
$LN19@GetCityDan:
	test	edi, edi
	jge	SHORT $LN27@GetCityDan
	mov	ecx, edx
$LN27@GetCityDan:
	mov	eax, esi
	test	esi, esi
	jge	SHORT $LN29@GetCityDan
	mov	eax, ebx
$LN29@GetCityDan:
	cmp	ecx, eax
	jl	SHORT $LN30@GetCityDan
	mov	eax, ecx
$LN30@GetCityDan:
	cmp	eax, ebp
	jg	SHORT $LN3@GetCityDan
	mov	eax, DWORD PTR _pPlot$[esp+36]
	movsx	edx, WORD PTR [eax+2]
	movsx	eax, WORD PTR [eax]
	push	esi
	push	edi
	push	edx
	push	eax
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	add	esp, 16					; 00000010H

; 349  : #endif
; 350  : 			if(!pEvalPlot)

	test	eax, eax
	je	SHORT $LN48@GetCityDan

; 351  : 			{
; 352  : 				continue;
; 353  : 			}
; 354  : 
; 355  : 			iDangerValue += GetDanger(*pEvalPlot);

	movsx	ecx, WORD PTR [eax+2]
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	imul	ecx, DWORD PTR [edx+4020]
	movsx	eax, WORD PTR [eax]
	mov	edx, DWORD PTR _this$[esp+36]
	add	ecx, eax
	mov	eax, DWORD PTR [edx+96]
	mov	ecx, DWORD PTR [eax+ecx*4]
	add	DWORD PTR _iDangerValue$[esp+36], ecx
$LN48@GetCityDan:
	mov	edx, DWORD PTR tv294[esp+32]
$LN3@GetCityDan:

; 345  : 	{
; 346  : 		for(int iY = -iEvalRange; iY <= iEvalRange; iY++)

	inc	esi
	dec	ebx
	cmp	esi, ebp
	jle	$LL49@GetCityDan
	mov	esi, DWORD PTR tv193[esp+36]
$LN6@GetCityDan:

; 331  : 
; 332  : 	int iDangerValue = 0;
; 333  : 
; 334  : #ifdef AUI_HEXSPACE_DX_LOOPS
; 335  : 	CvPlot* pEvalPlot;
; 336  : 	for (int iDY = -iEvalRange; iDY <= iEvalRange; iDY++)
; 337  : 	{
; 338  : 		int iMaxDX = iEvalRange - MAX(0, iDY);
; 339  : 		for (int iDX = -iEvalRange - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 340  : 		{
; 341  : 			// No need for range check because loops are set up properly
; 342  : 			pEvalPlot = plotXY(pPlot->getX(), pPlot->getY(), iDX, iDY);
; 343  : #else
; 344  : 	for(int iX = -iEvalRange; iX <= iEvalRange; iX++)

	inc	edi
	dec	edx
	cmp	edi, ebp
	mov	DWORD PTR tv294[esp+32], edx
	jle	$LL50@GetCityDan
	pop	ebx
$LN5@GetCityDan:

; 356  : 		}
; 357  : 	}
; 358  : 
; 359  : 	return iDangerValue;

	mov	eax, DWORD PTR _iDangerValue$[esp+32]
	pop	edi
	pop	esi
	pop	ebp

; 360  : }

	add	esp, 20					; 00000014H
	ret	4
?GetCityDanger@CvDangerPlots@@QAEHPAVCvCity@@@Z ENDP	; CvDangerPlots::GetCityDanger
_TEXT	ENDS
PUBLIC	?ModifyDangerByRelationship@CvDangerPlots@@QAEHW4PlayerTypes@@PAVCvPlot@@H@Z ; CvDangerPlots::ModifyDangerByRelationship
EXTRN	?GetMinorCivApproach@CvDiplomacyAI@@QBE?AW4MinorCivApproachTypes@@W4PlayerTypes@@@Z:PROC ; CvDiplomacyAI::GetMinorCivApproach
EXTRN	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z:PROC ; CvDiplomacyAI::GetMajorCivApproach
EXTRN	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ:PROC ; CvPlayer::GetDiplomacyAI
EXTRN	?isMinorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMinorCiv
EXTRN	?isHuman@CvPlayer@@QBE_NXZ:PROC			; CvPlayer::isHuman
EXTRN	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z:PROC	; CvTeam::isAtWar
EXTRN	__ftol2_sse_excpt:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?ModifyDangerByRelationship@CvDangerPlots@@QAEHW4PlayerTypes@@PAVCvPlot@@H@Z
_TEXT	SEGMENT
_bIgnoreInFriendlyTerritory$ = -1			; size = 1
_ePlayer$ = 8						; size = 4
_pPlot$ = 12						; size = 4
_iDanger$ = 16						; size = 4
?ModifyDangerByRelationship@CvDangerPlots@@QAEHW4PlayerTypes@@PAVCvPlot@@H@Z PROC ; CvDangerPlots::ModifyDangerByRelationship, COMDAT
; _this$ = ecx

; 363  : {

	push	ecx
	push	ebx

; 364  : 	CvAssertMsg(pPlot, "No plot passed in?");
; 365  : 	bool bIgnoreInFriendlyTerritory = false;
; 366  : 	int iResult = iDanger;
; 367  : 
; 368  : 	// Full value if a player we're at war with
; 369  : 	if(GET_TEAM(GET_PLAYER(m_ePlayer).getTeam()).isAtWar(GET_PLAYER(ePlayer).getTeam()))

	mov	ebx, DWORD PTR _ePlayer$[esp+4]
	push	ebp
	mov	ebp, DWORD PTR _iDanger$[esp+8]
	push	esi
	push	edi
	mov	edi, ebx
	imul	edi, 63236				; 0000f704H
	mov	esi, ecx
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [edi+ecx+44]
	mov	BYTE PTR _bIgnoreInFriendlyTerritory$[esp+20], 0
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN32@ModifyDang
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN33@ModifyDang
$LN32@ModifyDang:
	or	eax, -1
$LN33@ModifyDang:
	mov	edx, DWORD PTR [esi]
	imul	edx, 63236				; 0000f704H
	mov	ecx, DWORD PTR [edx+ecx+44]
	cmp	ecx, 63					; 0000003fH
	ja	SHORT $LN43@ModifyDang
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN44@ModifyDang
$LN43@ModifyDang:
	or	ecx, -1
$LN44@ModifyDang:
	imul	ecx, 2980				; 00000ba4H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	eax
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al

; 370  : 	{
; 371  : 		return iResult;

	jne	$LN1@ModifyDang

; 372  : 	}
; 373  : 
; 374  : 	// if it's a human player, ignore neutral units
; 375  : 	if(GET_PLAYER(m_ePlayer).isHuman())

	mov	ecx, DWORD PTR [esi]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN22@ModifyDang
	pop	edi
	pop	esi
	pop	ebp

; 376  : 	{
; 377  : 		return 0;

	xor	eax, eax
	pop	ebx

; 450  : }

	pop	ecx
	ret	12					; 0000000cH
$LN22@ModifyDang:

; 378  : 	}
; 379  : 
; 380  : 	if(GET_PLAYER(m_ePlayer).isMinorCiv())  // if the evaluator is a minor civ

	mov	ecx, DWORD PTR [esi]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	je	SHORT $LN21@ModifyDang

; 381  : 	{
; 382  : 		if(!GET_TEAM(GET_PLAYER(m_ePlayer).getTeam()).isAtWar(GET_PLAYER(ePlayer).getTeam()))  // and they're not at war with the other player

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edi, DWORD PTR [edi+eax+44]
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	edi, 63					; 0000003fH
	ja	SHORT $LN60@ModifyDang
	mov	edx, DWORD PTR [ecx+4]
	mov	edi, DWORD PTR [edx+edi*4]
	jmp	SHORT $LN61@ModifyDang
$LN60@ModifyDang:
	or	edi, -1
$LN61@ModifyDang:
	mov	edx, DWORD PTR [esi]
	imul	edx, 63236				; 0000f704H
	mov	eax, DWORD PTR [edx+eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN71@ModifyDang
	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN72@ModifyDang
$LN71@ModifyDang:
	or	eax, -1
$LN72@ModifyDang:
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	edi
	mov	ecx, eax
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	jne	$LN86@ModifyDang

; 383  : 		{
; 384  : 			bIgnoreInFriendlyTerritory = true; // ignore friendly territory

	mov	BYTE PTR _bIgnoreInFriendlyTerritory$[esp+20], 1

; 385  : 		}
; 386  : 	}

	jmp	$LN86@ModifyDang
$LN21@ModifyDang:

; 387  : 	else if(!GET_PLAYER(ePlayer).isMinorCiv())

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [edi+edx]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv

; 388  : 	{
; 389  : 		// should we be using bHideTrueFeelings?
; 390  : 		switch(GET_PLAYER(m_ePlayer).GetDiplomacyAI()->GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ false))

	mov	ecx, DWORD PTR [esi]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	test	al, al
	jne	$LN18@ModifyDang
	push	0
	push	ebx
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z ; CvDiplomacyAI::GetMajorCivApproach
	cmp	eax, 6
	ja	$LN86@ModifyDang
	jmp	DWORD PTR $LN90@ModifyDang[eax*4]
$LN15@ModifyDang:

; 391  : 		{
; 392  : 		case MAJOR_CIV_APPROACH_WAR:
; 393  : 			iResult = (int)(iResult * m_fMajorWarMod);

	fild	DWORD PTR _iDanger$[esp+16]
	fmul	QWORD PTR [esi+8]

; 394  : 			break;

	jmp	$LN88@ModifyDang
$LN14@ModifyDang:

; 395  : 		case MAJOR_CIV_APPROACH_HOSTILE:
; 396  : 			iResult = (int)(iResult * m_fMajorHostileMod);

	fild	DWORD PTR _iDanger$[esp+16]
	fmul	QWORD PTR [esi+16]
	call	__ftol2_sse_excpt

; 397  : 			bIgnoreInFriendlyTerritory = true;

	mov	BYTE PTR _bIgnoreInFriendlyTerritory$[esp+20], 1

; 398  : 			break;

	jmp	$LN89@ModifyDang
$LN13@ModifyDang:

; 399  : 		case MAJOR_CIV_APPROACH_DECEPTIVE:
; 400  : 			iResult = (int)(iResult * m_fMajorDeceptiveMod);

	fild	DWORD PTR _iDanger$[esp+16]
	fmul	QWORD PTR [esi+24]
	call	__ftol2_sse_excpt

; 401  : 			bIgnoreInFriendlyTerritory = true;

	mov	BYTE PTR _bIgnoreInFriendlyTerritory$[esp+20], 1

; 402  : 			break;

	jmp	$LN89@ModifyDang
$LN12@ModifyDang:

; 403  : 		case MAJOR_CIV_APPROACH_GUARDED:
; 404  : 			iResult = (int)(iResult * m_fMajorGuardedMod);

	fild	DWORD PTR _iDanger$[esp+16]
	fmul	QWORD PTR [esi+32]
	call	__ftol2_sse_excpt

; 405  : 			bIgnoreInFriendlyTerritory = true;

	mov	BYTE PTR _bIgnoreInFriendlyTerritory$[esp+20], 1

; 406  : 			break;

	jmp	$LN89@ModifyDang
$LN11@ModifyDang:

; 407  : 		case MAJOR_CIV_APPROACH_AFRAID:
; 408  : 			iResult = (int)(iResult * m_fMajorAfraidMod);

	fild	DWORD PTR _iDanger$[esp+16]
	fmul	QWORD PTR [esi+40]
	call	__ftol2_sse_excpt

; 409  : 			bIgnoreInFriendlyTerritory = true;

	mov	BYTE PTR _bIgnoreInFriendlyTerritory$[esp+20], 1

; 410  : 			break;

	jmp	SHORT $LN89@ModifyDang
$LN10@ModifyDang:

; 411  : 		case MAJOR_CIV_APPROACH_FRIENDLY:
; 412  : 			iResult = (int)(iResult * m_fMajorFriendlyMod);

	fild	DWORD PTR _iDanger$[esp+16]
	fmul	QWORD PTR [esi+48]
	call	__ftol2_sse_excpt

; 413  : 			bIgnoreInFriendlyTerritory = true;

	mov	BYTE PTR _bIgnoreInFriendlyTerritory$[esp+20], 1

; 414  : 			break;

	jmp	SHORT $LN89@ModifyDang
$LN9@ModifyDang:

; 415  : 		case MAJOR_CIV_APPROACH_NEUTRAL:
; 416  : 			iResult = (int)(iResult * m_fMajorNeutralMod);

	fild	DWORD PTR _iDanger$[esp+16]
	fmul	QWORD PTR [esi+56]
	call	__ftol2_sse_excpt

; 417  : 			bIgnoreInFriendlyTerritory = true;

	mov	BYTE PTR _bIgnoreInFriendlyTerritory$[esp+20], 1

; 418  : 			break;
; 419  : 		}
; 420  : 	}
; 421  : 	else

	jmp	SHORT $LN89@ModifyDang
$LN18@ModifyDang:

; 422  : 	{
; 423  : 		switch(GET_PLAYER(m_ePlayer).GetDiplomacyAI()->GetMinorCivApproach(ePlayer))

	push	ebx
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMinorCivApproach@CvDiplomacyAI@@QBE?AW4MinorCivApproachTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetMinorCivApproach
	cmp	eax, 4
	ja	SHORT $LN86@ModifyDang
	jmp	DWORD PTR $LN91@ModifyDang[eax*4]
$LN5@ModifyDang:

; 424  : 		{
; 425  : 		case MINOR_CIV_APPROACH_IGNORE:
; 426  : 			iResult = (int)(iResult * m_fMinorNeutralrMod);

	fild	DWORD PTR _iDanger$[esp+16]
	fmul	QWORD PTR [esi+64]
	call	__ftol2_sse_excpt

; 427  : 			bIgnoreInFriendlyTerritory = true;

	mov	BYTE PTR _bIgnoreInFriendlyTerritory$[esp+20], 1

; 428  : 			break;

	jmp	SHORT $LN89@ModifyDang
$LN4@ModifyDang:

; 429  : 		case MINOR_CIV_APPROACH_FRIENDLY:
; 430  : 			iResult = (int)(iResult * m_fMinorFriendlyMod);

	fild	DWORD PTR _iDanger$[esp+16]
	fmul	QWORD PTR [esi+72]
	call	__ftol2_sse_excpt

; 431  : 			bIgnoreInFriendlyTerritory = true;

	mov	BYTE PTR _bIgnoreInFriendlyTerritory$[esp+20], 1

; 432  : 			break;

	jmp	SHORT $LN89@ModifyDang
$LN3@ModifyDang:

; 433  : 		case MINOR_CIV_APPROACH_BULLY:
; 434  : 			iResult = (int)(iResult * m_fMinorBullyMod);

	fild	DWORD PTR _iDanger$[esp+16]
	fmul	QWORD PTR [esi+80]

; 435  : 			break;

	jmp	SHORT $LN88@ModifyDang
$LN2@ModifyDang:

; 436  : 		case MINOR_CIV_APPROACH_CONQUEST:
; 437  : 			iResult = (int)(iResult * m_fMinorConquestMod);

	fild	DWORD PTR _iDanger$[esp+16]
	fmul	QWORD PTR [esi+88]
$LN88@ModifyDang:
	call	__ftol2_sse_excpt
$LN89@ModifyDang:
	mov	ebp, eax
$LN86@ModifyDang:

; 438  : 			break;
; 439  : 		}
; 440  : 	}
; 441  : 
; 442  : 	// if the plot is in our own territory and, with the current approach, we should ignore danger values in our own territory
; 443  : 	// zero out the value
; 444  : 	if(pPlot && pPlot->getOwner() == m_ePlayer && bIgnoreInFriendlyTerritory)

	mov	eax, DWORD PTR _pPlot$[esp+16]
	test	eax, eax
	je	SHORT $LN1@ModifyDang
	movsx	eax, BYTE PTR [eax+4]
	cmp	eax, DWORD PTR [esi]
	jne	SHORT $LN1@ModifyDang
	cmp	BYTE PTR _bIgnoreInFriendlyTerritory$[esp+20], 0
	je	SHORT $LN1@ModifyDang

; 445  : 	{
; 446  : 		iResult = 0;

	xor	ebp, ebp
$LN1@ModifyDang:
	pop	edi
	pop	esi

; 447  : 	}
; 448  : 
; 449  : 	return iResult;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 450  : }

	pop	ecx
	ret	12					; 0000000cH
$LN90@ModifyDang:
	DD	$LN15@ModifyDang
	DD	$LN14@ModifyDang
	DD	$LN13@ModifyDang
	DD	$LN12@ModifyDang
	DD	$LN11@ModifyDang
	DD	$LN10@ModifyDang
	DD	$LN9@ModifyDang
$LN91@ModifyDang:
	DD	$LN5@ModifyDang
	DD	$LN4@ModifyDang
	DD	$LN86@ModifyDang
	DD	$LN2@ModifyDang
	DD	$LN3@ModifyDang
?ModifyDangerByRelationship@CvDangerPlots@@QAEHW4PlayerTypes@@PAVCvPlot@@H@Z ENDP ; CvDangerPlots::ModifyDangerByRelationship
_TEXT	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	?IsDangerByRelationshipZero@CvDangerPlots@@IAE_NW4PlayerTypes@@PAVCvPlot@@@Z ; CvDangerPlots::IsDangerByRelationshipZero
;	COMDAT __real@0000000000000000
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvdangerplots.cpp
CONST	ENDS
;	COMDAT ?IsDangerByRelationshipZero@CvDangerPlots@@IAE_NW4PlayerTypes@@PAVCvPlot@@@Z
_TEXT	SEGMENT
_bIgnoreInFriendlyTerritory$ = -1			; size = 1
_ePlayer$ = 8						; size = 4
_pPlot$ = 12						; size = 4
?IsDangerByRelationshipZero@CvDangerPlots@@IAE_NW4PlayerTypes@@PAVCvPlot@@@Z PROC ; CvDangerPlots::IsDangerByRelationshipZero, COMDAT
; _this$ = ecx

; 456  : {

	push	ecx

; 457  : 	CvAssertMsg(pPlot, "No plot passed in?");
; 458  : 	bool bIgnoreInFriendlyTerritory = false;
; 459  : #ifdef AUI_DANGER_PLOTS_IS_DANGER_BY_RELATIONSHIP_ZERO_MINORS_DO_NOT_IGNORE_TRESSPASSERS
; 460  : 	bool bConsiderInFriendlyTerritory = false;
; 461  : #endif
; 462  : 
; 463  : 	// Full value if a player we're at war with
; 464  : 	if(GET_TEAM(GET_PLAYER(m_ePlayer).getTeam()).isAtWar(GET_PLAYER(ePlayer).getTeam()))

	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR _ePlayer$[esp+16]
	mov	esi, edi
	imul	esi, 63236				; 0000f704H
	mov	ebp, ecx
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [esi+ecx+44]
	mov	BYTE PTR _bIgnoreInFriendlyTerritory$[esp+20], 0
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN54@IsDangerBy
	mov	ebx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ebx+eax*4]
	jmp	SHORT $LN55@IsDangerBy
$LN54@IsDangerBy:
	or	eax, -1
$LN55@IsDangerBy:
	mov	ebx, DWORD PTR [ebp]
	imul	ebx, 63236				; 0000f704H
	mov	ecx, DWORD PTR [ebx+ecx+44]
	cmp	ecx, 63					; 0000003fH
	ja	SHORT $LN65@IsDangerBy
	mov	edx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [edx+ecx*4]
	jmp	SHORT $LN66@IsDangerBy
$LN65@IsDangerBy:
	or	ecx, -1
$LN66@IsDangerBy:
	imul	ecx, 2980				; 00000ba4H
	add	ecx, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	eax
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	je	SHORT $LN23@IsDangerBy
	pop	edi
	pop	esi
	pop	ebp

; 465  : 	{
; 466  : 		return false;

	xor	al, al
	pop	ebx

; 565  : }

	pop	ecx
	ret	8
$LN23@IsDangerBy:

; 467  : 	}
; 468  : 
; 469  : 	// if it's a human player, ignore neutral units
; 470  : 	if(GET_PLAYER(m_ePlayer).isHuman())

	mov	ecx, DWORD PTR [ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	SHORT $LN22@IsDangerBy
	pop	edi
	pop	esi
	pop	ebp

; 471  : 	{
; 472  : 		return true;

	mov	al, 1
	pop	ebx

; 565  : }

	pop	ecx
	ret	8
$LN22@IsDangerBy:

; 473  : 	}
; 474  : 
; 475  : 	bool bResultMultiplierIsZero = false;
; 476  : 	if(GET_PLAYER(m_ePlayer).isMinorCiv())  // if the evaluator is a minor civ

	mov	ecx, DWORD PTR [ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	xor	bl, bl
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	je	SHORT $LN21@IsDangerBy

; 477  : 	{
; 478  : 		if(!GET_TEAM(GET_PLAYER(m_ePlayer).getTeam()).isAtWar(GET_PLAYER(ePlayer).getTeam()))  // and they're not at war with the other player

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	esi, DWORD PTR [esi+eax+44]
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	cmp	esi, 63					; 0000003fH
	ja	SHORT $LN82@IsDangerBy
	mov	edx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [edx+esi*4]
	jmp	SHORT $LN83@IsDangerBy
$LN82@IsDangerBy:
	or	esi, -1
$LN83@IsDangerBy:
	mov	edx, DWORD PTR [ebp]
	imul	edx, 63236				; 0000f704H
	mov	eax, DWORD PTR [edx+eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN93@IsDangerBy
	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN94@IsDangerBy
$LN93@IsDangerBy:
	or	eax, -1
$LN94@IsDangerBy:
	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	esi
	mov	ecx, eax
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al
	jne	$LN108@IsDangerBy

; 479  : 		{
; 480  : #ifdef AUI_DANGER_PLOTS_IS_DANGER_BY_RELATIONSHIP_ZERO_MINORS_DO_NOT_IGNORE_TRESSPASSERS
; 481  : 			bConsiderInFriendlyTerritory = true;
; 482  : #ifndef AUI_DANGER_PLOTS_FIX_IS_DANGER_BY_RELATIONSHIP_ZERO_MINORS_IGNORE_ALL_NONWARRED
; 483  : 			bIgnoreInFriendlyTerritory = true; // ignore friendly territory
; 484  : #endif
; 485  : #elif defined(AUI_DANGER_PLOTS_FIX_IS_DANGER_BY_RELATIONSHIP_ZERO_MINORS_IGNORE_ALL_NONWARRED)
; 486  : 			return true;
; 487  : #else
; 488  : 			bIgnoreInFriendlyTerritory = true; // ignore friendly territory

	mov	BYTE PTR _bIgnoreInFriendlyTerritory$[esp+20], 1

; 489  : #endif
; 490  : 		}
; 491  : 	}

	jmp	$LN108@IsDangerBy
$LN21@IsDangerBy:

; 492  : 	else if(!GET_PLAYER(ePlayer).isMinorCiv())

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [esi+edx]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv

; 493  : 	{
; 494  : 		// should we be using bHideTrueFeelings?
; 495  : 		switch(GET_PLAYER(m_ePlayer).GetDiplomacyAI()->GetMajorCivApproach(ePlayer, /*bHideTrueFeelings*/ false))

	mov	ecx, DWORD PTR [ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	test	al, al
	jne	$LN18@IsDangerBy
	push	0
	push	edi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMajorCivApproach@CvDiplomacyAI@@QBE?AW4MajorCivApproachTypes@@W4PlayerTypes@@_N@Z ; CvDiplomacyAI::GetMajorCivApproach
	cmp	eax, 6
	ja	$LN108@IsDangerBy
	jmp	DWORD PTR $LN113@IsDangerBy[eax*4]
$LN15@IsDangerBy:

; 496  : 		{
; 497  : 		case MAJOR_CIV_APPROACH_WAR:
; 498  : 			bResultMultiplierIsZero = m_fMajorWarMod == 0.f;

	fldz
	fcomp	QWORD PTR [ebp+8]

; 499  : 			break;

	jmp	$LN112@IsDangerBy
$LN14@IsDangerBy:

; 500  : 		case MAJOR_CIV_APPROACH_HOSTILE:
; 501  : 			bResultMultiplierIsZero = m_fMajorHostileMod == 0.f;

	fldz
	fcomp	QWORD PTR [ebp+16]
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN36@IsDangerBy
	mov	bl, 1

; 518  : 			bIgnoreInFriendlyTerritory = true;

	mov	BYTE PTR _bIgnoreInFriendlyTerritory$[esp+20], bl

; 519  : 			break;

	jmp	$LN108@IsDangerBy
$LN13@IsDangerBy:

; 502  : 			bIgnoreInFriendlyTerritory = true;
; 503  : 			break;
; 504  : 		case MAJOR_CIV_APPROACH_DECEPTIVE:
; 505  : 			bResultMultiplierIsZero = m_fMajorDeceptiveMod == 0.f;

	fldz
	fcomp	QWORD PTR [ebp+24]
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN36@IsDangerBy
	mov	bl, 1

; 518  : 			bIgnoreInFriendlyTerritory = true;

	mov	BYTE PTR _bIgnoreInFriendlyTerritory$[esp+20], bl

; 519  : 			break;

	jmp	$LN108@IsDangerBy
$LN12@IsDangerBy:

; 506  : 			bIgnoreInFriendlyTerritory = true;
; 507  : 			break;
; 508  : 		case MAJOR_CIV_APPROACH_GUARDED:
; 509  : 			bResultMultiplierIsZero = m_fMajorGuardedMod == 0.f;

	fldz
	fcomp	QWORD PTR [ebp+32]
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN36@IsDangerBy
	mov	bl, 1

; 518  : 			bIgnoreInFriendlyTerritory = true;

	mov	BYTE PTR _bIgnoreInFriendlyTerritory$[esp+20], bl

; 519  : 			break;

	jmp	$LN108@IsDangerBy
$LN11@IsDangerBy:

; 510  : 			bIgnoreInFriendlyTerritory = true;
; 511  : 			break;
; 512  : 		case MAJOR_CIV_APPROACH_AFRAID:
; 513  : 			bResultMultiplierIsZero = m_fMajorAfraidMod == 0.f;

	fldz
	fcomp	QWORD PTR [ebp+40]
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN36@IsDangerBy
	mov	bl, 1

; 518  : 			bIgnoreInFriendlyTerritory = true;

	mov	BYTE PTR _bIgnoreInFriendlyTerritory$[esp+20], bl

; 519  : 			break;

	jmp	$LN108@IsDangerBy
$LN10@IsDangerBy:

; 514  : 			bIgnoreInFriendlyTerritory = true;
; 515  : 			break;
; 516  : 		case MAJOR_CIV_APPROACH_FRIENDLY:
; 517  : 			bResultMultiplierIsZero = m_fMajorFriendlyMod == 0.f;

	fldz
	fcomp	QWORD PTR [ebp+48]
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN36@IsDangerBy
	mov	bl, 1

; 518  : 			bIgnoreInFriendlyTerritory = true;

	mov	BYTE PTR _bIgnoreInFriendlyTerritory$[esp+20], bl

; 519  : 			break;

	jmp	SHORT $LN108@IsDangerBy
$LN36@IsDangerBy:

; 514  : 			bIgnoreInFriendlyTerritory = true;
; 515  : 			break;
; 516  : 		case MAJOR_CIV_APPROACH_FRIENDLY:
; 517  : 			bResultMultiplierIsZero = m_fMajorFriendlyMod == 0.f;

	xor	bl, bl

; 518  : 			bIgnoreInFriendlyTerritory = true;

	mov	BYTE PTR _bIgnoreInFriendlyTerritory$[esp+20], 1

; 519  : 			break;

	jmp	SHORT $LN108@IsDangerBy
$LN9@IsDangerBy:

; 520  : 		case MAJOR_CIV_APPROACH_NEUTRAL:
; 521  : 			bResultMultiplierIsZero = m_fMajorNeutralMod == 0.f;

	fldz
	fcomp	QWORD PTR [ebp+56]
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN36@IsDangerBy
	mov	bl, 1
	mov	BYTE PTR _bIgnoreInFriendlyTerritory$[esp+20], bl
	jmp	SHORT $LN108@IsDangerBy
$LN18@IsDangerBy:

; 522  : 			bIgnoreInFriendlyTerritory = true;
; 523  : 			break;
; 524  : 		}
; 525  : 	}
; 526  : 	else
; 527  : 	{
; 528  : 		switch(GET_PLAYER(m_ePlayer).GetDiplomacyAI()->GetMinorCivApproach(ePlayer))

	push	edi
	call	?GetDiplomacyAI@CvPlayer@@QBEPAVCvDiplomacyAI@@XZ ; CvPlayer::GetDiplomacyAI
	mov	ecx, eax
	call	?GetMinorCivApproach@CvDiplomacyAI@@QBE?AW4MinorCivApproachTypes@@W4PlayerTypes@@@Z ; CvDiplomacyAI::GetMinorCivApproach
	cmp	eax, 4
	ja	SHORT $LN108@IsDangerBy
	jmp	DWORD PTR $LN114@IsDangerBy[eax*4]
$LN5@IsDangerBy:

; 529  : 		{
; 530  : 		case MINOR_CIV_APPROACH_IGNORE:
; 531  : 			bResultMultiplierIsZero = m_fMinorNeutralrMod == 0.f;

	fldz
	fcomp	QWORD PTR [ebp+64]
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN36@IsDangerBy
	mov	bl, 1
	mov	BYTE PTR _bIgnoreInFriendlyTerritory$[esp+20], bl
	jmp	SHORT $LN108@IsDangerBy
$LN4@IsDangerBy:

; 532  : 			bIgnoreInFriendlyTerritory = true;
; 533  : 			break;
; 534  : 		case MINOR_CIV_APPROACH_FRIENDLY:
; 535  : 			bResultMultiplierIsZero = m_fMinorFriendlyMod == 0.f;

	fldz
	fcomp	QWORD PTR [ebp+72]
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN36@IsDangerBy
	mov	bl, 1
	mov	BYTE PTR _bIgnoreInFriendlyTerritory$[esp+20], bl
	jmp	SHORT $LN108@IsDangerBy
$LN3@IsDangerBy:

; 536  : 			bIgnoreInFriendlyTerritory = true;
; 537  : 			break;
; 538  : 		case MINOR_CIV_APPROACH_BULLY:
; 539  : 			bResultMultiplierIsZero = (m_fMinorBullyMod == 0.f);

	fldz
	fcomp	QWORD PTR [ebp+80]

; 540  : 			break;

	jmp	SHORT $LN112@IsDangerBy
$LN2@IsDangerBy:

; 541  : 		case MINOR_CIV_APPROACH_CONQUEST:
; 542  : 			bResultMultiplierIsZero = m_fMinorConquestMod == 0.f;

	fldz
	fcomp	QWORD PTR [ebp+88]
$LN112@IsDangerBy:
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN46@IsDangerBy
	mov	bl, 1
	jmp	SHORT $LN108@IsDangerBy
$LN46@IsDangerBy:
	xor	bl, bl
$LN108@IsDangerBy:

; 543  : 			break;
; 544  : 		}
; 545  : 	}
; 546  : 
; 547  : 	// if the plot is in our own territory and, with the current approach, we should ignore danger values in our own territory
; 548  : 	// zero out the value
; 549  : #ifdef AUI_DANGER_PLOTS_IS_DANGER_BY_RELATIONSHIP_ZERO_MINORS_DO_NOT_IGNORE_TRESSPASSERS
; 550  : 	if (pPlot && pPlot->getOwner() == m_ePlayer)
; 551  : 	{
; 552  : 		if (bConsiderInFriendlyTerritory)
; 553  : 			return false;
; 554  : 		if (bIgnoreInFriendlyTerritory)
; 555  : 			return true;
; 556  : 	}
; 557  : #else
; 558  : 	if(pPlot && pPlot->getOwner() == m_ePlayer && bIgnoreInFriendlyTerritory)

	mov	eax, DWORD PTR _pPlot$[esp+16]
	test	eax, eax
	je	SHORT $LN1@IsDangerBy
	movsx	eax, BYTE PTR [eax+4]
	cmp	eax, DWORD PTR [ebp]
	jne	SHORT $LN1@IsDangerBy
	cmp	BYTE PTR _bIgnoreInFriendlyTerritory$[esp+20], 0

; 559  : 	{
; 560  : 		return true;

	mov	al, 1
	jne	SHORT $LN24@IsDangerBy
$LN1@IsDangerBy:

; 561  : 	}
; 562  : #endif
; 563  : 
; 564  : 	return bResultMultiplierIsZero;

	mov	al, bl
$LN24@IsDangerBy:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 565  : }

	pop	ecx
	ret	8
$LN113@IsDangerBy:
	DD	$LN15@IsDangerBy
	DD	$LN14@IsDangerBy
	DD	$LN13@IsDangerBy
	DD	$LN12@IsDangerBy
	DD	$LN11@IsDangerBy
	DD	$LN10@IsDangerBy
	DD	$LN9@IsDangerBy
$LN114@IsDangerBy:
	DD	$LN5@IsDangerBy
	DD	$LN4@IsDangerBy
	DD	$LN108@IsDangerBy
	DD	$LN2@IsDangerBy
	DD	$LN3@IsDangerBy
?IsDangerByRelationshipZero@CvDangerPlots@@IAE_NW4PlayerTypes@@PAVCvPlot@@@Z ENDP ; CvDangerPlots::IsDangerByRelationshipZero
_TEXT	ENDS
PUBLIC	?ShouldIgnorePlayer@CvDangerPlots@@QAE_NW4PlayerTypes@@@Z ; CvDangerPlots::ShouldIgnorePlayer
EXTRN	?IsFriends@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z:PROC ; CvMinorCivAI::IsFriends
EXTRN	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ:PROC ; CvPlayer::GetMinorCivAI
EXTRN	?isBarbarian@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isBarbarian
; Function compile flags: /Ogtpy
;	COMDAT ?ShouldIgnorePlayer@CvDangerPlots@@QAE_NW4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?ShouldIgnorePlayer@CvDangerPlots@@QAE_NW4PlayerTypes@@@Z PROC ; CvDangerPlots::ShouldIgnorePlayer, COMDAT
; _this$ = ecx

; 575  : 	if(GET_PLAYER(m_ePlayer).isMinorCiv() != GET_PLAYER(ePlayer).isMinorCiv() && !GET_PLAYER(ePlayer).isBarbarian() && !GET_PLAYER(m_ePlayer).isBarbarian())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR _ePlayer$[esp+12]
	mov	ebp, ecx
	imul	edi, 63236				; 0000f704H
	mov	esi, DWORD PTR [ebp]
	imul	esi, 63236				; 0000f704H
	lea	ecx, DWORD PTR [edi+eax]
	add	esi, eax
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	mov	ecx, esi
	mov	bl, al
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	cmp	al, bl
	je	$LN1@ShouldIgno
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [edi+eax]
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	test	al, al
	jne	$LN1@ShouldIgno
	mov	ecx, DWORD PTR [ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	test	al, al
	jne	$LN1@ShouldIgno

; 576  : 	{
; 577  : 		CvPlayer* pMinor = NULL;
; 578  : 		CvPlayer* pMajor;
; 579  : 
; 580  : 		if(GET_PLAYER(m_ePlayer).isMinorCiv())

	mov	ecx, DWORD PTR [ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al

; 581  : 		{
; 582  : 			pMinor = &GET_PLAYER(m_ePlayer);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	je	SHORT $LN5@ShouldIgno
	mov	esi, DWORD PTR [ebp]
	imul	esi, 63236				; 0000f704H
	add	esi, eax

; 583  : 			pMajor = &GET_PLAYER(ePlayer);
; 584  : 		}
; 585  : 		else

	jmp	SHORT $LN35@ShouldIgno
$LN5@ShouldIgno:

; 586  : 		{
; 587  : 			pMinor = &GET_PLAYER(ePlayer);

	lea	esi, DWORD PTR [edi+eax]

; 588  : 			pMajor = &GET_PLAYER(m_ePlayer);

	mov	edi, DWORD PTR [ebp]
	imul	edi, 63236				; 0000f704H
$LN35@ShouldIgno:
	add	edi, eax

; 589  : 		}
; 590  : 
; 591  : 		if(pMinor->GetMinorCivAI()->IsFriends(pMajor->GetID()))

	mov	eax, DWORD PTR [edi+44]
	push	eax
	mov	ecx, esi
	call	?GetMinorCivAI@CvPlayer@@QBEPAVCvMinorCivAI@@XZ ; CvPlayer::GetMinorCivAI
	mov	ecx, eax
	call	?IsFriends@CvMinorCivAI@@QAE_NW4PlayerTypes@@@Z ; CvMinorCivAI::IsFriends
	test	al, al
	je	SHORT $LN3@ShouldIgno
$LN36@ShouldIgno:
	pop	edi
	pop	esi
	pop	ebp

; 592  : 		{
; 593  : 			return true;

	mov	al, 1
	pop	ebx

; 609  : }

	ret	4
$LN3@ShouldIgno:

; 594  : 		}
; 595  : 
; 596  : 		// if we're a major, we should ignore minors that are not at war with us
; 597  : 		if (!GET_PLAYER(m_ePlayer).isMinorCiv())

	mov	ecx, DWORD PTR [ebp]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN1@ShouldIgno

; 598  : 		{
; 599  : 			TeamTypes eMajorTeam = pMajor->getTeam();
; 600  : 			TeamTypes eMinorTeam = pMinor->getTeam();

	mov	ecx, esi
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	mov	ecx, edi
	mov	esi, eax
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam

; 601  : 			if (!GET_TEAM(eMajorTeam).isAtWar(eMinorTeam))

	imul	eax, 2980				; 00000ba4H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	esi
	mov	ecx, eax
	call	?isAtWar@CvTeam@@QBE_NW4TeamTypes@@@Z	; CvTeam::isAtWar
	test	al, al

; 602  : 			{
; 603  : 				return true;

	je	SHORT $LN36@ShouldIgno
$LN1@ShouldIgno:
	pop	edi
	pop	esi
	pop	ebp

; 604  : 			}
; 605  : 		}
; 606  : 	}
; 607  : 
; 608  : 	return false;

	xor	al, al
	pop	ebx

; 609  : }

	ret	4
?ShouldIgnorePlayer@CvDangerPlots@@QAE_NW4PlayerTypes@@@Z ENDP ; CvDangerPlots::ShouldIgnorePlayer
_TEXT	ENDS
PUBLIC	?ShouldIgnoreUnit@CvDangerPlots@@QAE_NPAVCvUnit@@_N@Z ; CvDangerPlots::ShouldIgnoreUnit
EXTRN	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ:PROC ; CvUnit::getDomainType
EXTRN	?isVisibleOtherUnit@CvPlot@@QBE_NW4PlayerTypes@@@Z:PROC ; CvPlot::isVisibleOtherUnit
EXTRN	?isInvisible@CvUnit@@QBE_NW4TeamTypes@@_N1@Z:PROC ; CvUnit::isInvisible
EXTRN	?plot@CvUnit@@QBEPAVCvPlot@@XZ:PROC		; CvUnit::plot
EXTRN	?IsCanAttack@CvUnit@@QBE_NXZ:PROC		; CvUnit::IsCanAttack
; Function compile flags: /Ogtpy
;	COMDAT ?ShouldIgnoreUnit@CvDangerPlots@@QAE_NPAVCvUnit@@_N@Z
_TEXT	SEGMENT
_pUnit$ = 8						; size = 4
_bIgnoreVisibility$ = 12				; size = 1
?ShouldIgnoreUnit@CvDangerPlots@@QAE_NPAVCvUnit@@_N@Z PROC ; CvDangerPlots::ShouldIgnoreUnit, COMDAT
; _this$ = ecx

; 617  : {

	push	ebx
	push	edi

; 618  : 	if(!pUnit->IsCanAttack())

	mov	edi, DWORD PTR _pUnit$[esp+4]
	mov	ebx, ecx
	mov	ecx, edi
	call	?IsCanAttack@CvUnit@@QBE_NXZ		; CvUnit::IsCanAttack
	test	al, al
	jne	SHORT $LN5@ShouldIgno@2
	pop	edi

; 619  : 	{
; 620  : 		return true;

	mov	al, 1
	pop	ebx

; 660  : 	{
; 661  : 		return true;
; 662  : 	}
; 663  : 
; 664  : 	return false;
; 665  : }

	ret	8
$LN5@ShouldIgno@2:

; 621  : 	}
; 622  : 
; 623  : #if defined(AUI_DANGER_PLOTS_SHOULD_IGNORE_UNIT_MINORS_SEE_MAJORS)
; 624  : 	if (pUnit->isInvisible(GET_PLAYER(m_ePlayer).getTeam(), false))
; 625  : 	{
; 626  : 		return true;
; 627  : 	}
; 628  : 
; 629  : 	if (GET_PLAYER(m_ePlayer).isMinorCiv() && !GET_PLAYER(pUnit->getOwner()).isMinorCiv() && !pUnit->isBarbarian() &&
; 630  : 		GET_PLAYER(m_ePlayer).GetClosestFriendlyCity(*pUnit->plot(), AUI_DANGER_PLOTS_SHOULD_IGNORE_UNIT_MINORS_SEE_MAJORS))
; 631  : 		bIgnoreVisibility = true;
; 632  : #endif
; 633  : 
; 634  : #ifdef AUI_DANGER_PLOTS_FIX_SHOULD_IGNORE_UNIT_IGNORE_VISIBILITY_PLOT
; 635  : 	if (!pUnit->plot()->isVisible(GET_PLAYER(m_ePlayer).getTeam()) && !bIgnoreVisibility)
; 636  : #else
; 637  : 	if(!pUnit->plot()->isVisible(GET_PLAYER(m_ePlayer).getTeam()))

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+ecx+44]
	push	esi
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN14@ShouldIgno@2
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	esi, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN15@ShouldIgno@2
$LN14@ShouldIgno@2:
	or	esi, -1
$LN15@ShouldIgno@2:
	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot
	cmp	esi, -1
	je	SHORT $LN37@ShouldIgno@2
	mov	edx, DWORD PTR [eax+156]
	cmp	WORD PTR [edx+esi*2], 0
	setg	al
	test	al, al

; 638  : #endif
; 639  : 	{
; 640  : 		return true;

	je	SHORT $LN37@ShouldIgno@2

; 641  : 	}
; 642  : 
; 643  : #if !defined(AUI_DANGER_PLOTS_SHOULD_IGNORE_UNIT_MINORS_SEE_MAJORS)
; 644  : 	if(pUnit->isInvisible(GET_PLAYER(m_ePlayer).getTeam(), false))

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN30@ShouldIgno@2
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN31@ShouldIgno@2
$LN30@ShouldIgno@2:
	or	eax, -1
$LN31@ShouldIgno@2:
	push	1
	push	0
	push	eax
	mov	ecx, edi
	call	?isInvisible@CvUnit@@QBE_NW4TeamTypes@@_N1@Z ; CvUnit::isInvisible
	test	al, al

; 645  : 	{
; 646  : 		return true;

	jne	SHORT $LN37@ShouldIgno@2

; 647  : 	}
; 648  : #endif
; 649  : 
; 650  : 	CvPlot* pPlot = pUnit->plot();

	mov	ecx, edi
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot

; 651  : 	CvAssertMsg(pPlot, "Plot is null?")
; 652  : 
; 653  : 	if(NULL != pPlot && !pPlot->isVisibleOtherUnit(m_ePlayer) && !bIgnoreVisibility)

	test	eax, eax
	je	SHORT $LN2@ShouldIgno@2
	mov	edx, DWORD PTR [ebx]
	push	edx
	mov	ecx, eax
	call	?isVisibleOtherUnit@CvPlot@@QBE_NW4PlayerTypes@@@Z ; CvPlot::isVisibleOtherUnit
	test	al, al
	jne	SHORT $LN2@ShouldIgno@2
	cmp	BYTE PTR _bIgnoreVisibility$[esp+8], al
	jne	SHORT $LN2@ShouldIgno@2
$LN37@ShouldIgno@2:
	pop	esi
	pop	edi

; 654  : 	{
; 655  : 		return true;

	mov	al, 1
	pop	ebx

; 660  : 	{
; 661  : 		return true;
; 662  : 	}
; 663  : 
; 664  : 	return false;
; 665  : }

	ret	8
$LN2@ShouldIgno@2:

; 656  : 	}
; 657  : 
; 658  : 	// fix post-gold!
; 659  : 	if(pUnit->getDomainType() == DOMAIN_AIR)

	mov	ecx, edi
	call	?getDomainType@CvUnit@@QBE?AW4DomainTypes@@XZ ; CvUnit::getDomainType
	pop	esi
	cmp	eax, 1
	pop	edi
	sete	al
	pop	ebx

; 660  : 	{
; 661  : 		return true;
; 662  : 	}
; 663  : 
; 664  : 	return false;
; 665  : }

	ret	8
?ShouldIgnoreUnit@CvDangerPlots@@QAE_NPAVCvUnit@@_N@Z ENDP ; CvDangerPlots::ShouldIgnoreUnit
_TEXT	ENDS
PUBLIC	?ShouldIgnoreCity@CvDangerPlots@@QAE_NPAVCvCity@@_N@Z ; CvDangerPlots::ShouldIgnoreCity
EXTRN	?isRevealed@CvCity@@QBE_NW4TeamTypes@@_N@Z:PROC	; CvCity::isRevealed
; Function compile flags: /Ogtpy
;	COMDAT ?ShouldIgnoreCity@CvDangerPlots@@QAE_NPAVCvCity@@_N@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
_bIgnoreVisibility$ = 12				; size = 1
?ShouldIgnoreCity@CvDangerPlots@@QAE_NPAVCvCity@@_N@Z PROC ; CvDangerPlots::ShouldIgnoreCity, COMDAT
; _this$ = ecx

; 674  : 	// ignore unseen cities
; 675  : 	if(!pCity->isRevealed(GET_PLAYER(m_ePlayer).getTeam(), false)  && !bIgnoreVisibility)

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN10@ShouldIgno@3
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN11@ShouldIgno@3
$LN10@ShouldIgno@3:
	or	eax, -1
$LN11@ShouldIgno@3:
	mov	ecx, DWORD PTR _pCity$[esp-4]
	push	0
	push	eax
	call	?isRevealed@CvCity@@QBE_NW4TeamTypes@@_N@Z ; CvCity::isRevealed
	test	al, al
	jne	SHORT $LN1@ShouldIgno@3
	cmp	BYTE PTR _bIgnoreVisibility$[esp-4], al
	jne	SHORT $LN1@ShouldIgno@3

; 676  : 	{
; 677  : 		return true;

	mov	al, 1

; 681  : }

	ret	8
$LN1@ShouldIgno@3:

; 678  : 	}
; 679  : 
; 680  : 	return false;

	xor	al, al

; 681  : }

	ret	8
?ShouldIgnoreCity@CvDangerPlots@@QAE_NPAVCvCity@@_N@Z ENDP ; CvDangerPlots::ShouldIgnoreCity
_TEXT	ENDS
PUBLIC	?ShouldIgnoreCitadel@CvDangerPlots@@QAE_NPAVCvPlot@@_N@Z ; CvDangerPlots::ShouldIgnoreCitadel
EXTRN	?atWar@@YA_NW4TeamTypes@@0@Z:PROC		; atWar
; Function compile flags: /Ogtpy
;	COMDAT ?ShouldIgnoreCitadel@CvDangerPlots@@QAE_NPAVCvPlot@@_N@Z
_TEXT	SEGMENT
_pCitadelPlot$ = 8					; size = 4
_bIgnoreVisibility$ = 12				; size = 1
?ShouldIgnoreCitadel@CvDangerPlots@@QAE_NPAVCvPlot@@_N@Z PROC ; CvDangerPlots::ShouldIgnoreCitadel, COMDAT
; _this$ = ecx

; 689  : {

	push	ebx

; 690  : 	// ignore unseen cities
; 691  : 	if(!pCitadelPlot->isRevealed(GET_PLAYER(m_ePlayer).getTeam())  && !bIgnoreVisibility)

	mov	ebx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	push	esi
	mov	esi, DWORD PTR [ecx]
	mov	eax, esi
	imul	eax, 63236				; 0000f704H
	push	edi
	mov	edi, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	edx, DWORD PTR [eax+edi+44]
	cmp	edx, 63					; 0000003fH
	ja	SHORT $LN13@ShouldIgno@4
	mov	ecx, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN14@ShouldIgno@4
$LN13@ShouldIgno@4:
	or	ecx, -1
$LN14@ShouldIgno@4:
	mov	eax, ecx
	push	ebp
	shr	eax, 5
	mov	ebp, eax
	shl	ebp, 5
	sub	ecx, ebp
	mov	ebp, 1
	shl	ebp, cl
	mov	ecx, DWORD PTR _pCitadelPlot$[esp+12]
	test	ebp, DWORD PTR [ecx+eax*4+8]
	pop	ebp
	jne	SHORT $LN4@ShouldIgno@4
	cmp	BYTE PTR _bIgnoreVisibility$[esp+8], 0
	jne	SHORT $LN4@ShouldIgno@4
$LN46@ShouldIgno@4:
	pop	edi
	pop	esi

; 692  : 	{
; 693  : 		return true;

	mov	al, 1
	pop	ebx

; 712  : }

	ret	8
$LN4@ShouldIgno@4:

; 694  : 	}
; 695  : 
; 696  : 	PlayerTypes eOwner = pCitadelPlot->getOwner();

	movsx	eax, BYTE PTR [ecx+4]

; 697  : 	if(eOwner != NO_PLAYER)

	cmp	eax, -1
	je	SHORT $LN1@ShouldIgno@4

; 698  : 	{
; 699  : 		// Our own citadels aren't dangerous
; 700  : 		if(eOwner == m_ePlayer)

	cmp	eax, esi

; 701  : 		{
; 702  : 			return true;

	je	SHORT $LN46@ShouldIgno@4

; 703  : 		}
; 704  : 
; 705  : 		if(!atWar(GET_PLAYER(m_ePlayer).getTeam(), GET_PLAYER(eOwner).getTeam()))

	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+edi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN30@ShouldIgno@4
	mov	ecx, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN31@ShouldIgno@4
$LN30@ShouldIgno@4:
	or	eax, -1
$LN31@ShouldIgno@4:
	cmp	edx, 63					; 0000003fH
	ja	SHORT $LN41@ShouldIgno@4
	mov	ecx, DWORD PTR [ebx+4]
	mov	edx, DWORD PTR [ecx+edx*4]
	jmp	SHORT $LN42@ShouldIgno@4
$LN41@ShouldIgno@4:
	or	edx, -1
$LN42@ShouldIgno@4:
	push	eax
	push	edx
	call	?atWar@@YA_NW4TeamTypes@@0@Z		; atWar
	add	esp, 8
	test	al, al

; 706  : 		{
; 707  : 			return true;

	je	SHORT $LN46@ShouldIgno@4
$LN1@ShouldIgno@4:
	pop	edi
	pop	esi

; 708  : 		}
; 709  : 	}
; 710  : 
; 711  : 	return false;

	xor	al, al
	pop	ebx

; 712  : }

	ret	8
?ShouldIgnoreCitadel@CvDangerPlots@@QAE_NPAVCvPlot@@_N@Z ENDP ; CvDangerPlots::ShouldIgnoreCitadel
_TEXT	ENDS
PUBLIC	?AssignUnitDangerValue@CvDangerPlots@@QAEXPAVCvUnit@@PAVCvPlot@@@Z ; CvDangerPlots::AssignUnitDangerValue
EXTRN	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z:PROC	; CvAStar::GeneratePath
EXTRN	?getIgnoreUnitsPathFinder@CvGlobals@@QAEAAVCvIgnoreUnitsPathFinder@@XZ:PROC ; CvGlobals::getIgnoreUnitsPathFinder
EXTRN	?GetBaseCombatStrengthConsideringDamage@CvUnit@@QBEHXZ:PROC ; CvUnit::GetBaseCombatStrengthConsideringDamage
; Function compile flags: /Ogtpy
;	COMDAT ?AssignUnitDangerValue@CvDangerPlots@@QAEXPAVCvUnit@@PAVCvPlot@@@Z
_TEXT	SEGMENT
_iBaseUnitCombatValue$ = -12				; size = 4
_this$ = -8						; size = 4
_iPlotY$222357 = -4					; size = 4
$T224256 = 8						; size = 4
_pUnit$ = 8						; size = 4
_iTurnsAway$222360 = 12					; size = 4
_pPlot$ = 12						; size = 4
?AssignUnitDangerValue@CvDangerPlots@@QAEXPAVCvUnit@@PAVCvPlot@@@Z PROC ; CvDangerPlots::AssignUnitDangerValue, COMDAT
; _this$ = ecx

; 717  : {

	sub	esp, 12					; 0000000cH
	push	esi

; 718  : 	// MAJIK NUMBARS TO MOVE TO XML
; 719  : 	int iCombatValueCalc = 100;
; 720  : 	int iBaseUnitCombatValue = pUnit->GetBaseCombatStrengthConsideringDamage() * iCombatValueCalc;

	mov	esi, DWORD PTR _pUnit$[esp+12]
	push	edi
	mov	edi, ecx
	mov	ecx, esi
	mov	DWORD PTR _this$[esp+20], edi
	call	?GetBaseCombatStrengthConsideringDamage@CvUnit@@QBEHXZ ; CvUnit::GetBaseCombatStrengthConsideringDamage
	imul	eax, 100				; 00000064H
	mov	DWORD PTR _iBaseUnitCombatValue$[esp+20], eax

; 721  : 	// Combat capable?  If not, the calculations will always result in 0, so just skip it.
; 722  : 	if(iBaseUnitCombatValue > 0)

	test	eax, eax
	jle	$LN2@AssignUnit

; 723  : 	{
; 724  : 		// Will any danger be zero'ed out?
; 725  : 		if(!IsDangerByRelationshipZero(pUnit->getOwner(), pPlot))

	mov	eax, DWORD PTR [esi+40]
	push	ebp
	mov	ebp, DWORD PTR _pPlot$[esp+20]
	push	ebp
	push	eax
	mov	ecx, edi
	call	?IsDangerByRelationshipZero@CvDangerPlots@@IAE_NW4PlayerTypes@@PAVCvPlot@@@Z ; CvDangerPlots::IsDangerByRelationshipZero
	test	al, al
	jne	$LN35@AssignUnit

; 726  : 		{
; 727  : 			//int iDistance = plotDistance(pUnitPlot->getX(), pUnitPlot->getY(), pPlot->getX(), pPlot->getY());
; 728  : 			//int iRange = pUnit->baseMoves();
; 729  : 			//FAssertMsg(iRange > 0, "0 range? Uh oh");
; 730  : 
; 731  : 			CvIgnoreUnitsPathFinder& kPathFinder = GC.getIgnoreUnitsPathFinder();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getIgnoreUnitsPathFinder@CvGlobals@@QAEAAVCvIgnoreUnitsPathFinder@@XZ ; CvGlobals::getIgnoreUnitsPathFinder
	mov	edi, eax

; 732  : 			kPathFinder.SetData(pUnit);

	cmp	BYTE PTR [edi+80], 0
	je	SHORT $LN10@AssignUnit
	cmp	DWORD PTR [edi+44], esi
	je	SHORT $LN10@AssignUnit
	mov	BYTE PTR [edi+78], 1
$LN10@AssignUnit:
	push	ebx
	mov	DWORD PTR [edi+44], esi

; 733  : 
; 734  : 			int iPlotX = pPlot->getX();
; 735  : 			int iPlotY = pPlot->getY();

	movsx	edx, WORD PTR [ebp+2]
	movsx	ebx, WORD PTR [ebp]

; 736  : 			// can the unit actually walk there
; 737  : 			if(!kPathFinder.GeneratePath(pUnit->getX(), pUnit->getY(), iPlotX, iPlotY, 0, true /*bReuse*/))

	mov	eax, DWORD PTR [esi+88]
	mov	ecx, DWORD PTR [esi+76]
	push	1
	push	0
	push	edx
	push	ebx
	push	eax
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR _iPlotY$222357[esp+52], edx
	call	?GeneratePath@CvAStar@@QAE_NHHHHH_N@Z	; CvAStar::GeneratePath
	test	al, al
	je	SHORT $LN36@AssignUnit

; 738  : 			{
; 739  : 				return;
; 740  : 			}
; 741  : 
; 742  : 			CvAStarNode* pNode = kPathFinder.GetLastNode();
; 743  : 			int iTurnsAway = pNode->m_iData2;

	mov	eax, DWORD PTR [edi+96]
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR _iTurnsAway$222360[esp+24], eax

; 744  : 			iTurnsAway = max(iTurnsAway, 1);

	cmp	eax, 1
	mov	DWORD PTR $T224256[esp+24], 1
	lea	eax, DWORD PTR $T224256[esp+24]
	jl	SHORT $LN30@AssignUnit
	lea	eax, DWORD PTR _iTurnsAway$222360[esp+24]
$LN30@AssignUnit:
	mov	edi, DWORD PTR [eax]

; 745  : 
; 746  : 			int iUnitCombatValue = iBaseUnitCombatValue / iTurnsAway;

	mov	eax, DWORD PTR _iBaseUnitCombatValue$[esp+28]
	cdq
	idiv	edi

; 747  : 			iUnitCombatValue = ModifyDangerByRelationship(pUnit->getOwner(), pPlot, iUnitCombatValue);

	mov	esi, DWORD PTR [esi+40]
	push	eax
	push	ebp
	push	esi
	mov	esi, DWORD PTR _this$[esp+40]
	mov	ecx, esi
	call	?ModifyDangerByRelationship@CvDangerPlots@@QAEHW4PlayerTypes@@PAVCvPlot@@H@Z ; CvDangerPlots::ModifyDangerByRelationship

; 748  : 			AddDanger(iPlotX, iPlotY, iUnitCombatValue, iTurnsAway <= 1);

	cmp	edi, 1
	setle	cl
	movzx	edx, cl
	push	edx
	push	eax
	mov	eax, DWORD PTR _iPlotY$222357[esp+36]
	push	eax
	push	ebx
	mov	ecx, esi
	call	?AddDanger@CvDangerPlots@@QAEXHHH_N@Z	; CvDangerPlots::AddDanger
$LN36@AssignUnit:
	pop	ebx
$LN35@AssignUnit:
	pop	ebp
$LN2@AssignUnit:
	pop	edi
	pop	esi

; 749  : 		}
; 750  : 	}
; 751  : }

	add	esp, 12					; 0000000cH
	ret	8
?AssignUnitDangerValue@CvDangerPlots@@QAEXPAVCvUnit@@PAVCvPlot@@@Z ENDP ; CvDangerPlots::AssignUnitDangerValue
_TEXT	ENDS
PUBLIC	?AssignCityDangerValue@CvDangerPlots@@QAEXPAVCvCity@@PAVCvPlot@@@Z ; CvDangerPlots::AssignCityDangerValue
EXTRN	?getStrengthValue@CvCity@@QBEH_N@Z:PROC		; CvCity::getStrengthValue
; Function compile flags: /Ogtpy
;	COMDAT ?AssignCityDangerValue@CvDangerPlots@@QAEXPAVCvCity@@PAVCvPlot@@@Z
_TEXT	SEGMENT
_pCity$ = 8						; size = 4
_pPlot$ = 12						; size = 4
?AssignCityDangerValue@CvDangerPlots@@QAEXPAVCvCity@@PAVCvPlot@@@Z PROC ; CvDangerPlots::AssignCityDangerValue, COMDAT
; _this$ = ecx

; 756  : {

	push	esi

; 757  : 	int iCombatValue = pCity->getStrengthValue();

	mov	esi, DWORD PTR _pCity$[esp]
	push	edi
	mov	edi, ecx
	push	0
	mov	ecx, esi
	call	?getStrengthValue@CvCity@@QBEH_N@Z	; CvCity::getStrengthValue

; 758  : 	iCombatValue = ModifyDangerByRelationship(pCity->getOwner(), pPlot, iCombatValue);

	mov	ecx, DWORD PTR [esi+84]
	mov	esi, DWORD PTR _pPlot$[esp+4]
	push	eax
	push	esi
	push	ecx
	mov	ecx, edi
	call	?ModifyDangerByRelationship@CvDangerPlots@@QAEHW4PlayerTypes@@PAVCvPlot@@H@Z ; CvDangerPlots::ModifyDangerByRelationship

; 759  : 	AddDanger(pPlot->getX(), pPlot->getY(), iCombatValue, false);

	movsx	ecx, WORD PTR [esi+2]
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	imul	ecx, DWORD PTR [edx+4020]
	movsx	edx, WORD PTR [esi]
	add	ecx, edx
	test	eax, eax
	jle	SHORT $LN11@AssignCity
	and	eax, -2					; fffffffeH
$LN11@AssignCity:
	mov	edx, DWORD PTR [edi+96]
	add	DWORD PTR [edx+ecx*4], eax
	lea	ecx, DWORD PTR [edx+ecx*4]
	pop	edi
	pop	esi

; 760  : }

	ret	8
?AssignCityDangerValue@CvDangerPlots@@QAEXPAVCvCity@@PAVCvPlot@@@Z ENDP ; CvDangerPlots::AssignCityDangerValue
_TEXT	ENDS
PUBLIC	??0?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@QAE@I@Z ; FFastVector<unsigned int,1,297,0,BaseVector<unsigned int,1>::FDefaultFastVectorAllocator>::FFastVector<unsigned int,1,297,0,BaseVector<unsigned int,1>::FDefaultFastVectorAllocator>
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@QAE@I@Z
_TEXT	SEGMENT
_uiStartingMaxSize$ = 8					; size = 4
??0?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@QAE@I@Z PROC ; FFastVector<unsigned int,1,297,0,BaseVector<unsigned int,1>::FDefaultFastVectorAllocator>::FFastVector<unsigned int,1,297,0,BaseVector<unsigned int,1>::FDefaultFastVectorAllocator>, COMDAT
; _this$ = ecx

; 309  : 	FFastVector(unsigned int uiStartingMaxSize = 0)

	push	esi
	xor	eax, eax
	push	edi

; 310  : 	{
; 311  : #ifdef BREAK_ON_REPEATED_RESIZE
; 312  : 		m_nResizeTimes = 0;
; 313  : #endif
; 314  : 		m_pData = Alloc(uiStartingMaxSize);

	mov	edi, DWORD PTR _uiStartingMaxSize$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	cmp	edi, eax
	jbe	SHORT $LN5@FFastVecto
	push	85					; 00000055H
	push	OFFSET ??_C@_0EG@NKCAPKNA@s?3?2github?2lekmod?2lekmod_dll?2fire@
	lea	eax, DWORD PTR [edi*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+8], edi
$LN5@FFastVecto:
	mov	DWORD PTR [esi], eax
	pop	edi

; 315  : 	};

	mov	eax, esi
	pop	esi
	ret	4
??0?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@QAE@I@Z ENDP ; FFastVector<unsigned int,1,297,0,BaseVector<unsigned int,1>::FDefaultFastVectorAllocator>::FFastVector<unsigned int,1,297,0,BaseVector<unsigned int,1>::FDefaultFastVectorAllocator>
_TEXT	ENDS
PUBLIC	??1?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@QAE@XZ ; FFastVector<unsigned int,1,297,0,BaseVector<unsigned int,1>::FDefaultFastVectorAllocator>::~FFastVector<unsigned int,1,297,0,BaseVector<unsigned int,1>::FDefaultFastVectorAllocator>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@QAE@XZ
_TEXT	SEGMENT
??1?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@QAE@XZ PROC ; FFastVector<unsigned int,1,297,0,BaseVector<unsigned int,1>::FDefaultFastVectorAllocator>::~FFastVector<unsigned int,1,297,0,BaseVector<unsigned int,1>::FDefaultFastVectorAllocator>, COMDAT
; _this$ = ecx

; 317  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx

; 318  : 	};

	ret	0
??1?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@QAE@XZ ENDP ; FFastVector<unsigned int,1,297,0,BaseVector<unsigned int,1>::FDefaultFastVectorAllocator>::~FFastVector<unsigned int,1,297,0,BaseVector<unsigned int,1>::FDefaultFastVectorAllocator>
_TEXT	ENDS
PUBLIC	?GrowSize@?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@IAEXI@Z ; FFastVector<unsigned int,1,297,0,BaseVector<unsigned int,1>::FDefaultFastVectorAllocator>::GrowSize
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSize@?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@IAEXI@Z PROC ; FFastVector<unsigned int,1,297,0,BaseVector<unsigned int,1>::FDefaultFastVectorAllocator>::GrowSize, COMDAT
; _this$ = ecx

; 422  : 	{

	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 423  : 		unsigned int nOld = m_uiCurrMaxSize;

	mov	eax, DWORD PTR [esi+8]
	push	edi
	mov	ebp, eax

; 424  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	test	eax, eax
	jne	SHORT $LN34@GrowSize
	mov	DWORD PTR [esi+8], 1
$LN34@GrowSize:

; 425  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+12]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN9@GrowSize
	npad	1
$LL10@GrowSize:

; 426  : 
; 427  : 			//Try to double size...
; 428  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 429  : 
; 430  : 			//...on overflow bail and set to exact size
; 431  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN35@GrowSize

; 433  : 				break;
; 434  : 			}
; 435  : 
; 436  : 			//...otherwise use the doubled size
; 437  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL10@GrowSize

; 429  : 
; 430  : 			//...on overflow bail and set to exact size
; 431  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN9@GrowSize
$LN35@GrowSize:

; 432  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN9@GrowSize:

; 438  : 		}
; 439  : 
; 440  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	edi, DWORD PTR [esi+8]
	test	edi, edi
	jbe	SHORT $LN7@GrowSize
	push	85					; 00000055H
	push	OFFSET ??_C@_0EG@NKCAPKNA@s?3?2github?2lekmod?2lekmod_dll?2fire@
	lea	eax, DWORD PTR [edi*4]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	mov	ebx, eax
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+8], edi

; 441  : 		if (pTemp)

	test	ebx, ebx
	je	SHORT $LN7@GrowSize

; 442  : 		{
; 443  : 			if( bPODType ){
; 444  : 				memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	ebx
	call	_memcpy

; 445  : 			}else{
; 446  : 				for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 447  : 					new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 448  : 			}
; 449  : 			Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 16					; 00000010H
	pop	edi

; 450  : 			m_pData = pTemp;

	mov	DWORD PTR [esi], ebx
	pop	esi
	pop	ebp
	pop	ebx

; 456  : 		}
; 457  : 	};

	ret	4
$LN7@GrowSize:
	pop	edi

; 451  : 		}
; 452  : 		else
; 453  : 		{
; 454  : 			FAssertMsg2(0, "Failed to grow array size from %u to %u", nOld, m_uiCurrMaxSize);
; 455  : 			m_uiCurrMaxSize = nOld;

	mov	DWORD PTR [esi+8], ebp
	pop	esi
	pop	ebp
	pop	ebx

; 456  : 		}
; 457  : 	};

	ret	4
?GrowSize@?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@IAEXI@Z ENDP ; FFastVector<unsigned int,1,297,0,BaseVector<unsigned int,1>::FDefaultFastVectorAllocator>::GrowSize
_TEXT	ENDS
PUBLIC	??0CvDangerPlots@@QAE@XZ			; CvDangerPlots::CvDangerPlots
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvdangerplots.cpp
;	COMDAT ??0CvDangerPlots@@QAE@XZ
_TEXT	SEGMENT
??0CvDangerPlots@@QAE@XZ PROC				; CvDangerPlots::CvDangerPlots, COMDAT
; _this$ = ecx

; 35   : {

	mov	eax, ecx
	mov	DWORD PTR [eax], -1
	xor	ecx, ecx
	mov	BYTE PTR [eax+4], cl
	mov	BYTE PTR [eax+5], cl
	mov	DWORD PTR [eax+100], ecx
	mov	DWORD PTR [eax+104], ecx
	mov	DWORD PTR [eax+96], ecx

; 36   : 	m_fMajorWarMod = GC.getAI_DANGER_MAJOR_APPROACH_WAR();

	fld	DWORD PTR ?gGlobals@@3VCvGlobals@@A+8048
	fstp	QWORD PTR [eax+8]

; 37   : 	m_fMajorHostileMod = GC.getAI_DANGER_MAJOR_APPROACH_HOSTILE();

	fld	DWORD PTR ?gGlobals@@3VCvGlobals@@A+8052
	fstp	QWORD PTR [eax+16]

; 38   : 	m_fMajorDeceptiveMod = GC.getAI_DANGER_MAJOR_APPROACH_DECEPTIVE();

	fld	DWORD PTR ?gGlobals@@3VCvGlobals@@A+8056
	fstp	QWORD PTR [eax+24]

; 39   : 	m_fMajorGuardedMod = GC.getAI_DANGER_MAJOR_APPROACH_GUARDED();

	fld	DWORD PTR ?gGlobals@@3VCvGlobals@@A+8060
	fstp	QWORD PTR [eax+32]

; 40   : 	m_fMajorAfraidMod = GC.getAI_DANGER_MAJOR_APPROACH_AFRAID();

	fld	DWORD PTR ?gGlobals@@3VCvGlobals@@A+8064
	fstp	QWORD PTR [eax+40]

; 41   : 	m_fMajorFriendlyMod = GC.getAI_DANGER_MAJOR_APPROACH_FRIENDLY();

	fld	DWORD PTR ?gGlobals@@3VCvGlobals@@A+8068
	fstp	QWORD PTR [eax+48]

; 42   : 	m_fMajorNeutralMod = GC.getAI_DANGER_MAJOR_APPROACH_NEUTRAL();

	fld	DWORD PTR ?gGlobals@@3VCvGlobals@@A+8072
	fstp	QWORD PTR [eax+56]

; 43   : 	m_fMinorNeutralrMod = GC.getAI_DANGER_MINOR_APPROACH_NEUTRAL();

	fld	DWORD PTR ?gGlobals@@3VCvGlobals@@A+8076
	fstp	QWORD PTR [eax+64]

; 44   : 	m_fMinorFriendlyMod = GC.getAI_DANGER_MINOR_APPROACH_FRIENDLY();

	fld	DWORD PTR ?gGlobals@@3VCvGlobals@@A+8080
	fstp	QWORD PTR [eax+72]

; 45   : 	m_fMinorBullyMod = GC.getAI_DANGER_MINOR_APPROACH_BULLY();

	fld	DWORD PTR ?gGlobals@@3VCvGlobals@@A+8084
	fstp	QWORD PTR [eax+80]

; 46   : 	m_fMinorConquestMod = GC.getAI_DANGER_MINOR_APPROACH_CONQUEST();

	fld	DWORD PTR ?gGlobals@@3VCvGlobals@@A+8088
	fstp	QWORD PTR [eax+88]

; 47   : }

	ret	0
??0CvDangerPlots@@QAE@XZ ENDP				; CvDangerPlots::CvDangerPlots
_TEXT	ENDS
PUBLIC	??1CvDangerPlots@@QAE@XZ			; CvDangerPlots::~CvDangerPlots
; Function compile flags: /Ogtpy
;	COMDAT ??1CvDangerPlots@@QAE@XZ
_TEXT	SEGMENT
??1CvDangerPlots@@QAE@XZ PROC				; CvDangerPlots::~CvDangerPlots, COMDAT
; _this$ = ecx

; 52   : 	Uninit();

	xor	eax, eax
	mov	DWORD PTR [ecx], -1
	mov	DWORD PTR [ecx+100], eax
	mov	BYTE PTR [ecx+4], al
	mov	BYTE PTR [ecx+5], al

; 53   : }

	mov	eax, DWORD PTR [ecx+96]
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
	ret	0
??1CvDangerPlots@@QAE@XZ ENDP				; CvDangerPlots::~CvDangerPlots
_TEXT	ENDS
PUBLIC	?UpdateDanger@CvDangerPlots@@QAEX_N0@Z		; CvDangerPlots::UpdateDanger
EXTRN	?SetThreatValue@CvCity@@QAEXH@Z:PROC		; CvCity::SetThreatValue
EXTRN	?GetNearbyEnemyDamage@CvImprovementEntry@@QBEHXZ:PROC ; CvImprovementEntry::GetNearbyEnemyDamage
EXTRN	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z:PROC ; CvGlobals::getImprovementInfo
EXTRN	?getRevealedImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@W4TeamTypes@@@Z:PROC ; CvPlot::getRevealedImprovementType
EXTRN	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::nextCity
EXTRN	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::firstCity
EXTRN	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::nextUnit
EXTRN	?canRangeStrikeAt@CvUnit@@QBE_NHH_N0@Z:PROC	; CvUnit::canRangeStrikeAt
EXTRN	?canMoveOrAttackInto@CvUnit@@QBE_NABVCvPlot@@E@Z:PROC ; CvUnit::canMoveOrAttackInto
EXTRN	?GetRange@CvUnit@@QBEHXZ:PROC			; CvUnit::GetRange
EXTRN	?canRangeStrike@CvUnit@@QBE_NXZ:PROC		; CvUnit::canRangeStrike
EXTRN	?baseMoves@CvUnit@@QBEHW4DomainTypes@@@Z:PROC	; CvUnit::baseMoves
EXTRN	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z:PROC	; CvPlayer::firstUnit
; Function compile flags: /Ogtpy
;	COMDAT ?UpdateDanger@CvDangerPlots@@QAEX_N0@Z
_TEXT	SEGMENT
_this$ = -56						; size = 4
_pCityPlot$222153 = -52					; size = 4
_iRange$222132 = -52					; size = 4
tv1146 = -48						; size = 4
tv1110 = -48						; size = 4
tv1161 = -44						; size = 4
tv1125 = -44						; size = 4
_loopPlayer$222121 = -40				; size = 4
$T224647 = -36						; size = 4
_iLoop$222126 = -32					; size = 4
_iPlayer$222115 = -28					; size = 4
tv1175 = -24						; size = 4
_iPlotLoop$ = -20					; size = 4
_iRange$222152 = -20					; size = 4
_pUnitPlot$222134 = -20					; size = 4
_thisPlayer$ = -16					; size = 4
_iLoopCity$ = -12					; size = 4
tv1135 = -8						; size = 4
tv1070 = -8						; size = 4
tv804 = -8						; size = 4
tv1171 = -4						; size = 4
tv733 = -4						; size = 4
_uiOffset$224988 = -4					; size = 4
tv1190 = 8						; size = 4
_bPretendWarWithAllCivs$ = 8				; size = 1
_bIgnoreVisibility$ = 12				; size = 1
?UpdateDanger@CvDangerPlots@@QAEX_N0@Z PROC		; CvDangerPlots::UpdateDanger, COMDAT
; _this$ = ecx

; 95   : {

	sub	esp, 56					; 00000038H
	mov	edx, ecx
	push	esi

; 96   : 	// danger plots have not been initialized yet, so no need to update
; 97   : #ifdef AUI_DANGER_PLOTS_FIX_USE_ARRAY_NOT_FFASTVECTOR
; 98   : 	if (!m_DangerPlots)
; 99   : #else
; 100  : 	if(!m_bArrayAllocated)

	xor	esi, esi
	cmp	BYTE PTR [edx+4], 0
	mov	DWORD PTR _this$[esp+60], edx
	je	$LN49@UpdateDang

; 101  : #endif
; 102  : 	{
; 103  : 		return;
; 104  : 	}
; 105  : 
; 106  : 	// wipe out values
; 107  : 	int iGridSize = GC.getMap().numPlots();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	ecx, DWORD PTR [eax+4028]
	push	ebx
	push	ebp

; 108  : 	CvAssertMsg(iGridSize == m_DangerPlots.size(), "iGridSize does not match number of DangerPlots");
; 109  : #ifdef AUI_DANGER_PLOTS_FIX_USE_ARRAY_NOT_FFASTVECTOR
; 110  : 	fill(m_DangerPlots, &m_DangerPlots[iGridSize - 1], 0);
; 111  : #else
; 112  : 	for(int i = 0; i < iGridSize; i++)

	xor	eax, eax
	cmp	ecx, esi
	push	edi
	jle	SHORT $LN45@UpdateDang
	npad	6
$LL47@UpdateDang:

; 113  : 	{
; 114  : 		m_DangerPlots[i] = 0;

	mov	edi, DWORD PTR [edx+96]
	mov	DWORD PTR [edi+eax*4], esi
	inc	eax
	cmp	eax, ecx
	jl	SHORT $LL47@UpdateDang
$LN45@UpdateDang:

; 115  : 	}
; 116  : #endif
; 117  : 
; 118  : 	CvPlayer& thisPlayer = GET_PLAYER(m_ePlayer);

	mov	eax, DWORD PTR [edx]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	DWORD PTR _thisPlayer$[esp+72], eax

; 119  : 	TeamTypes thisTeam = thisPlayer.getTeam();

	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN63@UpdateDang
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T224647[esp+72], eax
	jmp	SHORT $LN64@UpdateDang
$LN63@UpdateDang:
	mov	DWORD PTR $T224647[esp+72], -1
$LN64@UpdateDang:

; 120  : 
; 121  : 	// for each opposing civ
; 122  : 	for(int iPlayer = 0; iPlayer < MAX_PLAYERS; iPlayer++)

	mov	DWORD PTR _iPlayer$222115[esp+72], esi
	mov	DWORD PTR tv1175[esp+72], esi
	npad	9
$LL250@UpdateDang:

; 123  : 	{
; 124  : 		PlayerTypes ePlayer = (PlayerTypes)iPlayer;
; 125  : 		CvPlayer& loopPlayer = GET_PLAYER(ePlayer);

	mov	ecx, DWORD PTR tv1175[esp+72]
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 126  : 		TeamTypes eTeam = loopPlayer.getTeam();

	mov	eax, DWORD PTR [ecx+edx+44]
	add	ecx, edx
	mov	DWORD PTR _loopPlayer$222121[esp+72], ecx
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN74@UpdateDang
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN75@UpdateDang
$LN74@UpdateDang:
	or	eax, -1
$LN75@UpdateDang:

; 127  : 
; 128  : 		if(!loopPlayer.isAlive())

	cmp	BYTE PTR [ecx+2256], 0
	je	$LN43@UpdateDang

; 129  : 		{
; 130  : 			continue;
; 131  : 		}
; 132  : 
; 133  : 		if(eTeam == thisTeam)

	cmp	eax, DWORD PTR $T224647[esp+72]
	je	$LN43@UpdateDang

; 134  : 		{
; 135  : 			continue;
; 136  : 		}
; 137  : 
; 138  : 		if(ShouldIgnorePlayer(ePlayer) && !bPretendWarWithAllCivs)

	mov	eax, DWORD PTR _iPlayer$222115[esp+72]
	mov	ecx, DWORD PTR _this$[esp+72]
	push	eax
	call	?ShouldIgnorePlayer@CvDangerPlots@@QAE_NW4PlayerTypes@@@Z ; CvDangerPlots::ShouldIgnorePlayer
	test	al, al
	je	SHORT $LN249@UpdateDang
	cmp	BYTE PTR _bPretendWarWithAllCivs$[esp+68], 0
	je	$LN43@UpdateDang
$LN249@UpdateDang:

; 139  : 		{
; 140  : 			continue;
; 141  : 		}
; 142  : 
; 143  : 		//for each unit
; 144  : 		int iLoop;
; 145  : 		CvUnit* pLoopUnit = NULL;
; 146  : 		for(pLoopUnit = loopPlayer.firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = loopPlayer.nextUnit(&iLoop))

	push	0
	lea	ecx, DWORD PTR _iLoop$222126[esp+76]
	push	ecx
	mov	ecx, DWORD PTR _loopPlayer$222121[esp+80]
	call	?firstUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::firstUnit
	mov	ebx, eax
	test	ebx, ebx
	je	$LN244@UpdateDang
	npad	8
$LL38@UpdateDang:

; 147  : 		{
; 148  : 			if(ShouldIgnoreUnit(pLoopUnit, bIgnoreVisibility))

	mov	edx, DWORD PTR _bIgnoreVisibility$[esp+68]
	mov	edi, DWORD PTR _this$[esp+72]
	push	edx
	push	ebx
	mov	ecx, edi
	call	?ShouldIgnoreUnit@CvDangerPlots@@QAE_NPAVCvUnit@@_N@Z ; CvDangerPlots::ShouldIgnoreUnit
	test	al, al
	jne	$LN37@UpdateDang

; 149  : 			{
; 150  : 				continue;
; 151  : 			}
; 152  : 
; 153  : 			int iRange = pLoopUnit->baseMoves();

	push	-1
	mov	ecx, ebx
	call	?baseMoves@CvUnit@@QBEHW4DomainTypes@@@Z ; CvUnit::baseMoves

; 154  : 			if(pLoopUnit->canRangeStrike())

	mov	ecx, ebx
	mov	esi, eax
	mov	DWORD PTR _iRange$222132[esp+72], eax
	call	?canRangeStrike@CvUnit@@QBE_NXZ		; CvUnit::canRangeStrike
	test	al, al
	je	SHORT $LN34@UpdateDang

; 155  : 			{
; 156  : 				iRange += pLoopUnit->GetRange();

	mov	ecx, ebx
	call	?GetRange@CvUnit@@QBEHXZ		; CvUnit::GetRange
	add	esi, eax
	mov	DWORD PTR _iRange$222132[esp+72], esi
$LN34@UpdateDang:

; 157  : 			}
; 158  : 
; 159  : 			CvPlot* pUnitPlot = pLoopUnit->plot();

	mov	ecx, ebx
	call	?plot@CvUnit@@QBEPAVCvPlot@@XZ		; CvUnit::plot

; 160  : 			AssignUnitDangerValue(pLoopUnit, pUnitPlot);

	push	eax
	push	ebx
	mov	ecx, edi
	mov	DWORD PTR _pUnitPlot$222134[esp+80], eax
	call	?AssignUnitDangerValue@CvDangerPlots@@QAEXPAVCvUnit@@PAVCvPlot@@@Z ; CvDangerPlots::AssignUnitDangerValue

; 161  : 			CvPlot* pLoopPlot = NULL;
; 162  : 
; 163  : #ifdef AUI_HEXSPACE_DX_LOOPS
; 164  : 			for (int iDY = -iRange; iDY <= iRange; iDY++)
; 165  : 			{
; 166  : 				int iMaxDX = iRange - MAX(0, iDY);
; 167  : 				for (int iDX = -iRange - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 168  : 				{
; 169  : 					// No need for range check because loops are set up properly
; 170  : 					pLoopPlot = plotXY(pUnitPlot->getX(), pUnitPlot->getY(), iDX, iDY);
; 171  : #else
; 172  : 			for(int iDX = -(iRange); iDX <= iRange; iDX++)

	mov	ebp, esi
	neg	ebp
	cmp	ebp, esi
	mov	DWORD PTR tv1135[esp+72], ebp
	jg	$LN37@UpdateDang
	mov	eax, ebp
	neg	eax
	mov	DWORD PTR tv1125[esp+72], eax
	npad	4
$LL33@UpdateDang:

; 173  : 			{
; 174  : 				for(int iDY = -(iRange); iDY <= iRange; iDY++)

	mov	edi, DWORD PTR tv1135[esp+72]
	cmp	edi, DWORD PTR _iRange$222132[esp+72]
	jg	$LN32@UpdateDang

; 175  : 				{
; 176  : 					pLoopPlot = plotXYWithRangeCheck(pUnitPlot->getX(), pUnitPlot->getY(), iDX, iDY, iRange);

	xor	eax, eax
	test	ebp, ebp
	setge	al
	mov	DWORD PTR tv733[esp+72], eax
	mov	eax, edi
	neg	eax
	mov	DWORD PTR tv1110[esp+72], eax
$LL30@UpdateDang:
	xor	ecx, ecx
	test	edi, edi
	setge	cl
	cmp	DWORD PTR tv733[esp+72], ecx
	mov	ecx, ebp
	jne	SHORT $LN89@UpdateDang
	test	ebp, ebp
	jge	SHORT $LN93@UpdateDang
	mov	ecx, DWORD PTR tv1125[esp+72]
$LN93@UpdateDang:
	mov	eax, edi
	test	edi, edi
	jge	SHORT $LN95@UpdateDang
	mov	eax, DWORD PTR tv1110[esp+72]
$LN95@UpdateDang:
	add	eax, ecx
	jmp	SHORT $LN100@UpdateDang
$LN89@UpdateDang:
	test	ebp, ebp
	jge	SHORT $LN97@UpdateDang
	mov	ecx, DWORD PTR tv1125[esp+72]
$LN97@UpdateDang:
	mov	eax, edi
	test	edi, edi
	jge	SHORT $LN99@UpdateDang
	mov	eax, DWORD PTR tv1110[esp+72]
$LN99@UpdateDang:
	cmp	ecx, eax
	jl	SHORT $LN100@UpdateDang
	mov	eax, ecx
$LN100@UpdateDang:
	cmp	eax, DWORD PTR _iRange$222132[esp+72]
	jg	SHORT $LN29@UpdateDang
	mov	eax, DWORD PTR _pUnitPlot$222134[esp+72]
	movsx	edx, WORD PTR [eax+2]
	movsx	eax, WORD PTR [eax]
	push	edi
	push	ebp
	push	edx
	push	eax
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	mov	esi, eax
	add	esp, 16					; 00000010H

; 177  : #endif
; 178  : 					if(!pLoopPlot || pLoopPlot == pUnitPlot)

	test	esi, esi
	je	SHORT $LN29@UpdateDang
	cmp	esi, DWORD PTR _pUnitPlot$222134[esp+72]
	je	SHORT $LN29@UpdateDang

; 179  : 					{
; 180  : 						continue;
; 181  : 					}
; 182  : 
; 183  : 					if(!pLoopUnit->canMoveOrAttackInto(*pLoopPlot) && !pLoopUnit->canRangeStrikeAt(pLoopPlot->getX(),pLoopPlot->getY()))

	push	0
	push	esi
	mov	ecx, ebx
	call	?canMoveOrAttackInto@CvUnit@@QBE_NABVCvPlot@@E@Z ; CvUnit::canMoveOrAttackInto
	test	al, al
	jne	SHORT $LN25@UpdateDang
	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	1
	push	1
	push	eax
	push	ecx
	mov	ecx, ebx
	call	?canRangeStrikeAt@CvUnit@@QBE_NHH_N0@Z	; CvUnit::canRangeStrikeAt
	test	al, al
	je	SHORT $LN29@UpdateDang
$LN25@UpdateDang:

; 184  : 					{
; 185  : 						continue;
; 186  : 					}
; 187  : 
; 188  : 					AssignUnitDangerValue(pLoopUnit, pLoopPlot);

	mov	ecx, DWORD PTR _this$[esp+72]
	push	esi
	push	ebx
	call	?AssignUnitDangerValue@CvDangerPlots@@QAEXPAVCvUnit@@PAVCvPlot@@@Z ; CvDangerPlots::AssignUnitDangerValue
$LN29@UpdateDang:
	dec	DWORD PTR tv1110[esp+72]
	inc	edi
	cmp	edi, DWORD PTR _iRange$222132[esp+72]
	jle	$LL30@UpdateDang
$LN32@UpdateDang:

; 161  : 			CvPlot* pLoopPlot = NULL;
; 162  : 
; 163  : #ifdef AUI_HEXSPACE_DX_LOOPS
; 164  : 			for (int iDY = -iRange; iDY <= iRange; iDY++)
; 165  : 			{
; 166  : 				int iMaxDX = iRange - MAX(0, iDY);
; 167  : 				for (int iDX = -iRange - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 168  : 				{
; 169  : 					// No need for range check because loops are set up properly
; 170  : 					pLoopPlot = plotXY(pUnitPlot->getX(), pUnitPlot->getY(), iDX, iDY);
; 171  : #else
; 172  : 			for(int iDX = -(iRange); iDX <= iRange; iDX++)

	dec	DWORD PTR tv1125[esp+72]
	inc	ebp
	cmp	ebp, DWORD PTR _iRange$222132[esp+72]
	jle	$LL33@UpdateDang
$LN37@UpdateDang:

; 139  : 		{
; 140  : 			continue;
; 141  : 		}
; 142  : 
; 143  : 		//for each unit
; 144  : 		int iLoop;
; 145  : 		CvUnit* pLoopUnit = NULL;
; 146  : 		for(pLoopUnit = loopPlayer.firstUnit(&iLoop); pLoopUnit != NULL; pLoopUnit = loopPlayer.nextUnit(&iLoop))

	push	0
	lea	ecx, DWORD PTR _iLoop$222126[esp+76]
	push	ecx
	mov	ecx, DWORD PTR _loopPlayer$222121[esp+80]
	call	?nextUnit@CvPlayer@@QAEPAVCvUnit@@PAH_N@Z ; CvPlayer::nextUnit
	mov	ebx, eax
	test	ebx, ebx
	jne	$LL38@UpdateDang
$LN244@UpdateDang:

; 189  : 				}
; 190  : 			}
; 191  : 		}
; 192  : 
; 193  : 		// for each city
; 194  : 		CvCity* pLoopCity;
; 195  : 		for(pLoopCity = loopPlayer.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = loopPlayer.nextCity(&iLoop))

	mov	ecx, DWORD PTR _loopPlayer$222121[esp+72]
	push	0
	lea	edx, DWORD PTR _iLoop$222126[esp+76]
	push	edx
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	ebx, eax
	test	ebx, ebx
	je	$LN43@UpdateDang
	npad	6
$LL247@UpdateDang:
	mov	ebp, DWORD PTR _this$[esp+72]

; 196  : 		{
; 197  : 			if(ShouldIgnoreCity(pLoopCity, bIgnoreVisibility))

	mov	eax, DWORD PTR [ebp]
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN115@UpdateDang
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN116@UpdateDang
$LN115@UpdateDang:
	or	eax, -1
$LN116@UpdateDang:
	push	0
	push	eax
	mov	ecx, ebx
	call	?isRevealed@CvCity@@QBE_NW4TeamTypes@@_N@Z ; CvCity::isRevealed
	test	al, al
	jne	SHORT $LN106@UpdateDang
	cmp	BYTE PTR _bIgnoreVisibility$[esp+68], al
	je	$LN23@UpdateDang
$LN106@UpdateDang:

; 198  : 			{
; 199  : 				continue;
; 200  : 			}
; 201  : 
; 202  : 			int iRange = GC.getCITY_ATTACK_RANGE();

	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+7488

; 203  : 			CvPlot* pCityPlot = pLoopCity->plot();

	mov	ecx, ebx
	mov	DWORD PTR _iRange$222152[esp+72], esi
	call	?plot@CvCity@@QBEPAVCvPlot@@XZ		; CvCity::plot
	mov	edi, eax

; 204  : 			AssignCityDangerValue(pLoopCity, pCityPlot);

	push	0
	mov	ecx, ebx
	mov	DWORD PTR _pCityPlot$222153[esp+76], edi
	call	?getStrengthValue@CvCity@@QBEH_N@Z	; CvCity::getStrengthValue
	mov	ecx, DWORD PTR [ebx+84]
	push	eax
	push	edi
	push	ecx
	mov	ecx, ebp
	call	?ModifyDangerByRelationship@CvDangerPlots@@QAEHW4PlayerTypes@@PAVCvPlot@@H@Z ; CvDangerPlots::ModifyDangerByRelationship
	movsx	ecx, WORD PTR [edi+2]
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	imul	ecx, DWORD PTR [edx+4020]
	movsx	edx, WORD PTR [edi]
	add	ecx, edx
	test	eax, eax
	jle	SHORT $LN132@UpdateDang
	and	eax, -2					; fffffffeH
$LN132@UpdateDang:
	mov	edx, DWORD PTR _this$[esp+72]
	mov	edx, DWORD PTR [edx+96]
	add	DWORD PTR [edx+ecx*4], eax

; 205  : 			CvPlot* pLoopPlot = NULL;
; 206  : 
; 207  : #ifdef AUI_HEXSPACE_DX_LOOPS
; 208  : 			int iMaxDX, iDX;
; 209  : 			for (int iDY = -iRange; iDY <= iRange; iDY++)
; 210  : 			{
; 211  : 				iMaxDX = iRange - MAX(0, iDY);
; 212  : 				for (iDX = -iRange - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 213  : 				{
; 214  : 					// No need for range check because loops are set up properly
; 215  : 					pLoopPlot = plotXY(pCityPlot->getX(), pCityPlot->getY(), iDX, iDY);
; 216  : #else
; 217  : 			for(int iDX = -(iRange); iDX <= iRange; iDX++)

	mov	ebp, esi
	lea	ecx, DWORD PTR [edx+ecx*4]
	neg	ebp
	cmp	ebp, esi
	mov	DWORD PTR tv1171[esp+72], ebp
	jg	$LN23@UpdateDang
	mov	eax, ebp
	neg	eax
	mov	DWORD PTR tv1161[esp+72], eax
$LL20@UpdateDang:

; 218  : 			{
; 219  : 				for(int iDY = -(iRange); iDY <= iRange; iDY++)

	mov	edi, DWORD PTR tv1171[esp+72]
	cmp	edi, esi
	jg	$LN19@UpdateDang

; 220  : 				{
; 221  : 					pLoopPlot = plotXYWithRangeCheck(pCityPlot->getX(), pCityPlot->getY(), iDX, iDY, iRange);

	xor	eax, eax
	test	ebp, ebp
	setge	al
	mov	edx, edi
	neg	edx
	mov	DWORD PTR tv1146[esp+72], edx
	mov	DWORD PTR tv804[esp+72], eax
$LL17@UpdateDang:
	xor	ecx, ecx
	test	edi, edi
	setge	cl
	cmp	DWORD PTR tv804[esp+72], ecx
	mov	ecx, ebp
	jne	SHORT $LN149@UpdateDang
	test	ebp, ebp
	jge	SHORT $LN153@UpdateDang
	mov	ecx, DWORD PTR tv1161[esp+72]
$LN153@UpdateDang:
	mov	eax, edi
	test	edi, edi
	jge	SHORT $LN155@UpdateDang
	mov	eax, edx
$LN155@UpdateDang:
	add	eax, ecx
	jmp	SHORT $LN160@UpdateDang
$LN149@UpdateDang:
	test	ebp, ebp
	jge	SHORT $LN157@UpdateDang
	mov	ecx, DWORD PTR tv1161[esp+72]
$LN157@UpdateDang:
	mov	eax, edi
	test	edi, edi
	jge	SHORT $LN159@UpdateDang
	mov	eax, edx
$LN159@UpdateDang:
	cmp	ecx, eax
	jl	SHORT $LN160@UpdateDang
	mov	eax, ecx
$LN160@UpdateDang:
	cmp	eax, esi
	jg	SHORT $LN16@UpdateDang
	mov	eax, DWORD PTR _pCityPlot$222153[esp+72]
	movsx	edx, WORD PTR [eax+2]
	movsx	eax, WORD PTR [eax]
	push	edi
	push	ebp
	push	edx
	push	eax
	call	?plotXY@@YAPAVCvPlot@@HHHH@Z		; plotXY
	mov	esi, eax
	add	esp, 16					; 00000010H

; 222  : #endif
; 223  : 					if(!pLoopPlot)

	test	esi, esi
	je	SHORT $LN245@UpdateDang

; 224  : 					{
; 225  : 						continue;
; 226  : 					}
; 227  : 
; 228  : 					AssignCityDangerValue(pLoopCity, pLoopPlot);

	push	0
	mov	ecx, ebx
	call	?getStrengthValue@CvCity@@QBEH_N@Z	; CvCity::getStrengthValue
	mov	ecx, DWORD PTR [ebx+84]
	push	eax
	push	esi
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+84]
	call	?ModifyDangerByRelationship@CvDangerPlots@@QAEHW4PlayerTypes@@PAVCvPlot@@H@Z ; CvDangerPlots::ModifyDangerByRelationship
	movsx	ecx, WORD PTR [esi+2]
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	imul	ecx, DWORD PTR [edx+4020]
	movsx	edx, WORD PTR [esi]
	add	ecx, edx
	test	eax, eax
	jle	SHORT $LN172@UpdateDang
	and	eax, -2					; fffffffeH
$LN172@UpdateDang:
	mov	edx, DWORD PTR _this$[esp+72]
	mov	edx, DWORD PTR [edx+96]
	add	DWORD PTR [edx+ecx*4], eax
	lea	ecx, DWORD PTR [edx+ecx*4]
$LN245@UpdateDang:
	mov	edx, DWORD PTR tv1146[esp+72]
	mov	esi, DWORD PTR _iRange$222152[esp+72]
$LN16@UpdateDang:
	inc	edi
	dec	edx
	cmp	edi, esi
	mov	DWORD PTR tv1146[esp+72], edx
	jle	$LL17@UpdateDang
$LN19@UpdateDang:

; 205  : 			CvPlot* pLoopPlot = NULL;
; 206  : 
; 207  : #ifdef AUI_HEXSPACE_DX_LOOPS
; 208  : 			int iMaxDX, iDX;
; 209  : 			for (int iDY = -iRange; iDY <= iRange; iDY++)
; 210  : 			{
; 211  : 				iMaxDX = iRange - MAX(0, iDY);
; 212  : 				for (iDX = -iRange - MIN(0, iDY); iDX <= iMaxDX; iDX++) // MIN() and MAX() stuff is to reduce loops (hexspace!)
; 213  : 				{
; 214  : 					// No need for range check because loops are set up properly
; 215  : 					pLoopPlot = plotXY(pCityPlot->getX(), pCityPlot->getY(), iDX, iDY);
; 216  : #else
; 217  : 			for(int iDX = -(iRange); iDX <= iRange; iDX++)

	dec	DWORD PTR tv1161[esp+72]
	inc	ebp
	cmp	ebp, esi
	jle	$LL20@UpdateDang
$LN23@UpdateDang:

; 189  : 				}
; 190  : 			}
; 191  : 		}
; 192  : 
; 193  : 		// for each city
; 194  : 		CvCity* pLoopCity;
; 195  : 		for(pLoopCity = loopPlayer.firstCity(&iLoop); pLoopCity != NULL; pLoopCity = loopPlayer.nextCity(&iLoop))

	mov	ecx, DWORD PTR _loopPlayer$222121[esp+72]
	push	0
	lea	eax, DWORD PTR _iLoop$222126[esp+76]
	push	eax
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	ebx, eax
	test	ebx, ebx
	jne	$LL247@UpdateDang
$LN43@UpdateDang:

; 120  : 
; 121  : 	// for each opposing civ
; 122  : 	for(int iPlayer = 0; iPlayer < MAX_PLAYERS; iPlayer++)

	mov	eax, DWORD PTR tv1175[esp+72]
	inc	DWORD PTR _iPlayer$222115[esp+72]
	add	eax, 63236				; 0000f704H
	cmp	eax, 4047104				; 003dc100H
	mov	DWORD PTR tv1175[esp+72], eax
	jl	$LL250@UpdateDang

; 229  : 				}
; 230  : 			}
; 231  : 		}
; 232  : 	}
; 233  : 
; 234  : 	// Citadels
; 235  : 	int iCitadelValue = GetDangerValueOfCitadel();

	mov	ecx, DWORD PTR _this$[esp+72]
	mov	ecx, DWORD PTR [ecx]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetMilitaryAI@CvPlayer@@QBEPAVCvMilitaryAI@@XZ ; CvPlayer::GetMilitaryAI
	push	2
	mov	ecx, eax
	call	?GetPowerOfStrongestBuildableUnit@CvMilitaryAI@@QAEHW4DomainTypes@@@Z ; CvMilitaryAI::GetPowerOfStrongestBuildableUnit

; 236  : #ifdef AUI_WARNING_FIXES
; 237  : 	uint iPlotLoop;
; 238  : #else
; 239  : 	int iPlotLoop;
; 240  : #endif
; 241  : 	CvPlot* pPlot, *pAdjacentPlot;
; 242  : 	for(iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	edi, eax
	imul	edi, 50					; 00000032H
	cmp	DWORD PTR [edx+4028], 0
	mov	DWORD PTR _iPlotLoop$[esp+72], 0
	jle	$LN246@UpdateDang
	mov	ecx, DWORD PTR $T224647[esp+72]
	mov	ebx, ecx
	shr	ebx, 5

; 243  : 	{
; 244  : 		pPlot = GC.getMap().plotByIndexUnchecked(iPlotLoop);
; 245  : 
; 246  : 		if(pPlot->isRevealed(thisTeam))

	mov	eax, ebx
	shl	eax, 5
	sub	ecx, eax
	mov	ebp, 1
	shl	ebp, cl
	mov	DWORD PTR _uiOffset$224988[esp+72], ebx
	mov	DWORD PTR tv1190[esp+68], 0
	mov	DWORD PTR tv1070[esp+72], ebp
	npad	1
$LL13@UpdateDang:
	mov	esi, DWORD PTR [edx+4068]
	add	esi, DWORD PTR tv1190[esp+68]
	test	DWORD PTR [esi+ebx*4+8], ebp
	je	$LN12@UpdateDang

; 247  : 		{
; 248  : 			ImprovementTypes eImprovement = pPlot->getRevealedImprovementType(thisTeam);

	mov	ecx, DWORD PTR $T224647[esp+72]
	push	ecx
	mov	ecx, esi
	call	?getRevealedImprovementType@CvPlot@@QBE?AW4ImprovementTypes@@W4TeamTypes@@@Z ; CvPlot::getRevealedImprovementType

; 249  : 			if(eImprovement != NO_IMPROVEMENT && GC.getImprovementInfo(eImprovement)->GetNearbyEnemyDamage() > 0)

	cmp	eax, -1
	je	SHORT $LN12@UpdateDang
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	ecx, eax
	call	?GetNearbyEnemyDamage@CvImprovementEntry@@QBEHXZ ; CvImprovementEntry::GetNearbyEnemyDamage
	test	eax, eax
	jle	SHORT $LN12@UpdateDang

; 250  : 			{
; 251  : 				if(!ShouldIgnoreCitadel(pPlot, bIgnoreVisibility))

	mov	edx, DWORD PTR _bIgnoreVisibility$[esp+68]
	mov	ecx, DWORD PTR _this$[esp+72]
	push	edx
	push	esi
	call	?ShouldIgnoreCitadel@CvDangerPlots@@QAE_NPAVCvPlot@@_N@Z ; CvDangerPlots::ShouldIgnoreCitadel
	test	al, al
	jne	SHORT $LN12@UpdateDang

; 252  : 				{
; 253  : 					for(int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	xor	ebp, ebp
$LL7@UpdateDang:

; 254  : 					{
; 255  : 						pAdjacentPlot = plotDirection(pPlot->getX(), pPlot->getY(), ((DirectionTypes)iI));

	movsx	eax, WORD PTR [esi+2]
	movsx	ecx, WORD PTR [esi]
	push	ebp
	push	eax
	push	ecx
	call	?plotDirection@@YAPAVCvPlot@@HHW4DirectionTypes@@@Z ; plotDirection
	add	esp, 12					; 0000000cH

; 256  : 
; 257  : 						if(pAdjacentPlot != NULL)

	test	eax, eax
	je	SHORT $LN6@UpdateDang

; 258  : 						{
; 259  : 							AddDanger(pAdjacentPlot->getX(), pAdjacentPlot->getY(), iCitadelValue, true);

	movsx	ecx, WORD PTR [eax+2]
	mov	ebx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	imul	ecx, DWORD PTR [ebx+4020]
	movsx	eax, WORD PTR [eax]
	add	ecx, eax
	mov	edx, edi
	test	edi, edi
	jle	SHORT $LN243@UpdateDang
	or	edx, 1
$LN243@UpdateDang:
	mov	eax, DWORD PTR _this$[esp+72]
	mov	eax, DWORD PTR [eax+96]
	add	DWORD PTR [eax+ecx*4], edx
	mov	ebx, DWORD PTR _uiOffset$224988[esp+72]
	lea	eax, DWORD PTR [eax+ecx*4]
$LN6@UpdateDang:
	inc	ebp
	cmp	ebp, 6
	jl	SHORT $LL7@UpdateDang

; 252  : 				{
; 253  : 					for(int iI = 0; iI < NUM_DIRECTION_TYPES; iI++)

	mov	ebp, DWORD PTR tv1070[esp+72]
$LN12@UpdateDang:

; 236  : #ifdef AUI_WARNING_FIXES
; 237  : 	uint iPlotLoop;
; 238  : #else
; 239  : 	int iPlotLoop;
; 240  : #endif
; 241  : 	CvPlot* pPlot, *pAdjacentPlot;
; 242  : 	for(iPlotLoop = 0; iPlotLoop < GC.getMap().numPlots(); iPlotLoop++)

	mov	eax, DWORD PTR _iPlotLoop$[esp+72]
	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	add	DWORD PTR tv1190[esp+68], 484		; 000001e4H
	inc	eax
	cmp	eax, DWORD PTR [edx+4028]
	mov	DWORD PTR _iPlotLoop$[esp+72], eax
	jl	$LL13@UpdateDang
$LN246@UpdateDang:
	mov	edi, DWORD PTR _thisPlayer$[esp+72]
	mov	ebx, DWORD PTR _this$[esp+72]

; 260  : 						}
; 261  : 					}
; 262  : 				}
; 263  : 			}
; 264  : 		}
; 265  : 	}
; 266  : 
; 267  : 	// testing city danger values
; 268  : 	CvCity* pLoopCity;
; 269  : 	int iLoopCity = 0;
; 270  : 	for(pLoopCity = thisPlayer.firstCity(&iLoopCity); pLoopCity != NULL; pLoopCity = thisPlayer.nextCity(&iLoopCity))

	push	0
	lea	ecx, DWORD PTR _iLoopCity$[esp+76]
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR _iLoopCity$[esp+80], 0
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	esi, eax
	test	esi, esi
	je	SHORT $LN1@UpdateDang
$LL3@UpdateDang:

; 271  : 	{
; 272  : 		int iThreatValue = GetCityDanger(pLoopCity);

	push	esi
	mov	ecx, ebx
	call	?GetCityDanger@CvDangerPlots@@QAEHPAVCvCity@@@Z ; CvDangerPlots::GetCityDanger

; 273  : 		pLoopCity->SetThreatValue(iThreatValue);

	push	eax
	mov	ecx, esi
	call	?SetThreatValue@CvCity@@QAEXH@Z		; CvCity::SetThreatValue
	push	0
	lea	edx, DWORD PTR _iLoopCity$[esp+76]
	push	edx
	mov	ecx, edi
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	esi, eax
	test	esi, esi
	jne	SHORT $LL3@UpdateDang
$LN1@UpdateDang:
	pop	edi
	pop	ebp

; 274  : 	}
; 275  : 
; 276  : 	m_bDirty = false;

	mov	BYTE PTR [ebx+5], 0
	pop	ebx
$LN49@UpdateDang:
	pop	esi

; 277  : }

	add	esp, 56					; 00000038H
	ret	8
?UpdateDanger@CvDangerPlots@@QAEX_N0@Z ENDP		; CvDangerPlots::UpdateDanger
_TEXT	ENDS
PUBLIC	?resize@?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@QAEXI@Z ; FFastVector<unsigned int,1,297,0,BaseVector<unsigned int,1>::FDefaultFastVectorAllocator>::resize
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?resize@?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@QAEXI@Z
_TEXT	SEGMENT
_uiNewSize$ = 8						; size = 4
?resize@?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@QAEXI@Z PROC ; FFastVector<unsigned int,1,297,0,BaseVector<unsigned int,1>::FDefaultFastVectorAllocator>::resize, COMDAT
; _this$ = ecx

; 353  : 	{

	push	esi
	push	edi

; 354  : 		if( m_uiCurrMaxSize < uiNewSize ){

	mov	edi, DWORD PTR _uiNewSize$[esp+4]
	mov	esi, ecx
	cmp	DWORD PTR [esi+8], edi
	jae	SHORT $LN6@resize

; 355  : 			GrowSize(uiNewSize);

	push	edi
	call	?GrowSize@?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@IAEXI@Z ; FFastVector<unsigned int,1,297,0,BaseVector<unsigned int,1>::FDefaultFastVectorAllocator>::GrowSize

; 356  : 		}
; 357  : 		m_uiCurrSize = MIN(uiNewSize, m_uiCurrMaxSize);

	cmp	DWORD PTR [esi+8], edi
	jae	SHORT $LN6@resize
	mov	eax, DWORD PTR [esi+8]
	pop	edi
	mov	DWORD PTR [esi+4], eax
	pop	esi

; 358  : 	};

	ret	4

; 356  : 		}
; 357  : 		m_uiCurrSize = MIN(uiNewSize, m_uiCurrMaxSize);

$LN6@resize:
	lea	eax, DWORD PTR _uiNewSize$[esp+4]
	mov	ecx, DWORD PTR [eax]
	pop	edi
	mov	DWORD PTR [esi+4], ecx
	pop	esi

; 358  : 	};

	ret	4
?resize@?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@QAEXI@Z ENDP ; FFastVector<unsigned int,1,297,0,BaseVector<unsigned int,1>::FDefaultFastVectorAllocator>::resize
_TEXT	ENDS
PUBLIC	?Init@CvDangerPlots@@QAEXW4PlayerTypes@@_N@Z	; CvDangerPlots::Init
; Function compile flags: /Ogtpy
; File s:\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvdangerplots.cpp
;	COMDAT ?Init@CvDangerPlots@@QAEXW4PlayerTypes@@_N@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
$T225138 = 12						; size = 4
_bAllocate$ = 12					; size = 1
?Init@CvDangerPlots@@QAEXW4PlayerTypes@@_N@Z PROC	; CvDangerPlots::Init, COMDAT
; _this$ = ecx

; 58   : 	Uninit();
; 59   : 	m_ePlayer = ePlayer;
; 60   : 
; 61   : 	if(bAllocate)

	cmp	BYTE PTR _bAllocate$[esp-4], 0
	mov	eax, DWORD PTR _ePlayer$[esp-4]
	push	ebp
	mov	ebp, ecx
	mov	DWORD PTR [ebp+100], 0
	mov	BYTE PTR [ebp+4], 0
	mov	BYTE PTR [ebp+5], 0
	mov	DWORD PTR [ebp], eax
	je	SHORT $LN1@Init

; 62   : 	{
; 63   : 		int iGridSize = GC.getMap().numPlots();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	ebx
	push	esi
	mov	esi, DWORD PTR [ecx+4028]
	push	edi

; 64   : 		CvAssertMsg(iGridSize > 0, "iGridSize is zero");
; 65   : #ifdef AUI_DANGER_PLOTS_FIX_USE_ARRAY_NOT_FFASTVECTOR
; 66   : 		m_DangerPlots = FNEW(uint[iGridSize], c_eCiv5GameplayDLL, 0);
; 67   : 		fill(m_DangerPlots, &m_DangerPlots[iGridSize - 1], 0);
; 68   : #else
; 69   : 		m_DangerPlots.resize(iGridSize);

	lea	edi, DWORD PTR [ebp+96]
	lea	ebx, DWORD PTR [edi+8]
	mov	DWORD PTR $T225138[esp+12], esi
	cmp	DWORD PTR [ebx], esi
	jae	SHORT $LN26@Init
	push	esi
	mov	ecx, edi
	call	?GrowSize@?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@IAEXI@Z ; FFastVector<unsigned int,1,297,0,BaseVector<unsigned int,1>::FDefaultFastVectorAllocator>::GrowSize
	cmp	DWORD PTR [ebx], esi
	jb	SHORT $LN27@Init
$LN26@Init:
	lea	ebx, DWORD PTR $T225138[esp+12]
$LN27@Init:
	mov	edx, DWORD PTR [ebx]

; 70   : 		m_bArrayAllocated = true;
; 71   : 		for(int i = 0; i < iGridSize; i++)

	xor	eax, eax
	mov	DWORD PTR [edi+4], edx
	mov	BYTE PTR [ebp+4], 1
	test	esi, esi
	jle	SHORT $LN32@Init
	npad	4
$LL3@Init:

; 72   : 		{
; 73   : 			m_DangerPlots[i] = 0;

	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [ecx+eax*4], 0
	inc	eax
	cmp	eax, esi
	jl	SHORT $LL3@Init
$LN32@Init:
	pop	edi
	pop	esi
	pop	ebx
$LN1@Init:
	pop	ebp

; 74   : 		}
; 75   : #endif
; 76   : 	}
; 77   : }

	ret	8
?Init@CvDangerPlots@@QAEXW4PlayerTypes@@_N@Z ENDP	; CvDangerPlots::Init
_TEXT	ENDS
PUBLIC	?Read@CvDangerPlots@@QAEXAAVFDataStream@@@Z	; CvDangerPlots::Read
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z:PROC ; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ?Read@CvDangerPlots@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
$T225179 = -8						; size = 4
_uiVersion$ = -4					; size = 4
_iGridSize$ = 8						; size = 4
_kStream$ = 8						; size = 4
?Read@CvDangerPlots@@QAEXAAVFDataStream@@@Z PROC	; CvDangerPlots::Read, COMDAT
; _this$ = ecx

; 775  : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	push	edi

; 776  : 	// Version number to maintain backwards compatibility
; 777  : 	uint uiVersion;
; 778  : 	kStream >> uiVersion;

	mov	edi, DWORD PTR _kStream$[esp+20]
	lea	eax, DWORD PTR _uiVersion$[esp+24]
	mov	ebx, ecx
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 779  : 
; 780  : 	kStream >> m_ePlayer;

	push	ebx
	push	edi
	call	??5@YAAAVFDataStream@@AAV0@AAW4PlayerTypes@@@Z ; operator>>
	add	esp, 8

; 781  : #ifdef AUI_DANGER_PLOTS_FIX_USE_ARRAY_NOT_FFASTVECTOR
; 782  : 	bool bArrayAllocated = false;
; 783  : 	kStream >> bArrayAllocated;
; 784  : #else
; 785  : 	kStream >> m_bArrayAllocated;

	lea	ecx, DWORD PTR [ebx+4]
	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 786  : #endif
; 787  : 
; 788  : 	int iGridSize;
; 789  : 	kStream >> iGridSize;

	lea	edx, DWORD PTR _iGridSize$[esp+20]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 790  : 
; 791  : #ifdef AUI_DANGER_PLOTS_FIX_USE_ARRAY_NOT_FFASTVECTOR
; 792  : 	if (m_DangerPlots)
; 793  : 		SAFE_DELETE_ARRAY(m_DangerPlots);
; 794  : 	if (bArrayAllocated)
; 795  : 	{
; 796  : 		m_DangerPlots = FNEW(uint[iGridSize], c_eCiv5GameplayDLL, 0);
; 797  : #else
; 798  : 	m_DangerPlots.resize(iGridSize);

	mov	eax, DWORD PTR _iGridSize$[esp+20]
	lea	ebp, DWORD PTR [ebx+96]
	lea	esi, DWORD PTR [ebp+8]
	mov	DWORD PTR $T225179[esp+24], eax
	cmp	DWORD PTR [esi], eax
	jae	SHORT $LN12@Read
	push	eax
	mov	ecx, ebp
	call	?GrowSize@?$FFastVector@I$00$0BCJ@$0A@UFDefaultFastVectorAllocator@?$BaseVector@I$00@@@@IAEXI@Z ; FFastVector<unsigned int,1,297,0,BaseVector<unsigned int,1>::FDefaultFastVectorAllocator>::GrowSize
	mov	eax, DWORD PTR _iGridSize$[esp+20]
$LN12@Read:
	mov	ecx, DWORD PTR $T225179[esp+24]
	cmp	DWORD PTR [esi], ecx
	jb	SHORT $LN18@Read
	lea	esi, DWORD PTR $T225179[esp+24]
$LN18@Read:
	mov	edx, DWORD PTR [esi]

; 799  : #endif
; 800  : 	for(int i = 0; i < iGridSize; i++)

	xor	esi, esi
	mov	DWORD PTR [ebp+4], edx
	test	eax, eax
	jle	SHORT $LN25@Read
	npad	1
$LL3@Read:
	mov	eax, DWORD PTR [ebp]
	lea	ecx, DWORD PTR [eax+esi*4]

; 801  : 	{
; 802  : 		kStream >> m_DangerPlots[i];

	push	ecx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read
	inc	esi
	cmp	esi, DWORD PTR _iGridSize$[esp+20]
	jl	SHORT $LL3@Read
$LN25@Read:
	pop	edi
	pop	esi
	pop	ebp

; 803  : 	}
; 804  : #ifdef AUI_DANGER_PLOTS_FIX_USE_ARRAY_NOT_FFASTVECTOR
; 805  : 	}
; 806  : #endif
; 807  : 
; 808  : 	m_bDirty = false;

	mov	BYTE PTR [ebx+5], 0
	pop	ebx

; 809  : }

	add	esp, 8
	ret	4
?Read@CvDangerPlots@@QAEXAAVFDataStream@@@Z ENDP	; CvDangerPlots::Read
_TEXT	ENDS
END
