; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Documents\GitHub\Lekmod\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvTechClasses.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?NO_QUEST_DATA@CvMinorCivQuest@@2HB		; CvMinorCivQuest::NO_QUEST_DATA
PUBLIC	?NO_TURN@CvMinorCivQuest@@2HB			; CvMinorCivQuest::NO_TURN
PUBLIC	?ms_V0ExpansionTechTags@@3PAPBDA		; ms_V0ExpansionTechTags
_DATA	SEGMENT
?ms_V0ExpansionTechTags@@3PAPBDA DD FLAT:$SG225089	; ms_V0ExpansionTechTags
	DD	FLAT:$SG225090
	DD	FLAT:$SG225091
	DD	FLAT:$SG225092
	DD	FLAT:$SG225093
	DD	FLAT:$SG225094
	DD	FLAT:$SG225095
	DD	FLAT:$SG225096
	DD	FLAT:$SG225097
	DD	FLAT:$SG225098
	DD	FLAT:$SG225099
	DD	FLAT:$SG225100
	DD	FLAT:$SG225101
	DD	FLAT:$SG225102
	DD	FLAT:$SG225103
	DD	FLAT:$SG225104
	DD	FLAT:$SG225105
	DD	FLAT:$SG225106
	DD	FLAT:$SG225107
	DD	FLAT:$SG225108
	DD	FLAT:$SG225109
	DD	FLAT:$SG225110
	DD	FLAT:$SG225111
	DD	FLAT:$SG225112
	DD	FLAT:$SG225113
	DD	FLAT:$SG225114
	DD	FLAT:$SG225115
	DD	FLAT:$SG225116
	DD	FLAT:$SG225117
	DD	FLAT:$SG225118
	DD	FLAT:$SG225119
	DD	FLAT:$SG225120
	DD	FLAT:$SG225121
	DD	FLAT:$SG225122
	DD	FLAT:$SG225123
	DD	FLAT:$SG225124
	DD	FLAT:$SG225125
	DD	FLAT:$SG225126
	DD	FLAT:$SG225127
	DD	FLAT:$SG225128
	DD	FLAT:$SG225129
	DD	FLAT:$SG225130
	DD	FLAT:$SG225131
	DD	FLAT:$SG225132
	DD	FLAT:$SG225133
	DD	FLAT:$SG225134
	DD	FLAT:$SG225135
	DD	FLAT:$SG225136
	DD	FLAT:$SG225137
	DD	FLAT:$SG225138
	DD	FLAT:$SG225139
	DD	FLAT:$SG225140
	DD	FLAT:$SG225141
	DD	FLAT:$SG225142
	DD	FLAT:$SG225143
	DD	FLAT:$SG225144
	DD	FLAT:$SG225145
	DD	FLAT:$SG225146
	DD	FLAT:$SG225147
	DD	FLAT:$SG225148
	DD	FLAT:$SG225149
	DD	FLAT:$SG225150
	DD	FLAT:$SG225151
	DD	FLAT:$SG225152
	DD	FLAT:$SG225153
	DD	FLAT:$SG225154
	DD	FLAT:$SG225155
	DD	FLAT:$SG225156
	DD	FLAT:$SG225157
	DD	FLAT:$SG225158
	DD	FLAT:$SG225159
	DD	FLAT:$SG225160
	DD	FLAT:$SG225161
	DD	FLAT:$SG225162
	DD	FLAT:$SG225163
	DD	FLAT:$SG225164
	DD	FLAT:$SG225165
	DD	FLAT:$SG225166
	DD	FLAT:$SG225167
	DD	FLAT:$SG225168
	DD	FLAT:$SG225169
_DATA	ENDS
CONST	SEGMENT
$SG223933 DB	'AIWeight', 00H
	ORG $+3
$SG223934 DB	'AITradeModifier', 00H
$SG223935 DB	'Cost', 00H
	ORG $+3
$SG223936 DB	'AdvancedStartCost', 00H
	ORG $+2
$SG223937 DB	'FeatureProductionModifier', 00H
	ORG $+2
$SG223938 DB	'UnitFortificationModifier', 00H
	ORG $+2
$SG223939 DB	'UnitBaseHealModifier', 00H
	ORG $+3
$SG223940 DB	'WorkerSpeedModifier', 00H
$SG223941 DB	'FirstFreeTechs', 00H
	ORG $+1
$SG223942 DB	'EmbarkedMoveChange', 00H
	ORG $+1
$SG223943 DB	'EmbarkedSightChange', 00H
$SG223944 DB	'InternationalTradeRoutesChange', 00H
	ORG $+1
$SG223945 DB	'InfluenceSpreadModifier', 00H
$SG223946 DB	'ExtraVotesPerDiplomat', 00H
	ORG $+2
$SG223947 DB	'EndsGame', 00H
	ORG $+3
$SG223948 DB	'AllowsEmbarking', 00H
$SG223949 DB	'AllowsEmbarkingCivilian', 00H
$SG223950 DB	'AllowsDefensiveEmbarking', 00H
	ORG $+3
$SG223951 DB	'EmbarkedAllWaterPassage', 00H
$SG223952 DB	'AllowsBarbarianBoats', 00H
	ORG $+3
$SG223953 DB	'Repeat', 00H
	ORG $+1
$SG223954 DB	'Trade', 00H
	ORG $+2
$SG223955 DB	'Disable', 00H
$SG223956 DB	'DisableTechSteal', 00H
	ORG $+3
$SG223957 DB	'GoodyTech', 00H
	ORG $+2
$SG223958 DB	'TriggersArchaeologicalSites', 00H
$SG223959 DB	'AllowsWorldCongress', 00H
$SG223960 DB	'ExtraWaterSeeFrom', 00H
	ORG $+2
$SG223961 DB	'MapCentering', 00H
	ORG $+3
$SG223962 DB	'MapVisible', 00H
	ORG $+1
$SG223963 DB	'MapTrading', 00H
	ORG $+1
$SG223964 DB	'TechTrading', 00H
$SG223965 DB	'GoldTrading', 00H
$SG223966 DB	'AllowEmbassyTradingAllowed', 00H
	ORG $+1
$SG223967 DB	'OpenBordersTradingAllowed', 00H
	ORG $+2
$SG223968 DB	'DefensivePactTradingAllowed', 00H
$SG223969 DB	'ResearchAgreementTradingAllowed', 00H
$SG223970 DB	'TradeAgreementTradingAllowed', 00H
	ORG $+3
$SG223971 DB	'PermanentAllianceTradingAllowed', 00H
$SG223972 DB	'BridgeBuilding', 00H
	ORG $+1
$SG223973 DB	'WaterWork', 00H
	ORG $+2
$SG223974 DB	'GridX', 00H
	ORG $+2
$SG223975 DB	'GridY', 00H
	ORG $+2
$SG223977 DB	'Era', 00H
$SG223978 DB	'FirstFreeUnitClass', 00H
	ORG $+1
$SG223979 DB	'Quote', 00H
	ORG $+2
$SG223980 DB	'AudioIntro', 00H
	ORG $+1
$SG223981 DB	'AudioIntroHeader', 00H
	ORG $+3
$SG223983 DB	'Moves', 00H
	ORG $+2
$SG223984 DB	'TechType', 00H
	ORG $+3
$SG223985 DB	'DomainType', 00H
	ORG $+1
$SG223986 DB	'Technology_DomainExtraMoves', 00H
$SG223987 DB	'Domains', 00H
$SG223988 DB	'Range', 00H
	ORG $+2
$SG223989 DB	'TechType', 00H
	ORG $+3
$SG223990 DB	'DomainType', 00H
	ORG $+1
$SG223991 DB	'Technology_TradeRouteDomainExtraRange', 00H
	ORG $+2
$SG223992 DB	'Domains', 00H
$SG223993 DB	'TechType', 00H
	ORG $+3
$SG223994 DB	'PromotionType', 00H
	ORG $+2
$SG223995 DB	'Technology_FreePromotions', 00H
	ORG $+2
$SG223996 DB	'UnitPromotions', 00H
	ORG $+1
$SG223997 DB	'TechType', 00H
	ORG $+3
$SG223998 DB	'Technology_Flavors', 00H
	ORG $+1
$SG224000 DB	'Technologies', 00H
	ORG $+3
$SG224002 DB	'Technologies - Technology_ORPrereqTechs', 00H
$SG224820 DB	'PlayerCanResearch', 00H
	ORG $+2
$SG224005 DB	'select Technologies.ID from Technology_ORPrereqTechs inn'
	DB	'er join Technologies on Technologies.Type = PrereqTech where '
	DB	'TechType = ?;', 00H
	ORG $+1
$SG224011 DB	'Technologies - Technology_PrereqTechs', 00H
	ORG $+6
$SG224014 DB	'select Technologies.ID from Technology_PrereqTechs inner'
	DB	' join Technologies on Technologies.Type = PrereqTech where Te'
	DB	'chType = ?;', 00H
	ORG $+3
$SG224781 DB	'PlayerCanEverResearch', 00H
	ORG $+2
$SG224861 DB	'LEADER_CATHERINE', 00H
	ORG $+3
$SG224874 DB	'TECH_HORSEBACK_RIDING', 00H
	ORG $+2
$SG225039 DB	'.csv', 00H
	ORG $+3
$SG225040 DB	'TechAILog_', 00H
	ORG $+1
$SG225042 DB	'TechAILog.csv', 00H
	ORG $+2
$SG225044 DB	'%03d, ', 00H
	ORG $+1
$SG225046 DB	', ', 00H
	ORG $+1
$SG225053 DB	'Flavor, %s, %d', 00H
	ORG $+1
$SG225056 DB	'Flavor, %s, %d', 00H
	ORG $+1
$SG225089 DB	'TECH_AGRICULTURE', 00H
	ORG $+3
$SG225090 DB	'TECH_POTTERY', 00H
	ORG $+3
$SG225091 DB	'TECH_ANIMAL_HUSBANDRY', 00H
	ORG $+2
$SG225092 DB	'TECH_ARCHERY', 00H
	ORG $+3
$SG225093 DB	'TECH_MINING', 00H
$SG225094 DB	'TECH_SAILING', 00H
	ORG $+3
$SG225095 DB	'TECH_CALENDAR', 00H
	ORG $+2
$SG225096 DB	'TECH_WRITING', 00H
	ORG $+3
$SG225097 DB	'TECH_TRAPPING', 00H
	ORG $+2
$SG225098 DB	'TECH_THE_WHEEL', 00H
	ORG $+1
$SG225099 DB	'TECH_MASONRY', 00H
	ORG $+3
$SG225100 DB	'TECH_BRONZE_WORKING', 00H
$SG225101 DB	'TECH_OPTICS', 00H
$SG225102 DB	'TECH_HORSEBACK_RIDING', 00H
	ORG $+2
$SG225103 DB	'TECH_MATHEMATICS', 00H
	ORG $+3
$SG225104 DB	'TECH_CONSTRUCTION', 00H
	ORG $+2
$SG225105 DB	'TECH_PHILOSOPHY', 00H
$SG225106 DB	'TECH_DRAMA', 00H
	ORG $+1
$SG225107 DB	'TECH_CURRENCY', 00H
	ORG $+2
$SG225108 DB	'TECH_ENGINEERING', 00H
	ORG $+3
$SG225109 DB	'TECH_IRON_WORKING', 00H
	ORG $+2
$SG225110 DB	'TECH_THEOLOGY', 00H
	ORG $+2
$SG225111 DB	'TECH_CIVIL_SERVICE', 00H
	ORG $+1
$SG225112 DB	'TECH_GUILDS', 00H
$SG225113 DB	'TECH_METAL_CASTING', 00H
	ORG $+1
$SG225114 DB	'TECH_COMPASS', 00H
	ORG $+3
$SG225115 DB	'TECH_EDUCATION', 00H
	ORG $+1
$SG225116 DB	'TECH_CHIVALRY', 00H
	ORG $+2
$SG225117 DB	'TECH_MACHINERY', 00H
	ORG $+1
$SG225118 DB	'TECH_PHYSICS', 00H
	ORG $+3
$SG225119 DB	'TECH_STEEL', 00H
	ORG $+1
$SG225120 DB	'TECH_ASTRONOMY', 00H
	ORG $+1
$SG225121 DB	'TECH_ACOUSTICS', 00H
	ORG $+1
$SG225122 DB	'TECH_BANKING', 00H
	ORG $+3
$SG225123 DB	'TECH_PRINTING_PRESS', 00H
$SG225124 DB	'TECH_GUNPOWDER', 00H
	ORG $+1
$SG225125 DB	'TECH_NAVIGATION', 00H
$SG225126 DB	'TECH_ARCHITECTURE', 00H
	ORG $+2
$SG225127 DB	'TECH_ECONOMICS', 00H
	ORG $+1
$SG225128 DB	'TECH_METALLURGY', 00H
$SG225129 DB	'TECH_CHEMISTRY', 00H
	ORG $+1
$SG225130 DB	'TECH_ARCHAEOLOGY', 00H
	ORG $+3
$SG225131 DB	'TECH_SCIENTIFIC_THEORY', 00H
	ORG $+1
$SG225132 DB	'TECH_INDUSTRIALIZATION', 00H
	ORG $+1
$SG225133 DB	'TECH_MILITARY_SCIENCE', 00H
	ORG $+2
$SG225134 DB	'TECH_RIFLING', 00H
	ORG $+3
$SG225135 DB	'TECH_FERTILIZER', 00H
$SG225136 DB	'TECH_BIOLOGY', 00H
	ORG $+3
$SG225137 DB	'TECH_STEAM_POWER', 00H
	ORG $+3
$SG225138 DB	'TECH_DYNAMITE', 00H
	ORG $+2
$SG225139 DB	'TECH_ELECTRICITY', 00H
	ORG $+3
$SG225140 DB	'TECH_REPLACEABLE_PARTS', 00H
	ORG $+1
$SG225141 DB	'TECH_RAILROAD', 00H
	ORG $+2
$SG225142 DB	'TECH_REFRIGERATION', 00H
	ORG $+1
$SG225143 DB	'TECH_HYDROELECTRICS', 00H
$SG225144 DB	'TECH_RADIO', 00H
	ORG $+1
$SG225145 DB	'TECH_FLIGHT', 00H
$SG225146 DB	'TECH_BALLISTICS', 00H
$SG225147 DB	'TECH_COMBUSTION', 00H
$SG225148 DB	'TECH_PLASTIC', 00H
	ORG $+3
$SG225149 DB	'TECH_PENICILIN', 00H
	ORG $+1
$SG225150 DB	'TECH_ELECTRONICS', 00H
	ORG $+3
$SG225151 DB	'TECH_RADAR', 00H
	ORG $+1
$SG225152 DB	'TECH_COMBINED_ARMS', 00H
	ORG $+1
$SG225153 DB	'TECH_ATOMIC_THEORY', 00H
	ORG $+1
$SG225154 DB	'TECH_ECOLOGY', 00H
	ORG $+3
$SG225155 DB	'TECH_COMPUTERS', 00H
	ORG $+1
$SG225156 DB	'TECH_TELECOM', 00H
	ORG $+3
$SG225157 DB	'TECH_ROCKETRY', 00H
	ORG $+2
$SG225158 DB	'TECH_NUCLEAR_FISSION', 00H
	ORG $+3
$SG225159 DB	'TECH_GLOBALIZATION', 00H
	ORG $+1
$SG225160 DB	'TECH_ROBOTICS', 00H
	ORG $+2
$SG225161 DB	'TECH_SATELLITES', 00H
$SG225162 DB	'TECH_STEALTH', 00H
	ORG $+3
$SG225163 DB	'TECH_MOBILE_TACTICS', 00H
$SG225164 DB	'TECH_LASERS', 00H
$SG225165 DB	'TECH_ADVANCED_BALLISTICS', 00H
	ORG $+3
$SG225166 DB	'TECH_PARTICLE_PHYSICS', 00H
	ORG $+2
$SG225167 DB	'TECH_NANOTECHNOLOGY', 00H
$SG225168 DB	'TECH_NUCLEAR_FUSION', 00H
$SG225169 DB	'TECH_FUTURE_TECH', 00H
	ORG $+3
$SG225286 DB	'TeamSetHasTech', 00H
	ORG $+1
$SG225380 DB	'TXT_KEY_NOTIFICATION_ENOUGH_CULTURE_FOR_POLICY_DISMISS', 00H
	ORG $+1
$SG225383 DB	'TXT_KEY_NOTIFICATION_ENOUGH_CULTURE_FOR_POLICY', 00H
	ORG $+1
$SG225386 DB	'TXT_KEY_NOTIFICATION_SUMMARY_ENOUGH_CULTURE_FOR_POLICY', 00H
CONST	ENDS
;	COMDAT ?NO_TURN@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_TURN@CvMinorCivQuest@@2HB DD 0ffffffffH		; CvMinorCivQuest::NO_TURN
CONST	ENDS
;	COMDAT ?NO_QUEST_DATA@CvMinorCivQuest@@2HB
CONST	SEGMENT
?NO_QUEST_DATA@CvMinorCivQuest@@2HB DD 0ffffffffH	; CvMinorCivQuest::NO_QUEST_DATA
CONST	ENDS
PUBLIC	?wrapCoordDifference@@YAHHI_N@Z			; wrapCoordDifference
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?wrapCoordDifference@@YAHHI_N@Z
_TEXT	SEGMENT
_iDiff$ = 8						; size = 4
_uiRange$ = 12						; size = 4
_bWrap$ = 16						; size = 1
?wrapCoordDifference@@YAHHI_N@Z PROC			; wrapCoordDifference, COMDAT

; 57   : 	if(bWrap)

	cmp	BYTE PTR _bWrap$[esp-4], 0
	mov	eax, DWORD PTR _iDiff$[esp-4]
	je	SHORT $LN5@wrapCoordD

; 58   : 	{
; 59   : 		if(iDiff > (int)(uiRange >> 1))		// Using an unsigned int so we can safely assume that value >> 1 == value / 2

	mov	edx, DWORD PTR _uiRange$[esp-4]
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN3@wrapCoordD

; 60   : 		{
; 61   : 			return (iDiff - (int)uiRange);

	sub	eax, edx

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
$LN3@wrapCoordD:

; 62   : 		}
; 63   : 		else if(iDiff < -(int)(uiRange >> 1))

	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN5@wrapCoordD

; 64   : 		{
; 65   : 			return (iDiff + (int)uiRange);

	add	eax, edx
$LN5@wrapCoordD:

; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return iDiff;
; 70   : }

	ret	0
?wrapCoordDifference@@YAHHI_N@Z ENDP			; wrapCoordDifference
_TEXT	ENDS
PUBLIC	?xToHexspaceX@@YAHHH@Z				; xToHexspaceX
; Function compile flags: /Ogtpy
;	COMDAT ?xToHexspaceX@@YAHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?xToHexspaceX@@YAHHH@Z PROC				; xToHexspaceX, COMDAT

; 86   : 	return iX - ((iY >= 0) ? (iY>>1) : ((iY - 1)/2));

	mov	ecx, DWORD PTR _iY$[esp-4]
	test	ecx, ecx
	jge	SHORT $LN5@xToHexspac
	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
	mov	ecx, eax
$LN5@xToHexspac:
	mov	eax, DWORD PTR _iX$[esp-4]
	sar	ecx, 1
	sub	eax, ecx

; 87   : }

	ret	0
?xToHexspaceX@@YAHHH@Z ENDP				; xToHexspaceX
_TEXT	ENDS
PUBLIC	?GetAIWeight@CvTechEntry@@QBEHXZ		; CvTechEntry::GetAIWeight
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtechclasses.cpp
;	COMDAT ?GetAIWeight@CvTechEntry@@QBEHXZ
_TEXT	SEGMENT
?GetAIWeight@CvTechEntry@@QBEHXZ PROC			; CvTechEntry::GetAIWeight, COMDAT
; _this$ = ecx

; 225  : 	return m_iAIWeight;

	mov	eax, DWORD PTR [ecx+260]

; 226  : }

	ret	0
?GetAIWeight@CvTechEntry@@QBEHXZ ENDP			; CvTechEntry::GetAIWeight
_TEXT	ENDS
PUBLIC	?GetAITradeModifier@CvTechEntry@@QBEHXZ		; CvTechEntry::GetAITradeModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetAITradeModifier@CvTechEntry@@QBEHXZ
_TEXT	SEGMENT
?GetAITradeModifier@CvTechEntry@@QBEHXZ PROC		; CvTechEntry::GetAITradeModifier, COMDAT
; _this$ = ecx

; 231  : 	return m_iAITradeModifier;

	mov	eax, DWORD PTR [ecx+264]

; 232  : }

	ret	0
?GetAITradeModifier@CvTechEntry@@QBEHXZ ENDP		; CvTechEntry::GetAITradeModifier
_TEXT	ENDS
PUBLIC	?GetResearchCost@CvTechEntry@@QBEHXZ		; CvTechEntry::GetResearchCost
; Function compile flags: /Ogtpy
;	COMDAT ?GetResearchCost@CvTechEntry@@QBEHXZ
_TEXT	SEGMENT
?GetResearchCost@CvTechEntry@@QBEHXZ PROC		; CvTechEntry::GetResearchCost, COMDAT
; _this$ = ecx

; 237  : 	return m_iResearchCost;

	mov	eax, DWORD PTR [ecx+268]

; 238  : }

	ret	0
?GetResearchCost@CvTechEntry@@QBEHXZ ENDP		; CvTechEntry::GetResearchCost
_TEXT	ENDS
PUBLIC	?GetAdvancedStartCost@CvTechEntry@@QBEHXZ	; CvTechEntry::GetAdvancedStartCost
; Function compile flags: /Ogtpy
;	COMDAT ?GetAdvancedStartCost@CvTechEntry@@QBEHXZ
_TEXT	SEGMENT
?GetAdvancedStartCost@CvTechEntry@@QBEHXZ PROC		; CvTechEntry::GetAdvancedStartCost, COMDAT
; _this$ = ecx

; 243  : 	return m_iAdvancedStartCost;

	mov	eax, DWORD PTR [ecx+272]

; 244  : }

	ret	0
?GetAdvancedStartCost@CvTechEntry@@QBEHXZ ENDP		; CvTechEntry::GetAdvancedStartCost
_TEXT	ENDS
PUBLIC	?GetEra@CvTechEntry@@QBEHXZ			; CvTechEntry::GetEra
; Function compile flags: /Ogtpy
;	COMDAT ?GetEra@CvTechEntry@@QBEHXZ
_TEXT	SEGMENT
?GetEra@CvTechEntry@@QBEHXZ PROC			; CvTechEntry::GetEra, COMDAT
; _this$ = ecx

; 249  : 	return m_iEra;

	mov	eax, DWORD PTR [ecx+276]

; 250  : }

	ret	0
?GetEra@CvTechEntry@@QBEHXZ ENDP			; CvTechEntry::GetEra
_TEXT	ENDS
PUBLIC	?GetFeatureProductionModifier@CvTechEntry@@QBEHXZ ; CvTechEntry::GetFeatureProductionModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetFeatureProductionModifier@CvTechEntry@@QBEHXZ
_TEXT	SEGMENT
?GetFeatureProductionModifier@CvTechEntry@@QBEHXZ PROC	; CvTechEntry::GetFeatureProductionModifier, COMDAT
; _this$ = ecx

; 255  : 	return m_iFeatureProductionModifier;

	mov	eax, DWORD PTR [ecx+280]

; 256  : }

	ret	0
?GetFeatureProductionModifier@CvTechEntry@@QBEHXZ ENDP	; CvTechEntry::GetFeatureProductionModifier
_TEXT	ENDS
PUBLIC	?GetUnitFortificationModifier@CvTechEntry@@QBEHXZ ; CvTechEntry::GetUnitFortificationModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnitFortificationModifier@CvTechEntry@@QBEHXZ
_TEXT	SEGMENT
?GetUnitFortificationModifier@CvTechEntry@@QBEHXZ PROC	; CvTechEntry::GetUnitFortificationModifier, COMDAT
; _this$ = ecx

; 261  : 	return m_iUnitFortificationModifier;

	mov	eax, DWORD PTR [ecx+284]

; 262  : }

	ret	0
?GetUnitFortificationModifier@CvTechEntry@@QBEHXZ ENDP	; CvTechEntry::GetUnitFortificationModifier
_TEXT	ENDS
PUBLIC	?GetUnitBaseHealModifier@CvTechEntry@@QBEHXZ	; CvTechEntry::GetUnitBaseHealModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnitBaseHealModifier@CvTechEntry@@QBEHXZ
_TEXT	SEGMENT
?GetUnitBaseHealModifier@CvTechEntry@@QBEHXZ PROC	; CvTechEntry::GetUnitBaseHealModifier, COMDAT
; _this$ = ecx

; 267  : 	return m_iUnitBaseHealModifier;

	mov	eax, DWORD PTR [ecx+288]

; 268  : }

	ret	0
?GetUnitBaseHealModifier@CvTechEntry@@QBEHXZ ENDP	; CvTechEntry::GetUnitBaseHealModifier
_TEXT	ENDS
PUBLIC	?GetWorkerSpeedModifier@CvTechEntry@@QBEHXZ	; CvTechEntry::GetWorkerSpeedModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetWorkerSpeedModifier@CvTechEntry@@QBEHXZ
_TEXT	SEGMENT
?GetWorkerSpeedModifier@CvTechEntry@@QBEHXZ PROC	; CvTechEntry::GetWorkerSpeedModifier, COMDAT
; _this$ = ecx

; 273  : 	return m_iWorkerSpeedModifier;

	mov	eax, DWORD PTR [ecx+292]

; 274  : }

	ret	0
?GetWorkerSpeedModifier@CvTechEntry@@QBEHXZ ENDP	; CvTechEntry::GetWorkerSpeedModifier
_TEXT	ENDS
PUBLIC	?GetFirstFreeUnitClass@CvTechEntry@@QBEHXZ	; CvTechEntry::GetFirstFreeUnitClass
; Function compile flags: /Ogtpy
;	COMDAT ?GetFirstFreeUnitClass@CvTechEntry@@QBEHXZ
_TEXT	SEGMENT
?GetFirstFreeUnitClass@CvTechEntry@@QBEHXZ PROC		; CvTechEntry::GetFirstFreeUnitClass, COMDAT
; _this$ = ecx

; 279  : 	return m_iFirstFreeUnitClass;

	mov	eax, DWORD PTR [ecx+296]

; 280  : }

	ret	0
?GetFirstFreeUnitClass@CvTechEntry@@QBEHXZ ENDP		; CvTechEntry::GetFirstFreeUnitClass
_TEXT	ENDS
PUBLIC	?GetFirstFreeTechs@CvTechEntry@@QBEHXZ		; CvTechEntry::GetFirstFreeTechs
; Function compile flags: /Ogtpy
;	COMDAT ?GetFirstFreeTechs@CvTechEntry@@QBEHXZ
_TEXT	SEGMENT
?GetFirstFreeTechs@CvTechEntry@@QBEHXZ PROC		; CvTechEntry::GetFirstFreeTechs, COMDAT
; _this$ = ecx

; 285  : 	return m_iFirstFreeTechs;

	mov	eax, DWORD PTR [ecx+300]

; 286  : }

	ret	0
?GetFirstFreeTechs@CvTechEntry@@QBEHXZ ENDP		; CvTechEntry::GetFirstFreeTechs
_TEXT	ENDS
PUBLIC	?GetEmbarkedMoveChange@CvTechEntry@@QBEHXZ	; CvTechEntry::GetEmbarkedMoveChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetEmbarkedMoveChange@CvTechEntry@@QBEHXZ
_TEXT	SEGMENT
?GetEmbarkedMoveChange@CvTechEntry@@QBEHXZ PROC		; CvTechEntry::GetEmbarkedMoveChange, COMDAT
; _this$ = ecx

; 291  : 	return m_iEmbarkedMoveChange;

	mov	eax, DWORD PTR [ecx+304]

; 292  : }

	ret	0
?GetEmbarkedMoveChange@CvTechEntry@@QBEHXZ ENDP		; CvTechEntry::GetEmbarkedMoveChange
_TEXT	ENDS
PUBLIC	?GetEmbarkedSightChange@CvTechEntry@@QBEHXZ	; CvTechEntry::GetEmbarkedSightChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetEmbarkedSightChange@CvTechEntry@@QBEHXZ
_TEXT	SEGMENT
?GetEmbarkedSightChange@CvTechEntry@@QBEHXZ PROC	; CvTechEntry::GetEmbarkedSightChange, COMDAT
; _this$ = ecx

; 297  : 	return m_iEmbarkedSightChange;

	mov	eax, DWORD PTR [ecx+308]

; 298  : }

	ret	0
?GetEmbarkedSightChange@CvTechEntry@@QBEHXZ ENDP	; CvTechEntry::GetEmbarkedSightChange
_TEXT	ENDS
PUBLIC	?GetNumInternationalTradeRoutesChange@CvTechEntry@@QBEHXZ ; CvTechEntry::GetNumInternationalTradeRoutesChange
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumInternationalTradeRoutesChange@CvTechEntry@@QBEHXZ
_TEXT	SEGMENT
?GetNumInternationalTradeRoutesChange@CvTechEntry@@QBEHXZ PROC ; CvTechEntry::GetNumInternationalTradeRoutesChange, COMDAT
; _this$ = ecx

; 303  : 	return m_iInternationalTradeRoutesChange;

	mov	eax, DWORD PTR [ecx+312]

; 304  : }

	ret	0
?GetNumInternationalTradeRoutesChange@CvTechEntry@@QBEHXZ ENDP ; CvTechEntry::GetNumInternationalTradeRoutesChange
_TEXT	ENDS
PUBLIC	?GetInfluenceSpreadModifier@CvTechEntry@@QBEHXZ	; CvTechEntry::GetInfluenceSpreadModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetInfluenceSpreadModifier@CvTechEntry@@QBEHXZ
_TEXT	SEGMENT
?GetInfluenceSpreadModifier@CvTechEntry@@QBEHXZ PROC	; CvTechEntry::GetInfluenceSpreadModifier, COMDAT
; _this$ = ecx

; 309  : 	return m_iInfluenceSpreadModifier;

	mov	eax, DWORD PTR [ecx+316]

; 310  : }

	ret	0
?GetInfluenceSpreadModifier@CvTechEntry@@QBEHXZ ENDP	; CvTechEntry::GetInfluenceSpreadModifier
_TEXT	ENDS
PUBLIC	?GetExtraVotesPerDiplomat@CvTechEntry@@QBEHXZ	; CvTechEntry::GetExtraVotesPerDiplomat
; Function compile flags: /Ogtpy
;	COMDAT ?GetExtraVotesPerDiplomat@CvTechEntry@@QBEHXZ
_TEXT	SEGMENT
?GetExtraVotesPerDiplomat@CvTechEntry@@QBEHXZ PROC	; CvTechEntry::GetExtraVotesPerDiplomat, COMDAT
; _this$ = ecx

; 315  : 	return m_iExtraVotesPerDiplomat;

	mov	eax, DWORD PTR [ecx+320]

; 316  : }

	ret	0
?GetExtraVotesPerDiplomat@CvTechEntry@@QBEHXZ ENDP	; CvTechEntry::GetExtraVotesPerDiplomat
_TEXT	ENDS
PUBLIC	?GetGridX@CvTechEntry@@QBEHXZ			; CvTechEntry::GetGridX
; Function compile flags: /Ogtpy
;	COMDAT ?GetGridX@CvTechEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGridX@CvTechEntry@@QBEHXZ PROC			; CvTechEntry::GetGridX, COMDAT
; _this$ = ecx

; 321  : 	return m_iGridX;

	mov	eax, DWORD PTR [ecx+324]

; 322  : }

	ret	0
?GetGridX@CvTechEntry@@QBEHXZ ENDP			; CvTechEntry::GetGridX
_TEXT	ENDS
PUBLIC	?GetGridY@CvTechEntry@@QBEHXZ			; CvTechEntry::GetGridY
; Function compile flags: /Ogtpy
;	COMDAT ?GetGridY@CvTechEntry@@QBEHXZ
_TEXT	SEGMENT
?GetGridY@CvTechEntry@@QBEHXZ PROC			; CvTechEntry::GetGridY, COMDAT
; _this$ = ecx

; 327  : 	return m_iGridY;

	mov	eax, DWORD PTR [ecx+328]

; 328  : }

	ret	0
?GetGridY@CvTechEntry@@QBEHXZ ENDP			; CvTechEntry::GetGridY
_TEXT	ENDS
PUBLIC	?IsEndsGame@CvTechEntry@@QBE_NXZ		; CvTechEntry::IsEndsGame
; Function compile flags: /Ogtpy
;	COMDAT ?IsEndsGame@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsEndsGame@CvTechEntry@@QBE_NXZ PROC			; CvTechEntry::IsEndsGame, COMDAT
; _this$ = ecx

; 333  : 	return m_bEndsGame;

	mov	al, BYTE PTR [ecx+332]

; 334  : }

	ret	0
?IsEndsGame@CvTechEntry@@QBE_NXZ ENDP			; CvTechEntry::IsEndsGame
_TEXT	ENDS
PUBLIC	?IsAllowsEmbarking@CvTechEntry@@QBE_NXZ		; CvTechEntry::IsAllowsEmbarking
; Function compile flags: /Ogtpy
;	COMDAT ?IsAllowsEmbarking@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsAllowsEmbarking@CvTechEntry@@QBE_NXZ PROC		; CvTechEntry::IsAllowsEmbarking, COMDAT
; _this$ = ecx

; 339  : 	return m_bAllowsEmbarking;

	mov	al, BYTE PTR [ecx+333]

; 340  : }

	ret	0
?IsAllowsEmbarking@CvTechEntry@@QBE_NXZ ENDP		; CvTechEntry::IsAllowsEmbarking
_TEXT	ENDS
PUBLIC	?IsAllowsEmbarkingCivilian@CvTechEntry@@QBE_NXZ	; CvTechEntry::IsAllowsEmbarkingCivilian
; Function compile flags: /Ogtpy
;	COMDAT ?IsAllowsEmbarkingCivilian@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsAllowsEmbarkingCivilian@CvTechEntry@@QBE_NXZ PROC	; CvTechEntry::IsAllowsEmbarkingCivilian, COMDAT
; _this$ = ecx

; 345  : 	return m_bAllowsEmbarkingCivilian;

	mov	al, BYTE PTR [ecx+334]

; 346  : }

	ret	0
?IsAllowsEmbarkingCivilian@CvTechEntry@@QBE_NXZ ENDP	; CvTechEntry::IsAllowsEmbarkingCivilian
_TEXT	ENDS
PUBLIC	?IsAllowsDefensiveEmbarking@CvTechEntry@@QBE_NXZ ; CvTechEntry::IsAllowsDefensiveEmbarking
; Function compile flags: /Ogtpy
;	COMDAT ?IsAllowsDefensiveEmbarking@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsAllowsDefensiveEmbarking@CvTechEntry@@QBE_NXZ PROC	; CvTechEntry::IsAllowsDefensiveEmbarking, COMDAT
; _this$ = ecx

; 351  : 	return m_bAllowsDefensiveEmbarking;

	mov	al, BYTE PTR [ecx+335]

; 352  : }

	ret	0
?IsAllowsDefensiveEmbarking@CvTechEntry@@QBE_NXZ ENDP	; CvTechEntry::IsAllowsDefensiveEmbarking
_TEXT	ENDS
PUBLIC	?IsEmbarkedAllWaterPassage@CvTechEntry@@QBE_NXZ	; CvTechEntry::IsEmbarkedAllWaterPassage
; Function compile flags: /Ogtpy
;	COMDAT ?IsEmbarkedAllWaterPassage@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsEmbarkedAllWaterPassage@CvTechEntry@@QBE_NXZ PROC	; CvTechEntry::IsEmbarkedAllWaterPassage, COMDAT
; _this$ = ecx

; 357  : 	return m_bEmbarkedAllWaterPassage;

	mov	al, BYTE PTR [ecx+336]

; 358  : }

	ret	0
?IsEmbarkedAllWaterPassage@CvTechEntry@@QBE_NXZ ENDP	; CvTechEntry::IsEmbarkedAllWaterPassage
_TEXT	ENDS
PUBLIC	?IsAllowsBarbarianBoats@CvTechEntry@@QBE_NXZ	; CvTechEntry::IsAllowsBarbarianBoats
; Function compile flags: /Ogtpy
;	COMDAT ?IsAllowsBarbarianBoats@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsAllowsBarbarianBoats@CvTechEntry@@QBE_NXZ PROC	; CvTechEntry::IsAllowsBarbarianBoats, COMDAT
; _this$ = ecx

; 363  : 	return m_bAllowsBarbarianBoats;

	mov	al, BYTE PTR [ecx+337]

; 364  : }

	ret	0
?IsAllowsBarbarianBoats@CvTechEntry@@QBE_NXZ ENDP	; CvTechEntry::IsAllowsBarbarianBoats
_TEXT	ENDS
PUBLIC	?IsRepeat@CvTechEntry@@QBE_NXZ			; CvTechEntry::IsRepeat
; Function compile flags: /Ogtpy
;	COMDAT ?IsRepeat@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsRepeat@CvTechEntry@@QBE_NXZ PROC			; CvTechEntry::IsRepeat, COMDAT
; _this$ = ecx

; 369  : 	return m_bRepeat;

	mov	al, BYTE PTR [ecx+338]

; 370  : }

	ret	0
?IsRepeat@CvTechEntry@@QBE_NXZ ENDP			; CvTechEntry::IsRepeat
_TEXT	ENDS
PUBLIC	?IsTrade@CvTechEntry@@QBE_NXZ			; CvTechEntry::IsTrade
; Function compile flags: /Ogtpy
;	COMDAT ?IsTrade@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsTrade@CvTechEntry@@QBE_NXZ PROC			; CvTechEntry::IsTrade, COMDAT
; _this$ = ecx

; 375  : 	return m_bTrade;

	mov	al, BYTE PTR [ecx+339]

; 376  : }

	ret	0
?IsTrade@CvTechEntry@@QBE_NXZ ENDP			; CvTechEntry::IsTrade
_TEXT	ENDS
PUBLIC	?IsDisable@CvTechEntry@@QBE_NXZ			; CvTechEntry::IsDisable
; Function compile flags: /Ogtpy
;	COMDAT ?IsDisable@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsDisable@CvTechEntry@@QBE_NXZ PROC			; CvTechEntry::IsDisable, COMDAT
; _this$ = ecx

; 381  : 	return m_bDisable;

	mov	al, BYTE PTR [ecx+340]

; 382  : }

	ret	0
?IsDisable@CvTechEntry@@QBE_NXZ ENDP			; CvTechEntry::IsDisable
_TEXT	ENDS
PUBLIC	?IsGoodyTech@CvTechEntry@@QBE_NXZ		; CvTechEntry::IsGoodyTech
; Function compile flags: /Ogtpy
;	COMDAT ?IsGoodyTech@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsGoodyTech@CvTechEntry@@QBE_NXZ PROC			; CvTechEntry::IsGoodyTech, COMDAT
; _this$ = ecx

; 388  : 	return m_bGoodyTech;

	mov	al, BYTE PTR [ecx+342]

; 389  : }

	ret	0
?IsGoodyTech@CvTechEntry@@QBE_NXZ ENDP			; CvTechEntry::IsGoodyTech
_TEXT	ENDS
PUBLIC	?IsTriggersArchaeologicalSites@CvTechEntry@@QBE_NXZ ; CvTechEntry::IsTriggersArchaeologicalSites
; Function compile flags: /Ogtpy
;	COMDAT ?IsTriggersArchaeologicalSites@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsTriggersArchaeologicalSites@CvTechEntry@@QBE_NXZ PROC ; CvTechEntry::IsTriggersArchaeologicalSites, COMDAT
; _this$ = ecx

; 394  : 	return m_bTriggersArchaeologicalSites;

	mov	al, BYTE PTR [ecx+357]

; 395  : }

	ret	0
?IsTriggersArchaeologicalSites@CvTechEntry@@QBE_NXZ ENDP ; CvTechEntry::IsTriggersArchaeologicalSites
_TEXT	ENDS
PUBLIC	?IsAllowsWorldCongress@CvTechEntry@@QBE_NXZ	; CvTechEntry::IsAllowsWorldCongress
; Function compile flags: /Ogtpy
;	COMDAT ?IsAllowsWorldCongress@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsAllowsWorldCongress@CvTechEntry@@QBE_NXZ PROC	; CvTechEntry::IsAllowsWorldCongress, COMDAT
; _this$ = ecx

; 400  : 	return m_bAllowsWorldCongress;

	mov	al, BYTE PTR [ecx+358]

; 401  : }

	ret	0
?IsAllowsWorldCongress@CvTechEntry@@QBE_NXZ ENDP	; CvTechEntry::IsAllowsWorldCongress
_TEXT	ENDS
PUBLIC	?IsExtraWaterSeeFrom@CvTechEntry@@QBE_NXZ	; CvTechEntry::IsExtraWaterSeeFrom
; Function compile flags: /Ogtpy
;	COMDAT ?IsExtraWaterSeeFrom@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsExtraWaterSeeFrom@CvTechEntry@@QBE_NXZ PROC		; CvTechEntry::IsExtraWaterSeeFrom, COMDAT
; _this$ = ecx

; 406  : 	return m_bExtraWaterSeeFrom;

	mov	al, BYTE PTR [ecx+343]

; 407  : }

	ret	0
?IsExtraWaterSeeFrom@CvTechEntry@@QBE_NXZ ENDP		; CvTechEntry::IsExtraWaterSeeFrom
_TEXT	ENDS
PUBLIC	?IsMapCentering@CvTechEntry@@QBE_NXZ		; CvTechEntry::IsMapCentering
; Function compile flags: /Ogtpy
;	COMDAT ?IsMapCentering@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsMapCentering@CvTechEntry@@QBE_NXZ PROC		; CvTechEntry::IsMapCentering, COMDAT
; _this$ = ecx

; 412  : 	return m_bMapCentering;

	mov	al, BYTE PTR [ecx+344]

; 413  : }

	ret	0
?IsMapCentering@CvTechEntry@@QBE_NXZ ENDP		; CvTechEntry::IsMapCentering
_TEXT	ENDS
PUBLIC	?IsMapVisible@CvTechEntry@@QBE_NXZ		; CvTechEntry::IsMapVisible
; Function compile flags: /Ogtpy
;	COMDAT ?IsMapVisible@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsMapVisible@CvTechEntry@@QBE_NXZ PROC			; CvTechEntry::IsMapVisible, COMDAT
; _this$ = ecx

; 418  : 	return m_bMapVisible;

	mov	al, BYTE PTR [ecx+345]

; 419  : }

	ret	0
?IsMapVisible@CvTechEntry@@QBE_NXZ ENDP			; CvTechEntry::IsMapVisible
_TEXT	ENDS
PUBLIC	?IsMapTrading@CvTechEntry@@QBE_NXZ		; CvTechEntry::IsMapTrading
; Function compile flags: /Ogtpy
;	COMDAT ?IsMapTrading@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsMapTrading@CvTechEntry@@QBE_NXZ PROC			; CvTechEntry::IsMapTrading, COMDAT
; _this$ = ecx

; 424  : 	return m_bMapTrading;

	mov	al, BYTE PTR [ecx+346]

; 425  : }

	ret	0
?IsMapTrading@CvTechEntry@@QBE_NXZ ENDP			; CvTechEntry::IsMapTrading
_TEXT	ENDS
PUBLIC	?IsTechTrading@CvTechEntry@@QBE_NXZ		; CvTechEntry::IsTechTrading
; Function compile flags: /Ogtpy
;	COMDAT ?IsTechTrading@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsTechTrading@CvTechEntry@@QBE_NXZ PROC		; CvTechEntry::IsTechTrading, COMDAT
; _this$ = ecx

; 430  : 	return m_bTechTrading;

	mov	al, BYTE PTR [ecx+347]

; 431  : }

	ret	0
?IsTechTrading@CvTechEntry@@QBE_NXZ ENDP		; CvTechEntry::IsTechTrading
_TEXT	ENDS
PUBLIC	?IsGoldTrading@CvTechEntry@@QBE_NXZ		; CvTechEntry::IsGoldTrading
; Function compile flags: /Ogtpy
;	COMDAT ?IsGoldTrading@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsGoldTrading@CvTechEntry@@QBE_NXZ PROC		; CvTechEntry::IsGoldTrading, COMDAT
; _this$ = ecx

; 436  : 	return m_bGoldTrading;

	mov	al, BYTE PTR [ecx+348]

; 437  : }

	ret	0
?IsGoldTrading@CvTechEntry@@QBE_NXZ ENDP		; CvTechEntry::IsGoldTrading
_TEXT	ENDS
PUBLIC	?IsAllowEmbassyTradingAllowed@CvTechEntry@@QBE_NXZ ; CvTechEntry::IsAllowEmbassyTradingAllowed
; Function compile flags: /Ogtpy
;	COMDAT ?IsAllowEmbassyTradingAllowed@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsAllowEmbassyTradingAllowed@CvTechEntry@@QBE_NXZ PROC	; CvTechEntry::IsAllowEmbassyTradingAllowed, COMDAT
; _this$ = ecx

; 442  : 	return m_bAllowEmbassyTradingAllowed;

	mov	al, BYTE PTR [ecx+349]

; 443  : }

	ret	0
?IsAllowEmbassyTradingAllowed@CvTechEntry@@QBE_NXZ ENDP	; CvTechEntry::IsAllowEmbassyTradingAllowed
_TEXT	ENDS
PUBLIC	?IsOpenBordersTradingAllowed@CvTechEntry@@QBE_NXZ ; CvTechEntry::IsOpenBordersTradingAllowed
; Function compile flags: /Ogtpy
;	COMDAT ?IsOpenBordersTradingAllowed@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsOpenBordersTradingAllowed@CvTechEntry@@QBE_NXZ PROC	; CvTechEntry::IsOpenBordersTradingAllowed, COMDAT
; _this$ = ecx

; 448  : 	return m_bOpenBordersTradingAllowed;

	mov	al, BYTE PTR [ecx+350]

; 449  : }

	ret	0
?IsOpenBordersTradingAllowed@CvTechEntry@@QBE_NXZ ENDP	; CvTechEntry::IsOpenBordersTradingAllowed
_TEXT	ENDS
PUBLIC	__MarkAllocaS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\malloc.h
;	COMDAT __MarkAllocaS
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Marker$ = 12						; size = 4
__MarkAllocaS PROC					; COMDAT

; 205  :     if (_Ptr)

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN1@MarkAlloca

; 206  :     {
; 207  :         *((unsigned int*)_Ptr) = _Marker;

	mov	ecx, DWORD PTR __Marker$[esp-4]
	mov	DWORD PTR [eax], ecx

; 208  :         _Ptr = (char*)_Ptr + _ALLOCA_S_MARKER_SIZE;

	add	eax, 8
$LN1@MarkAlloca:

; 209  :     }
; 210  :     return _Ptr;
; 211  : }

	ret	0
__MarkAllocaS ENDP
_TEXT	ENDS
PUBLIC	?IsDefensivePactTradingAllowed@CvTechEntry@@QBE_NXZ ; CvTechEntry::IsDefensivePactTradingAllowed
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtechclasses.cpp
;	COMDAT ?IsDefensivePactTradingAllowed@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsDefensivePactTradingAllowed@CvTechEntry@@QBE_NXZ PROC ; CvTechEntry::IsDefensivePactTradingAllowed, COMDAT
; _this$ = ecx

; 454  : 	return m_bDefensivePactTradingAllowed;

	mov	al, BYTE PTR [ecx+351]

; 455  : }

	ret	0
?IsDefensivePactTradingAllowed@CvTechEntry@@QBE_NXZ ENDP ; CvTechEntry::IsDefensivePactTradingAllowed
_TEXT	ENDS
PUBLIC	__freea
EXTRN	__imp__free:PROC
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\malloc.h
;	COMDAT __freea
_TEXT	SEGMENT
__Memory$ = 8						; size = 4
__freea	PROC						; COMDAT

; 240  :     unsigned int _Marker;
; 241  :     if (_Memory)

	mov	eax, DWORD PTR __Memory$[esp-4]
	test	eax, eax
	je	SHORT $LN3@freea

; 242  :     {
; 243  :         _Memory = (char*)_Memory - _ALLOCA_S_MARKER_SIZE;

	sub	eax, 8

; 244  :         _Marker = *(unsigned int *)_Memory;
; 245  :         if (_Marker == _ALLOCA_S_HEAP_MARKER)

	cmp	DWORD PTR [eax], 56797			; 0000ddddH
	jne	SHORT $LN3@freea

; 246  :         {
; 247  :             free(_Memory);

	mov	DWORD PTR __Memory$[esp-4], eax
	jmp	DWORD PTR __imp__free
$LN3@freea:

; 248  :         }
; 249  : #if defined(_ASSERTE)
; 250  :         else if (_Marker != _ALLOCA_S_STACK_MARKER)
; 251  :         {
; 252  :             _ASSERTE(("Corrupted pointer passed to _freea", 0));
; 253  :         }
; 254  : #endif
; 255  :     }
; 256  : }

	ret	0
__freea	ENDP
_TEXT	ENDS
PUBLIC	?IsResearchAgreementTradingAllowed@CvTechEntry@@QBE_NXZ ; CvTechEntry::IsResearchAgreementTradingAllowed
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtechclasses.cpp
;	COMDAT ?IsResearchAgreementTradingAllowed@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsResearchAgreementTradingAllowed@CvTechEntry@@QBE_NXZ PROC ; CvTechEntry::IsResearchAgreementTradingAllowed, COMDAT
; _this$ = ecx

; 460  : 	return m_bResearchAgreementTradingAllowed;

	mov	al, BYTE PTR [ecx+352]

; 461  : }

	ret	0
?IsResearchAgreementTradingAllowed@CvTechEntry@@QBE_NXZ ENDP ; CvTechEntry::IsResearchAgreementTradingAllowed
_TEXT	ENDS
PUBLIC	?IsTradeAgreementTradingAllowed@CvTechEntry@@QBE_NXZ ; CvTechEntry::IsTradeAgreementTradingAllowed
; Function compile flags: /Ogtpy
;	COMDAT ?IsTradeAgreementTradingAllowed@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsTradeAgreementTradingAllowed@CvTechEntry@@QBE_NXZ PROC ; CvTechEntry::IsTradeAgreementTradingAllowed, COMDAT
; _this$ = ecx

; 466  : 	return m_bTradeAgreementTradingAllowed;

	mov	al, BYTE PTR [ecx+353]

; 467  : }

	ret	0
?IsTradeAgreementTradingAllowed@CvTechEntry@@QBE_NXZ ENDP ; CvTechEntry::IsTradeAgreementTradingAllowed
_TEXT	ENDS
PUBLIC	?IsPermanentAllianceTrading@CvTechEntry@@QBE_NXZ ; CvTechEntry::IsPermanentAllianceTrading
; Function compile flags: /Ogtpy
;	COMDAT ?IsPermanentAllianceTrading@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsPermanentAllianceTrading@CvTechEntry@@QBE_NXZ PROC	; CvTechEntry::IsPermanentAllianceTrading, COMDAT
; _this$ = ecx

; 472  : 	return m_bPermanentAllianceTrading;

	mov	al, BYTE PTR [ecx+354]

; 473  : }

	ret	0
?IsPermanentAllianceTrading@CvTechEntry@@QBE_NXZ ENDP	; CvTechEntry::IsPermanentAllianceTrading
_TEXT	ENDS
PUBLIC	?IsBridgeBuilding@CvTechEntry@@QBE_NXZ		; CvTechEntry::IsBridgeBuilding
; Function compile flags: /Ogtpy
;	COMDAT ?IsBridgeBuilding@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsBridgeBuilding@CvTechEntry@@QBE_NXZ PROC		; CvTechEntry::IsBridgeBuilding, COMDAT
; _this$ = ecx

; 478  : 	return m_bBridgeBuilding;

	mov	al, BYTE PTR [ecx+355]

; 479  : }

	ret	0
?IsBridgeBuilding@CvTechEntry@@QBE_NXZ ENDP		; CvTechEntry::IsBridgeBuilding
_TEXT	ENDS
PUBLIC	?IsWaterWork@CvTechEntry@@QBE_NXZ		; CvTechEntry::IsWaterWork
; Function compile flags: /Ogtpy
;	COMDAT ?IsWaterWork@CvTechEntry@@QBE_NXZ
_TEXT	SEGMENT
?IsWaterWork@CvTechEntry@@QBE_NXZ PROC			; CvTechEntry::IsWaterWork, COMDAT
; _this$ = ecx

; 484  : 	return m_bWaterWork;

	mov	al, BYTE PTR [ecx+356]

; 485  : }

	ret	0
?IsWaterWork@CvTechEntry@@QBE_NXZ ENDP			; CvTechEntry::IsWaterWork
_TEXT	ENDS
PUBLIC	?IsFreePromotion@CvTechEntry@@QBEHH@Z		; CvTechEntry::IsFreePromotion
; Function compile flags: /Ogtpy
;	COMDAT ?IsFreePromotion@CvTechEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?IsFreePromotion@CvTechEntry@@QBEHH@Z PROC		; CvTechEntry::IsFreePromotion, COMDAT
; _this$ = ecx

; 490  : 	return m_pabFreePromotion ? m_pabFreePromotion[i] : -1;

	mov	eax, DWORD PTR [ecx+492]
	test	eax, eax
	je	SHORT $LN3@IsFreeProm
	mov	ecx, DWORD PTR _i$[esp-4]
	movzx	eax, BYTE PTR [eax+ecx]

; 491  : }

	ret	4
$LN3@IsFreeProm:

; 490  : 	return m_pabFreePromotion ? m_pabFreePromotion[i] : -1;

	or	eax, -1

; 491  : }

	ret	4
?IsFreePromotion@CvTechEntry@@QBEHH@Z ENDP		; CvTechEntry::IsFreePromotion
_TEXT	ENDS
PUBLIC	?GetQuote@CvTechEntry@@QAEPBDXZ			; CvTechEntry::GetQuote
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?GetQuote@CvTechEntry@@QAEPBDXZ
_TEXT	SEGMENT
?GetQuote@CvTechEntry@@QAEPBDXZ PROC			; CvTechEntry::GetQuote, COMDAT
; _this$ = ecx

; 496  : 	return m_wstrQuote.c_str();

	add	ecx, 388				; 00000184H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetQuote@CvTechEntry@@QAEPBDXZ ENDP			; CvTechEntry::GetQuote
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	esi
	lea	eax, DWORD PTR __Message$[esp]
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?GetDomainExtraMoves@CvTechEntry@@QBEHH@Z	; CvTechEntry::GetDomainExtraMoves
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtechclasses.cpp
;	COMDAT ?GetDomainExtraMoves@CvTechEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetDomainExtraMoves@CvTechEntry@@QBEHH@Z PROC		; CvTechEntry::GetDomainExtraMoves, COMDAT
; _this$ = ecx

; 535  : 	return m_piDomainExtraMoves ? m_piDomainExtraMoves[i] : -1;

	mov	eax, DWORD PTR [ecx+472]
	test	eax, eax
	je	SHORT $LN3@GetDomainE
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 536  : }

	ret	4
$LN3@GetDomainE:

; 535  : 	return m_piDomainExtraMoves ? m_piDomainExtraMoves[i] : -1;

	or	eax, -1

; 536  : }

	ret	4
?GetDomainExtraMoves@CvTechEntry@@QBEHH@Z ENDP		; CvTechEntry::GetDomainExtraMoves
_TEXT	ENDS
PUBLIC	?GetTradeRouteDomainExtraRange@CvTechEntry@@QBEHH@Z ; CvTechEntry::GetTradeRouteDomainExtraRange
; Function compile flags: /Ogtpy
;	COMDAT ?GetTradeRouteDomainExtraRange@CvTechEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetTradeRouteDomainExtraRange@CvTechEntry@@QBEHH@Z PROC ; CvTechEntry::GetTradeRouteDomainExtraRange, COMDAT
; _this$ = ecx

; 541  : 	return m_piTradeRouteDomainExtraRange ? m_piTradeRouteDomainExtraRange[i] : -1;

	mov	eax, DWORD PTR [ecx+476]
	test	eax, eax
	je	SHORT $LN3@GetTradeRo
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 542  : }

	ret	4
$LN3@GetTradeRo:

; 541  : 	return m_piTradeRouteDomainExtraRange ? m_piTradeRouteDomainExtraRange[i] : -1;

	or	eax, -1

; 542  : }

	ret	4
?GetTradeRouteDomainExtraRange@CvTechEntry@@QBEHH@Z ENDP ; CvTechEntry::GetTradeRouteDomainExtraRange
_TEXT	ENDS
PUBLIC	?GetFlavorValue@CvTechEntry@@QBEHH@Z		; CvTechEntry::GetFlavorValue
; Function compile flags: /Ogtpy
;	COMDAT ?GetFlavorValue@CvTechEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetFlavorValue@CvTechEntry@@QBEHH@Z PROC		; CvTechEntry::GetFlavorValue, COMDAT
; _this$ = ecx

; 548  : 	CvAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 549  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 550  : 	return m_piFlavorValue ? m_piFlavorValue[i] : -1;

	mov	eax, DWORD PTR [ecx+480]
	test	eax, eax
	je	SHORT $LN3@GetFlavorV
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 551  : }

	ret	4
$LN3@GetFlavorV:

; 548  : 	CvAssertMsg(i < GC.getNumFlavorTypes(), "Index out of bounds");
; 549  : 	CvAssertMsg(i > -1, "Index out of bounds");
; 550  : 	return m_piFlavorValue ? m_piFlavorValue[i] : -1;

	or	eax, -1

; 551  : }

	ret	4
?GetFlavorValue@CvTechEntry@@QBEHH@Z ENDP		; CvTechEntry::GetFlavorValue
_TEXT	ENDS
PUBLIC	?GetPrereqOrTechs@CvTechEntry@@QBEHH@Z		; CvTechEntry::GetPrereqOrTechs
; Function compile flags: /Ogtpy
;	COMDAT ?GetPrereqOrTechs@CvTechEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetPrereqOrTechs@CvTechEntry@@QBEHH@Z PROC		; CvTechEntry::GetPrereqOrTechs, COMDAT
; _this$ = ecx

; 556  : 	return m_piPrereqOrTechs ? m_piPrereqOrTechs[i] : -1;

	mov	eax, DWORD PTR [ecx+484]
	test	eax, eax
	je	SHORT $LN3@GetPrereqO
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 557  : }

	ret	4
$LN3@GetPrereqO:

; 556  : 	return m_piPrereqOrTechs ? m_piPrereqOrTechs[i] : -1;

	or	eax, -1

; 557  : }

	ret	4
?GetPrereqOrTechs@CvTechEntry@@QBEHH@Z ENDP		; CvTechEntry::GetPrereqOrTechs
_TEXT	ENDS
PUBLIC	?GetPrereqAndTechs@CvTechEntry@@QBEHH@Z		; CvTechEntry::GetPrereqAndTechs
; Function compile flags: /Ogtpy
;	COMDAT ?GetPrereqAndTechs@CvTechEntry@@QBEHH@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?GetPrereqAndTechs@CvTechEntry@@QBEHH@Z PROC		; CvTechEntry::GetPrereqAndTechs, COMDAT
; _this$ = ecx

; 562  : 	return m_piPrereqAndTechs ? m_piPrereqAndTechs[i] : -1;

	mov	eax, DWORD PTR [ecx+488]
	test	eax, eax
	je	SHORT $LN3@GetPrereqA
	mov	ecx, DWORD PTR _i$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 563  : }

	ret	4
$LN3@GetPrereqA:

; 562  : 	return m_piPrereqAndTechs ? m_piPrereqAndTechs[i] : -1;

	or	eax, -1

; 563  : }

	ret	4
?GetPrereqAndTechs@CvTechEntry@@QBEHH@Z ENDP		; CvTechEntry::GetPrereqAndTechs
_TEXT	ENDS
PUBLIC	?GetTechEntries@CvTechXMLEntries@@QAEAAV?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@XZ ; CvTechXMLEntries::GetTechEntries
; Function compile flags: /Ogtpy
;	COMDAT ?GetTechEntries@CvTechXMLEntries@@QAEAAV?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@XZ
_TEXT	SEGMENT
?GetTechEntries@CvTechXMLEntries@@QAEAAV?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@XZ PROC ; CvTechXMLEntries::GetTechEntries, COMDAT
; _this$ = ecx

; 582  : {

	mov	eax, ecx

; 583  : 	return m_paTechEntries;
; 584  : }

	ret	0
?GetTechEntries@CvTechXMLEntries@@QAEAAV?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@XZ ENDP ; CvTechXMLEntries::GetTechEntries
_TEXT	ENDS
PUBLIC	??_7CvPlayerTechs@@6B@				; CvPlayerTechs::`vftable'
PUBLIC	??0CvPlayerTechs@@QAE@XZ			; CvPlayerTechs::CvPlayerTechs
PUBLIC	??_R4CvPlayerTechs@@6B@				; CvPlayerTechs::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvPlayerTechs@@@8			; CvPlayerTechs `RTTI Type Descriptor'
PUBLIC	??_R3CvPlayerTechs@@8				; CvPlayerTechs::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvPlayerTechs@@8				; CvPlayerTechs::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvPlayerTechs@@8			; CvPlayerTechs::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CvFlavorRecipient@@8		; CvFlavorRecipient::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCvFlavorRecipient@@@8			; CvFlavorRecipient `RTTI Type Descriptor'
PUBLIC	??_R3CvFlavorRecipient@@8			; CvFlavorRecipient::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvFlavorRecipient@@8			; CvFlavorRecipient::`RTTI Base Class Array'
PUBLIC	?Uninit@CvPlayerTechs@@UAEXXZ			; CvPlayerTechs::Uninit
PUBLIC	?FlavorUpdate@CvPlayerTechs@@UAEXXZ		; CvPlayerTechs::FlavorUpdate
PUBLIC	?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z ; CvPlayerTechs::LogFlavors
EXTRN	??0CvFlavorRecipient@@QAE@XZ:PROC		; CvFlavorRecipient::CvFlavorRecipient
EXTRN	?Init@CvFlavorRecipient@@UAEXXZ:PROC		; CvFlavorRecipient::Init
;	COMDAT ??_R2CvFlavorRecipient@@8
rdata$r	SEGMENT
??_R2CvFlavorRecipient@@8 DD FLAT:??_R1A@?0A@EA@CvFlavorRecipient@@8 ; CvFlavorRecipient::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CvFlavorRecipient@@8
rdata$r	SEGMENT
??_R3CvFlavorRecipient@@8 DD 00H			; CvFlavorRecipient::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CvFlavorRecipient@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvFlavorRecipient@@@8
_DATA	SEGMENT
??_R0?AVCvFlavorRecipient@@@8 DD FLAT:??_7type_info@@6B@ ; CvFlavorRecipient `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvFlavorRecipient@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@CvFlavorRecipient@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvFlavorRecipient@@8 DD FLAT:??_R0?AVCvFlavorRecipient@@@8 ; CvFlavorRecipient::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvFlavorRecipient@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CvPlayerTechs@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvPlayerTechs@@8 DD FLAT:??_R0?AVCvPlayerTechs@@@8 ; CvPlayerTechs::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvPlayerTechs@@8
rdata$r	ENDS
;	COMDAT ??_R2CvPlayerTechs@@8
rdata$r	SEGMENT
??_R2CvPlayerTechs@@8 DD FLAT:??_R1A@?0A@EA@CvPlayerTechs@@8 ; CvPlayerTechs::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvFlavorRecipient@@8
rdata$r	ENDS
;	COMDAT ??_R3CvPlayerTechs@@8
rdata$r	SEGMENT
??_R3CvPlayerTechs@@8 DD 00H				; CvPlayerTechs::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvPlayerTechs@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvPlayerTechs@@@8
_DATA	SEGMENT
??_R0?AVCvPlayerTechs@@@8 DD FLAT:??_7type_info@@6B@	; CvPlayerTechs `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvPlayerTechs@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvPlayerTechs@@6B@
rdata$r	SEGMENT
??_R4CvPlayerTechs@@6B@ DD 00H				; CvPlayerTechs::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvPlayerTechs@@@8
	DD	FLAT:??_R3CvPlayerTechs@@8
rdata$r	ENDS
;	COMDAT ??_7CvPlayerTechs@@6B@
CONST	SEGMENT
??_7CvPlayerTechs@@6B@ DD FLAT:??_R4CvPlayerTechs@@6B@	; CvPlayerTechs::`vftable'
	DD	FLAT:?Init@CvFlavorRecipient@@UAEXXZ
	DD	FLAT:?Uninit@CvPlayerTechs@@UAEXXZ
	DD	FLAT:?FlavorUpdate@CvPlayerTechs@@UAEXXZ
	DD	FLAT:?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvPlayerTechs@@QAE@XZ
_TEXT	SEGMENT
??0CvPlayerTechs@@QAE@XZ PROC				; CvPlayerTechs::CvPlayerTechs, COMDAT
; _this$ = ecx

; 633  : {

	push	esi
	mov	esi, ecx
	call	??0CvFlavorRecipient@@QAE@XZ		; CvFlavorRecipient::CvFlavorRecipient
	xor	eax, eax
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], eax
	mov	DWORD PTR [esi+24], eax
	mov	DWORD PTR [esi+28], eax
	mov	DWORD PTR [esi+32], eax
	mov	DWORD PTR [esi+36], eax
	mov	DWORD PTR [esi+40], eax
	mov	DWORD PTR [esi+44], eax
	mov	DWORD PTR [esi+48], eax
	mov	DWORD PTR [esi], OFFSET ??_7CvPlayerTechs@@6B@

; 634  : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvPlayerTechs@@QAE@XZ ENDP				; CvPlayerTechs::CvPlayerTechs
_TEXT	ENDS
PUBLIC	??1CvPlayerTechs@@QAE@XZ			; CvPlayerTechs::~CvPlayerTechs
EXTRN	??1CvFlavorRecipient@@QAE@XZ:PROC		; CvFlavorRecipient::~CvFlavorRecipient
; Function compile flags: /Ogtpy
;	COMDAT ??1CvPlayerTechs@@QAE@XZ
_TEXT	SEGMENT
??1CvPlayerTechs@@QAE@XZ PROC				; CvPlayerTechs::~CvPlayerTechs, COMDAT
; _this$ = ecx

; 638  : {

	mov	DWORD PTR [ecx], OFFSET ??_7CvPlayerTechs@@6B@

; 639  : }

	jmp	??1CvFlavorRecipient@@QAE@XZ		; CvFlavorRecipient::~CvFlavorRecipient
??1CvPlayerTechs@@QAE@XZ ENDP				; CvPlayerTechs::~CvPlayerTechs
_TEXT	ENDS
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	eax, DWORD PTR __Message$[esp+16]
	push	eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 31   : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 35   : 		return (_Str.c_str());

	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
; Function compile flags: /Ogtpy
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 110  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@3:
	mov	eax, esi
	pop	esi
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?GetPlayer@CvPlayerTechs@@QAEPAVCvPlayer@@XZ	; CvPlayerTechs::GetPlayer
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtechclasses.cpp
;	COMDAT ?GetPlayer@CvPlayerTechs@@QAEPAVCvPlayer@@XZ
_TEXT	SEGMENT
?GetPlayer@CvPlayerTechs@@QAEPAVCvPlayer@@XZ PROC	; CvPlayerTechs::GetPlayer, COMDAT
; _this$ = ecx

; 932  : 	return m_pPlayer;

	mov	eax, DWORD PTR [ecx+44]

; 933  : }

	ret	0
?GetPlayer@CvPlayerTechs@@QAEPAVCvPlayer@@XZ ENDP	; CvPlayerTechs::GetPlayer
_TEXT	ENDS
PUBLIC	?GetTechAI@CvPlayerTechs@@QAEPAVCvTechAI@@XZ	; CvPlayerTechs::GetTechAI
; Function compile flags: /Ogtpy
;	COMDAT ?GetTechAI@CvPlayerTechs@@QAEPAVCvTechAI@@XZ
_TEXT	SEGMENT
?GetTechAI@CvPlayerTechs@@QAEPAVCvTechAI@@XZ PROC	; CvPlayerTechs::GetTechAI, COMDAT
; _this$ = ecx

; 938  : 	return m_pTechAI;

	mov	eax, DWORD PTR [ecx+48]

; 939  : }

	ret	0
?GetTechAI@CvPlayerTechs@@QAEPAVCvTechAI@@XZ ENDP	; CvPlayerTechs::GetTechAI
_TEXT	ENDS
PUBLIC	?IsResearchingTech@CvPlayerTechs@@QBE_NW4TechTypes@@@Z ; CvPlayerTechs::IsResearchingTech
; Function compile flags: /Ogtpy
;	COMDAT ?IsResearchingTech@CvPlayerTechs@@QBE_NW4TechTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?IsResearchingTech@CvPlayerTechs@@QBE_NW4TechTypes@@@Z PROC ; CvPlayerTechs::IsResearchingTech, COMDAT
; _this$ = ecx

; 944  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 945  : 	CvAssertMsg(eIndex < GC.getNumTechInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 946  : 	return m_pabResearchingTech[eIndex];

	mov	eax, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	mov	al, BYTE PTR [ecx+eax]

; 947  : }

	ret	4
?IsResearchingTech@CvPlayerTechs@@QBE_NW4TechTypes@@@Z ENDP ; CvPlayerTechs::IsResearchingTech
_TEXT	ENDS
PUBLIC	?SetResearchingTech@CvPlayerTechs@@QAEXW4TechTypes@@_N@Z ; CvPlayerTechs::SetResearchingTech
; Function compile flags: /Ogtpy
;	COMDAT ?SetResearchingTech@CvPlayerTechs@@QAEXW4TechTypes@@_N@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_bNewValue$ = 12					; size = 1
?SetResearchingTech@CvPlayerTechs@@QAEXW4TechTypes@@_N@Z PROC ; CvPlayerTechs::SetResearchingTech, COMDAT
; _this$ = ecx

; 952  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 953  : 	CvAssertMsg(eIndex < GC.getNumTechInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 954  : 
; 955  : 	if(m_pabResearchingTech[eIndex] != bNewValue)

	mov	eax, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	add	eax, ecx
	mov	cl, BYTE PTR _bNewValue$[esp-4]
	cmp	BYTE PTR [eax], cl
	je	SHORT $LN1@SetResearc

; 956  : 	{
; 957  : 		m_pabResearchingTech[eIndex] = bNewValue;

	mov	BYTE PTR [eax], cl
$LN1@SetResearc:

; 958  : 	}
; 959  : }

	ret	8
?SetResearchingTech@CvPlayerTechs@@QAEXW4TechTypes@@_N@Z ENDP ; CvPlayerTechs::SetResearchingTech
_TEXT	ENDS
PUBLIC	?SetCivTechPriority@CvPlayerTechs@@QAEXW4TechTypes@@H@Z ; CvPlayerTechs::SetCivTechPriority
; Function compile flags: /Ogtpy
;	COMDAT ?SetCivTechPriority@CvPlayerTechs@@QAEXW4TechTypes@@H@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_iNewValue$ = 12					; size = 4
?SetCivTechPriority@CvPlayerTechs@@QAEXW4TechTypes@@H@Z PROC ; CvPlayerTechs::SetCivTechPriority, COMDAT
; _this$ = ecx

; 964  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 965  : 	CvAssertMsg(eIndex < GC.getNumTechInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 966  : 
; 967  : 	m_piCivTechPriority[eIndex] = iNewValue;

	mov	eax, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _iNewValue$[esp-4]
	mov	edx, DWORD PTR _eIndex$[esp-4]
	mov	DWORD PTR [eax+edx*4], ecx

; 968  : }

	ret	8
?SetCivTechPriority@CvPlayerTechs@@QAEXW4TechTypes@@H@Z ENDP ; CvPlayerTechs::SetCivTechPriority
_TEXT	ENDS
PUBLIC	?GetCivTechPriority@CvPlayerTechs@@QBEHW4TechTypes@@@Z ; CvPlayerTechs::GetCivTechPriority
; Function compile flags: /Ogtpy
;	COMDAT ?GetCivTechPriority@CvPlayerTechs@@QBEHW4TechTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?GetCivTechPriority@CvPlayerTechs@@QBEHW4TechTypes@@@Z PROC ; CvPlayerTechs::GetCivTechPriority, COMDAT
; _this$ = ecx

; 973  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 974  : 	CvAssertMsg(eIndex < GC.getNumTechInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 975  : 	return m_piCivTechPriority[eIndex];

	mov	eax, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 976  : }

	ret	4
?GetCivTechPriority@CvPlayerTechs@@QBEHW4TechTypes@@@Z ENDP ; CvPlayerTechs::GetCivTechPriority
_TEXT	ENDS
PUBLIC	?SetLocaleTechPriority@CvPlayerTechs@@QAEXW4TechTypes@@H@Z ; CvPlayerTechs::SetLocaleTechPriority
; Function compile flags: /Ogtpy
;	COMDAT ?SetLocaleTechPriority@CvPlayerTechs@@QAEXW4TechTypes@@H@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_iNewValue$ = 12					; size = 4
?SetLocaleTechPriority@CvPlayerTechs@@QAEXW4TechTypes@@H@Z PROC ; CvPlayerTechs::SetLocaleTechPriority, COMDAT
; _this$ = ecx

; 981  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 982  : 	CvAssertMsg(eIndex < GC.getNumTechInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 983  : 
; 984  : 	m_piLocaleTechPriority[eIndex] = iNewValue;

	mov	eax, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _iNewValue$[esp-4]
	mov	edx, DWORD PTR _eIndex$[esp-4]
	mov	DWORD PTR [eax+edx*4], ecx

; 985  : }

	ret	8
?SetLocaleTechPriority@CvPlayerTechs@@QAEXW4TechTypes@@H@Z ENDP ; CvPlayerTechs::SetLocaleTechPriority
_TEXT	ENDS
PUBLIC	?GetLocaleTechPriority@CvPlayerTechs@@QBEHW4TechTypes@@@Z ; CvPlayerTechs::GetLocaleTechPriority
; Function compile flags: /Ogtpy
;	COMDAT ?GetLocaleTechPriority@CvPlayerTechs@@QBEHW4TechTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?GetLocaleTechPriority@CvPlayerTechs@@QBEHW4TechTypes@@@Z PROC ; CvPlayerTechs::GetLocaleTechPriority, COMDAT
; _this$ = ecx

; 990  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 991  : 	CvAssertMsg(eIndex < GC.getNumTechInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 992  : 	return m_piLocaleTechPriority[eIndex];

	mov	eax, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 993  : }

	ret	4
?GetLocaleTechPriority@CvPlayerTechs@@QBEHW4TechTypes@@@Z ENDP ; CvPlayerTechs::GetLocaleTechPriority
_TEXT	ENDS
PUBLIC	?GetLocaleTechResource@CvPlayerTechs@@QBE?AW4ResourceTypes@@W4TechTypes@@@Z ; CvPlayerTechs::GetLocaleTechResource
; Function compile flags: /Ogtpy
;	COMDAT ?GetLocaleTechResource@CvPlayerTechs@@QBE?AW4ResourceTypes@@W4TechTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?GetLocaleTechResource@CvPlayerTechs@@QBE?AW4ResourceTypes@@W4TechTypes@@@Z PROC ; CvPlayerTechs::GetLocaleTechResource, COMDAT
; _this$ = ecx

; 997  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 998  : 	CvAssertMsg(eIndex < GC.getNumTechInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 999  : 
; 1000 : 	return m_peLocaleTechResources[eIndex];

	mov	eax, DWORD PTR [ecx+24]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 1001 : }

	ret	4
?GetLocaleTechResource@CvPlayerTechs@@QBE?AW4ResourceTypes@@W4TechTypes@@@Z ENDP ; CvPlayerTechs::GetLocaleTechResource
_TEXT	ENDS
PUBLIC	?GetCivTechUniqueUnit@CvPlayerTechs@@QBE?AW4UnitTypes@@W4TechTypes@@@Z ; CvPlayerTechs::GetCivTechUniqueUnit
; Function compile flags: /Ogtpy
;	COMDAT ?GetCivTechUniqueUnit@CvPlayerTechs@@QBE?AW4UnitTypes@@W4TechTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?GetCivTechUniqueUnit@CvPlayerTechs@@QBE?AW4UnitTypes@@W4TechTypes@@@Z PROC ; CvPlayerTechs::GetCivTechUniqueUnit, COMDAT
; _this$ = ecx

; 1005 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 1006 : 	CvAssertMsg(eIndex < GC.getNumTechInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 1007 : 
; 1008 : 	return m_peCivTechUniqueUnits[eIndex];

	mov	eax, DWORD PTR [ecx+28]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 1009 : }

	ret	4
?GetCivTechUniqueUnit@CvPlayerTechs@@QBE?AW4UnitTypes@@W4TechTypes@@@Z ENDP ; CvPlayerTechs::GetCivTechUniqueUnit
_TEXT	ENDS
PUBLIC	?GetCivTechUniqueBuilding@CvPlayerTechs@@QBE?AW4BuildingTypes@@W4TechTypes@@@Z ; CvPlayerTechs::GetCivTechUniqueBuilding
; Function compile flags: /Ogtpy
;	COMDAT ?GetCivTechUniqueBuilding@CvPlayerTechs@@QBE?AW4BuildingTypes@@W4TechTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?GetCivTechUniqueBuilding@CvPlayerTechs@@QBE?AW4BuildingTypes@@W4TechTypes@@@Z PROC ; CvPlayerTechs::GetCivTechUniqueBuilding, COMDAT
; _this$ = ecx

; 1013 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 1014 : 	CvAssertMsg(eIndex < GC.getNumTechInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 1015 : 
; 1016 : 	return m_peCivTechUniqueBuildings[eIndex];

	mov	eax, DWORD PTR [ecx+32]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 1017 : }

	ret	4
?GetCivTechUniqueBuilding@CvPlayerTechs@@QBE?AW4BuildingTypes@@W4TechTypes@@@Z ENDP ; CvPlayerTechs::GetCivTechUniqueBuilding
_TEXT	ENDS
PUBLIC	?GetCivTechUniqueImprovement@CvPlayerTechs@@QBE?AW4ImprovementTypes@@W4TechTypes@@@Z ; CvPlayerTechs::GetCivTechUniqueImprovement
; Function compile flags: /Ogtpy
;	COMDAT ?GetCivTechUniqueImprovement@CvPlayerTechs@@QBE?AW4ImprovementTypes@@W4TechTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?GetCivTechUniqueImprovement@CvPlayerTechs@@QBE?AW4ImprovementTypes@@W4TechTypes@@@Z PROC ; CvPlayerTechs::GetCivTechUniqueImprovement, COMDAT
; _this$ = ecx

; 1021 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 1022 : 	CvAssertMsg(eIndex < GC.getNumTechInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 1023 : 
; 1024 : 	return m_peCivTechUniqueImprovements[eIndex];

	mov	eax, DWORD PTR [ecx+36]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 1025 : }

	ret	4
?GetCivTechUniqueImprovement@CvPlayerTechs@@QBE?AW4ImprovementTypes@@W4TechTypes@@@Z ENDP ; CvPlayerTechs::GetCivTechUniqueImprovement
_TEXT	ENDS
PUBLIC	?IsResearch@CvPlayerTechs@@QBE_NXZ		; CvPlayerTechs::IsResearch
EXTRN	?isFoundedFirstCity@CvPlayer@@QBE_NXZ:PROC	; CvPlayer::isFoundedFirstCity
; Function compile flags: /Ogtpy
;	COMDAT ?IsResearch@CvPlayerTechs@@QBE_NXZ
_TEXT	SEGMENT
?IsResearch@CvPlayerTechs@@QBE_NXZ PROC			; CvPlayerTechs::IsResearch, COMDAT
; _this$ = ecx

; 1132 : #ifdef AUI_PLAYERTECH_FIX_CAN_RESEARCH_WITH_NO_FOUNDED_CITY
; 1133 : 	return (m_pPlayer->getNumCities() > 0);
; 1134 : #else
; 1135 : 	// Have we founded a city?
; 1136 : 	if(!m_pPlayer->isFoundedFirstCity())

	mov	ecx, DWORD PTR [ecx+44]
	call	?isFoundedFirstCity@CvPlayer@@QBE_NXZ	; CvPlayer::isFoundedFirstCity
	test	al, al
	setne	al

; 1137 : 	{
; 1138 : 		return false;
; 1139 : 	}
; 1140 : 
; 1141 : 	return true;
; 1142 : #endif
; 1143 : }

	ret	0
?IsResearch@CvPlayerTechs@@QBE_NXZ ENDP			; CvPlayerTechs::IsResearch
_TEXT	ENDS
PUBLIC	?GetCurrentResearch@CvPlayerTechs@@QBE?AW4TechTypes@@XZ ; CvPlayerTechs::GetCurrentResearch
EXTRN	?headResearchQueueNode@CvPlayer@@QAEPAV?$CLLNode@W4TechTypes@@@@XZ:PROC ; CvPlayer::headResearchQueueNode
; Function compile flags: /Ogtpy
;	COMDAT ?GetCurrentResearch@CvPlayerTechs@@QBE?AW4TechTypes@@XZ
_TEXT	SEGMENT
?GetCurrentResearch@CvPlayerTechs@@QBE?AW4TechTypes@@XZ PROC ; CvPlayerTechs::GetCurrentResearch, COMDAT
; _this$ = ecx

; 1303 : 	CLLNode<TechTypes>* pResearchNode;
; 1304 : 
; 1305 : 	pResearchNode = m_pPlayer->headResearchQueueNode();

	mov	ecx, DWORD PTR [ecx+44]
	call	?headResearchQueueNode@CvPlayer@@QAEPAV?$CLLNode@W4TechTypes@@@@XZ ; CvPlayer::headResearchQueueNode

; 1306 : 
; 1307 : 	if(pResearchNode != NULL)

	test	eax, eax
	je	SHORT $LN2@GetCurrent

; 1308 : 	{
; 1309 : 		return pResearchNode->m_data;

	mov	eax, DWORD PTR [eax+4]

; 1314 : 	}
; 1315 : }

	ret	0
$LN2@GetCurrent:

; 1310 : 	}
; 1311 : 	else
; 1312 : 	{
; 1313 : 		return NO_TECH;

	or	eax, -1

; 1314 : 	}
; 1315 : }

	ret	0
?GetCurrentResearch@CvPlayerTechs@@QBE?AW4TechTypes@@XZ ENDP ; CvPlayerTechs::GetCurrentResearch
_TEXT	ENDS
PUBLIC	?IsCurrentResearchRepeat@CvPlayerTechs@@QBE_NXZ	; CvPlayerTechs::IsCurrentResearchRepeat
EXTRN	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z:PROC ; CvGlobals::getTechInfo
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Ogtpy
;	COMDAT ?IsCurrentResearchRepeat@CvPlayerTechs@@QBE_NXZ
_TEXT	SEGMENT
?IsCurrentResearchRepeat@CvPlayerTechs@@QBE_NXZ PROC	; CvPlayerTechs::IsCurrentResearchRepeat, COMDAT
; _this$ = ecx

; 1320 : 	const TechTypes eCurrentResearch = GetCurrentResearch();

	mov	ecx, DWORD PTR [ecx+44]
	call	?headResearchQueueNode@CvPlayer@@QAEPAV?$CLLNode@W4TechTypes@@@@XZ ; CvPlayer::headResearchQueueNode
	test	eax, eax
	je	SHORT $LN11@IsCurrentR
	mov	eax, DWORD PTR [eax+4]

; 1321 : 	if(eCurrentResearch == NO_TECH)

	cmp	eax, -1
	jne	SHORT $LN2@IsCurrentR
$LN11@IsCurrentR:

; 1322 : 	{
; 1323 : 		return false;

	xor	al, al

; 1333 : }

	ret	0
$LN2@IsCurrentR:

; 1324 : 	}
; 1325 : 
; 1326 : 	CvTechEntry* pkTechInfo = GC.getTechInfo(eCurrentResearch);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo

; 1327 : 	if(pkTechInfo == NULL)

	test	eax, eax

; 1328 : 	{
; 1329 : 		return false;

	je	SHORT $LN11@IsCurrentR

; 1330 : 	}
; 1331 : 
; 1332 : 	return pkTechInfo->IsRepeat();

	mov	al, BYTE PTR [eax+338]

; 1333 : }

	ret	0
?IsCurrentResearchRepeat@CvPlayerTechs@@QBE_NXZ ENDP	; CvPlayerTechs::IsCurrentResearchRepeat
_TEXT	ENDS
PUBLIC	?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ ; CvPlayerTechs::GetTechs
; Function compile flags: /Ogtpy
;	COMDAT ?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ
_TEXT	SEGMENT
?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ PROC ; CvPlayerTechs::GetTechs, COMDAT
; _this$ = ecx

; 1534 : 	return m_pTechs;

	mov	eax, DWORD PTR [ecx+40]

; 1535 : }

	ret	0
?GetTechs@CvPlayerTechs@@QBEPAVCvTechXMLEntries@@XZ ENDP ; CvPlayerTechs::GetTechs
_TEXT	ENDS
PUBLIC	??0CvTeamTechs@@QAE@XZ				; CvTeamTechs::CvTeamTechs
; Function compile flags: /Ogtpy
;	COMDAT ??0CvTeamTechs@@QAE@XZ
_TEXT	SEGMENT
??0CvTeamTechs@@QAE@XZ PROC				; CvTeamTechs::CvTeamTechs, COMDAT
; _this$ = ecx

; 1743 : {

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx

; 1744 : }

	ret	0
??0CvTeamTechs@@QAE@XZ ENDP				; CvTeamTechs::CvTeamTechs
_TEXT	ENDS
PUBLIC	??1CvTeamTechs@@QAE@XZ				; CvTeamTechs::~CvTeamTechs
; Function compile flags: /Ogtpy
;	COMDAT ??1CvTeamTechs@@QAE@XZ
_TEXT	SEGMENT
??1CvTeamTechs@@QAE@XZ PROC				; CvTeamTechs::~CvTeamTechs, COMDAT
; _this$ = ecx

; 1749 : }

	ret	0
??1CvTeamTechs@@QAE@XZ ENDP				; CvTeamTechs::~CvTeamTechs
_TEXT	ENDS
PUBLIC	?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z	; CvTeamTechs::HasTech
; Function compile flags: /Ogtpy
;	COMDAT ?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z PROC		; CvTeamTechs::HasTech, COMDAT
; _this$ = ecx

; 1996 : 	if(eIndex == NO_TECH)

	mov	edx, DWORD PTR _eIndex$[esp-4]
	cmp	edx, -1
	jne	SHORT $LN3@HasTech

; 1997 : 	{
; 1998 : 		return true;

	mov	al, 1

; 2008 : }

	ret	4
$LN3@HasTech:

; 1999 : 	}
; 2000 : 
; 2001 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 2002 : 	CvAssertMsg(eIndex < GC.getNumTechInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 2003 : 	CvAssertMsg(m_pabHasTech != NULL, "m_pabHasTech is not expected to be equal with NULL");
; 2004 : 	if(m_pabHasTech != NULL)

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	je	SHORT $LN2@HasTech

; 2005 : 		return m_pabHasTech[eIndex];

	mov	al, BYTE PTR [eax+edx]

; 2008 : }

	ret	4
$LN2@HasTech:

; 2006 : 	else
; 2007 : 		return false;

	xor	al, al

; 2008 : }

	ret	4
?HasTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ENDP		; CvTeamTechs::HasTech
_TEXT	ENDS
PUBLIC	?GetLastTechAcquired@CvTeamTechs@@QBE?AW4TechTypes@@XZ ; CvTeamTechs::GetLastTechAcquired
; Function compile flags: /Ogtpy
;	COMDAT ?GetLastTechAcquired@CvTeamTechs@@QBE?AW4TechTypes@@XZ
_TEXT	SEGMENT
?GetLastTechAcquired@CvTeamTechs@@QBE?AW4TechTypes@@XZ PROC ; CvTeamTechs::GetLastTechAcquired, COMDAT
; _this$ = ecx

; 2013 : 	return m_eLastTechAcquired;

	mov	eax, DWORD PTR [ecx]

; 2014 : }

	ret	0
?GetLastTechAcquired@CvTeamTechs@@QBE?AW4TechTypes@@XZ ENDP ; CvTeamTechs::GetLastTechAcquired
_TEXT	ENDS
PUBLIC	?SetLastTechAcquired@CvTeamTechs@@QAEXW4TechTypes@@@Z ; CvTeamTechs::SetLastTechAcquired
; Function compile flags: /Ogtpy
;	COMDAT ?SetLastTechAcquired@CvTeamTechs@@QAEXW4TechTypes@@@Z
_TEXT	SEGMENT
_eTech$ = 8						; size = 4
?SetLastTechAcquired@CvTeamTechs@@QAEXW4TechTypes@@@Z PROC ; CvTeamTechs::SetLastTechAcquired, COMDAT
; _this$ = ecx

; 2019 : 	CvAssertMsg(eTech >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 2020 : 	CvAssertMsg(eTech < GC.getNumTechInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 2021 : 
; 2022 : 	m_eLastTechAcquired = eTech;

	mov	eax, DWORD PTR _eTech$[esp-4]
	mov	DWORD PTR [ecx], eax

; 2023 : }

	ret	4
?SetLastTechAcquired@CvTeamTechs@@QAEXW4TechTypes@@@Z ENDP ; CvTeamTechs::SetLastTechAcquired
_TEXT	ENDS
PUBLIC	?GetNumTechsKnown@CvTeamTechs@@QBEHXZ		; CvTeamTechs::GetNumTechsKnown
EXTRN	?getNumTechInfos@CvGlobals@@QAEHXZ:PROC		; CvGlobals::getNumTechInfos
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumTechsKnown@CvTeamTechs@@QBEHXZ
_TEXT	SEGMENT
?GetNumTechsKnown@CvTeamTechs@@QBEHXZ PROC		; CvTeamTechs::GetNumTechsKnown, COMDAT
; _this$ = ecx

; 2027 : {

	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 2028 : 	int iNumTechs = 0;
; 2029 : 
; 2030 : #ifdef AUI_WARNING_FIXES
; 2031 : 	for (uint iTechLoop = 0; iTechLoop < GC.getNumTechInfos(); iTechLoop++)
; 2032 : #else
; 2033 : 	for(int iTechLoop = 0; iTechLoop < GC.getNumTechInfos(); iTechLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	ebx, ebx
	xor	esi, esi
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	test	eax, eax
	jle	SHORT $LN15@GetNumTech
$LL4@GetNumTech:

; 2034 : #endif
; 2035 : 	{
; 2036 : 		if(HasTech((TechTypes) iTechLoop))

	cmp	esi, -1
	je	SHORT $LN14@GetNumTech
	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	je	SHORT $LN3@GetNumTech
	cmp	BYTE PTR [eax+esi], 0
	je	SHORT $LN3@GetNumTech
$LN14@GetNumTech:

; 2037 : 		{
; 2038 : 			iNumTechs++;

	inc	ebx
$LN3@GetNumTech:

; 2028 : 	int iNumTechs = 0;
; 2029 : 
; 2030 : #ifdef AUI_WARNING_FIXES
; 2031 : 	for (uint iTechLoop = 0; iTechLoop < GC.getNumTechInfos(); iTechLoop++)
; 2032 : #else
; 2033 : 	for(int iTechLoop = 0; iTechLoop < GC.getNumTechInfos(); iTechLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	cmp	esi, eax
	jl	SHORT $LL4@GetNumTech
$LN15@GetNumTech:
	pop	edi
	pop	esi

; 2039 : 		}
; 2040 : 	}
; 2041 : 
; 2042 : 	return iNumTechs;

	mov	eax, ebx
	pop	ebx

; 2043 : }

	ret	0
?GetNumTechsKnown@CvTeamTechs@@QBEHXZ ENDP		; CvTeamTechs::GetNumTechsKnown
_TEXT	ENDS
PUBLIC	?SetNoTradeTech@CvTeamTechs@@QAEXW4TechTypes@@_N@Z ; CvTeamTechs::SetNoTradeTech
; Function compile flags: /Ogtpy
;	COMDAT ?SetNoTradeTech@CvTeamTechs@@QAEXW4TechTypes@@_N@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_bNewValue$ = 12					; size = 1
?SetNoTradeTech@CvTeamTechs@@QAEXW4TechTypes@@_N@Z PROC	; CvTeamTechs::SetNoTradeTech, COMDAT
; _this$ = ecx

; 2069 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 2070 : 	CvAssertMsg(eIndex < GC.getNumTechInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 2071 : 
; 2072 : 	if(m_pabNoTradeTech[eIndex] != bNewValue)

	mov	eax, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	add	eax, ecx
	mov	cl, BYTE PTR _bNewValue$[esp-4]
	cmp	BYTE PTR [eax], cl
	je	SHORT $LN1@SetNoTrade

; 2073 : 	{
; 2074 : 		m_pabNoTradeTech[eIndex] = bNewValue;

	mov	BYTE PTR [eax], cl
$LN1@SetNoTrade:

; 2075 : 	}
; 2076 : }

	ret	8
?SetNoTradeTech@CvTeamTechs@@QAEXW4TechTypes@@_N@Z ENDP	; CvTeamTechs::SetNoTradeTech
_TEXT	ENDS
PUBLIC	?IsNoTradeTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ; CvTeamTechs::IsNoTradeTech
; Function compile flags: /Ogtpy
;	COMDAT ?IsNoTradeTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?IsNoTradeTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z PROC	; CvTeamTechs::IsNoTradeTech, COMDAT
; _this$ = ecx

; 2081 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 2082 : 	CvAssertMsg(eIndex < GC.getNumTechInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 2083 : 	return m_pabNoTradeTech[eIndex];

	mov	eax, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	mov	al, BYTE PTR [ecx+eax]

; 2084 : }

	ret	4
?IsNoTradeTech@CvTeamTechs@@QBE_NW4TechTypes@@@Z ENDP	; CvTeamTechs::IsNoTradeTech
_TEXT	ENDS
PUBLIC	?IncrementTechCount@CvTeamTechs@@QAEXW4TechTypes@@@Z ; CvTeamTechs::IncrementTechCount
; Function compile flags: /Ogtpy
;	COMDAT ?IncrementTechCount@CvTeamTechs@@QAEXW4TechTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?IncrementTechCount@CvTeamTechs@@QAEXW4TechTypes@@@Z PROC ; CvTeamTechs::IncrementTechCount, COMDAT
; _this$ = ecx

; 2089 : 	m_paiTechCount[eIndex]++;

	mov	eax, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	inc	DWORD PTR [eax+ecx*4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 2090 : }

	ret	4
?IncrementTechCount@CvTeamTechs@@QAEXW4TechTypes@@@Z ENDP ; CvTeamTechs::IncrementTechCount
_TEXT	ENDS
PUBLIC	?GetTechCount@CvTeamTechs@@QBEHW4TechTypes@@@Z	; CvTeamTechs::GetTechCount
; Function compile flags: /Ogtpy
;	COMDAT ?GetTechCount@CvTeamTechs@@QBEHW4TechTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?GetTechCount@CvTeamTechs@@QBEHW4TechTypes@@@Z PROC	; CvTeamTechs::GetTechCount, COMDAT
; _this$ = ecx

; 2095 : 	return m_paiTechCount[eIndex];

	mov	eax, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR _eIndex$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 2096 : }

	ret	4
?GetTechCount@CvTeamTechs@@QBEHW4TechTypes@@@Z ENDP	; CvTeamTechs::GetTechCount
_TEXT	ENDS
PUBLIC	?GetResearchProgress@CvTeamTechs@@QBEHW4TechTypes@@@Z ; CvTeamTechs::GetResearchProgress
; Function compile flags: /Ogtpy
;	COMDAT ?GetResearchProgress@CvTeamTechs@@QBEHW4TechTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?GetResearchProgress@CvTeamTechs@@QBEHW4TechTypes@@@Z PROC ; CvTeamTechs::GetResearchProgress, COMDAT
; _this$ = ecx

; 2207 : 	if(eIndex != NO_TECH)

	mov	eax, DWORD PTR _eIndex$[esp-4]
	cmp	eax, -1
	je	SHORT $LN2@GetResearc

; 2208 : 	{
; 2209 : 		return m_paiResearchProgress[eIndex] / 100;

	mov	ecx, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+eax*4]
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 2214 : 	}
; 2215 : }

	ret	4
$LN2@GetResearc:

; 2210 : 	}
; 2211 : 	else
; 2212 : 	{
; 2213 : 		return 0;

	xor	eax, eax

; 2214 : 	}
; 2215 : }

	ret	4
?GetResearchProgress@CvTeamTechs@@QBEHW4TechTypes@@@Z ENDP ; CvTeamTechs::GetResearchProgress
_TEXT	ENDS
PUBLIC	?GetResearchProgressTimes100@CvTeamTechs@@QBEHW4TechTypes@@@Z ; CvTeamTechs::GetResearchProgressTimes100
; Function compile flags: /Ogtpy
;	COMDAT ?GetResearchProgressTimes100@CvTeamTechs@@QBEHW4TechTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?GetResearchProgressTimes100@CvTeamTechs@@QBEHW4TechTypes@@@Z PROC ; CvTeamTechs::GetResearchProgressTimes100, COMDAT
; _this$ = ecx

; 2220 : 	if(eIndex != NO_TECH)

	mov	eax, DWORD PTR _eIndex$[esp-4]
	cmp	eax, -1
	je	SHORT $LN2@GetResearc@2

; 2221 : 	{
; 2222 : 		return m_paiResearchProgress[eIndex];

	mov	ecx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [ecx+eax*4]

; 2227 : 	}
; 2228 : }

	ret	4
$LN2@GetResearc@2:

; 2223 : 	}
; 2224 : 	else
; 2225 : 	{
; 2226 : 		return 0;

	xor	eax, eax

; 2227 : 	}
; 2228 : }

	ret	4
?GetResearchProgressTimes100@CvTeamTechs@@QBEHW4TechTypes@@@Z ENDP ; CvTeamTechs::GetResearchProgressTimes100
_TEXT	ENDS
PUBLIC	?GetTechs@CvTeamTechs@@QBEPAVCvTechXMLEntries@@XZ ; CvTeamTechs::GetTechs
; Function compile flags: /Ogtpy
;	COMDAT ?GetTechs@CvTeamTechs@@QBEPAVCvTechXMLEntries@@XZ
_TEXT	SEGMENT
?GetTechs@CvTeamTechs@@QBEPAVCvTechXMLEntries@@XZ PROC	; CvTeamTechs::GetTechs, COMDAT
; _this$ = ecx

; 2318 : 	return m_pTechs;

	mov	eax, DWORD PTR [ecx+20]

; 2319 : }

	ret	0
?GetTechs@CvTeamTechs@@QBEPAVCvTechXMLEntries@@XZ ENDP	; CvTeamTechs::GetTechs
_TEXT	ENDS
PUBLIC	??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int> >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z PROC	; std::vector<int,std::allocator<int> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ENDP	; std::vector<int,std::allocator<int> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QBEIXZ ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAEAAPAVCvTechEntry@@I@Z ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAEAAPAVCvTechEntry@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAEAAPAVCvTechEntry@@I@Z PROC ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAEAAPAVCvTechEntry@@I@Z ENDP ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::operator[]
_TEXT	ENDS
PUBLIC	??0?$ArrayWrapper@H@@QAE@HPAH@Z			; ArrayWrapper<int>::ArrayWrapper<int>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??0?$ArrayWrapper@H@@QAE@HPAH@Z
_TEXT	SEGMENT
_count$ = 8						; size = 4
_values$ = 12						; size = 4
??0?$ArrayWrapper@H@@QAE@HPAH@Z PROC			; ArrayWrapper<int>::ArrayWrapper<int>, COMDAT
; _this$ = ecx

; 378  : 		: m_values(values), m_count(count) {}

	mov	edx, DWORD PTR _count$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _values$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	ret	8
??0?$ArrayWrapper@H@@QAE@HPAH@Z ENDP			; ArrayWrapper<int>::ArrayWrapper<int>
_TEXT	ENDS
PUBLIC	??0?$ArrayWrapper@_N@@QAE@HPA_N@Z		; ArrayWrapper<bool>::ArrayWrapper<bool>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$ArrayWrapper@_N@@QAE@HPA_N@Z
_TEXT	SEGMENT
_count$ = 8						; size = 4
_values$ = 12						; size = 4
??0?$ArrayWrapper@_N@@QAE@HPA_N@Z PROC			; ArrayWrapper<bool>::ArrayWrapper<bool>, COMDAT
; _this$ = ecx

; 378  : 		: m_values(values), m_count(count) {}

	mov	edx, DWORD PTR _count$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _values$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	ret	8
??0?$ArrayWrapper@_N@@QAE@HPA_N@Z ENDP			; ArrayWrapper<bool>::ArrayWrapper<bool>
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvTechEntry@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvTechEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvTechEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvTechEntry@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvTechEntry@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvTechEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvTechEntry *> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvTechEntry@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvTechEntry *> >::~_Container_base_aux_alloc_empty<std::allocator<CvTechEntry *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvTechEntry@@@std@@QAE@XZ	; std::allocator<CvTechEntry *>::allocator<CvTechEntry *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvTechEntry@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVCvTechEntry@@@std@@QAE@XZ PROC	; std::allocator<CvTechEntry *>::allocator<CvTechEntry *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@PAVCvTechEntry@@@std@@QAE@XZ ENDP	; std::allocator<CvTechEntry *>::allocator<CvTechEntry *>
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QBEABQAVCvTechEntry@@XZ ; std::_Vector_const_iterator<CvTechEntry *,std::allocator<CvTechEntry *> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QBEABQAVCvTechEntry@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QBEABQAVCvTechEntry@@XZ PROC ; std::_Vector_const_iterator<CvTechEntry *,std::allocator<CvTechEntry *> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QBEABQAVCvTechEntry@@XZ ENDP ; std::_Vector_const_iterator<CvTechEntry *,std::allocator<CvTechEntry *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvTechEntry *,std::allocator<CvTechEntry *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvTechEntry *,std::allocator<CvTechEntry *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvTechEntry *,std::allocator<CvTechEntry *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvTechEntry *,std::allocator<CvTechEntry *> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvTechEntry *,std::allocator<CvTechEntry *> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvTechEntry *,std::allocator<CvTechEntry *> >::operator==
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@KAXXZ ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::_Xlen
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T227416 = -80						; size = 28
$T227415 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@KAXXZ PROC ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T227416[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T227415[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T227416[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T227415[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T227415[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T227415[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T227415[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen:
$LN12@Xlen:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T227416[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T227415[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@KAXXZ ENDP ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvTechEntry@@@std@@@std@@IAE@V?$allocator@PAVCvTechEntry@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvTechEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvTechEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvTechEntry@@@std@@@std@@IAE@V?$allocator@PAVCvTechEntry@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvTechEntry@@@std@@@std@@IAE@V?$allocator@PAVCvTechEntry@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvTechEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvTechEntry *> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@PAVCvTechEntry@@@std@@@std@@IAE@V?$allocator@PAVCvTechEntry@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvTechEntry *> >::_Container_base_aux_alloc_empty<std::allocator<CvTechEntry *> >
_TEXT	ENDS
PUBLIC	??0?$allocator@PAVCvTechEntry@@@std@@QAE@ABV01@@Z ; std::allocator<CvTechEntry *>::allocator<CvTechEntry *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVCvTechEntry@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@PAVCvTechEntry@@@std@@QAE@ABV01@@Z PROC	; std::allocator<CvTechEntry *>::allocator<CvTechEntry *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@PAVCvTechEntry@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<CvTechEntry *>::allocator<CvTechEntry *>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVCvTechEntry@@@std@@QAEXPAPAVCvTechEntry@@I@Z ; std::allocator<CvTechEntry *>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@PAVCvTechEntry@@@std@@QAEXPAPAVCvTechEntry@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVCvTechEntry@@@std@@QAEXPAPAVCvTechEntry@@I@Z PROC ; std::allocator<CvTechEntry *>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@PAVCvTechEntry@@@std@@QAEXPAPAVCvTechEntry@@I@Z ENDP ; std::allocator<CvTechEntry *>::deallocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE@PAPAVCvTechEntry@@@Z ; std::_Vector_const_iterator<CvTechEntry *,std::allocator<CvTechEntry *> >::_Vector_const_iterator<CvTechEntry *,std::allocator<CvTechEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE@PAPAVCvTechEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE@PAPAVCvTechEntry@@@Z PROC ; std::_Vector_const_iterator<CvTechEntry *,std::allocator<CvTechEntry *> >::_Vector_const_iterator<CvTechEntry *,std::allocator<CvTechEntry *> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE@PAPAVCvTechEntry@@@Z ENDP ; std::_Vector_const_iterator<CvTechEntry *,std::allocator<CvTechEntry *> >::_Vector_const_iterator<CvTechEntry *,std::allocator<CvTechEntry *> >
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVCvTechEntry@@@std@@QBEIXZ ; std::allocator<CvTechEntry *>::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@PAVCvTechEntry@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVCvTechEntry@@@std@@QBEIXZ PROC	; std::allocator<CvTechEntry *>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@PAVCvTechEntry@@@std@@QBEIXZ ENDP	; std::allocator<CvTechEntry *>::max_size
_TEXT	ENDS
PUBLIC	??$max@H@std@@YAABHABH0@Z			; std::max<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$max@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@H@std@@YAABHABH0@Z PROC				; std::max<int>, COMDAT

; 3384 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN4@max
	mov	eax, ecx
$LN4@max:

; 3385 : 	}

	ret	0
??$max@H@std@@YAABHABH0@Z ENDP				; std::max<int>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z		; SAFE_DELETE_ARRAY<int>
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z PROC			; SAFE_DELETE_ARRAY<int>, COMDAT

; 311  : {

	push	esi

; 312  : 	delete[] pkInstanceArray;

	mov	esi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z ENDP			; SAFE_DELETE_ARRAY<int>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@_N@@YAXAAPA_N@Z		; SAFE_DELETE_ARRAY<bool>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE_ARRAY@_N@@YAXAAPA_N@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@_N@@YAXAAPA_N@Z PROC		; SAFE_DELETE_ARRAY<bool>, COMDAT

; 311  : {

	push	esi

; 312  : 	delete[] pkInstanceArray;

	mov	esi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@_N@@YAXAAPA_N@Z ENDP		; SAFE_DELETE_ARRAY<bool>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@W4ResourceTypes@@@@YAXAAPAW4ResourceTypes@@@Z ; SAFE_DELETE_ARRAY<enum ResourceTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE_ARRAY@W4ResourceTypes@@@@YAXAAPAW4ResourceTypes@@@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@W4ResourceTypes@@@@YAXAAPAW4ResourceTypes@@@Z PROC ; SAFE_DELETE_ARRAY<enum ResourceTypes>, COMDAT

; 311  : {

	push	esi

; 312  : 	delete[] pkInstanceArray;

	mov	esi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@W4ResourceTypes@@@@YAXAAPAW4ResourceTypes@@@Z ENDP ; SAFE_DELETE_ARRAY<enum ResourceTypes>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@W4BuildingTypes@@@@YAXAAPAW4BuildingTypes@@@Z ; SAFE_DELETE_ARRAY<enum BuildingTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE_ARRAY@W4BuildingTypes@@@@YAXAAPAW4BuildingTypes@@@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@W4BuildingTypes@@@@YAXAAPAW4BuildingTypes@@@Z PROC ; SAFE_DELETE_ARRAY<enum BuildingTypes>, COMDAT

; 311  : {

	push	esi

; 312  : 	delete[] pkInstanceArray;

	mov	esi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@W4BuildingTypes@@@@YAXAAPAW4BuildingTypes@@@Z ENDP ; SAFE_DELETE_ARRAY<enum BuildingTypes>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@W4UnitTypes@@@@YAXAAPAW4UnitTypes@@@Z ; SAFE_DELETE_ARRAY<enum UnitTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE_ARRAY@W4UnitTypes@@@@YAXAAPAW4UnitTypes@@@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@W4UnitTypes@@@@YAXAAPAW4UnitTypes@@@Z PROC ; SAFE_DELETE_ARRAY<enum UnitTypes>, COMDAT

; 311  : {

	push	esi

; 312  : 	delete[] pkInstanceArray;

	mov	esi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@W4UnitTypes@@@@YAXAAPAW4UnitTypes@@@Z ENDP ; SAFE_DELETE_ARRAY<enum UnitTypes>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@W4ImprovementTypes@@@@YAXAAPAW4ImprovementTypes@@@Z ; SAFE_DELETE_ARRAY<enum ImprovementTypes>
; Function compile flags: /Ogtpy
;	COMDAT ??$SAFE_DELETE_ARRAY@W4ImprovementTypes@@@@YAXAAPAW4ImprovementTypes@@@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@W4ImprovementTypes@@@@YAXAAPAW4ImprovementTypes@@@Z PROC ; SAFE_DELETE_ARRAY<enum ImprovementTypes>, COMDAT

; 311  : {

	push	esi

; 312  : 	delete[] pkInstanceArray;

	mov	esi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@W4ImprovementTypes@@@@YAXAAPAW4ImprovementTypes@@@Z ENDP ; SAFE_DELETE_ARRAY<enum ImprovementTypes>
_TEXT	ENDS
PUBLIC	??$min@H@std@@YAABHABH0@Z			; std::min<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$min@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@H@std@@YAABHABH0@Z PROC				; std::min<int>, COMDAT

; 3399 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Left$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jl	SHORT $LN4@min
	mov	eax, ecx
$LN4@min:

; 3400 : 	}

	ret	0
??$min@H@std@@YAABHABH0@Z ENDP				; std::min<int>
_TEXT	ENDS
PUBLIC	??$ReadHashedTypeArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@IPAHI@Z ; CvInfosSerializationHelper::ReadHashedTypeArray<int>
EXTRN	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z:PROC ; CvInfosSerializationHelper::ReadHashed
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfosserializationhelper.h
;	COMDAT ??$ReadHashedTypeArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@IPAHI@Z
_TEXT	SEGMENT
_kStream$ = 8						; size = 4
_uiInputArraySize$ = 12					; size = 4
_paArray$ = 16						; size = 4
_uiOutputArraySize$ = 20				; size = 4
??$ReadHashedTypeArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@IPAHI@Z PROC ; CvInfosSerializationHelper::ReadHashedTypeArray<int>, COMDAT

; 472  : {

	push	ebp

; 473  : 	for(uint iI = 0; iI < uiInputArraySize; iI++)

	mov	ebp, DWORD PTR _uiInputArraySize$[esp]
	push	esi
	xor	esi, esi
	test	ebp, ebp
	jbe	SHORT $LN2@ReadHashed
	push	ebx
	mov	ebx, DWORD PTR _kStream$[esp+8]
	push	edi
	mov	edi, DWORD PTR _uiOutputArraySize$[esp+12]
$LL9@ReadHashed:

; 474  : 	{
; 475  : 		TType eType = (TType)ReadHashed(kStream);

	push	0
	push	ebx
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	add	esp, 8

; 476  : 		if(iI < uiOutputArraySize)

	cmp	esi, edi
	jae	SHORT $LN3@ReadHashed

; 477  : 			paArray[iI] = eType;

	mov	ecx, DWORD PTR _paArray$[esp+12]
	mov	DWORD PTR [ecx+esi*4], eax
$LN3@ReadHashed:
	inc	esi
	cmp	esi, ebp
	jb	SHORT $LL9@ReadHashed
	pop	edi
	pop	ebx
$LN2@ReadHashed:
	pop	esi
	pop	ebp

; 478  : 	}
; 479  : }

	ret	0
??$ReadHashedTypeArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@IPAHI@Z ENDP ; CvInfosSerializationHelper::ReadHashedTypeArray<int>
_TEXT	ENDS
PUBLIC	??$ReadAndRemapDataArray@_N@CvInfosSerializationHelper@@YA_NAAVFDataStream@@HPA_NHPBH@Z ; CvInfosSerializationHelper::ReadAndRemapDataArray<bool>
EXTRN	__imp__malloc:PROC
EXTRN	__alloca_probe_16:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??$ReadAndRemapDataArray@_N@CvInfosSerializationHelper@@YA_NAAVFDataStream@@HPA_NHPBH@Z
_TEXT	SEGMENT
_kStream$ = 8						; size = 4
_iSrcCount$ = 12					; size = 4
_bRemapSuccess$ = 15					; size = 1
_pvDest$ = 16						; size = 4
_iDestCount$ = 20					; size = 4
_piaRemap$ = 24						; size = 4
??$ReadAndRemapDataArray@_N@CvInfosSerializationHelper@@YA_NAAVFDataStream@@HPA_NHPBH@Z PROC ; CvInfosSerializationHelper::ReadAndRemapDataArray<bool>, COMDAT

; 485  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi

; 486  : 	TType* pvBuffer = (TType*)_malloca(iSrcCount * sizeof(TType));

	mov	edi, DWORD PTR _iSrcCount$[ebp]
	lea	eax, DWORD PTR [edi+8]
	cmp	eax, 1024				; 00000400H
	ja	SHORT $LN8@ReadAndRem
	call	__alloca_probe_16
	mov	esi, esp
	test	esi, esi
	je	SHORT $LN9@ReadAndRem
	mov	DWORD PTR [esi], 52428			; 0000ccccH
	add	esi, 8
	jmp	SHORT $LN9@ReadAndRem
$LN8@ReadAndRem:
	push	eax
	call	DWORD PTR __imp__malloc
	add	esp, 4
	test	eax, eax
	je	SHORT $LN13@ReadAndRem
	mov	DWORD PTR [eax], 56797			; 0000ddddH
	add	eax, 8
$LN13@ReadAndRem:
	mov	esi, eax
$LN9@ReadAndRem:

; 487  : #ifdef AUI_WARNING_FIXES
; 488  : 	if (!pvBuffer)
; 489  : 		return false;
; 490  : #endif
; 491  : 	kStream.ReadIt(iSrcCount * sizeof(TType), (void*)pvBuffer);

	mov	ecx, DWORD PTR _kStream$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+4]
	push	esi
	push	edi
	call	edx

; 492  : 
; 493  : 	bool bRemapSuccess = true;

	mov	bl, 1

; 494  : 	for(int i = 0; i < iSrcCount; ++i)

	xor	eax, eax
	mov	BYTE PTR _bRemapSuccess$[ebp], bl
	test	edi, edi
	jle	SHORT $LN3@ReadAndRem
	mov	edx, DWORD PTR _pvDest$[ebp]
	npad	4
$LL5@ReadAndRem:

; 495  : 	{
; 496  : 		int iDestIndex = piaRemap[i];	// The new index

	mov	ecx, DWORD PTR _piaRemap$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]

; 497  : 		if(iDestIndex >= 0 && iDestIndex < iDestCount)

	test	ecx, ecx
	jl	SHORT $LN2@ReadAndRem
	cmp	ecx, DWORD PTR _iDestCount$[ebp]
	jge	SHORT $LN2@ReadAndRem

; 498  : 		{
; 499  : 			pvDest[iDestIndex] = pvBuffer[i];

	movzx	ebx, BYTE PTR [eax+esi]
	mov	BYTE PTR [ecx+edx], bl

; 500  : 		}
; 501  : 		else

	mov	bl, BYTE PTR _bRemapSuccess$[ebp]
	jmp	SHORT $LN4@ReadAndRem
$LN2@ReadAndRem:

; 502  : 			bRemapSuccess = false;

	xor	bl, bl
	mov	BYTE PTR _bRemapSuccess$[ebp], bl
$LN4@ReadAndRem:
	inc	eax
	cmp	eax, edi
	jl	SHORT $LL5@ReadAndRem
$LN3@ReadAndRem:

; 503  : 	}
; 504  : 	_freea(pvBuffer);

	test	esi, esi
	je	SHORT $LN25@ReadAndRem
	cmp	DWORD PTR [esi-8], 56797		; 0000ddddH
	lea	eax, DWORD PTR [esi-8]
	jne	SHORT $LN25@ReadAndRem
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
$LN25@ReadAndRem:

; 505  : 	return bRemapSuccess;

	mov	al, bl

; 506  : }

	lea	esp, DWORD PTR [ebp-12]
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
??$ReadAndRemapDataArray@_N@CvInfosSerializationHelper@@YA_NAAVFDataStream@@HPA_NHPBH@Z ENDP ; CvInfosSerializationHelper::ReadAndRemapDataArray<bool>
_TEXT	ENDS
PUBLIC	??$ReadAndRemapDataArray@H@CvInfosSerializationHelper@@YA_NAAVFDataStream@@HPAHHPBH@Z ; CvInfosSerializationHelper::ReadAndRemapDataArray<int>
; Function compile flags: /Ogtpy
;	COMDAT ??$ReadAndRemapDataArray@H@CvInfosSerializationHelper@@YA_NAAVFDataStream@@HPAHHPBH@Z
_TEXT	SEGMENT
tv64 = 8						; size = 4
_kStream$ = 8						; size = 4
_iSrcCount$ = 12					; size = 4
_bRemapSuccess$ = 15					; size = 1
_pvDest$ = 16						; size = 4
_iDestCount$ = 20					; size = 4
_piaRemap$ = 24						; size = 4
??$ReadAndRemapDataArray@H@CvInfosSerializationHelper@@YA_NAAVFDataStream@@HPAHHPBH@Z PROC ; CvInfosSerializationHelper::ReadAndRemapDataArray<int>, COMDAT

; 485  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi

; 486  : 	TType* pvBuffer = (TType*)_malloca(iSrcCount * sizeof(TType));

	mov	esi, DWORD PTR _iSrcCount$[ebp]
	lea	eax, DWORD PTR [esi*4+8]
	push	edi
	cmp	eax, 1024				; 00000400H
	ja	SHORT $LN8@ReadAndRem@2
	call	__alloca_probe_16
	mov	eax, esp
	test	eax, eax
	je	SHORT $LN13@ReadAndRem@2
	mov	DWORD PTR [eax], 52428			; 0000ccccH
	jmp	SHORT $LN26@ReadAndRem@2
$LN8@ReadAndRem@2:
	push	eax
	call	DWORD PTR __imp__malloc
	add	esp, 4
	test	eax, eax
	je	SHORT $LN13@ReadAndRem@2
	mov	DWORD PTR [eax], 56797			; 0000ddddH
$LN26@ReadAndRem@2:
	add	eax, 8
$LN13@ReadAndRem@2:

; 487  : #ifdef AUI_WARNING_FIXES
; 488  : 	if (!pvBuffer)
; 489  : 		return false;
; 490  : #endif
; 491  : 	kStream.ReadIt(iSrcCount * sizeof(TType), (void*)pvBuffer);

	mov	ecx, DWORD PTR _kStream$[ebp]
	mov	edi, eax
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	push	edi
	lea	edx, DWORD PTR [esi*4]
	push	edx
	call	eax

; 492  : 
; 493  : 	bool bRemapSuccess = true;

	mov	bl, 1
	mov	BYTE PTR _bRemapSuccess$[ebp], bl

; 494  : 	for(int i = 0; i < iSrcCount; ++i)

	test	esi, esi
	jle	SHORT $LN3@ReadAndRem@2
	mov	edx, DWORD PTR _piaRemap$[ebp]
	mov	DWORD PTR tv64[ebp], esi
	mov	esi, DWORD PTR _pvDest$[ebp]
	mov	ecx, edi
	sub	edx, edi
	npad	4
$LL5@ReadAndRem@2:

; 495  : 	{
; 496  : 		int iDestIndex = piaRemap[i];	// The new index

	mov	eax, DWORD PTR [edx+ecx]

; 497  : 		if(iDestIndex >= 0 && iDestIndex < iDestCount)

	test	eax, eax
	jl	SHORT $LN2@ReadAndRem@2
	cmp	eax, DWORD PTR _iDestCount$[ebp]
	jge	SHORT $LN2@ReadAndRem@2

; 498  : 		{
; 499  : 			pvDest[iDestIndex] = pvBuffer[i];

	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR [esi+eax*4], ebx

; 500  : 		}
; 501  : 		else

	mov	bl, BYTE PTR _bRemapSuccess$[ebp]
	jmp	SHORT $LN4@ReadAndRem@2
$LN2@ReadAndRem@2:

; 502  : 			bRemapSuccess = false;

	xor	bl, bl
	mov	BYTE PTR _bRemapSuccess$[ebp], bl
$LN4@ReadAndRem@2:
	add	ecx, 4
	sub	DWORD PTR tv64[ebp], 1
	jne	SHORT $LL5@ReadAndRem@2
$LN3@ReadAndRem@2:

; 503  : 	}
; 504  : 	_freea(pvBuffer);

	test	edi, edi
	je	SHORT $LN25@ReadAndRem@2
	cmp	DWORD PTR [edi-8], 56797		; 0000ddddH
	lea	eax, DWORD PTR [edi-8]
	jne	SHORT $LN25@ReadAndRem@2
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
$LN25@ReadAndRem@2:

; 505  : 	return bRemapSuccess;

	mov	al, bl

; 506  : }

	lea	esp, DWORD PTR [ebp-12]
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	0
??$ReadAndRemapDataArray@H@CvInfosSerializationHelper@@YA_NAAVFDataStream@@HPAHHPBH@Z ENDP ; CvInfosSerializationHelper::ReadAndRemapDataArray<int>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@PAVCvTechEntry@@@std@@YAPAPAVCvTechEntry@@IPAPAV1@@Z ; std::_Allocate<CvTechEntry *>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@PAVCvTechEntry@@@std@@YAPAPAVCvTechEntry@@IPAPAV1@@Z
_TEXT	SEGMENT
$T227556 = -12						; size = 12
$T227560 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVCvTechEntry@@@std@@YAPAPAVCvTechEntry@@IPAPAV1@@Z PROC ; std::_Allocate<CvTechEntry *>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T227560[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T227556[esp+16]
	mov	DWORD PTR $T227560[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T227556[esp+16]
	push	ecx
	mov	DWORD PTR $T227556[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate:
$LN8@Allocate:
	int	3
??$_Allocate@PAVCvTechEntry@@@std@@YAPAPAVCvTechEntry@@IPAPAV1@@Z ENDP ; std::_Allocate<CvTechEntry *>
_TEXT	ENDS
PUBLIC	??_GCvTechAI@@QAEPAXI@Z				; CvTechAI::`scalar deleting destructor'
EXTRN	??1CvTechAI@@QAE@XZ:PROC			; CvTechAI::~CvTechAI
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvTechAI@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvTechAI@@QAEPAXI@Z PROC				; CvTechAI::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvTechAI@@QAE@XZ			; CvTechAI::~CvTechAI
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@4
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@4:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvTechAI@@QAEPAXI@Z ENDP				; CvTechAI::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?getArray@?$ArrayWrapper@H@@QAEPAHXZ		; ArrayWrapper<int>::getArray
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ?getArray@?$ArrayWrapper@H@@QAEPAHXZ
_TEXT	SEGMENT
?getArray@?$ArrayWrapper@H@@QAEPAHXZ PROC		; ArrayWrapper<int>::getArray, COMDAT
; _this$ = ecx

; 382  : 		return m_values;

	mov	eax, DWORD PTR [ecx]

; 383  : 	}

	ret	0
?getArray@?$ArrayWrapper@H@@QAEPAHXZ ENDP		; ArrayWrapper<int>::getArray
_TEXT	ENDS
PUBLIC	?getArray@?$ArrayWrapper@H@@QBEPBHXZ		; ArrayWrapper<int>::getArray
; Function compile flags: /Ogtpy
;	COMDAT ?getArray@?$ArrayWrapper@H@@QBEPBHXZ
_TEXT	SEGMENT
?getArray@?$ArrayWrapper@H@@QBEPBHXZ PROC		; ArrayWrapper<int>::getArray, COMDAT
; _this$ = ecx

; 386  : 		return m_values;

	mov	eax, DWORD PTR [ecx]

; 387  : 	}

	ret	0
?getArray@?$ArrayWrapper@H@@QBEPBHXZ ENDP		; ArrayWrapper<int>::getArray
_TEXT	ENDS
PUBLIC	?getCount@?$ArrayWrapper@H@@QBEHXZ		; ArrayWrapper<int>::getCount
; Function compile flags: /Ogtpy
;	COMDAT ?getCount@?$ArrayWrapper@H@@QBEHXZ
_TEXT	SEGMENT
?getCount@?$ArrayWrapper@H@@QBEHXZ PROC			; ArrayWrapper<int>::getCount, COMDAT
; _this$ = ecx

; 391  : 		return m_count;

	mov	eax, DWORD PTR [ecx+4]

; 392  : 	}

	ret	0
?getCount@?$ArrayWrapper@H@@QBEHXZ ENDP			; ArrayWrapper<int>::getCount
_TEXT	ENDS
PUBLIC	?getArray@?$ArrayWrapper@_N@@QBEPB_NXZ		; ArrayWrapper<bool>::getArray
; Function compile flags: /Ogtpy
;	COMDAT ?getArray@?$ArrayWrapper@_N@@QBEPB_NXZ
_TEXT	SEGMENT
?getArray@?$ArrayWrapper@_N@@QBEPB_NXZ PROC		; ArrayWrapper<bool>::getArray, COMDAT
; _this$ = ecx

; 386  : 		return m_values;

	mov	eax, DWORD PTR [ecx]

; 387  : 	}

	ret	0
?getArray@?$ArrayWrapper@_N@@QBEPB_NXZ ENDP		; ArrayWrapper<bool>::getArray
_TEXT	ENDS
PUBLIC	?getCount@?$ArrayWrapper@_N@@QBEHXZ		; ArrayWrapper<bool>::getCount
; Function compile flags: /Ogtpy
;	COMDAT ?getCount@?$ArrayWrapper@_N@@QBEHXZ
_TEXT	SEGMENT
?getCount@?$ArrayWrapper@_N@@QBEHXZ PROC		; ArrayWrapper<bool>::getCount, COMDAT
; _this$ = ecx

; 391  : 		return m_count;

	mov	eax, DWORD PTR [ecx+4]

; 392  : 	}

	ret	0
?getCount@?$ArrayWrapper@_N@@QBEHXZ ENDP		; ArrayWrapper<bool>::getCount
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAPAVCvTechEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvTechEntry@@0@Z ; std::_Iter_random<CvTechEntry * *,CvTechEntry * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAPAVCvTechEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvTechEntry@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVCvTechEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvTechEntry@@0@Z PROC ; std::_Iter_random<CvTechEntry * *,CvTechEntry * *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAPAVCvTechEntry@@PAPAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVCvTechEntry@@0@Z ENDP ; std::_Iter_random<CvTechEntry * *,CvTechEntry * *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAPAVCvTechEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvTechEntry@@0@Z ; std::_Ptr_cat<CvTechEntry * *,CvTechEntry * *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAPAVCvTechEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvTechEntry@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVCvTechEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvTechEntry@@0@Z PROC ; std::_Ptr_cat<CvTechEntry * *,CvTechEntry * *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAPAVCvTechEntry@@PAPAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVCvTechEntry@@0@Z ENDP ; std::_Ptr_cat<CvTechEntry * *,CvTechEntry * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVCvTechEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvTechEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvTechEntry * *,CvTechEntry * *,std::random_access_iterator_tag>
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAPAVCvTechEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvTechEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVCvTechEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvTechEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvTechEntry * *,CvTechEntry * *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAPAVCvTechEntry@@PAPAV1@Urandom_access_iterator_tag@std@@@std@@YAPAPAVCvTechEntry@@PAPAV1@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvTechEntry * *,CvTechEntry * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvTechEntry@@@std@@@std@@YAXPAPAVCvTechEntry@@0AAV?$allocator@PAVCvTechEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvTechEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvTechEntry@@@std@@@std@@YAXPAPAVCvTechEntry@@0AAV?$allocator@PAVCvTechEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVCvTechEntry@@@std@@@std@@YAXPAPAVCvTechEntry@@0AAV?$allocator@PAVCvTechEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvTechEntry *> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvTechEntry@@@std@@@std@@YAXPAPAVCvTechEntry@@0AAV?$allocator@PAVCvTechEntry@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvTechEntry *> >
_TEXT	ENDS
PUBLIC	??M?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator<
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??M?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??M?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator<, COMDAT
; _this$ = ecx

; 221  : 
; 222  :  #if _HAS_ITERATOR_DEBUGGING
; 223  : 		_Compat(_Right);
; 224  :  #else
; 225  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 226  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 227  : 
; 228  : 		return (_Myptr < _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, DWORD PTR [ecx]
	sbb	eax, eax
	neg	eax

; 229  : 		}

	ret	4
??M?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator<
_TEXT	ENDS
PUBLIC	??0?$pair@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@V12@@std@@QAE@ABV?$_Vector_iterator@HV?$allocator@H@std@@@1@0@Z ; std::pair<std::_Vector_iterator<int,std::allocator<int> >,std::_Vector_iterator<int,std::allocator<int> > >::pair<std::_Vector_iterator<int,std::allocator<int> >,std::_Vector_iterator<int,std::allocator<int> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??0?$pair@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@V12@@std@@QAE@ABV?$_Vector_iterator@HV?$allocator@H@std@@@1@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@V12@@std@@QAE@ABV?$_Vector_iterator@HV?$allocator@H@std@@@1@0@Z PROC ; std::pair<std::_Vector_iterator<int,std::allocator<int> >,std::_Vector_iterator<int,std::allocator<int> > >::pair<std::_Vector_iterator<int,std::allocator<int> >,std::_Vector_iterator<int,std::allocator<int> > >, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	mov	eax, ecx
	mov	ecx, DWORD PTR __Val1$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	ret	8
??0?$pair@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@V12@@std@@QAE@ABV?$_Vector_iterator@HV?$allocator@H@std@@@1@0@Z ENDP ; std::pair<std::_Vector_iterator<int,std::allocator<int> >,std::_Vector_iterator<int,std::allocator<int> > >::pair<std::_Vector_iterator<int,std::allocator<int> >,std::_Vector_iterator<int,std::allocator<int> > >
_TEXT	ENDS
PUBLIC	??F?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<int,std::allocator<int> >::operator--
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??F?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator--, COMDAT
; _this$ = ecx

; 137  : 		{	// predecrement

	mov	eax, ecx

; 138  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 139  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr > ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 140  : 
; 141  :  #if _HAS_ITERATOR_DEBUGGING
; 142  : 		if (this->_Mycont == 0
; 143  : 			|| _Myptr == ((_Myvec *)this->_Mycont)->_Myfirst)
; 144  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 145  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 146  : 
; 147  : 		--_Myptr;

	add	DWORD PTR [eax], -4			; fffffffcH

; 148  : 		return (*this);
; 149  : 		}

	ret	0
??F?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator--
_TEXT	ENDS
PUBLIC	??$_Dist_type@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAPAHV?$_Vector_iterator@HV?$allocator@H@std@@@0@@Z ; std::_Dist_type<std::_Vector_iterator<int,std::allocator<int> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Dist_type@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAPAHV?$_Vector_iterator@HV?$allocator@H@std@@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Dist_type@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAPAHV?$_Vector_iterator@HV?$allocator@H@std@@@0@@Z PROC ; std::_Dist_type<std::_Vector_iterator<int,std::allocator<int> > >, COMDAT

; 1831 : 	return (0);

	xor	eax, eax

; 1832 : 	}

	ret	0
??$_Dist_type@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAPAHV?$_Vector_iterator@HV?$allocator@H@std@@@0@@Z ENDP ; std::_Dist_type<std::_Vector_iterator<int,std::allocator<int> > >
_TEXT	ENDS
PUBLIC	??$_Val_type@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAPAHV?$_Vector_iterator@HV?$allocator@H@std@@@0@@Z ; std::_Val_type<std::_Vector_iterator<int,std::allocator<int> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Val_type@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAPAHV?$_Vector_iterator@HV?$allocator@H@std@@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAPAHV?$_Vector_iterator@HV?$allocator@H@std@@@0@@Z PROC ; std::_Val_type<std::_Vector_iterator<int,std::allocator<int> > >, COMDAT

; 1766 : 	return (0);

	xor	eax, eax

; 1767 : 	}

	ret	0
??$_Val_type@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAPAHV?$_Vector_iterator@HV?$allocator@H@std@@@0@@Z ENDP ; std::_Val_type<std::_Vector_iterator<int,std::allocator<int> > >
_TEXT	ENDS
PUBLIC	??$swap@H@std@@YAXAAH0@Z			; std::swap<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$swap@H@std@@YAXAAH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@H@std@@YAXAAH0@Z PROC				; std::swap<int>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [eax]
	push	esi

; 21   : 
; 22   : 		_Left = _Right;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [ecx], edx
	pop	esi
$LN1@swap:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@H@std@@YAXAAH0@Z ENDP				; std::swap<int>
_TEXT	ENDS
PUBLIC	??$_Iter_random@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z ; std::_Iter_random<std::_Vector_iterator<int,std::allocator<int> >,std::_Vector_iterator<int,std::allocator<int> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z PROC ; std::_Iter_random<std::_Vector_iterator<int,std::allocator<int> >,std::_Vector_iterator<int,std::allocator<int> > >, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z ENDP ; std::_Iter_random<std::_Vector_iterator<int,std::allocator<int> >,std::_Vector_iterator<int,std::allocator<int> > >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z ; std::_Ptr_cat<std::_Vector_iterator<int,std::allocator<int> >,std::_Vector_iterator<int,std::allocator<int> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z PROC ; std::_Ptr_cat<std::_Vector_iterator<int,std::allocator<int> >,std::_Vector_iterator<int,std::allocator<int> > >, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z ENDP ; std::_Ptr_cat<std::_Vector_iterator<int,std::allocator<int> >,std::_Vector_iterator<int,std::allocator<int> > >
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+20]
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	add	edi, 12					; 0000000cH
	push	edi
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	??0CvString@@QAE@XZ				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??0CvString@@QAE@XZ
_TEXT	SEGMENT
??0CvString@@QAE@XZ PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 23   : 	CvString() {}

	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, esi
	pop	esi
	ret	0
??0CvString@@QAE@XZ ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??0CvString@@QAE@PBD@Z				; CvString::CvString
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvString@@QAE@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??0CvString@@QAE@PBD@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 25   : 	CvString(const char* s) : std::string(s ? s : "") {CvAssertMsg(s != NULL, "Passing NULL to std::string; possible heap corruption!");}

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	jne	SHORT $LN4@CvString
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN4@CvString:
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@PBD@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
; Function compile flags: /Ogtpy
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	??BCvString@@QBEPBDXZ				; CvString::operator char const *
; Function compile flags: /Ogtpy
;	COMDAT ??BCvString@@QBEPBDXZ
_TEXT	SEGMENT
??BCvString@@QBEPBDXZ PROC				; CvString::operator char const *, COMDAT
; _this$ = ecx

; 31   : 	operator const char*() const 	{ return c_str(); }												

	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
??BCvString@@QBEPBDXZ ENDP				; CvString::operator char const *
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@PBD@Z			; CvString::operator=
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@PBD@Z PROC				; CvString::operator=, COMDAT
; _this$ = ecx

; 37   : 	CvString& operator=( const char* s) { if (s) assign(s); else clear();	return *this; }	

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	je	SHORT $LN2@operator
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
$LN2@operator:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@PBD@Z ENDP				; CvString::operator=
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvString::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CvString::operator=, COMDAT
; _this$ = ecx

; 38   : 	CvString& operator=( const std::string& s) { assign(s.c_str());	return *this; }	

	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _s$[esp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CvString::operator=
_TEXT	ENDS
PUBLIC	?GetCString@CvString@@QBEPBDXZ			; CvString::GetCString
; Function compile flags: /Ogtpy
;	COMDAT ?GetCString@CvString@@QBEPBDXZ
_TEXT	SEGMENT
?GetCString@CvString@@QBEPBDXZ PROC			; CvString::GetCString, COMDAT
; _this$ = ecx

; 42   : 	const char* GetCString() const 	{ return c_str(); }

	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetCString@CvString@@QBEPBDXZ ENDP			; CvString::GetCString
_TEXT	ENDS
PUBLIC	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	__imp___vsnprintf:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z
_TEXT	SEGMENT
_buf$ = -2048						; size = 2048
_out$ = 8						; size = 4
_fmt$ = 12						; size = 4
_args$ = 16						; size = 4
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z PROC ; CvString::formatv, COMDAT

; 191  : {

	sub	esp, 2048				; 00000800H
	push	ebx
	push	ebp

; 192  : 	char buf[2048];
; 193  : 	char * pbuf = buf;

	mov	ebp, DWORD PTR _args$[esp+2052]
	push	esi
	push	edi
	lea	edi, DWORD PTR _buf$[esp+2064]
	mov	esi, 2047				; 000007ffH
	npad	6
$LL10@formatv:

; 194  : 	int len = 0;
; 195  : 	int attempts = 0;
; 196  : 	bool success = false;
; 197  : 	const int kMaxAttempts = 40;
; 198  : 
; 199  : 	do
; 200  : 	{
; 201  : 		int maxlen = 2047+2048*attempts;
; 202  : 		len = _vsnprintf(pbuf,maxlen,fmt,args);

	mov	eax, DWORD PTR _fmt$[esp+2060]
	push	ebp
	push	eax
	push	esi
	push	edi
	mov	ebx, esi
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H

; 203  : 		attempts++;

	add	esi, 2048				; 00000800H

; 204  : 		success = (len>=0 && len<=maxlen);

	test	eax, eax
	jl	SHORT $LN13@formatv
	cmp	eax, ebx
	jle	SHORT $LN18@formatv
$LN13@formatv:

; 205  : 		if (!success)
; 206  : 		{
; 207  : 			if (pbuf!=buf)

	lea	ecx, DWORD PTR _buf$[esp+2064]
	xor	bl, bl
	cmp	edi, ecx
	je	SHORT $LN6@formatv

; 208  : 				delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@formatv:

; 209  : 			pbuf = new char[2048+2048*attempts];

	lea	edx, DWORD PTR [esi+1]
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4

; 210  : 		}
; 211  : 	}
; 212  : 	while (!success && attempts<kMaxAttempts);

	cmp	esi, 83967				; 000147ffH
	mov	edi, eax
	jl	SHORT $LL10@formatv

; 222  : 		out = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN21@formatv:
	mov	ecx, DWORD PTR _out$[esp+2064]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 223  : 
; 224  : 	if (pbuf!=buf)

	lea	eax, DWORD PTR _buf$[esp+2064]
	cmp	edi, eax
	je	SHORT $LN20@formatv

; 225  : 		delete [] pbuf;

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN20@formatv:
	pop	edi
	pop	esi
	pop	ebp

; 226  : 
; 227  : 	return success;

	mov	al, bl
	pop	ebx

; 228  : }

	add	esp, 2048				; 00000800H
	ret	0
$LN18@formatv:

; 204  : 		success = (len>=0 && len<=maxlen);

	mov	bl, 1

; 213  : 
; 214  : 	if ( attempts==kMaxAttempts )
; 215  : 	{
; 216  : 		// dxPrintNL( "CvString::formatv - Max reallocs occurred while formatting string. Result is likely truncated!", 0 );
; 217  : 	}
; 218  : 
; 219  : 	if (success)
; 220  : 		out = pbuf;

	push	edi

; 221  : 	else

	jmp	SHORT $LN21@formatv
?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ENDP ; CvString::formatv
_TEXT	ENDS
PUBLIC	?Format@CvString@@QAAXPBDZZ			; CvString::Format
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Format@CvString@@QAAXPBDZZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0
__ehfuncinfo$?Format@CvString@@QAAXPBDZZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Format@CvString@@QAAXPBDZZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?Format@CvString@@QAAXPBDZZ
_TEXT	SEGMENT
_result$ = -40						; size = 28
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_lpszFormat$ = 12					; size = 4
?Format@CvString@@QAAXPBDZZ PROC			; CvString::Format, COMDAT

; 269  : {

	push	-1
	push	__ehhandler$?Format@CvString@@QAAXPBDZZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH

; 270  : 	std::string result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 271  : 	va_list args;
; 272  : 	va_start(args,lpszFormat);
; 273  : 	formatv(result,lpszFormat,args);

	mov	ecx, DWORD PTR _lpszFormat$[esp+36]
	lea	eax, DWORD PTR _lpszFormat$[esp+40]
	push	eax
	push	ecx
	lea	edx, DWORD PTR _result$[esp+48]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+60], 0
	call	?formatv@CvString@@SA_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBDPAD@Z ; CvString::formatv
	add	esp, 12					; 0000000cH

; 274  : 	va_end(args);
; 275  : 	*this = result;

	lea	ecx, DWORD PTR _result$[esp+40]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR _this$[esp+36]
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z

; 276  : }

	lea	ecx, DWORD PTR _result$[esp+40]
	mov	DWORD PTR __$EHRec$[esp+48], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Format@CvString@@QAAXPBDZZ$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Format@CvString@@QAAXPBDZZ:
	mov	eax, OFFSET __ehfuncinfo$?Format@CvString@@QAAXPBDZZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?Format@CvString@@QAAXPBDZZ ENDP			; CvString::Format
PUBLIC	??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ; CvLuaArgsHandle::operator->
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\lua\cvluaargshandle.h
;	COMDAT ??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ
_TEXT	SEGMENT
??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ PROC ; CvLuaArgsHandle::operator->, COMDAT
; _this$ = ecx

; 40   : 	return m_Ptr;

	mov	eax, DWORD PTR [ecx]

; 41   : }

	ret	0
??CCvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ENDP ; CvLuaArgsHandle::operator->
_TEXT	ENDS
PUBLIC	?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ; CvLuaArgsHandle::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ
_TEXT	SEGMENT
?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ PROC ; CvLuaArgsHandle::get, COMDAT
; _this$ = ecx

; 45   : 	return m_Ptr;

	mov	eax, DWORD PTR [ecx]

; 46   : }

	ret	0
?get@CvLuaArgsHandle@@QBEPAVICvEngineScriptSystemArgs1@@XZ ENDP ; CvLuaArgsHandle::get
_TEXT	ENDS
PUBLIC	?GetType@CvBaseInfo@@QBEPBDXZ			; CvBaseInfo::GetType
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfos.h
;	COMDAT ?GetType@CvBaseInfo@@QBEPBDXZ
_TEXT	SEGMENT
?GetType@CvBaseInfo@@QBEPBDXZ PROC			; CvBaseInfo::GetType, COMDAT
; _this$ = ecx

; 92   : 		return m_strType.c_str();

	add	ecx, 176				; 000000b0H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetType@CvBaseInfo@@QBEPBDXZ ENDP			; CvBaseInfo::GetType
_TEXT	ENDS
PUBLIC	?getMap@CvGlobals@@QAEAAVCvMap@@XZ		; CvGlobals::getMap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMap@CvGlobals@@QAEAAVCvMap@@XZ
_TEXT	SEGMENT
?getMap@CvGlobals@@QAEAAVCvMap@@XZ PROC			; CvGlobals::getMap, COMDAT
; _this$ = ecx

; 175  : 		return *m_map;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+52]

; 176  : 	}

	ret	0
?getMap@CvGlobals@@QAEAAVCvMap@@XZ ENDP			; CvGlobals::getMap
_TEXT	ENDS
PUBLIC	?getGame@CvGlobals@@QAEAAVCvGame@@XZ		; CvGlobals::getGame
; Function compile flags: /Ogtpy
;	COMDAT ?getGame@CvGlobals@@QAEAAVCvGame@@XZ
_TEXT	SEGMENT
?getGame@CvGlobals@@QAEAAVCvGame@@XZ PROC		; CvGlobals::getGame, COMDAT
; _this$ = ecx

; 183  : 		return *m_game;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+48]

; 184  : 	}

	ret	0
?getGame@CvGlobals@@QAEAAVCvGame@@XZ ENDP		; CvGlobals::getGame
_TEXT	ENDS
PUBLIC	?getNumFlavorTypes@CvGlobals@@QAEHXZ		; CvGlobals::getNumFlavorTypes
; Function compile flags: /Ogtpy
;	COMDAT ?getNumFlavorTypes@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNumFlavorTypes@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNumFlavorTypes, COMDAT
; _this$ = ecx

; 804  : 		return m_iNumFlavorTypes;

	mov	eax, DWORD PTR [ecx+1764]

; 805  : 	}

	ret	0
?getNumFlavorTypes@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNumFlavorTypes
_TEXT	ENDS
PUBLIC	?getFlavorTypes@CvGlobals@@QAEAAVCvString@@W4FlavorTypes@@@Z ; CvGlobals::getFlavorTypes
; Function compile flags: /Ogtpy
;	COMDAT ?getFlavorTypes@CvGlobals@@QAEAAVCvString@@W4FlavorTypes@@@Z
_TEXT	SEGMENT
_e$ = 8							; size = 4
?getFlavorTypes@CvGlobals@@QAEAAVCvString@@W4FlavorTypes@@@Z PROC ; CvGlobals::getFlavorTypes, COMDAT
; _this$ = ecx

; 812  : 		CvAssert(e > -1); /*CvAssert(e < GC.getNumFlavorTypes())*/;
; 813  : 		return m_paszFlavorTypes[e];

	mov	eax, DWORD PTR _e$[esp-4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx+1760]
	lea	eax, DWORD PTR [eax+edx*4]

; 814  : 	}

	ret	4
?getFlavorTypes@CvGlobals@@QAEAAVCvString@@W4FlavorTypes@@@Z ENDP ; CvGlobals::getFlavorTypes
_TEXT	ENDS
PUBLIC	?getTECH_WEIGHT_PROPAGATION_PERCENT@CvGlobals@@QAEHXZ ; CvGlobals::getTECH_WEIGHT_PROPAGATION_PERCENT
; Function compile flags: /Ogtpy
;	COMDAT ?getTECH_WEIGHT_PROPAGATION_PERCENT@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getTECH_WEIGHT_PROPAGATION_PERCENT@CvGlobals@@QAEHXZ PROC ; CvGlobals::getTECH_WEIGHT_PROPAGATION_PERCENT, COMDAT
; _this$ = ecx

; 901  : 		return m_iTECH_WEIGHT_PROPAGATION_PERCENT;

	mov	eax, DWORD PTR [ecx+1836]

; 902  : 	}

	ret	0
?getTECH_WEIGHT_PROPAGATION_PERCENT@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getTECH_WEIGHT_PROPAGATION_PERCENT
_TEXT	ENDS
PUBLIC	?getTECH_PRIORITY_UNIQUE_ITEM@CvGlobals@@QAEHXZ	; CvGlobals::getTECH_PRIORITY_UNIQUE_ITEM
; Function compile flags: /Ogtpy
;	COMDAT ?getTECH_PRIORITY_UNIQUE_ITEM@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getTECH_PRIORITY_UNIQUE_ITEM@CvGlobals@@QAEHXZ PROC	; CvGlobals::getTECH_PRIORITY_UNIQUE_ITEM, COMDAT
; _this$ = ecx

; 909  : 		return m_iTECH_PRIORITY_UNIQUE_ITEM;

	mov	eax, DWORD PTR [ecx+1844]

; 910  : 	}

	ret	0
?getTECH_PRIORITY_UNIQUE_ITEM@CvGlobals@@QAEHXZ ENDP	; CvGlobals::getTECH_PRIORITY_UNIQUE_ITEM
_TEXT	ENDS
PUBLIC	?getTECH_PRIORITY_MAYA_CALENDAR_BONUS@CvGlobals@@QAEHXZ ; CvGlobals::getTECH_PRIORITY_MAYA_CALENDAR_BONUS
; Function compile flags: /Ogtpy
;	COMDAT ?getTECH_PRIORITY_MAYA_CALENDAR_BONUS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getTECH_PRIORITY_MAYA_CALENDAR_BONUS@CvGlobals@@QAEHXZ PROC ; CvGlobals::getTECH_PRIORITY_MAYA_CALENDAR_BONUS, COMDAT
; _this$ = ecx

; 913  : 		return m_iTECH_PRIORITY_MAYA_CALENDAR_BONUS;

	mov	eax, DWORD PTR [ecx+1848]

; 914  : 	}

	ret	0
?getTECH_PRIORITY_MAYA_CALENDAR_BONUS@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getTECH_PRIORITY_MAYA_CALENDAR_BONUS
_TEXT	ENDS
PUBLIC	?getNUM_OR_TECH_PREREQS@CvGlobals@@QAEHXZ	; CvGlobals::getNUM_OR_TECH_PREREQS
; Function compile flags: /Ogtpy
;	COMDAT ?getNUM_OR_TECH_PREREQS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNUM_OR_TECH_PREREQS@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNUM_OR_TECH_PREREQS, COMDAT
; _this$ = ecx

; 5344 : 		return m_iNUM_OR_TECH_PREREQS;

	mov	eax, DWORD PTR [ecx+6268]

; 5345 : 	}

	ret	0
?getNUM_OR_TECH_PREREQS@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNUM_OR_TECH_PREREQS
_TEXT	ENDS
PUBLIC	?getNUM_AND_TECH_PREREQS@CvGlobals@@QAEHXZ	; CvGlobals::getNUM_AND_TECH_PREREQS
; Function compile flags: /Ogtpy
;	COMDAT ?getNUM_AND_TECH_PREREQS@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getNUM_AND_TECH_PREREQS@CvGlobals@@QAEHXZ PROC		; CvGlobals::getNUM_AND_TECH_PREREQS, COMDAT
; _this$ = ecx

; 5348 : 		return m_iNUM_AND_TECH_PREREQS;

	mov	eax, DWORD PTR [ecx+6272]

; 5349 : 	}

	ret	0
?getNUM_AND_TECH_PREREQS@CvGlobals@@QAEHXZ ENDP		; CvGlobals::getNUM_AND_TECH_PREREQS
_TEXT	ENDS
PUBLIC	?getTECH_COST_EXTRA_TEAM_MEMBER_MODIFIER@CvGlobals@@QAEHXZ ; CvGlobals::getTECH_COST_EXTRA_TEAM_MEMBER_MODIFIER
; Function compile flags: /Ogtpy
;	COMDAT ?getTECH_COST_EXTRA_TEAM_MEMBER_MODIFIER@CvGlobals@@QAEHXZ
_TEXT	SEGMENT
?getTECH_COST_EXTRA_TEAM_MEMBER_MODIFIER@CvGlobals@@QAEHXZ PROC ; CvGlobals::getTECH_COST_EXTRA_TEAM_MEMBER_MODIFIER, COMDAT
; _this$ = ecx

; 5752 : 		return m_iTECH_COST_EXTRA_TEAM_MEMBER_MODIFIER;

	mov	eax, DWORD PTR [ecx+6676]

; 5753 : 	}

	ret	0
?getTECH_COST_EXTRA_TEAM_MEMBER_MODIFIER@CvGlobals@@QAEHXZ ENDP ; CvGlobals::getTECH_COST_EXTRA_TEAM_MEMBER_MODIFIER
_TEXT	ENDS
PUBLIC	?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ; CvGlobals::getDLLIFace
; Function compile flags: /Ogtpy
;	COMDAT ?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ
_TEXT	SEGMENT
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ PROC ; CvGlobals::getDLLIFace, COMDAT
; _this$ = ecx

; 7738 : 		return m_pDLL;

	mov	eax, DWORD PTR [ecx+8596]

; 7739 : 	}

	ret	0
?getDLLIFace@CvGlobals@@QAEPAVICvEngineUtility4@@XZ ENDP ; CvGlobals::getDLLIFace
_TEXT	ENDS
PUBLIC	?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ ; CvGlobals::GetEngineUserInterface
; Function compile flags: /Ogtpy
;	COMDAT ?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ
_TEXT	SEGMENT
?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ PROC ; CvGlobals::GetEngineUserInterface, COMDAT
; _this$ = ecx

; 7748 : 		return m_pEngineUI;

	mov	eax, DWORD PTR [ecx+8600]

; 7749 : 	}

	ret	0
?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ ENDP ; CvGlobals::GetEngineUserInterface
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV0@@Z			; CvString::operator=
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4CvString@@QAEAAV0@ABV0@@Z PROC			; CvString::operator=, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV0@@Z ENDP			; CvString::operator=
_TEXT	ENDS
PUBLIC	?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z	; CvPlayerAI::getPlayer
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
;	COMDAT ?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z PROC	; CvPlayerAI::getPlayer, COMDAT

; 28   : 		CvAssertMsg(ePlayer != NO_PLAYER, "Player is not assigned a valid value");
; 29   : 		CvAssertMsg(ePlayer < MAX_PLAYERS, "Player is not assigned a valid value");
; 30   : 		return m_aPlayers[ePlayer];

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 31   : 	}

	ret	0
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z ENDP	; CvPlayerAI::getPlayer
_TEXT	ENDS
PUBLIC	?getX@CvPlot@@QBEHXZ				; CvPlot::getX
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?getX@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getX@CvPlot@@QBEHXZ PROC				; CvPlot::getX, COMDAT
; _this$ = ecx

; 307  : 		return m_iX;

	movsx	eax, WORD PTR [ecx]

; 308  : 	}

	ret	0
?getX@CvPlot@@QBEHXZ ENDP				; CvPlot::getX
_TEXT	ENDS
PUBLIC	?getY@CvPlot@@QBEHXZ				; CvPlot::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getY@CvPlot@@QBEHXZ PROC				; CvPlot::getY, COMDAT
; _this$ = ecx

; 312  : 		return m_iY;

	movsx	eax, WORD PTR [ecx+2]

; 313  : 	}

	ret	0
?getY@CvPlot@@QBEHXZ ENDP				; CvPlot::getY
_TEXT	ENDS
PUBLIC	?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ	; CvPlot::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlot::getOwner, COMDAT
; _this$ = ecx

; 387  : 		return (PlayerTypes)m_eOwner;

	movsx	eax, BYTE PTR [ecx+4]

; 388  : 	}

	ret	0
?getOwner@CvPlot@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlot::getOwner
_TEXT	ENDS
PUBLIC	?isWater@CvPlot@@QBE_NXZ			; CvPlot::isWater
; Function compile flags: /Ogtpy
;	COMDAT ?isWater@CvPlot@@QBE_NXZ
_TEXT	SEGMENT
?isWater@CvPlot@@QBE_NXZ PROC				; CvPlot::isWater, COMDAT
; _this$ = ecx

; 409  : 		return (PlotTypes)m_ePlotType == PLOT_OCEAN;

	xor	eax, eax
	cmp	BYTE PTR [ecx+5], 3
	sete	al

; 410  : 	};

	ret	0
?isWater@CvPlot@@QBE_NXZ ENDP				; CvPlot::isWater
_TEXT	ENDS
PUBLIC	?getGridWidth@CvMap@@QBEHXZ			; CvMap::getGridWidth
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?getGridWidth@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridWidth@CvMap@@QBEHXZ PROC			; CvMap::getGridWidth, COMDAT
; _this$ = ecx

; 198  : 		return m_iGridWidth;

	mov	eax, DWORD PTR [ecx+4020]

; 199  : 	}

	ret	0
?getGridWidth@CvMap@@QBEHXZ ENDP			; CvMap::getGridWidth
_TEXT	ENDS
PUBLIC	?getGridHeight@CvMap@@QBEHXZ			; CvMap::getGridHeight
; Function compile flags: /Ogtpy
;	COMDAT ?getGridHeight@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridHeight@CvMap@@QBEHXZ PROC			; CvMap::getGridHeight, COMDAT
; _this$ = ecx

; 206  : 		return m_iGridHeight;

	mov	eax, DWORD PTR [ecx+4024]

; 207  : 	}

	ret	0
?getGridHeight@CvMap@@QBEHXZ ENDP			; CvMap::getGridHeight
_TEXT	ENDS
PUBLIC	?isWrapX@CvMap@@QBE_NXZ				; CvMap::isWrapX
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapX@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapX@CvMap@@QBE_NXZ PROC				; CvMap::isWrapX, COMDAT
; _this$ = ecx

; 228  : 		return m_bWrapX;

	mov	al, BYTE PTR [ecx+4056]

; 229  : 	}

	ret	0
?isWrapX@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapX
_TEXT	ENDS
PUBLIC	?isWrapY@CvMap@@QBE_NXZ				; CvMap::isWrapY
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapY@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapY@CvMap@@QBE_NXZ PROC				; CvMap::isWrapY, COMDAT
; _this$ = ecx

; 233  : 		return m_bWrapY;

	mov	al, BYTE PTR [ecx+4057]

; 234  : 	}

	ret	0
?isWrapY@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapY
_TEXT	ENDS
PUBLIC	?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z		; CvTeam::getTeam
EXTRN	?m_aTeams@CvTeam@@1PAV1@A:DWORD			; CvTeam::m_aTeams
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvteam.h
;	COMDAT ?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z
_TEXT	SEGMENT
_eTeam$ = 8						; size = 4
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z PROC		; CvTeam::getTeam, COMDAT

; 29   : 		CvAssertMsg(eTeam != NO_TEAM, "eTeam is not assigned a valid value");
; 30   : 		CvAssertMsg(eTeam < MAX_TEAMS, "eTeam is not assigned a valid value");
; 31   : 		return m_aTeams[eTeam];

	mov	eax, DWORD PTR _eTeam$[esp-4]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams

; 32   : 	}

	ret	0
?getTeam@CvTeam@@SAAAV1@W4TeamTypes@@@Z ENDP		; CvTeam::getTeam
_TEXT	ENDS
PUBLIC	?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z ; CvDatabaseUtility::InitializeArray
EXTRN	_memset:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvdatabaseutility.h
;	COMDAT ?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z
_TEXT	SEGMENT
_pArray$ = 8						; size = 4
_count$ = 12						; size = 4
_iDefault$ = 16						; size = 4
?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z PROC	; CvDatabaseUtility::InitializeArray, COMDAT
; _this$ = ecx

; 120  : {

	push	esi

; 121  : 	CvAssertMsg(count > 0, "Initializing array to 0 or less items.");
; 122  : #ifdef AUI_WARNING_FIXES
; 123  : 	delete[] pArray;
; 124  : #endif
; 125  : 	pArray = FNEW(int[count], c_eCiv5GameplayDLL, 0);

	mov	esi, DWORD PTR _count$[esp]
	xor	ecx, ecx
	mov	eax, esi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 126  : 	if(iDefault == 0)

	mov	edx, DWORD PTR _iDefault$[esp+4]
	mov	ecx, DWORD PTR _pArray$[esp+4]
	add	esp, 4
	mov	DWORD PTR [ecx], eax
	test	edx, edx
	jne	SHORT $LN5@Initialize

; 127  : 	{
; 128  : 		ZeroMemory(pArray, sizeof(int) * count);

	lea	ecx, DWORD PTR [esi*4]
	push	ecx
	push	edx
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
	pop	esi

; 134  : 	}
; 135  : }

	ret	12					; 0000000cH
$LN5@Initialize:

; 129  : 	}
; 130  : 	else
; 131  : 	{
; 132  : 		for(size_t i = 0; i < count; ++i)

	xor	eax, eax
	test	esi, esi
	jbe	SHORT $LN1@Initialize
	push	edi
	npad	5
$LL3@Initialize:

; 133  : 			pArray[i] = iDefault;

	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [edi+eax*4], edx
	inc	eax
	cmp	eax, esi
	jb	SHORT $LL3@Initialize
	pop	edi
$LN1@Initialize:
	pop	esi

; 134  : 	}
; 135  : }

	ret	12					; 0000000cH
?InitializeArray@CvDatabaseUtility@@QAEXAAPAHIH@Z ENDP	; CvDatabaseUtility::InitializeArray
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@ABV0@@Z			; CvString::CvString
; Function compile flags: /Ogtpy
;	COMDAT ??0CvString@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0CvString@@QAE@ABV0@@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@ABV0@@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC	; std::vector<int,std::allocator<int> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP	; std::vector<int,std::allocator<int> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z PROC ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ENDP ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::~_Container_base_aux_alloc_empty<std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::~_Container_base_aux_alloc_empty<std::allocator<int> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::~_Container_base_aux_alloc_empty<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$allocator@H@std@@QAE@XZ			; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@H@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@H@std@@QAE@XZ PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@H@std@@QAE@XZ ENDP			; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T227797 = -80						; size = 28
$T227796 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ PROC	; std::vector<int,std::allocator<int> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T227797[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T227796[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T227797[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T227796[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T227796[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T227796[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T227796[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@2:
$LN12@Xlen@2:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T227797[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T227796[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ENDP	; std::vector<int,std::allocator<int> >::_Xlen
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::_Container_base_aux_alloc_empty<std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::_Container_base_aux_alloc_empty<std::allocator<int> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::_Container_base_aux_alloc_empty<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$allocator@H@std@@QAE@ABV01@@Z		; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@H@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@H@std@@QAE@ABV01@@Z PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@H@std@@QAE@ABV01@@Z ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@H@std@@QAEXPAHI@Z	; std::allocator<int>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXPAHI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@H@std@@QAEXPAHI@Z PROC		; std::allocator<int>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@H@std@@QAEXPAHI@Z ENDP		; std::allocator<int>::deallocate
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@H@std@@QBEIXZ		; std::allocator<int>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@H@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@H@std@@QBEIXZ PROC		; std::allocator<int>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@H@std@@QBEIXZ ENDP		; std::allocator<int>::max_size
_TEXT	ENDS
PUBLIC	??$?6H@FDataStream@@QAEAAV0@ABH@Z		; FDataStream::operator<<<int>
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6H@FDataStream@@QAEAAV0@ABH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6H@FDataStream@@QAEAAV0@ABH@Z PROC			; FDataStream::operator<<<int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6H@FDataStream@@QAEAAV0@ABH@Z ENDP			; FDataStream::operator<<<int>
_TEXT	ENDS
PUBLIC	??$?5H@FDataStream@@QAEAAV0@AAH@Z		; FDataStream::operator>><int>
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5H@FDataStream@@QAEAAV0@AAH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5H@FDataStream@@QAEAAV0@AAH@Z PROC			; FDataStream::operator>><int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5H@FDataStream@@QAEAAV0@AAH@Z ENDP			; FDataStream::operator>><int>
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvCity@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvCity>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ		; FAutoVariable<int,CvCity>::operator int const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ
_TEXT	SEGMENT
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ PROC		; FAutoVariable<int,CvCity>::operator int const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@HVCvCity@@@@QBEABHXZ ENDP		; FAutoVariable<int,CvCity>::operator int const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ	; FAutoVariable<bool,CvPlayer>::operator bool const &
; Function compile flags: /Ogtpy
;	COMDAT ??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ
_TEXT	SEGMENT
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ PROC	; FAutoVariable<bool,CvPlayer>::operator bool const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@_NVCvPlayer@@@@QBEAB_NXZ ENDP	; FAutoVariable<bool,CvPlayer>::operator bool const &
_TEXT	ENDS
PUBLIC	??$_Allocate@H@std@@YAPAHIPAH@Z			; std::_Allocate<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Allocate@H@std@@YAPAHIPAH@Z
_TEXT	SEGMENT
$T227853 = -12						; size = 12
$T227857 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@H@std@@YAPAHIPAH@Z PROC			; std::_Allocate<int>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T227857[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T227853[esp+16]
	mov	DWORD PTR $T227857[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T227853[esp+16]
	push	ecx
	mov	DWORD PTR $T227853[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@2:
$LN8@Allocate@2:
	int	3
??$_Allocate@H@std@@YAPAHIPAH@Z ENDP			; std::_Allocate<int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator==
_TEXT	ENDS
PUBLIC	??$?5_N@FDataStream@@QAEAAV0@AA_N@Z		; FDataStream::operator>><bool>
EXTRN	?Read@FDataStream@@IAEXAA_N@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5_N@FDataStream@@QAEAAV0@AA_N@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5_N@FDataStream@@QAEAAV0@AA_N@Z PROC		; FDataStream::operator>><bool>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5_N@FDataStream@@QAEAAV0@AA_N@Z ENDP		; FDataStream::operator>><bool>
_TEXT	ENDS
PUBLIC	??$?6_N@FDataStream@@QAEAAV0@AB_N@Z		; FDataStream::operator<<<bool>
EXTRN	?Write@FDataStream@@IAEXAB_N@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6_N@FDataStream@@QAEAAV0@AB_N@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6_N@FDataStream@@QAEAAV0@AB_N@Z PROC		; FDataStream::operator<<<bool>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6_N@FDataStream@@QAEAAV0@AB_N@Z ENDP		; FDataStream::operator<<<bool>
_TEXT	ENDS
PUBLIC	??$?5I@FDataStream@@QAEAAV0@AAI@Z		; FDataStream::operator>><unsigned int>
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5I@FDataStream@@QAEAAV0@AAI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5I@FDataStream@@QAEAAV0@AAI@Z PROC			; FDataStream::operator>><unsigned int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5I@FDataStream@@QAEAAV0@AAI@Z ENDP			; FDataStream::operator>><unsigned int>
_TEXT	ENDS
PUBLIC	??$?6I@FDataStream@@QAEAAV0@ABI@Z		; FDataStream::operator<<<unsigned int>
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6I@FDataStream@@QAEAAV0@ABI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6I@FDataStream@@QAEAAV0@ABI@Z PROC			; FDataStream::operator<<<unsigned int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6I@FDataStream@@QAEAAV0@ABI@Z ENDP			; FDataStream::operator<<<unsigned int>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z ; std::_Ptr_cat<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z PROC ; std::_Ptr_cat<int *,int *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z ENDP ; std::_Ptr_cat<int *,int *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ ; std::_Vector_const_iterator<int,std::allocator<int> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<int,std::allocator<int> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 4

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator++
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z ; std::_Iter_random<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z PROC ; std::_Iter_random<int *,int *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z ENDP ; std::_Iter_random<int *,int *>
_TEXT	ENDS
PUBLIC	?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::capacity
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=
_TEXT	ENDS
PUBLIC	??$_Fill@PAHH@std@@YAXPAH0ABH@Z			; std::_Fill<int *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill@PAHH@std@@YAXPAH0ABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAHH@std@@YAXPAH0ABH@Z PROC			; std::_Fill<int *,int>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@Fill
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL3@Fill
	pop	esi
$LN1@Fill:

; 3160 : 	}

	ret	0
??$_Fill@PAHH@std@@YAXPAH0ABH@Z ENDP			; std::_Fill<int *,int>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z ; std::_Move_cat<int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z PROC ; std::_Move_cat<int *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z ENDP ; std::_Move_cat<int *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>, COMDAT

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi

; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;

	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx

; 2711 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_backw

; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_backw:

; 2713 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2714 : 	}

	ret	0
??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z ; std::_Iter_cat<int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z PROC ; std::_Iter_cat<int *>, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z ENDP ; std::_Iter_cat<int *>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<int *,unsigned int,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<int *,unsigned int,int>, COMDAT

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	mov	eax, DWORD PTR __Count$[esp-4]
	test	eax, eax
	jbe	SHORT $LN1@Fill_n
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
$LL3@Fill_n:

; 3198 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL3@Fill_n
	pop	esi
$LN1@Fill_n:

; 3199 : 	}

	ret	0
??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<int *,unsigned int,int>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<int *,int *,std::allocator<int> >, COMDAT

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 150  : 	if (_Count > 0)

	test	eax, eax
	jbe	SHORT $LN4@Uninit_cop

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Uninit_cop:
	pop	edi

; 152  : 	return (_Result);

	mov	eax, esi
	pop	esi

; 153  : 	}

	ret	0
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?dxWrap@@YAHH@Z					; dxWrap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?dxWrap@@YAHH@Z
_TEXT	SEGMENT
_iDX$ = 8						; size = 4
?dxWrap@@YAHH@Z PROC					; dxWrap, COMDAT

; 74   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

	mov	edx, DWORD PTR [eax+4020]
	cmp	BYTE PTR [eax+4056], 0
	mov	eax, DWORD PTR _iDX$[esp-4]
	je	SHORT $LN13@dxWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dxWrap
	sub	eax, edx

; 76   : }

	ret	0

; 75   : 	return wrapCoordDifference(iDX, kMap.getGridWidth(), kMap.isWrapX());

$LN11@dxWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dxWrap
	add	eax, edx
$LN13@dxWrap:

; 76   : }

	ret	0
?dxWrap@@YAHH@Z ENDP					; dxWrap
_TEXT	ENDS
PUBLIC	?dyWrap@@YAHH@Z					; dyWrap
; Function compile flags: /Ogtpy
;	COMDAT ?dyWrap@@YAHH@Z
_TEXT	SEGMENT
_iDY$ = 8						; size = 4
?dyWrap@@YAHH@Z PROC					; dyWrap, COMDAT

; 80   : 	const CvMap& kMap = GC.getMap();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

	mov	edx, DWORD PTR [eax+4024]
	cmp	BYTE PTR [eax+4057], 0
	mov	eax, DWORD PTR _iDY$[esp-4]
	je	SHORT $LN13@dyWrap
	mov	ecx, edx
	shr	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN11@dyWrap
	sub	eax, edx

; 82   : }

	ret	0

; 81   : 	return wrapCoordDifference(iDY, kMap.getGridHeight(), kMap.isWrapY());

$LN11@dyWrap:
	neg	ecx
	cmp	eax, ecx
	jge	SHORT $LN13@dyWrap
	add	eax, edx
$LN13@dyWrap:

; 82   : }

	ret	0
?dyWrap@@YAHH@Z ENDP					; dyWrap
_TEXT	ENDS
PUBLIC	?plotDistance@@YAHHHHH@Z			; plotDistance
; Function compile flags: /Ogtpy
;	COMDAT ?plotDistance@@YAHHHHH@Z
_TEXT	SEGMENT
_iDY$ = -12						; size = 4
tv320 = -8						; size = 4
tv357 = -4						; size = 4
_iX1$ = 8						; size = 4
_iDX$ = 12						; size = 4
_iY1$ = 12						; size = 4
$T228036 = 16						; size = 4
_iX2$ = 16						; size = 4
_iY2$ = 20						; size = 4
?plotDistance@@YAHHHHH@Z PROC				; plotDistance, COMDAT

; 144  : {

	sub	esp, 12					; 0000000cH

; 145  : 	int iDX;
; 146  : 	int iWrappedDX = dxWrap(iX2 - iX1);

	mov	ecx, DWORD PTR _iX2$[esp+8]
	sub	ecx, DWORD PTR _iX1$[esp+8]
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	cmp	BYTE PTR [edi+4056], 0
	mov	edx, DWORD PTR [edi+4020]
	mov	DWORD PTR tv320[esp+28], ecx
	je	SHORT $LN18@plotDistan
	mov	eax, edx
	shr	eax, 1
	cmp	ecx, eax
	jle	SHORT $LN20@plotDistan
	sub	ecx, edx
	jmp	SHORT $LN18@plotDistan
$LN20@plotDistan:
	neg	eax
	cmp	ecx, eax
	jge	SHORT $LN18@plotDistan
	add	ecx, edx
$LN18@plotDistan:

; 147  : 	int iWrappedDY = dyWrap(iY2 - iY1);

	mov	ebp, DWORD PTR _iY2$[esp+24]
	sub	ebp, DWORD PTR _iY1$[esp+24]
	cmp	BYTE PTR [edi+4057], 0
	mov	eax, DWORD PTR [edi+4024]
	je	SHORT $LN32@plotDistan
	mov	edx, eax
	shr	edx, 1
	cmp	ebp, edx
	jle	SHORT $LN34@plotDistan
	mov	ebx, ebp
	sub	ebx, eax
	mov	DWORD PTR $T228036[esp+24], ebx
	jmp	SHORT $LN36@plotDistan
$LN34@plotDistan:
	neg	edx
	cmp	ebp, edx
	jge	SHORT $LN32@plotDistan
	lea	ebx, DWORD PTR [eax+ebp]
	mov	DWORD PTR $T228036[esp+24], ebx
	jmp	SHORT $LN36@plotDistan
$LN32@plotDistan:
	mov	ebx, ebp
	mov	DWORD PTR $T228036[esp+24], ebp
$LN36@plotDistan:

; 148  : 	int iDY = abs(iWrappedDY);

	mov	eax, ebx
	cdq
	mov	esi, eax
	xor	esi, edx
	sub	esi, edx

; 149  : 
; 150  : #ifdef GAMECOREUTILS_FIX_PLOT_DISTANCE
; 151  : 	const CvMap& kMap = GC.getMap();
; 152  : 	// equidistant column joint fix (on X-wrapped maps):
; 153  : 	if ((kMap.isWrapX()) && (abs(iWrappedDX * 2) == kMap.getGridWidth()) && (iDY % 2 != 0) && ((iY1 % 2 == 0) == (iWrappedDX > (kMap.getGridWidth() >> 2))))

	cmp	BYTE PTR [edi+4056], 0
	mov	DWORD PTR _iDY$[esp+28], esi
	je	$LN77@plotDistan
	lea	eax, DWORD PTR [ecx+ecx]
	cdq
	mov	ebx, eax
	mov	eax, DWORD PTR [edi+4020]
	xor	ebx, edx
	sub	ebx, edx
	cmp	ebx, eax
	jne	SHORT $LN73@plotDistan
	mov	edx, esi
	and	edx, -2147483647			; 80000001H
	jns	SHORT $LN79@plotDistan
	dec	edx
	or	edx, -2					; fffffffeH
	inc	edx
$LN79@plotDistan:
	je	SHORT $LN73@plotDistan
	sar	eax, 2
	xor	edx, edx
	cmp	ecx, eax
	mov	eax, DWORD PTR _iY1$[esp+24]
	setg	dl
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN80@plotDistan
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN80@plotDistan:

; 154  : 	{
; 155  : 		iWrappedDX *= -1;  // change polarity

	mov	ebx, DWORD PTR $T228036[esp+24]
	neg	eax
	sbb	eax, eax
	inc	eax
	cmp	eax, edx
	jne	SHORT $LN5@plotDistan
	neg	ecx
	jmp	SHORT $LN5@plotDistan
$LN73@plotDistan:
	mov	ebx, DWORD PTR $T228036[esp+24]
$LN5@plotDistan:

; 156  : 	}
; 157  : 	if ((kMap.isWrapX()) && (abs(iWrappedDX * 2) == kMap.getGridWidth()) && (abs(iWrappedDY) < abs(iY2 - iY1)) && (iDY % 2 == 0) && (iX2 - iX1 < 0))

	cmp	BYTE PTR [edi+4056], 0
	je	$LN77@plotDistan
	lea	eax, DWORD PTR [ecx+ecx]
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	eax, DWORD PTR [edi+4020]
	jne	SHORT $LN75@plotDistan
	mov	eax, ebp
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	esi, eax
	jge	SHORT $LN75@plotDistan
	mov	edx, DWORD PTR _iDY$[esp+28]
	and	edx, -2147483647			; 80000001H
	jns	SHORT $LN81@plotDistan
	dec	edx
	or	edx, -2					; fffffffeH
	inc	edx
$LN81@plotDistan:
	jne	SHORT $LN75@plotDistan
	cmp	DWORD PTR tv320[esp+28], 0
	jge	SHORT $LN75@plotDistan

; 158  : 	{
; 159  : 		iWrappedDX *= -1;  // change polarity

	neg	ecx
$LN75@plotDistan:

; 160  : 	}
; 161  : 	// special case when map is toroidal AND map height is odd
; 162  : 	// TODO works but ugly
; 163  : 	if ((kMap.isWrapX()) && (kMap.getGridHeight() % 2 != 0) && (iY1 % 2 == kMap.getGridWidth() % 2) && (iY2 % 2 == 0) &&
; 164  : 		(abs(iWrappedDY) < abs(iY2 - iY1)) && (abs(iX2 - iX1) == kMap.getGridWidth() / 2 + ((kMap.getGridWidth() % 2 == 1) && (iX2 - iX1 > 0)) ? 1 : 0))

	cmp	BYTE PTR [edi+4056], 0
	je	$LN77@plotDistan
	mov	eax, DWORD PTR [edi+4024]
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN82@plotDistan
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN82@plotDistan:
	je	$LN77@plotDistan
	mov	edi, DWORD PTR [edi+4020]
	mov	DWORD PTR tv357[esp+28], edi
	and	edi, -2147483647			; 80000001H
	jns	SHORT $LN83@plotDistan
	dec	edi
	or	edi, -2					; fffffffeH
	inc	edi
$LN83@plotDistan:
	mov	edx, DWORD PTR _iY1$[esp+24]
	and	edx, -2147483647			; 80000001H
	jns	SHORT $LN84@plotDistan
	dec	edx
	or	edx, -2					; fffffffeH
	inc	edx
$LN84@plotDistan:
	cmp	edx, edi
	jne	SHORT $LN77@plotDistan
	mov	eax, DWORD PTR _iY2$[esp+24]
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN85@plotDistan
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN85@plotDistan:
	jne	SHORT $LN77@plotDistan
	mov	eax, ebp
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	esi, eax
	jge	SHORT $LN77@plotDistan
	cmp	edi, 1
	jne	SHORT $LN76@plotDistan
	cmp	DWORD PTR tv320[esp+28], 0
	jle	SHORT $LN76@plotDistan
	mov	esi, edi
	jmp	SHORT $LN9@plotDistan
$LN76@plotDistan:
	xor	esi, esi
$LN9@plotDistan:
	mov	eax, DWORD PTR tv320[esp+28]
	cdq
	mov	edi, eax
	mov	eax, DWORD PTR tv357[esp+28]
	xor	edi, edx
	sub	edi, edx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, esi
	cmp	edi, eax
	jne	SHORT $LN77@plotDistan

; 165  : 	{
; 166  : 		iWrappedDX -= (iWrappedDX > 0) - (iWrappedDX < 0);  // decrease regardless of polarity

	xor	edx, edx
	test	ecx, ecx
	setl	dl
	xor	eax, eax
	test	ecx, ecx
	setg	al
	sub	edx, eax
	add	ecx, edx
$LN77@plotDistan:

; 167  : 	}
; 168  : #endif
; 169  : 
; 170  : 	// convert to hex-space coordinates - the coordinate system axes are E and NE (not orthogonal)
; 171  : 	int iHX1 = xToHexspaceX(iX1, iY1);

	mov	eax, DWORD PTR _iY1$[esp+24]
	test	eax, eax
	jge	SHORT $LN88@plotDistan
	dec	eax
	cdq
	sub	eax, edx
$LN88@plotDistan:
	mov	edi, DWORD PTR _iX1$[esp+24]

; 172  : 	int iHX2 = xToHexspaceX(iX1 + iWrappedDX, iY1 + iWrappedDY);

	mov	edx, DWORD PTR _iY1$[esp+24]
	sar	eax, 1
	mov	esi, edi
	sub	esi, eax
	lea	eax, DWORD PTR [ebx+edx]
	test	eax, eax
	jge	SHORT $LN89@plotDistan
	dec	eax
	cdq
	sub	eax, edx
$LN89@plotDistan:
	sar	eax, 1
	sub	ecx, eax
	add	ecx, edi

; 173  : 
; 174  : #ifdef GAMECOREUTILS_FIX_PLOT_DISTANCE
; 175  : 	// obvious bug
; 176  : 	iDX = abs(iHX2 - iHX1);

	sub	ecx, esi
	mov	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx

; 177  : #else
; 178  : 	iDX = abs(dxWrap(iHX2 - iHX1));
; 179  : #endif
; 180  : 
; 181  : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 182  : 	if (((iHX2 - iHX1) ^ (iWrappedDY)) >= 0)  // the signs match
; 183  : #else
; 184  : 	if((iHX2 - iHX1 >= 0) == (iWrappedDY >= 0))  // the signs match

	xor	edx, edx
	test	ecx, ecx
	setge	dl
	xor	ecx, ecx
	test	ebx, ebx
	setge	cl
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR _iDX$[esp+12], eax
	pop	ebx
	cmp	edx, ecx
	jne	SHORT $LN2@plotDistan

; 185  : #endif
; 186  : 	{
; 187  : 		return iDX + iDY;

	mov	edx, DWORD PTR _iDY$[esp+12]
	add	eax, edx

; 195  : #endif
; 196  : 	}
; 197  : }

	add	esp, 12					; 0000000cH
	ret	0
$LN2@plotDistan:

; 188  : 	}
; 189  : 	else
; 190  : 	{
; 191  : #ifdef NQM_FAST_COMP
; 192  : 		return (MAX(iDX, iDY));
; 193  : #else
; 194  : 		return (std::max(iDX, iDY));

	cmp	eax, DWORD PTR _iDY$[esp+12]
	lea	eax, DWORD PTR _iDY$[esp+12]
	jl	SHORT $LN71@plotDistan
	lea	eax, DWORD PTR _iDX$[esp+8]
$LN71@plotDistan:
	mov	eax, DWORD PTR [eax]

; 195  : #endif
; 196  : 	}
; 197  : }

	add	esp, 12					; 0000000cH
	ret	0
?plotDistance@@YAHHHHH@Z ENDP				; plotDistance
_TEXT	ENDS
PUBLIC	?GetLocalizedText@@YA?AVCvString@@PBD@Z		; GetLocalizedText
EXTRN	__imp_??1String@Localization@@UAE@XZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z:PROC
EXTRN	__imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z:PROC
EXTRN	__imp_?Lookup@Localization@@YA?AVString@1@PBD@Z:PROC
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?GetLocalizedText@@YA?AVCvString@@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$0
__ehfuncinfo$?GetLocalizedText@@YA?AVCvString@@PBD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
xdata$x	ENDS
;	COMDAT ?GetLocalizedText@@YA?AVCvString@@PBD@Z
_TEXT	SEGMENT
_bytes$ = -100						; size = 4
$T228143 = -96						; size = 4
_text$ = -92						; size = 80
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_szString$ = 12						; size = 4
?GetLocalizedText@@YA?AVCvString@@PBD@Z PROC		; GetLocalizedText, COMDAT

; 514  : {

	push	-1
	push	__ehhandler$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H

; 515  : 	Localization::String text = Localization::Lookup(szString);

	mov	eax, DWORD PTR _szString$[esp+96]
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	ecx, DWORD PTR _text$[esp+116]
	xor	ebx, ebx
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	mov	DWORD PTR $T228143[esp+120], ebx
	call	DWORD PTR __imp_?Lookup@Localization@@YA?AVString@1@PBD@Z
	add	esp, 8

; 516  : 
; 517  : 	size_t bytes = 0;
; 518  : 	const char* szComposedString = text.toUTF8(bytes);

	push	1
	lea	edx, DWORD PTR _bytes$[esp+116]
	push	edx
	lea	ecx, DWORD PTR _text$[esp+120]
	mov	DWORD PTR __$EHRec$[esp+128], 1
	mov	DWORD PTR _bytes$[esp+120], ebx
	call	DWORD PTR __imp_?toUTF8@String@Localization@@QAEPBDAAIH@Z

; 519  : 	CvString str;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+108]
	mov	ecx, esi
	mov	edi, eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 520  : 	str.assign(szComposedString, bytes);
; 521  : 	return str;

	mov	eax, DWORD PTR _bytes$[esp+112]
	push	eax
	push	edi
	mov	ecx, esi
	mov	DWORD PTR $T228143[esp+120], 1
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
	lea	ecx, DWORD PTR _text$[esp+112]
	mov	BYTE PTR __$EHRec$[esp+120], bl
	call	DWORD PTR __imp_??1String@Localization@@UAE@XZ

; 522  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+112]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 100				; 00000064H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$0:
	lea	ecx, DWORD PTR _text$[ebp]
	jmp	DWORD PTR __imp_??1String@Localization@@UAE@XZ
__unwindfunclet$?GetLocalizedText@@YA?AVCvString@@PBD@Z$1:
	mov	eax, DWORD PTR $T228143[ebp]
	and	eax, 1
	je	$LN5@GetLocaliz
	and	DWORD PTR $T228143[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
$LN5@GetLocaliz:
	ret	0
__ehhandler$?GetLocalizedText@@YA?AVCvString@@PBD@Z:
	mov	eax, OFFSET __ehfuncinfo$?GetLocalizedText@@YA?AVCvString@@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetLocalizedText@@YA?AVCvString@@PBD@Z ENDP		; GetLocalizedText
PUBLIC	??1CvBaseInfo@@QAE@XZ				; CvBaseInfo::~CvBaseInfo
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CvBaseInfo@@QAE@XZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??1CvBaseInfo@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??1CvBaseInfo@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1CvBaseInfo@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvBaseInfo@@QAE@XZ PROC				; CvBaseInfo::~CvBaseInfo, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??1CvBaseInfo@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	lea	ecx, DWORD PTR [esi+232]
	mov	DWORD PTR __$EHRec$[esp+28], 7
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+204]
	mov	BYTE PTR __$EHRec$[esp+28], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+176]
	mov	BYTE PTR __$EHRec$[esp+28], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+148]
	mov	BYTE PTR __$EHRec$[esp+28], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+120]
	mov	BYTE PTR __$EHRec$[esp+28], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+92]
	mov	BYTE PTR __$EHRec$[esp+28], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+64]
	mov	BYTE PTR __$EHRec$[esp+28], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+36]
	mov	BYTE PTR __$EHRec$[esp+28], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR __$EHRec$[esp+28], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 120				; 00000078H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 148				; 00000094H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 176				; 000000b0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvBaseInfo@@QAE@XZ$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 204				; 000000ccH
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvBaseInfo@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvBaseInfo@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvBaseInfo@@QAE@XZ ENDP				; CvBaseInfo::~CvBaseInfo
PUBLIC	??_7CvTechEntry@@6B@				; CvTechEntry::`vftable'
PUBLIC	??1CvTechEntry@@QAE@XZ				; CvTechEntry::~CvTechEntry
PUBLIC	??_R4CvTechEntry@@6B@				; CvTechEntry::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvTechEntry@@@8				; CvTechEntry `RTTI Type Descriptor'
PUBLIC	??_R3CvTechEntry@@8				; CvTechEntry::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvTechEntry@@8				; CvTechEntry::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvTechEntry@@8			; CvTechEntry::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CvBaseInfo@@8			; CvBaseInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCvBaseInfo@@@8				; CvBaseInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvBaseInfo@@8				; CvBaseInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvBaseInfo@@8				; CvBaseInfo::`RTTI Base Class Array'
PUBLIC	?CacheResults@CvTechEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvTechEntry::CacheResults
EXTRN	??8CvBaseInfo@@UBE_NABV0@@Z:PROC		; CvBaseInfo::operator==
EXTRN	?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::readFrom
EXTRN	?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z:PROC ; CvBaseInfo::writeTo
;	COMDAT ??_R2CvBaseInfo@@8
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
rdata$r	SEGMENT
??_R2CvBaseInfo@@8 DD FLAT:??_R1A@?0A@EA@CvBaseInfo@@8	; CvBaseInfo::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CvBaseInfo@@8
rdata$r	SEGMENT
??_R3CvBaseInfo@@8 DD 00H				; CvBaseInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvBaseInfo@@@8
_DATA	SEGMENT
??_R0?AVCvBaseInfo@@@8 DD FLAT:??_7type_info@@6B@	; CvBaseInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvBaseInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvBaseInfo@@8 DD FLAT:??_R0?AVCvBaseInfo@@@8 ; CvBaseInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CvTechEntry@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvTechEntry@@8 DD FLAT:??_R0?AVCvTechEntry@@@8 ; CvTechEntry::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvTechEntry@@8
rdata$r	ENDS
;	COMDAT ??_R2CvTechEntry@@8
rdata$r	SEGMENT
??_R2CvTechEntry@@8 DD FLAT:??_R1A@?0A@EA@CvTechEntry@@8 ; CvTechEntry::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CvBaseInfo@@8
rdata$r	ENDS
;	COMDAT ??_R3CvTechEntry@@8
rdata$r	SEGMENT
??_R3CvTechEntry@@8 DD 00H				; CvTechEntry::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CvTechEntry@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvTechEntry@@@8
_DATA	SEGMENT
??_R0?AVCvTechEntry@@@8 DD FLAT:??_7type_info@@6B@	; CvTechEntry `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvTechEntry@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvTechEntry@@6B@
rdata$r	SEGMENT
??_R4CvTechEntry@@6B@ DD 00H				; CvTechEntry::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvTechEntry@@@8
	DD	FLAT:??_R3CvTechEntry@@8
rdata$r	ENDS
;	COMDAT ??_7CvTechEntry@@6B@
CONST	SEGMENT
??_7CvTechEntry@@6B@ DD FLAT:??_R4CvTechEntry@@6B@	; CvTechEntry::`vftable'
	DD	FLAT:?CacheResults@CvTechEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	FLAT:??8CvBaseInfo@@UBE_NABV0@@Z
	DD	FLAT:?readFrom@CvBaseInfo@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?writeTo@CvBaseInfo@@UBEXAAVFDataStream@@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1CvTechEntry@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvTechEntry@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvTechEntry@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1CvTechEntry@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1CvTechEntry@@QAE@XZ$3
__ehfuncinfo$??1CvTechEntry@@QAE@XZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??1CvTechEntry@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtechclasses.cpp
xdata$x	ENDS
;	COMDAT ??1CvTechEntry@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvTechEntry@@QAE@XZ PROC				; CvTechEntry::~CvTechEntry, COMDAT
; _this$ = ecx

; 83   : {

	push	-1
	push	__ehhandler$??1CvTechEntry@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+24], esi
	mov	DWORD PTR [esi], OFFSET ??_7CvTechEntry@@6B@

; 84   : 	SAFE_DELETE_ARRAY(m_piDomainExtraMoves);

	mov	eax, DWORD PTR [esi+472]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+36], 3
	call	??_V@YAXPAX@Z				; operator delete[]
	xor	ebx, ebx
	mov	DWORD PTR [esi+472], ebx

; 85   : 	SAFE_DELETE_ARRAY(m_piTradeRouteDomainExtraRange);

	mov	eax, DWORD PTR [esi+476]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+476], ebx

; 86   : 	SAFE_DELETE_ARRAY(m_piFlavorValue);

	mov	eax, DWORD PTR [esi+480]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+480], ebx

; 87   : 	SAFE_DELETE_ARRAY(m_piPrereqOrTechs);

	mov	eax, DWORD PTR [esi+484]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+484], ebx

; 88   : 	SAFE_DELETE_ARRAY(m_piPrereqAndTechs);

	mov	eax, DWORD PTR [esi+488]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+488], ebx

; 89   : 	SAFE_DELETE_ARRAY(m_pabFreePromotion);

	mov	eax, DWORD PTR [esi+492]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 24					; 00000018H

; 90   : }

	lea	ecx, DWORD PTR [esi+444]
	mov	DWORD PTR [esi+492], ebx
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+416]
	mov	BYTE PTR __$EHRec$[esp+32], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+388]
	mov	BYTE PTR __$EHRec$[esp+32], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+360]
	mov	BYTE PTR __$EHRec$[esp+32], bl
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+32], -1
	call	??1CvBaseInfo@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvTechEntry@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__unwindfunclet$??1CvTechEntry@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 360				; 00000168H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvTechEntry@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 388				; 00000184H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??1CvTechEntry@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 416				; 000001a0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??1CvTechEntry@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvTechEntry@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvTechEntry@@QAE@XZ ENDP				; CvTechEntry::~CvTechEntry
PUBLIC	?SetQuoteKey@CvTechEntry@@QAEXPBD@Z		; CvTechEntry::SetQuoteKey
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?SetQuoteKey@CvTechEntry@@QAEXPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetQuoteKey@CvTechEntry@@QAEXPBD@Z$0
__ehfuncinfo$?SetQuoteKey@CvTechEntry@@QAEXPBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SetQuoteKey@CvTechEntry@@QAEXPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtechclasses.cpp
xdata$x	ENDS
;	COMDAT ?SetQuoteKey@CvTechEntry@@QAEXPBD@Z
_TEXT	SEGMENT
$T228291 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_szVal$ = 8						; size = 4
?SetQuoteKey@CvTechEntry@@QAEXPBD@Z PROC		; CvTechEntry::SetQuoteKey, COMDAT
; _this$ = ecx

; 501  : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?SetQuoteKey@CvTechEntry@@QAEXPBD@Z
	push	eax

; 502  : 	m_strQuoteKey = szVal;

	mov	eax, DWORD PTR _szVal$[esp+8]
	mov	DWORD PTR fs:0, esp
	sub	esp, 28					; 0000001cH
	push	esi
	push	edi
	mov	edi, ecx
	lea	esi, DWORD PTR [edi+360]
	mov	ecx, esi
	test	eax, eax
	je	SHORT $LN5@SetQuoteKe
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN4@SetQuoteKe
$LN5@SetQuoteKe:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN4@SetQuoteKe:

; 503  : 	m_wstrQuote = GetLocalizedText(m_strQuoteKey);

	mov	ecx, esi
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	eax, DWORD PTR $T228291[esp+52]
	push	eax
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	lea	ecx, DWORD PTR [edi+388]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+60], 0
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T228291[esp+48]
	mov	DWORD PTR __$EHRec$[esp+56], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 504  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 40					; 00000028H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetQuoteKey@CvTechEntry@@QAEXPBD@Z$0:
	lea	ecx, DWORD PTR $T228291[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?SetQuoteKey@CvTechEntry@@QAEXPBD@Z:
	mov	eax, OFFSET __ehfuncinfo$?SetQuoteKey@CvTechEntry@@QAEXPBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetQuoteKey@CvTechEntry@@QAEXPBD@Z ENDP		; CvTechEntry::SetQuoteKey
PUBLIC	?GetSound@CvTechEntry@@QBEPBDXZ			; CvTechEntry::GetSound
; Function compile flags: /Ogtpy
;	COMDAT ?GetSound@CvTechEntry@@QBEPBDXZ
_TEXT	SEGMENT
?GetSound@CvTechEntry@@QBEPBDXZ PROC			; CvTechEntry::GetSound, COMDAT
; _this$ = ecx

; 509  : 	return m_strSound;

	add	ecx, 416				; 000001a0H
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetSound@CvTechEntry@@QBEPBDXZ ENDP			; CvTechEntry::GetSound
_TEXT	ENDS
PUBLIC	?SetSound@CvTechEntry@@QAEXPBD@Z		; CvTechEntry::SetSound
; Function compile flags: /Ogtpy
;	COMDAT ?SetSound@CvTechEntry@@QAEXPBD@Z
_TEXT	SEGMENT
_szVal$ = 8						; size = 4
?SetSound@CvTechEntry@@QAEXPBD@Z PROC			; CvTechEntry::SetSound, COMDAT
; _this$ = ecx

; 515  : 	m_strSound = szVal;

	mov	eax, DWORD PTR _szVal$[esp-4]
	add	ecx, 416				; 000001a0H
	test	eax, eax
	je	SHORT $LN4@SetSound
	mov	DWORD PTR _szVal$[esp-4], eax
	jmp	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
$LN4@SetSound:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 516  : }

	ret	4
?SetSound@CvTechEntry@@QAEXPBD@Z ENDP			; CvTechEntry::SetSound
_TEXT	ENDS
PUBLIC	?GetSoundMP@CvTechEntry@@QBEPBDXZ		; CvTechEntry::GetSoundMP
; Function compile flags: /Ogtpy
;	COMDAT ?GetSoundMP@CvTechEntry@@QBEPBDXZ
_TEXT	SEGMENT
?GetSoundMP@CvTechEntry@@QBEPBDXZ PROC			; CvTechEntry::GetSoundMP, COMDAT
; _this$ = ecx

; 521  : 	return m_strSoundMP;

	add	ecx, 444				; 000001bcH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?GetSoundMP@CvTechEntry@@QBEPBDXZ ENDP			; CvTechEntry::GetSoundMP
_TEXT	ENDS
PUBLIC	?SetSoundMP@CvTechEntry@@QAEXPBD@Z		; CvTechEntry::SetSoundMP
; Function compile flags: /Ogtpy
;	COMDAT ?SetSoundMP@CvTechEntry@@QAEXPBD@Z
_TEXT	SEGMENT
_szVal$ = 8						; size = 4
?SetSoundMP@CvTechEntry@@QAEXPBD@Z PROC			; CvTechEntry::SetSoundMP, COMDAT
; _this$ = ecx

; 527  : 	m_strSoundMP = szVal;

	mov	eax, DWORD PTR _szVal$[esp-4]
	add	ecx, 444				; 000001bcH
	test	eax, eax
	je	SHORT $LN4@SetSoundMP
	mov	DWORD PTR _szVal$[esp-4], eax
	jmp	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
$LN4@SetSoundMP:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 528  : }

	ret	4
?SetSoundMP@CvTechEntry@@QAEXPBD@Z ENDP			; CvTechEntry::SetSoundMP
_TEXT	ENDS
PUBLIC	?GetNumTechs@CvTechXMLEntries@@QAEHXZ		; CvTechXMLEntries::GetNumTechs
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumTechs@CvTechXMLEntries@@QAEHXZ
_TEXT	SEGMENT
?GetNumTechs@CvTechXMLEntries@@QAEHXZ PROC		; CvTechXMLEntries::GetNumTechs, COMDAT
; _this$ = ecx

; 593  : 	return m_paTechEntries.size();

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 594  : }

	ret	0
?GetNumTechs@CvTechXMLEntries@@QAEHXZ ENDP		; CvTechXMLEntries::GetNumTechs
_TEXT	ENDS
PUBLIC	?GetEntry@CvTechXMLEntries@@QAEPAVCvTechEntry@@H@Z ; CvTechXMLEntries::GetEntry
; Function compile flags: /Ogtpy
;	COMDAT ?GetEntry@CvTechXMLEntries@@QAEPAVCvTechEntry@@H@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?GetEntry@CvTechXMLEntries@@QAEPAVCvTechEntry@@H@Z PROC	; CvTechXMLEntries::GetEntry, COMDAT
; _this$ = ecx

; 614  : 	return m_paTechEntries[index];

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _index$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 615  : }

	ret	4
?GetEntry@CvTechXMLEntries@@QAEPAVCvTechEntry@@H@Z ENDP	; CvTechXMLEntries::GetEntry
_TEXT	ENDS
PUBLIC	?Reset@CvPlayerTechs@@QAEXXZ			; CvPlayerTechs::Reset
EXTRN	?Reset@CvTechAI@@QAEXXZ:PROC			; CvTechAI::Reset
EXTRN	?GetFreeBuildingPrereqTech@CvTraitEntry@@QBE?AW4TechTypes@@XZ:PROC ; CvTraitEntry::GetFreeBuildingPrereqTech
EXTRN	?GetCapitalFreeBuildingPrereqTech@CvTraitEntry@@QBE?AW4TechTypes@@XZ:PROC ; CvTraitEntry::GetCapitalFreeBuildingPrereqTech
EXTRN	?GetFreeUnitPrereqTech@CvTraitEntry@@QBE?AW4TechTypes@@XZ:PROC ; CvTraitEntry::GetFreeUnitPrereqTech
EXTRN	?GetPrereqTech@CvTraitEntry@@QBEHXZ:PROC	; CvTraitEntry::GetPrereqTech
EXTRN	?IsMayaCalendarBonuses@CvTraitEntry@@QBE_NXZ:PROC ; CvTraitEntry::IsMayaCalendarBonuses
EXTRN	?getTraitInfo@CvGlobals@@QAEPAVCvTraitEntry@@W4TraitTypes@@@Z:PROC ; CvGlobals::getTraitInfo
EXTRN	?hasTrait@CvLeaderHeadInfo@@QBE_NH@Z:PROC	; CvLeaderHeadInfo::hasTrait
EXTRN	?getLeaderInfo@CvPlayer@@QBEAAVCvLeaderHeadInfo@@XZ:PROC ; CvPlayer::getLeaderInfo
EXTRN	?getNumTraitInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumTraitInfos
EXTRN	?getTechPrereq@CvBuildInfo@@QBEHXZ:PROC		; CvBuildInfo::getTechPrereq
EXTRN	?getImprovement@CvBuildInfo@@QBEHXZ:PROC	; CvBuildInfo::getImprovement
EXTRN	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z:PROC ; CvGlobals::getBuildInfo
EXTRN	?getNumBuildInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumBuildInfos
EXTRN	?GetRequiredCivilization@CvImprovementEntry@@QBE?AW4CivilizationTypes@@XZ:PROC ; CvImprovementEntry::GetRequiredCivilization
EXTRN	?IsSpecificCivRequired@CvImprovementEntry@@QBE_NXZ:PROC ; CvImprovementEntry::IsSpecificCivRequired
EXTRN	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z:PROC ; CvGlobals::getImprovementInfo
EXTRN	?getNumImprovementInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumImprovementInfos
EXTRN	?GetPrereqAndTech@CvUnitEntry@@QBEHXZ:PROC	; CvUnitEntry::GetPrereqAndTech
EXTRN	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z:PROC ; CvGlobals::getUnitInfo
EXTRN	?getCivilizationUnits@CvCivilizationInfo@@QBEHH@Z:PROC ; CvCivilizationInfo::getCivilizationUnits
EXTRN	?isCivilizationUnitOverridden@CvCivilizationInfo@@QBE_NH@Z:PROC ; CvCivilizationInfo::isCivilizationUnitOverridden
EXTRN	?getNumUnitClassInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumUnitClassInfos
EXTRN	?GetPrereqAndTech@CvBuildingEntry@@QBEHXZ:PROC	; CvBuildingEntry::GetPrereqAndTech
EXTRN	?isCivilizationBuildingOverridden@CvCivilizationInfo@@QBE_NH@Z:PROC ; CvCivilizationInfo::isCivilizationBuildingOverridden
EXTRN	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z:PROC ; CvBuildingXMLEntries::GetEntry
EXTRN	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z:PROC ; CvCivilizationInfo::getCivilizationBuildings
EXTRN	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ:PROC ; CvGlobals::getNumBuildingClassInfos
EXTRN	?getCivilizationInfo@CvGlobals@@QAEPAVCvCivilizationInfo@@W4CivilizationTypes@@@Z:PROC ; CvGlobals::getCivilizationInfo
EXTRN	?getCivilizationType@CvPlayer@@QBE?AW4CivilizationTypes@@XZ:PROC ; CvPlayer::getCivilizationType
EXTRN	?isBarbarian@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isBarbarian
EXTRN	?isMinorCiv@CvPlayer@@QBE_NXZ:PROC		; CvPlayer::isMinorCiv
EXTRN	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ:PROC ; CvGlobals::GetGameBuildings
; Function compile flags: /Ogtpy
;	COMDAT ?Reset@CvPlayerTechs@@QAEXXZ
_TEXT	SEGMENT
_pkInfo$224448 = -8					; size = 4
_pkGameBuildings$ = -4					; size = 4
?Reset@CvPlayerTechs@@QAEXXZ PROC			; CvPlayerTechs::Reset, COMDAT
; _this$ = ecx

; 694  : {

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 695  : #ifdef AUI_WARNING_FIXES
; 696  : 	uint iI;
; 697  : #else
; 698  : 	int iI;
; 699  : #endif
; 700  : 	CvBuildingXMLEntries* pkGameBuildings = GC.GetGameBuildings();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?GetGameBuildings@CvGlobals@@QBEPAVCvBuildingXMLEntries@@XZ ; CvGlobals::GetGameBuildings

; 701  : 
; 702  : 	for(iI = 0; iI < m_pTechs->GetNumTechs(); iI++)

	mov	ecx, DWORD PTR [esi+40]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _pkGameBuildings$[esp+12], eax
	xor	eax, eax
	test	edx, -4					; fffffffcH
	jle	SHORT $LN38@Reset
	npad	9
$LL40@Reset:

; 703  : 	{
; 704  : 		m_pabResearchingTech[iI] = false;

	mov	ecx, DWORD PTR [esi+12]
	mov	BYTE PTR [eax+ecx], 0

; 705  : 		m_piCivTechPriority[iI] = 1;

	mov	edx, DWORD PTR [esi+16]
	mov	DWORD PTR [edx+eax*4], 1

; 706  : 		m_piLocaleTechPriority[iI] = 1;

	mov	ecx, DWORD PTR [esi+20]
	mov	DWORD PTR [ecx+eax*4], 1

; 707  : 		m_peLocaleTechResources[iI] = NO_RESOURCE;

	mov	edx, DWORD PTR [esi+24]
	mov	DWORD PTR [edx+eax*4], -1

; 708  : 		m_peCivTechUniqueUnits[iI] = NO_UNIT;

	mov	ecx, DWORD PTR [esi+28]
	mov	DWORD PTR [ecx+eax*4], -1

; 709  : 		m_peCivTechUniqueBuildings[iI] = NO_BUILDING;

	mov	edx, DWORD PTR [esi+32]
	mov	DWORD PTR [edx+eax*4], -1

; 710  : 		m_peCivTechUniqueImprovements[iI] = NO_IMPROVEMENT;

	mov	ecx, DWORD PTR [esi+36]
	mov	DWORD PTR [ecx+eax*4], -1
	mov	ecx, DWORD PTR [esi+40]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx+4]
	inc	eax
	sar	edx, 2
	cmp	eax, edx
	jl	SHORT $LL40@Reset
$LN38@Reset:

; 711  : 	}
; 712  : 
; 713  : 	// Tweak tech priorities to recognize unique properties of this civ
; 714  : 	if(!m_pPlayer->isMinorCiv() && !m_pPlayer->isBarbarian() && m_pPlayer->getCivilizationType() != NO_CIVILIZATION)

	mov	ecx, DWORD PTR [esi+44]
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	$LN9@Reset
	mov	ecx, DWORD PTR [esi+44]
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	test	al, al
	jne	$LN9@Reset
	mov	ecx, DWORD PTR [esi+44]
	call	?getCivilizationType@CvPlayer@@QBE?AW4CivilizationTypes@@XZ ; CvPlayer::getCivilizationType
	cmp	eax, -1
	je	$LN9@Reset

; 715  : 	{
; 716  : 		CvCivilizationInfo* pkInfo = GC.getCivilizationInfo(m_pPlayer->getCivilizationType());

	mov	ecx, DWORD PTR [esi+44]
	push	ebx
	push	ebp
	push	edi
	call	?getCivilizationType@CvPlayer@@QBE?AW4CivilizationTypes@@XZ ; CvPlayer::getCivilizationType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getCivilizationInfo@CvGlobals@@QAEPAVCvCivilizationInfo@@W4CivilizationTypes@@@Z ; CvGlobals::getCivilizationInfo
	mov	DWORD PTR _pkInfo$224448[esp+24], eax

; 717  : 		if(pkInfo)

	test	eax, eax
	je	$LN74@Reset

; 718  : 		{
; 719  : 			// Loop through all building classes
; 720  : 			for(iI = 0; iI < GC.getNumBuildingClassInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	ebp, ebp
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	test	eax, eax
	jle	SHORT $LN33@Reset
	npad	9
$LL75@Reset:

; 721  : 			{
; 722  : 				const BuildingTypes eBuilding = static_cast<BuildingTypes>(pkInfo->getCivilizationBuildings(iI));

	mov	ecx, DWORD PTR _pkInfo$224448[esp+24]
	push	ebp
	call	?getCivilizationBuildings@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationBuildings
	mov	edi, eax

; 723  : 				CvBuildingEntry* pkBuildingInfo = NULL;
; 724  : 
; 725  : 				if(eBuilding != -1)

	cmp	edi, -1
	je	SHORT $LN34@Reset

; 726  : 					pkBuildingInfo = pkGameBuildings->GetEntry(eBuilding);

	mov	ecx, DWORD PTR _pkGameBuildings$[esp+24]
	push	edi
	call	?GetEntry@CvBuildingXMLEntries@@QAEPAVCvBuildingEntry@@H@Z ; CvBuildingXMLEntries::GetEntry
	mov	ebx, eax

; 727  : 
; 728  : 				if(pkBuildingInfo)

	test	ebx, ebx
	je	SHORT $LN34@Reset

; 729  : 				{
; 730  : 					// Is this one overridden for our civ?
; 731  : 					if(pkInfo->isCivilizationBuildingOverridden(iI))

	mov	ecx, DWORD PTR _pkInfo$224448[esp+24]
	push	ebp
	call	?isCivilizationBuildingOverridden@CvCivilizationInfo@@QBE_NH@Z ; CvCivilizationInfo::isCivilizationBuildingOverridden
	test	al, al
	je	SHORT $LN34@Reset

; 732  : 					{
; 733  : 						int iTech = pkBuildingInfo->GetPrereqAndTech();

	mov	ecx, ebx
	call	?GetPrereqAndTech@CvBuildingEntry@@QBEHXZ ; CvBuildingEntry::GetPrereqAndTech

; 734  : 						if(iTech != NO_TECH)

	cmp	eax, -1
	je	SHORT $LN34@Reset

; 735  : 						{
; 736  : 							m_piCivTechPriority[iTech] *= GC.getTECH_PRIORITY_UNIQUE_ITEM();

	mov	ecx, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1844
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [ecx], edx

; 737  : 							m_peCivTechUniqueBuildings[iTech] = eBuilding;

	mov	ecx, DWORD PTR [esi+32]
	mov	DWORD PTR [ecx+eax*4], edi
$LN34@Reset:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	ebp
	call	?getNumBuildingClassInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumBuildingClassInfos
	cmp	ebp, eax
	jl	SHORT $LL75@Reset
$LN33@Reset:

; 738  : 						}
; 739  : 					}
; 740  : 				}
; 741  : 			}
; 742  : 
; 743  : 			// Loop through all units
; 744  : 			for(iI = 0; iI < GC.getNumUnitClassInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	ebx, ebx
	call	?getNumUnitClassInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumUnitClassInfos
	test	eax, eax
	jle	SHORT $LN26@Reset
$LL28@Reset:

; 745  : 			{
; 746  : 				// Is this one overridden for our civ?
; 747  : 				if(pkInfo->isCivilizationUnitOverridden(iI))

	mov	edi, DWORD PTR _pkInfo$224448[esp+24]
	push	ebx
	mov	ecx, edi
	call	?isCivilizationUnitOverridden@CvCivilizationInfo@@QBE_NH@Z ; CvCivilizationInfo::isCivilizationUnitOverridden
	test	al, al
	je	SHORT $LN27@Reset

; 748  : 				{
; 749  : 					UnitTypes eCivilizationUnit = static_cast<UnitTypes>(pkInfo->getCivilizationUnits(iI));

	push	ebx
	mov	ecx, edi
	call	?getCivilizationUnits@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationUnits

; 750  : 					if(eCivilizationUnit != NO_UNIT)

	cmp	eax, -1
	je	SHORT $LN27@Reset

; 751  : 					{
; 752  : 						CvUnitEntry* pkUnitEntry = GC.getUnitInfo(eCivilizationUnit);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getUnitInfo@CvGlobals@@QAEPAVCvUnitEntry@@W4UnitTypes@@@Z ; CvGlobals::getUnitInfo

; 753  : 						if(pkUnitEntry)

	test	eax, eax
	je	SHORT $LN27@Reset

; 754  : 						{
; 755  : 							int iTech = pkUnitEntry->GetPrereqAndTech();

	mov	ecx, eax
	call	?GetPrereqAndTech@CvUnitEntry@@QBEHXZ	; CvUnitEntry::GetPrereqAndTech
	mov	edi, eax

; 756  : 							if(iTech != NO_TECH)

	cmp	edi, -1
	je	SHORT $LN27@Reset

; 757  : 							{
; 758  : 								m_piCivTechPriority[iTech] *= GC.getTECH_PRIORITY_UNIQUE_ITEM();

	mov	edx, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [edx+edi*4]
	imul	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1844
	lea	eax, DWORD PTR [edx+edi*4]
	mov	DWORD PTR [eax], ecx

; 759  : 								m_peCivTechUniqueUnits[iTech] = (UnitTypes)pkInfo->getCivilizationUnits(iI);

	mov	ecx, DWORD PTR _pkInfo$224448[esp+24]
	push	ebx
	call	?getCivilizationUnits@CvCivilizationInfo@@QBEHH@Z ; CvCivilizationInfo::getCivilizationUnits
	mov	edx, DWORD PTR [esi+28]
	mov	DWORD PTR [edx+edi*4], eax
$LN27@Reset:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	ebx
	call	?getNumUnitClassInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumUnitClassInfos
	cmp	ebx, eax
	jl	SHORT $LL28@Reset
$LN26@Reset:

; 760  : 							}
; 761  : 						}
; 762  : 					}
; 763  : 				}
; 764  : 			}
; 765  : 
; 766  : 			// Loop through all improvements
; 767  : 			for(iI = 0; iI < GC.getNumImprovementInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	ebp, ebp
	call	?getNumImprovementInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumImprovementInfos
	test	eax, eax
	jle	$LN74@Reset
$LL21@Reset:

; 768  : 			{
; 769  : 				CvImprovementEntry* pkImprovementEntry = GC.getImprovementInfo((ImprovementTypes)iI);

	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo
	mov	edi, eax

; 770  : 				if(pkImprovementEntry)

	test	edi, edi
	je	$LN20@Reset

; 771  : 				{
; 772  : 					if(pkImprovementEntry->IsSpecificCivRequired() && pkImprovementEntry->GetRequiredCivilization() == m_pPlayer->getCivilizationType())

	mov	ecx, edi
	call	?IsSpecificCivRequired@CvImprovementEntry@@QBE_NXZ ; CvImprovementEntry::IsSpecificCivRequired
	test	al, al
	je	SHORT $LN20@Reset
	mov	ecx, edi
	call	?GetRequiredCivilization@CvImprovementEntry@@QBE?AW4CivilizationTypes@@XZ ; CvImprovementEntry::GetRequiredCivilization
	mov	ecx, DWORD PTR [esi+44]
	mov	edi, eax
	call	?getCivilizationType@CvPlayer@@QBE?AW4CivilizationTypes@@XZ ; CvPlayer::getCivilizationType
	cmp	edi, eax
	jne	SHORT $LN20@Reset

; 773  : 					{
; 774  : 						// Find corresponding build
; 775  : #ifdef AUI_WARNING_FIXES
; 776  : 						for (uint jJ = 0; jJ < GC.getNumBuildInfos(); jJ++)
; 777  : #else
; 778  : 						for(int jJ = 0; jJ < GC.getNumBuildInfos(); jJ++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	ebx, ebx
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	test	eax, eax
	jle	SHORT $LN20@Reset
	npad	10
$LL16@Reset:

; 779  : #endif
; 780  : 						{
; 781  : 							CvBuildInfo* pkBuildEntry = GC.getBuildInfo((BuildTypes)jJ);

	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	edi, eax

; 782  : #ifdef AUI_WARNING_FIXES
; 783  : 							if (pkBuildEntry && (uint)pkBuildEntry->getImprovement() == iI)
; 784  : #else
; 785  : 							if(pkBuildEntry && pkBuildEntry->getImprovement() == iI)

	test	edi, edi
	je	SHORT $LN15@Reset
	mov	ecx, edi
	call	?getImprovement@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getImprovement
	cmp	eax, ebp
	jne	SHORT $LN15@Reset

; 786  : #endif
; 787  : 							{
; 788  : 								int iTech = pkBuildEntry->getTechPrereq();

	mov	ecx, edi
	call	?getTechPrereq@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getTechPrereq

; 789  : 								if(iTech != NO_TECH)

	cmp	eax, -1
	je	SHORT $LN15@Reset

; 790  : 								{
; 791  : 									m_piCivTechPriority[iTech] *= GC.getTECH_PRIORITY_UNIQUE_ITEM();

	mov	ecx, DWORD PTR [esi+16]
	mov	edx, DWORD PTR [ecx+eax*4]
	imul	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1844
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [ecx], edx

; 792  : 									m_peCivTechUniqueImprovements[iTech] = static_cast<ImprovementTypes>(iI);

	mov	ecx, DWORD PTR [esi+36]
	mov	DWORD PTR [ecx+eax*4], ebp
$LN15@Reset:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	ebx
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	ebx, eax
	jl	SHORT $LL16@Reset
$LN20@Reset:

; 760  : 							}
; 761  : 						}
; 762  : 					}
; 763  : 				}
; 764  : 			}
; 765  : 
; 766  : 			// Loop through all improvements
; 767  : 			for(iI = 0; iI < GC.getNumImprovementInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	ebp
	call	?getNumImprovementInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumImprovementInfos
	cmp	ebp, eax
	jl	$LL21@Reset
$LN74@Reset:

; 793  : 								}
; 794  : 							}
; 795  : 						}
; 796  : 					}
; 797  : 				}
; 798  : 			}
; 799  : 		}
; 800  : 
; 801  : 		// Player Traits
; 802  : #ifdef AUI_WARNING_FIXES
; 803  : 		for (uint iTraitLoop = 0; iTraitLoop < GC.getNumTraitInfos(); iTraitLoop++)
; 804  : #else
; 805  : 		int iNumTraits = GC.getNumTraitInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTraitInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTraitInfos
	mov	ebp, eax

; 806  : 		for(int iTraitLoop = 0; iTraitLoop < iNumTraits; iTraitLoop++)

	xor	ebx, ebx
	test	ebp, ebp
	jle	$LN82@Reset
$LL81@Reset:

; 807  : #endif
; 808  : 		{
; 809  : 			TraitTypes eTraitLoop = (TraitTypes) iTraitLoop;
; 810  : 			// Do we have this trait?
; 811  : 			CvLeaderHeadInfo* pkLeaderInfo = &m_pPlayer->getLeaderInfo();

	mov	ecx, DWORD PTR [esi+44]
	call	?getLeaderInfo@CvPlayer@@QBEAAVCvLeaderHeadInfo@@XZ ; CvPlayer::getLeaderInfo

; 812  : 			if(pkLeaderInfo)

	test	eax, eax
	je	$LN10@Reset

; 813  : 			{
; 814  : 				if(!pkLeaderInfo->hasTrait(iTraitLoop))  // This trait check disregards tech prereqs and obsoletes

	push	ebx
	mov	ecx, eax
	call	?hasTrait@CvLeaderHeadInfo@@QBE_NH@Z	; CvLeaderHeadInfo::hasTrait
	test	al, al
	je	$LN10@Reset

; 815  : 					continue;
; 816  : 
; 817  : 				CvTraitEntry* pkTraitInfo = GC.getTraitInfo(eTraitLoop);

	push	ebx
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTraitInfo@CvGlobals@@QAEPAVCvTraitEntry@@W4TraitTypes@@@Z ; CvGlobals::getTraitInfo
	mov	edi, eax

; 818  : 				if(pkTraitInfo)

	test	edi, edi
	je	SHORT $LN10@Reset

; 819  : 				{
; 820  : 					// Maya Calendar trait - We want to heavily weight the unlock tech
; 821  : 					if(pkTraitInfo->IsMayaCalendarBonuses())

	mov	ecx, edi
	call	?IsMayaCalendarBonuses@CvTraitEntry@@QBE_NXZ ; CvTraitEntry::IsMayaCalendarBonuses
	test	al, al
	je	SHORT $LN78@Reset

; 822  : 					{
; 823  : 						int iPrereqTech = pkTraitInfo->GetPrereqTech();

	mov	ecx, edi
	call	?GetPrereqTech@CvTraitEntry@@QBEHXZ	; CvTraitEntry::GetPrereqTech

; 824  : 						if(iPrereqTech != NO_TECH)

	cmp	eax, -1
	je	SHORT $LN78@Reset

; 825  : 						{
; 826  : 							m_piCivTechPriority[iPrereqTech] *= GC.getTECH_PRIORITY_MAYA_CALENDAR_BONUS();

	mov	edx, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [edx+eax*4]
	imul	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1848
	lea	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [eax], ecx
$LN78@Reset:

; 827  : 						}
; 828  : 					}
; 829  : 
; 830  : 					// Other traits that unlock by tech? -- Yep. ~EAP
; 831  : 					int iPrereqTech = pkTraitInfo->GetFreeUnitPrereqTech();

	mov	ecx, edi
	call	?GetFreeUnitPrereqTech@CvTraitEntry@@QBE?AW4TechTypes@@XZ ; CvTraitEntry::GetFreeUnitPrereqTech

; 832  : 					if (iPrereqTech != NO_TECH)

	cmp	eax, -1
	je	SHORT $LN3@Reset

; 833  : 					{
; 834  : 						m_piCivTechPriority[iPrereqTech] += GC.getTECH_PRIORITY_MAYA_CALENDAR_BONUS();

	mov	edx, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1848
	add	DWORD PTR [edx+eax*4], ecx
	lea	eax, DWORD PTR [edx+eax*4]
$LN3@Reset:

; 835  : 					}
; 836  : 
; 837  : 					iPrereqTech = pkTraitInfo->GetCapitalFreeBuildingPrereqTech();

	mov	ecx, edi
	call	?GetCapitalFreeBuildingPrereqTech@CvTraitEntry@@QBE?AW4TechTypes@@XZ ; CvTraitEntry::GetCapitalFreeBuildingPrereqTech

; 838  : 					if (iPrereqTech != NO_TECH)

	cmp	eax, -1
	je	SHORT $LN2@Reset

; 839  : 					{
; 840  : 						m_piCivTechPriority[iPrereqTech] += GC.getTECH_PRIORITY_MAYA_CALENDAR_BONUS();

	mov	edx, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1848
	add	DWORD PTR [edx+eax*4], ecx
	lea	eax, DWORD PTR [edx+eax*4]
$LN2@Reset:

; 841  : 					}
; 842  : 
; 843  : 
; 844  : 					iPrereqTech = pkTraitInfo->GetFreeBuildingPrereqTech();

	mov	ecx, edi
	call	?GetFreeBuildingPrereqTech@CvTraitEntry@@QBE?AW4TechTypes@@XZ ; CvTraitEntry::GetFreeBuildingPrereqTech

; 845  : 					if (iPrereqTech != NO_TECH)

	cmp	eax, -1
	je	SHORT $LN10@Reset

; 846  : 					{
; 847  : 						m_piCivTechPriority[iPrereqTech] += GC.getTECH_PRIORITY_MAYA_CALENDAR_BONUS();

	mov	edx, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1848
	add	DWORD PTR [edx+eax*4], ecx
	lea	eax, DWORD PTR [edx+eax*4]
$LN10@Reset:
	inc	ebx
	cmp	ebx, ebp
	jl	$LL81@Reset
$LN82@Reset:
	pop	edi
	pop	ebp
	pop	ebx
$LN9@Reset:

; 848  : 					}
; 849  : 				}
; 850  : 			}
; 851  : 		}
; 852  : 	}
; 853  : 
; 854  : 	// Reset AI too
; 855  : 	m_pTechAI->Reset();

	mov	ecx, DWORD PTR [esi+48]
	pop	esi

; 856  : }

	add	esp, 8

; 848  : 					}
; 849  : 				}
; 850  : 			}
; 851  : 		}
; 852  : 	}
; 853  : 
; 854  : 	// Reset AI too
; 855  : 	m_pTechAI->Reset();

	jmp	?Reset@CvTechAI@@QAEXXZ			; CvTechAI::Reset
?Reset@CvPlayerTechs@@QAEXXZ ENDP			; CvPlayerTechs::Reset
_TEXT	ENDS
PUBLIC	?AddFlavorAsStrategies@CvPlayerTechs@@AAEXH@Z	; CvPlayerTechs::AddFlavorAsStrategies
EXTRN	?AddFlavorWeights@CvTechAI@@QAEXW4FlavorTypes@@HH@Z:PROC ; CvTechAI::AddFlavorWeights
EXTRN	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z:PROC ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy
EXTRN	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ:PROC ; CvPlayer::GetGrandStrategyAI
EXTRN	?getDefaultEstimateEndTurn@CvGame@@QBEHXZ:PROC	; CvGame::getDefaultEstimateEndTurn
EXTRN	?getElapsedGameTurns@CvGame@@QBEHXZ:PROC	; CvGame::getElapsedGameTurns
EXTRN	?GetLatestFlavorValue@CvFlavorRecipient@@QAEHW4FlavorTypes@@_N@Z:PROC ; CvFlavorRecipient::GetLatestFlavorValue
; Function compile flags: /Ogtpy
;	COMDAT ?AddFlavorAsStrategies@CvPlayerTechs@@AAEXH@Z
_TEXT	SEGMENT
_iGameProgressFactor$ = -12				; size = 4
$T228431 = -8						; size = 4
tv214 = -4						; size = 4
$T228432 = -4						; size = 4
_iPropagatePercent$ = 8					; size = 4
?AddFlavorAsStrategies@CvPlayerTechs@@AAEXH@Z PROC	; CvPlayerTechs::AddFlavorAsStrategies, COMDAT
; _this$ = ecx

; 1642 : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 1643 : 	// Start by resetting the AI
; 1644 : 	m_pTechAI->Reset();

	mov	ecx, DWORD PTR [edi+48]
	call	?Reset@CvTechAI@@QAEXXZ			; CvTechAI::Reset

; 1645 : 
; 1646 : 	int iBiggestFlavor = -1000;
; 1647 : 	for(int iFlavor = 0; iFlavor < GC.getNumFlavorTypes(); iFlavor++)

	xor	esi, esi
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764, esi
	mov	ebp, -1000				; fffffc18H
	jle	SHORT $LN6@AddFlavorA
$LL8@AddFlavorA:

; 1648 : 	{
; 1649 : 		int iFlavorValue = GetLatestFlavorValue((FlavorTypes) iFlavor);

	push	0
	push	esi
	mov	ecx, edi
	call	?GetLatestFlavorValue@CvFlavorRecipient@@QAEHW4FlavorTypes@@_N@Z ; CvFlavorRecipient::GetLatestFlavorValue

; 1650 : 		if(iFlavorValue > iBiggestFlavor)

	cmp	eax, ebp
	jle	SHORT $LN7@AddFlavorA

; 1651 : 		{
; 1652 : 			iBiggestFlavor = iFlavorValue;

	mov	ebp, eax
$LN7@AddFlavorA:

; 1645 : 
; 1646 : 	int iBiggestFlavor = -1000;
; 1647 : 	for(int iFlavor = 0; iFlavor < GC.getNumFlavorTypes(); iFlavor++)

	inc	esi
	cmp	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	jl	SHORT $LL8@AddFlavorA
$LN6@AddFlavorA:

; 1653 : 		}
; 1654 : 	}
; 1655 : 
; 1656 : 	// Now populate the AI with the current flavor information
; 1657 : 	int iGameProgressFactor = (GC.getGame().getElapsedGameTurns() * 1000) / GC.getGame().getDefaultEstimateEndTurn();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	ebx, ecx
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	mov	esi, eax
	mov	ecx, ebx
	imul	esi, 1000				; 000003e8H
	call	?getDefaultEstimateEndTurn@CvGame@@QBEHXZ ; CvGame::getDefaultEstimateEndTurn
	mov	ecx, eax
	mov	eax, esi
	cdq
	idiv	ecx

; 1658 : 	iGameProgressFactor = min(900,max(100,iGameProgressFactor));

	mov	DWORD PTR $T228431[esp+28], 100		; 00000064H
	mov	DWORD PTR $T228432[esp+28], 900		; 00000384H
	cmp	eax, 100				; 00000064H
	mov	DWORD PTR _iGameProgressFactor$[esp+28], eax
	jle	SHORT $LN19@AddFlavorA
	cmp	eax, 900				; 00000384H
	lea	ecx, DWORD PTR _iGameProgressFactor$[esp+28]
	jge	SHORT $LN23@AddFlavorA
	mov	eax, ecx
	jmp	SHORT $LN24@AddFlavorA
$LN19@AddFlavorA:
	lea	ecx, DWORD PTR $T228431[esp+28]
	mov	eax, ecx
	jmp	SHORT $LN24@AddFlavorA
$LN23@AddFlavorA:
	lea	eax, DWORD PTR $T228432[esp+28]
$LN24@AddFlavorA:
	mov	eax, DWORD PTR [eax]

; 1659 : 	for(int iFlavor = 0; iFlavor < GC.getNumFlavorTypes(); iFlavor++)

	xor	esi, esi
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764, esi
	mov	DWORD PTR _iGameProgressFactor$[esp+28], eax
	jle	SHORT $LN2@AddFlavorA
	mov	ecx, 1000				; 000003e8H
	sub	ecx, eax
	mov	DWORD PTR tv214[esp+28], ecx
	npad	5
$LL32@AddFlavorA:

; 1660 : 	{
; 1661 : 		int iCurrentFlavorValue = GetLatestFlavorValue((FlavorTypes) iFlavor);

	push	0
	push	esi
	mov	ecx, edi
	call	?GetLatestFlavorValue@CvFlavorRecipient@@QAEHW4FlavorTypes@@_N@Z ; CvFlavorRecipient::GetLatestFlavorValue

; 1662 : 
; 1663 : 		// Scale the current to the same scale as the personality
; 1664 : 		iCurrentFlavorValue = (iCurrentFlavorValue * 10) / iBiggestFlavor;

	lea	eax, DWORD PTR [eax+eax*4]
	add	eax, eax
	cdq
	idiv	ebp

; 1665 : 
; 1666 : 		int iPersonalityFlavorValue = m_pPlayer->GetGrandStrategyAI()->GetPersonalityAndGrandStrategy((FlavorTypes) iFlavor);

	mov	ecx, DWORD PTR [edi+44]
	push	esi
	mov	ebx, eax
	call	?GetGrandStrategyAI@CvPlayer@@QBEPAVCvGrandStrategyAI@@XZ ; CvPlayer::GetGrandStrategyAI
	mov	ecx, eax
	call	?GetPersonalityAndGrandStrategy@CvGrandStrategyAI@@QAEHW4FlavorTypes@@@Z ; CvGrandStrategyAI::GetPersonalityAndGrandStrategy

; 1667 : 
; 1668 : 		// this should give a more even blend between the personality and long term strategy and the more fickle current needs
; 1669 : 		// in the beginning of the game it will be responsive to current events, but later it should try to go for the goal more strongly
; 1670 : 		int iFlavorValue = ((iCurrentFlavorValue * (1000 - iGameProgressFactor)) + (iPersonalityFlavorValue * iGameProgressFactor)) / 1000;

	mov	edx, DWORD PTR tv214[esp+28]
	mov	ecx, eax
	imul	edx, ebx
	imul	ecx, DWORD PTR _iGameProgressFactor$[esp+28]
	add	ecx, edx
	mov	eax, 274877907				; 10624dd3H
	imul	ecx
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1671 : 
; 1672 : 		if(iFlavorValue > 0)

	test	eax, eax
	jle	SHORT $LN3@AddFlavorA

; 1673 : 		{
; 1674 : 			m_pTechAI->AddFlavorWeights((FlavorTypes)iFlavor, iFlavorValue, iPropagatePercent);

	mov	ecx, DWORD PTR _iPropagatePercent$[esp+24]
	push	ecx
	mov	ecx, DWORD PTR [edi+48]
	push	eax
	push	esi
	call	?AddFlavorWeights@CvTechAI@@QAEXW4FlavorTypes@@HH@Z ; CvTechAI::AddFlavorWeights
$LN3@AddFlavorA:
	inc	esi
	cmp	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	jl	SHORT $LL32@AddFlavorA
$LN2@AddFlavorA:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1675 : 		}
; 1676 : 	}
; 1677 : }

	add	esp, 12					; 0000000cH
	ret	4
?AddFlavorAsStrategies@CvPlayerTechs@@AAEXH@Z ENDP	; CvPlayerTechs::AddFlavorAsStrategies
_TEXT	ENDS
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z:PROC
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	?GetInstance@FILogFileMgr@@SAAAV1@XZ:PROC	; FILogFileMgr::GetInstance
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z:PROC
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z:PROC
EXTRN	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ:PROC ; CvGlobals::getPlayerAndCityAILogSplit
EXTRN	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ:PROC ; CvPlayer::getCivilizationShortDescription
EXTRN	?getAILogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getAILogging
EXTRN	?getLogging@CvGlobals@@QAE_NXZ:PROC		; CvGlobals::getLogging
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__ehfuncinfo$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z DD 019930522H
	DD	0bH
	DD	FLAT:__unwindtable$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z$7
	DD	05H
	DD	FLAT:__unwindfunclet$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z$8
	DD	05H
	DD	FLAT:__unwindfunclet$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z$9
	DD	05H
	DD	FLAT:__unwindfunclet$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z$10
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtechclasses.cpp
xdata$x	ENDS
;	COMDAT ?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z
_TEXT	SEGMENT
$T228480 = -236						; size = 28
$T228479 = -236						; size = 28
$T228478 = -236						; size = 28
$T228476 = -236						; size = 28
_strOutBuf$225030 = -208				; size = 28
_playerName$225033 = -180				; size = 28
_strTemp$225032 = -152					; size = 28
_strBaseString$225031 = -124				; size = 28
_strLogName$225035 = -96				; size = 28
$T228477 = -68						; size = 28
_strDesc$225034 = -40					; size = 28
__$EHRec$ = -12						; size = 12
_eFlavor$ = 8						; size = 4
?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z PROC	; CvPlayerTechs::LogFlavors, COMDAT
; _this$ = ecx

; 1680 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 224				; 000000e0H
	push	ebx
	mov	ebx, ecx

; 1681 : 	if(GC.getLogging() && GC.getAILogging())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getLogging@CvGlobals@@QAE_NXZ		; CvGlobals::getLogging
	test	al, al
	je	$LN8@LogFlavors
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getAILogging@CvGlobals@@QAE_NXZ	; CvGlobals::getAILogging
	test	al, al
	je	$LN8@LogFlavors

; 1682 : 	{
; 1683 : 		CvString strOutBuf;

	lea	ecx, DWORD PTR _strOutBuf$225030[esp+240]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1684 : 		CvString strBaseString;

	lea	ecx, DWORD PTR _strBaseString$225031[esp+240]
	mov	DWORD PTR __$EHRec$[esp+248], 0
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1685 : 		CvString strTemp;

	lea	ecx, DWORD PTR _strTemp$225032[esp+240]
	mov	BYTE PTR __$EHRec$[esp+248], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1686 : 		CvString playerName;

	lea	ecx, DWORD PTR _playerName$225033[esp+240]
	mov	BYTE PTR __$EHRec$[esp+248], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1687 : 		CvString strDesc;

	lea	ecx, DWORD PTR _strDesc$225034[esp+240]
	mov	BYTE PTR __$EHRec$[esp+248], 3
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1688 : 		CvString strLogName;

	lea	ecx, DWORD PTR _strLogName$225035[esp+240]
	mov	BYTE PTR __$EHRec$[esp+248], 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1689 : 
; 1690 : 		// Find the name of this civ
; 1691 : 		playerName = m_pPlayer->getCivilizationShortDescription();

	mov	ecx, DWORD PTR [ebx+44]
	mov	BYTE PTR __$EHRec$[esp+248], 5
	call	?getCivilizationShortDescription@CvPlayer@@QBEPBDXZ ; CvPlayer::getCivilizationShortDescription
	lea	ecx, DWORD PTR _playerName$225033[esp+240]
	test	eax, eax
	je	SHORT $LN41@LogFlavors
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN40@LogFlavors
$LN41@LogFlavors:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN40@LogFlavors:
	push	ebp
	push	esi
	push	edi

; 1692 : 
; 1693 : 		// Open the log file
; 1694 : 		if(GC.getPlayerAndCityAILogSplit())

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getPlayerAndCityAILogSplit@CvGlobals@@QAE_NXZ ; CvGlobals::getPlayerAndCityAILogSplit
	mov	ebp, DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	test	al, al
	je	SHORT $LN7@LogFlavors

; 1695 : 		{
; 1696 : 			strLogName = "TechAILog_" + playerName + ".csv";

	lea	eax, DWORD PTR _playerName$225033[esp+252]
	push	eax
	lea	ecx, DWORD PTR $T228476[esp+256]
	push	OFFSET $SG225040
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	push	OFFSET $SG225039
	push	eax
	lea	edx, DWORD PTR $T228477[esp+272]
	push	edx
	mov	BYTE PTR __$EHRec$[esp+284], 6
	call	ebp
	add	esp, 24					; 00000018H
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+260], 7
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strLogName$225035[esp+256]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T228477[esp+252]
	mov	BYTE PTR __$EHRec$[esp+260], 6
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR $T228476[esp+252]
	mov	BYTE PTR __$EHRec$[esp+260], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1697 : 		}
; 1698 : 		else

	jmp	SHORT $LN46@LogFlavors
$LN7@LogFlavors:

; 1699 : 		{
; 1700 : 			strLogName = "TechAILog.csv";

	push	OFFSET $SG225042
	lea	ecx, DWORD PTR _strLogName$225035[esp+256]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
$LN46@LogFlavors:

; 1701 : 		}
; 1702 : 
; 1703 : 		FILogFile* pLog;
; 1704 : 		pLog = LOGFILEMGR.GetLog(strLogName, FILogFile::kDontTimeStamp);

	call	?GetInstance@FILogFileMgr@@SAAAV1@XZ	; FILogFileMgr::GetInstance
	lea	ecx, DWORD PTR _strLogName$225035[esp+252]
	mov	esi, eax
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [esi]
	push	0
	push	1
	push	eax
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, esi
	call	eax

; 1705 : 
; 1706 : 		// Get the leading info for this line
; 1707 : 		strBaseString.Format("%03d, ", GC.getGame().getElapsedGameTurns());

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	mov	edi, eax
	call	?getElapsedGameTurns@CvGame@@QBEHXZ	; CvGame::getElapsedGameTurns
	push	eax
	lea	ecx, DWORD PTR _strBaseString$225031[esp+256]
	push	OFFSET $SG225044
	push	ecx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 1708 : 		strBaseString += playerName + ", ";

	push	OFFSET $SG225046
	lea	edx, DWORD PTR _playerName$225033[esp+268]
	push	edx
	lea	eax, DWORD PTR $T228478[esp+272]
	push	eax
	call	ebp
	add	esp, 24					; 00000018H
	push	eax
	lea	ecx, DWORD PTR _strBaseString$225031[esp+256]
	mov	BYTE PTR __$EHRec$[esp+264], 8
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T228478[esp+252]
	mov	BYTE PTR __$EHRec$[esp+260], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1709 : 
; 1710 : 		// Dump out the setting for each flavor
; 1711 : 		if(eFlavor == NO_FLAVOR)

	mov	esi, DWORD PTR _eFlavor$[esp+248]
	cmp	esi, -1
	jne	$LN5@LogFlavors

; 1712 : 		{
; 1713 : 			for(int iI = 0; iI < GC.getNumFlavorTypes(); iI++)

	xor	esi, esi
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764, esi
	jle	$LN1@LogFlavors
	xor	ebp, ebp
	npad	12
$LL4@LogFlavors:

; 1714 : 			{
; 1715 : 				strTemp.Format("Flavor, %s, %d", GC.getFlavorTypes((FlavorTypes)iI).GetCString(), m_piLatestFlavorValues[iI]);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	add	ecx, ebp
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [ebx+8]
	mov	ecx, DWORD PTR [edx+esi*4]
	push	ecx
	push	eax
	lea	edx, DWORD PTR _strTemp$225032[esp+260]
	push	OFFSET $SG225053
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 1716 : 				strOutBuf = strBaseString + strTemp;

	lea	eax, DWORD PTR _strTemp$225032[esp+268]
	push	eax
	lea	ecx, DWORD PTR _strBaseString$225031[esp+272]
	push	ecx
	lea	edx, DWORD PTR $T228479[esp+276]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 28					; 0000001cH
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+260], 9
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$225030[esp+256]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T228479[esp+252]
	mov	BYTE PTR __$EHRec$[esp+260], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1717 : 				pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$225030[esp+252]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	edi
	call	edx
	inc	esi
	add	esp, 8
	add	ebp, 28					; 0000001cH
	cmp	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	jl	$LL4@LogFlavors

; 1718 : 			}
; 1719 : 		}
; 1720 : 		else

	jmp	$LN1@LogFlavors
$LN5@LogFlavors:

; 1721 : 		{
; 1722 : 			strTemp.Format("Flavor, %s, %d", GC.getFlavorTypes(eFlavor).GetCString(), m_piLatestFlavorValues[eFlavor]);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1760
	lea	eax, DWORD PTR [esi*8]
	sub	eax, esi
	lea	ecx, DWORD PTR [ecx+eax*4]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	edx, DWORD PTR [ebx+8]
	mov	ecx, DWORD PTR [edx+esi*4]
	push	ecx
	push	eax
	lea	edx, DWORD PTR _strTemp$225032[esp+260]
	push	OFFSET $SG225056
	push	edx
	call	?Format@CvString@@QAAXPBDZZ		; CvString::Format

; 1723 : 			strOutBuf = strBaseString + strTemp;

	lea	eax, DWORD PTR _strTemp$225032[esp+268]
	push	eax
	lea	ecx, DWORD PTR _strBaseString$225031[esp+272]
	push	ecx
	lea	edx, DWORD PTR $T228480[esp+276]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@0@Z
	add	esp, 28					; 0000001cH
	mov	ecx, eax
	mov	BYTE PTR __$EHRec$[esp+260], 10		; 0000000aH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR _strOutBuf$225030[esp+256]
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	lea	ecx, DWORD PTR $T228480[esp+252]
	mov	BYTE PTR __$EHRec$[esp+260], 5
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1724 : 			pLog->Msg(strOutBuf);

	lea	ecx, DWORD PTR _strOutBuf$225030[esp+252]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	edi
	call	edx
	add	esp, 8
$LN1@LogFlavors:

; 1725 : 		}
; 1726 : 	}

	lea	ecx, DWORD PTR _strLogName$225035[esp+252]
	mov	BYTE PTR __$EHRec$[esp+260], 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strDesc$225034[esp+252]
	mov	BYTE PTR __$EHRec$[esp+260], 3
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _playerName$225033[esp+252]
	mov	BYTE PTR __$EHRec$[esp+260], 2
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strTemp$225032[esp+252]
	mov	BYTE PTR __$EHRec$[esp+260], 1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strBaseString$225031[esp+252]
	mov	BYTE PTR __$EHRec$[esp+260], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strOutBuf$225030[esp+252]
	mov	DWORD PTR __$EHRec$[esp+260], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebp
$LN8@LogFlavors:

; 1727 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+240]
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 236				; 000000ecH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z$0:
	lea	ecx, DWORD PTR _strOutBuf$225030[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z$1:
	lea	ecx, DWORD PTR _strBaseString$225031[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z$2:
	lea	ecx, DWORD PTR _strTemp$225032[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z$3:
	lea	ecx, DWORD PTR _playerName$225033[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z$4:
	lea	ecx, DWORD PTR _strDesc$225034[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z$5:
	lea	ecx, DWORD PTR _strLogName$225035[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z$6:
	lea	ecx, DWORD PTR $T228476[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z$7:
	lea	ecx, DWORD PTR $T228477[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z$8:
	lea	ecx, DWORD PTR $T228478[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z$9:
	lea	ecx, DWORD PTR $T228479[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z$10:
	lea	ecx, DWORD PTR $T228480[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?LogFlavors@CvPlayerTechs@@EAEXW4FlavorTypes@@@Z ENDP	; CvPlayerTechs::LogFlavors
PUBLIC	?Uninit@CvTeamTechs@@QAEXXZ			; CvTeamTechs::Uninit
; Function compile flags: /Ogtpy
;	COMDAT ?Uninit@CvTeamTechs@@QAEXXZ
_TEXT	SEGMENT
?Uninit@CvTeamTechs@@QAEXXZ PROC			; CvTeamTechs::Uninit, COMDAT
; _this$ = ecx

; 1773 : {

	push	esi
	mov	esi, ecx

; 1774 : 	SAFE_DELETE_ARRAY(m_pabHasTech);

	mov	eax, DWORD PTR [esi+4]
	push	edi
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	xor	edi, edi
	mov	DWORD PTR [esi+4], edi

; 1775 : 	SAFE_DELETE_ARRAY(m_pabNoTradeTech);

	mov	ecx, DWORD PTR [esi+8]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+8], edi

; 1776 : 	SAFE_DELETE_ARRAY(m_paiResearchProgress);

	mov	edx, DWORD PTR [esi+12]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+12], edi

; 1777 : 	SAFE_DELETE_ARRAY(m_paiTechCount);

	mov	eax, DWORD PTR [esi+16]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+16], edi
	pop	edi
	pop	esi

; 1778 : }

	ret	0
?Uninit@CvTeamTechs@@QAEXXZ ENDP			; CvTeamTechs::Uninit
_TEXT	ENDS
PUBLIC	?Reset@CvTeamTechs@@QAEXXZ			; CvTeamTechs::Reset
; Function compile flags: /Ogtpy
;	COMDAT ?Reset@CvTeamTechs@@QAEXXZ
_TEXT	SEGMENT
?Reset@CvTeamTechs@@QAEXXZ PROC				; CvTeamTechs::Reset, COMDAT
; _this$ = ecx

; 1783 : #ifdef AUI_WARNING_FIXES
; 1784 : 	uint iI;
; 1785 : #else
; 1786 : 	int iI;
; 1787 : #endif
; 1788 : 
; 1789 : 	m_eLastTechAcquired = NO_TECH;
; 1790 : 
; 1791 : 	for(iI = 0; iI < m_pTechs->GetNumTechs(); iI++)

	mov	edx, DWORD PTR [ecx+20]
	push	esi
	mov	DWORD PTR [ecx], -1
	mov	esi, DWORD PTR [edx+8]
	sub	esi, DWORD PTR [edx+4]
	xor	eax, eax
	test	esi, -4					; fffffffcH
	jle	SHORT $LN1@Reset@2
	npad	6
$LL3@Reset@2:

; 1792 : 	{
; 1793 : 		m_pabHasTech[iI] = false;

	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [eax+edx], 0

; 1794 : 		m_pabNoTradeTech[iI] = false;

	mov	edx, DWORD PTR [ecx+8]
	mov	BYTE PTR [eax+edx], 0

; 1795 : 		m_paiResearchProgress[iI] = 0;

	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+eax*4], 0

; 1796 : 		m_paiTechCount[iI] = 0;

	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [edx+eax*4], 0
	mov	edx, DWORD PTR [ecx+20]
	mov	esi, DWORD PTR [edx+8]
	sub	esi, DWORD PTR [edx+4]
	inc	eax
	sar	esi, 2
	cmp	eax, esi
	jl	SHORT $LL3@Reset@2
$LN1@Reset@2:
	pop	esi

; 1797 : 	}
; 1798 : }

	ret	0
?Reset@CvTeamTechs@@QAEXXZ ENDP				; CvTeamTechs::Reset
_TEXT	ENDS
PUBLIC	?Read@CvTeamTechs@@QAEXAAVFDataStream@@@Z	; CvTeamTechs::Read
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4TechTypes@@@Z:PROC ; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ?Read@CvTeamTechs@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -8					; size = 4
_this$ = -4						; size = 4
_iNumSavedTechs$ = 8					; size = 4
_kStream$ = 8						; size = 4
?Read@CvTeamTechs@@QAEXAAVFDataStream@@@Z PROC		; CvTeamTechs::Read, COMDAT
; _this$ = ecx

; 1889 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx

; 1890 : 	// Version number to maintain backwards compatibility
; 1891 : 	uint uiVersion;
; 1892 : 	kStream >> uiVersion;

	mov	ebx, DWORD PTR _kStream$[ebp]
	push	esi
	push	edi
	mov	esi, ecx
	lea	eax, DWORD PTR _uiVersion$[ebp]
	push	eax
	mov	ecx, ebx
	mov	DWORD PTR _this$[ebp], esi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 1893 : 
; 1894 : 	kStream >> m_eLastTechAcquired;

	push	esi
	push	ebx
	call	??5@YAAAVFDataStream@@AAV0@AAW4TechTypes@@@Z ; operator>>
	add	esp, 8

; 1895 : 
; 1896 : 	// Read the number of techs
; 1897 : #ifdef AUI_WARNING_FIXES
; 1898 : 	uint iNumSavedTechs;
; 1899 : 	kStream >> iNumSavedTechs;
; 1900 : 
; 1901 : 	if (iNumSavedTechs)
; 1902 : 	{
; 1903 : 		uint iNumActiveTechs = m_pTechs->GetNumTechs();
; 1904 : #else
; 1905 : 	int iNumSavedTechs;
; 1906 : 	kStream >> iNumSavedTechs;

	lea	ecx, DWORD PTR _iNumSavedTechs$[ebp]
	push	ecx
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 1907 : 
; 1908 : 	if(iNumSavedTechs)

	mov	ecx, DWORD PTR _iNumSavedTechs$[ebp]
	test	ecx, ecx
	je	$LN22@Read

; 1909 : 	{
; 1910 : 		int iNumActiveTechs = m_pTechs->GetNumTechs();

	mov	eax, DWORD PTR [esi+20]
	mov	esi, DWORD PTR [eax+8]
	sub	esi, DWORD PTR [eax+4]

; 1911 : #endif
; 1912 : 
; 1913 : 		// Next is an array of the tech IDs that were available when the save was made.
; 1914 : 		CvAssert(m_pTechs == GC.GetGameTechs());	// The hash to indices conversion will convert the hash to the index in the main game techs array, so these better be the same.
; 1915 : 		int* paTechIDs = (int*)_malloca(iNumSavedTechs * sizeof(int));

	lea	eax, DWORD PTR [ecx*4+8]
	sar	esi, 2
	cmp	eax, 1024				; 00000400H
	ja	SHORT $LN4@Read
	call	__alloca_probe_16
	mov	edi, esp
	test	edi, edi
	je	SHORT $LN5@Read
	mov	DWORD PTR [edi], 52428			; 0000ccccH
	add	edi, 8
	jmp	SHORT $LN5@Read
$LN4@Read:
	push	eax
	call	DWORD PTR __imp__malloc
	add	esp, 4
	test	eax, eax
	je	SHORT $LN17@Read
	mov	DWORD PTR [eax], 56797			; 0000ddddH
	add	eax, 8
$LN17@Read:
	mov	edi, eax
$LN5@Read:

; 1916 : 		CvInfosSerializationHelper::ReadHashedTypeArray(kStream, iNumSavedTechs, paTechIDs, iNumSavedTechs);

	mov	eax, DWORD PTR _iNumSavedTechs$[ebp]
	push	eax
	push	edi
	push	eax
	push	ebx
	call	??$ReadHashedTypeArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@IPAHI@Z ; CvInfosSerializationHelper::ReadHashedTypeArray<int>

; 1917 : 
; 1918 : 		CvInfosSerializationHelper::ReadAndRemapDataArray(kStream, iNumSavedTechs, m_pabHasTech, iNumActiveTechs, paTechIDs);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _iNumSavedTechs$[ebp]
	push	edi
	push	esi
	push	eax
	push	ecx
	push	ebx
	call	??$ReadAndRemapDataArray@_N@CvInfosSerializationHelper@@YA_NAAVFDataStream@@HPA_NHPBH@Z ; CvInfosSerializationHelper::ReadAndRemapDataArray<bool>

; 1919 : 		CvInfosSerializationHelper::ReadAndRemapDataArray(kStream, iNumSavedTechs, m_pabNoTradeTech, iNumActiveTechs, paTechIDs);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _iNumSavedTechs$[ebp]
	push	edi
	push	esi
	push	eax
	push	ecx
	push	ebx
	call	??$ReadAndRemapDataArray@_N@CvInfosSerializationHelper@@YA_NAAVFDataStream@@HPA_NHPBH@Z ; CvInfosSerializationHelper::ReadAndRemapDataArray<bool>

; 1920 : 		CvInfosSerializationHelper::ReadAndRemapDataArray(kStream, iNumSavedTechs, m_paiResearchProgress, iNumActiveTechs, paTechIDs);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _iNumSavedTechs$[ebp]
	push	edi
	push	esi
	push	eax
	push	ecx
	push	ebx
	call	??$ReadAndRemapDataArray@H@CvInfosSerializationHelper@@YA_NAAVFDataStream@@HPAHHPBH@Z ; CvInfosSerializationHelper::ReadAndRemapDataArray<int>

; 1921 : 		CvInfosSerializationHelper::ReadAndRemapDataArray(kStream, iNumSavedTechs, m_paiTechCount, iNumActiveTechs, paTechIDs);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR _iNumSavedTechs$[ebp]
	add	esp, 76					; 0000004cH
	push	edi
	push	esi
	push	eax
	push	ecx
	push	ebx
	call	??$ReadAndRemapDataArray@H@CvInfosSerializationHelper@@YA_NAAVFDataStream@@HPAHHPBH@Z ; CvInfosSerializationHelper::ReadAndRemapDataArray<int>
	add	esp, 20					; 00000014H

; 1922 : 
; 1923 : 		_freea(paTechIDs);

	test	edi, edi
	je	SHORT $LN22@Read
	cmp	DWORD PTR [edi-8], 56797		; 0000ddddH
	lea	eax, DWORD PTR [edi-8]
	jne	SHORT $LN22@Read
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
$LN22@Read:

; 1924 : 	}
; 1925 : }

	lea	esp, DWORD PTR [ebp-20]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?Read@CvTeamTechs@@QAEXAAVFDataStream@@@Z ENDP		; CvTeamTechs::Read
_TEXT	ENDS
PUBLIC	?SetHasTech@CvTeamTechs@@QAEXW4TechTypes@@_N@Z	; CvTeamTechs::SetHasTech
EXTRN	??1CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::~CvLuaArgsHandle
EXTRN	?CallHook@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z:PROC ; LuaSupport::CallHook
EXTRN	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ:PROC	; CvTeam::GetID
EXTRN	??0CvLuaArgsHandle@@QAE@XZ:PROC			; CvLuaArgsHandle::CvLuaArgsHandle
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\lua\cvluaargshandle.h
xdata$x	SEGMENT
__unwindtable$?SetHasTech@CvTeamTechs@@QAEXW4TechTypes@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetHasTech@CvTeamTechs@@QAEXW4TechTypes@@_N@Z$0
__ehfuncinfo$?SetHasTech@CvTeamTechs@@QAEXW4TechTypes@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SetHasTech@CvTeamTechs@@QAEXW4TechTypes@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtechclasses.cpp
xdata$x	ENDS
;	COMDAT ?SetHasTech@CvTeamTechs@@QAEXW4TechTypes@@_N@Z
_TEXT	SEGMENT
_args$225284 = -20					; size = 4
_pkScriptSystem$225282 = -16				; size = 4
__$EHRec$ = -12						; size = 12
_eIndex$ = 8						; size = 4
_bNewValue$ = 12					; size = 1
_bResult$225285 = 12					; size = 1
?SetHasTech@CvTeamTechs@@QAEXW4TechTypes@@_N@Z PROC	; CvTeamTechs::SetHasTech, COMDAT
; _this$ = ecx

; 1966 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?SetHasTech@CvTeamTechs@@QAEXW4TechTypes@@_N@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx

; 1967 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 1968 : 	CvAssertMsg(eIndex < GC.getNumTechInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 1969 : 
; 1970 : 	if(m_pabHasTech[eIndex] != bNewValue)

	mov	ebx, DWORD PTR _bNewValue$[esp+20]
	push	ebp
	mov	ebp, ecx
	mov	eax, DWORD PTR [ebp+4]
	mov	ecx, DWORD PTR _eIndex$[esp+24]
	add	eax, ecx
	cmp	BYTE PTR [eax], bl
	je	$LN1@SetHasTech

; 1971 : 	{
; 1972 : 		m_pabHasTech[eIndex] = bNewValue;

	mov	BYTE PTR [eax], bl

; 1973 : 
; 1974 : 		if(bNewValue)

	test	bl, bl
	je	SHORT $LN7@SetHasTech

; 1975 : 			SetLastTechAcquired(eIndex);

	mov	DWORD PTR [ebp], ecx
$LN7@SetHasTech:

; 1976 : 
; 1977 : 		ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	DWORD PTR _pkScriptSystem$225282[esp+28], eax

; 1978 : 		if(pkScriptSystem)

	test	eax, eax
	je	SHORT $LN1@SetHasTech
	push	esi
	push	edi

; 1979 : 		{
; 1980 : 			CvLuaArgsHandle args;

	lea	ecx, DWORD PTR _args$225284[esp+36]
	call	??0CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::CvLuaArgsHandle

; 1981 : 			args->Push(m_pTeam->GetID());

	mov	eax, DWORD PTR _args$225284[esp+36]
	mov	esi, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ebp+24]
	mov	DWORD PTR __$EHRec$[esp+44], 0
	mov	edi, eax
	add	esi, 8
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	mov	edx, DWORD PTR [esi]
	push	eax
	mov	ecx, edi
	call	edx

; 1982 : 			args->Push(eIndex);

	mov	ecx, DWORD PTR _args$225284[esp+36]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR _eIndex$[esp+32]
	mov	eax, DWORD PTR [eax+8]
	push	edx
	call	eax

; 1983 : 			args->Push(bNewValue);

	mov	ecx, DWORD PTR _args$225284[esp+36]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+16]
	push	ebx
	call	eax

; 1984 : 
; 1985 : 			// Attempt to execute the game events.
; 1986 : 			// Will return false if there are no registered listeners.
; 1987 : 			bool bResult = false;
; 1988 : 			LuaSupport::CallHook(pkScriptSystem, "TeamSetHasTech", args.get(), bResult);

	mov	edx, DWORD PTR _args$225284[esp+36]
	mov	eax, DWORD PTR _pkScriptSystem$225282[esp+36]
	lea	ecx, DWORD PTR _bResult$225285[esp+32]
	push	ecx
	push	edx
	push	OFFSET $SG225286
	push	eax
	mov	BYTE PTR _bResult$225285[esp+48], 0
	call	?CallHook@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallHook
	add	esp, 16					; 00000010H

; 1989 : 		}

	lea	ecx, DWORD PTR _args$225284[esp+36]
	mov	DWORD PTR __$EHRec$[esp+44], -1
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
	pop	edi
	pop	esi
$LN1@SetHasTech:

; 1990 : 	}
; 1991 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetHasTech@CvTeamTechs@@QAEXW4TechTypes@@_N@Z$0:
	lea	ecx, DWORD PTR _args$225284[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__ehhandler$?SetHasTech@CvTeamTechs@@QAEXW4TechTypes@@_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?SetHasTech@CvTeamTechs@@QAEXW4TechTypes@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetHasTech@CvTeamTechs@@QAEXW4TechTypes@@_N@Z ENDP	; CvTeamTechs::SetHasTech
PUBLIC	?HasResearchedAllTechs@CvTeamTechs@@QBE_NXZ	; CvTeamTechs::HasResearchedAllTechs
; Function compile flags: /Ogtpy
;	COMDAT ?HasResearchedAllTechs@CvTeamTechs@@QBE_NXZ
_TEXT	SEGMENT
?HasResearchedAllTechs@CvTeamTechs@@QBE_NXZ PROC	; CvTeamTechs::HasResearchedAllTechs, COMDAT
; _this$ = ecx

; 2047 : {

	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 2048 : #ifdef AUI_WARNING_FIXES
; 2049 : 	uint iNumTechs = 0;
; 2050 : 	for (uint iTechLoop = 0; iTechLoop < GC.getNumTechInfos(); iTechLoop++)
; 2051 : #else
; 2052 : 	int iNumTechs = 0;
; 2053 : 
; 2054 : 	for(int iTechLoop = 0; iTechLoop < GC.getNumTechInfos(); iTechLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	ebx, ebx
	xor	esi, esi
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	test	eax, eax
	jle	SHORT $LN3@HasResearc
$LL5@HasResearc:

; 2055 : #endif
; 2056 : 	{
; 2057 : 		if(HasTech((TechTypes) iTechLoop) || GetTechCount((TechTypes)iTechLoop) > 0)

	cmp	esi, -1
	je	SHORT $LN1@HasResearc
	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	je	SHORT $LN21@HasResearc
	cmp	BYTE PTR [eax+esi], 0
	jne	SHORT $LN1@HasResearc
$LN21@HasResearc:
	mov	eax, DWORD PTR [edi+16]
	cmp	DWORD PTR [eax+esi*4], 0
	jle	SHORT $LN4@HasResearc
$LN1@HasResearc:

; 2058 : 		{
; 2059 : 			iNumTechs++;

	inc	ebx
$LN4@HasResearc:

; 2048 : #ifdef AUI_WARNING_FIXES
; 2049 : 	uint iNumTechs = 0;
; 2050 : 	for (uint iTechLoop = 0; iTechLoop < GC.getNumTechInfos(); iTechLoop++)
; 2051 : #else
; 2052 : 	int iNumTechs = 0;
; 2053 : 
; 2054 : 	for(int iTechLoop = 0; iTechLoop < GC.getNumTechInfos(); iTechLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	cmp	esi, eax
	jl	SHORT $LL5@HasResearc
$LN3@HasResearc:

; 2060 : 		}
; 2061 : 	}
; 2062 : 
; 2063 : 	return (iNumTechs >= m_pTechs->GetNumTechs());

	mov	eax, DWORD PTR [edi+20]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR [eax+4]
	pop	edi
	sar	ecx, 2
	xor	eax, eax
	cmp	ebx, ecx
	pop	esi
	setge	al
	pop	ebx

; 2064 : }

	ret	0
?HasResearchedAllTechs@CvTeamTechs@@QBE_NXZ ENDP	; CvTeamTechs::HasResearchedAllTechs
_TEXT	ENDS
PUBLIC	?GetResearchCost@CvTeamTechs@@QBEHW4TechTypes@@@Z ; CvTeamTechs::GetResearchCost
EXTRN	?getNumMembers@CvTeam@@QBEHXZ:PROC		; CvTeam::getNumMembers
EXTRN	?getResearchPercent@CvEraInfo@@QBEHXZ:PROC	; CvEraInfo::getResearchPercent
EXTRN	?getStartEraInfo@CvGame@@QBEAAVCvEraInfo@@XZ:PROC ; CvGame::getStartEraInfo
EXTRN	?getResearchPercent@CvGameSpeedInfo@@QBEHXZ:PROC ; CvGameSpeedInfo::getResearchPercent
EXTRN	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ:PROC ; CvGame::getGameSpeedInfo
EXTRN	?getResearchPercent@CvWorldInfo@@QBEHXZ:PROC	; CvWorldInfo::getResearchPercent
EXTRN	?getWorldInfo@CvMap@@QBEABVCvWorldInfo@@XZ:PROC	; CvMap::getWorldInfo
EXTRN	?getResearchPercent@CvHandicapInfo@@QBEHXZ:PROC	; CvHandicapInfo::getResearchPercent
EXTRN	?getHandicapInfo@CvGlobals@@QAEPAVCvHandicapInfo@@W4HandicapTypes@@@Z:PROC ; CvGlobals::getHandicapInfo
EXTRN	?getHandicapType@CvTeam@@QBE?AW4HandicapTypes@@XZ:PROC ; CvTeam::getHandicapType
; Function compile flags: /Ogtpy
;	COMDAT ?GetResearchCost@CvTeamTechs@@QBEHW4TechTypes@@@Z
_TEXT	SEGMENT
$T228746 = -4						; size = 4
$T228745 = -4						; size = 4
$T228744 = 8						; size = 4
_iCost$ = 8						; size = 4
_eTech$ = 8						; size = 4
?GetResearchCost@CvTeamTechs@@QBEHW4TechTypes@@@Z PROC	; CvTeamTechs::GetResearchCost, COMDAT
; _this$ = ecx

; 2232 : {

	push	ecx

; 2233 : 	CvAssertMsg(eTech != NO_TECH, "Tech is not assigned a valid value");
; 2234 : 	CvTechEntry* pkTechInfo = GC.getTechInfo(eTech);

	mov	eax, DWORD PTR _eTech$[esp]
	push	ebx
	mov	ebx, ecx
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo

; 2235 : 	if(pkTechInfo == NULL)

	test	eax, eax
	jne	SHORT $LN2@GetResearc@3
	pop	ebx

; 2307 : }

	pop	ecx
	ret	4
$LN2@GetResearc@3:

; 2236 : 	{
; 2237 : 		return 0;
; 2238 : 	}
; 2239 : 
; 2240 : 	int iCost = pkTechInfo->GetResearchCost();
; 2241 : 
; 2242 : 	CvHandicapInfo* pkHandicapInfo = GC.getHandicapInfo(m_pTeam->getHandicapType());

	mov	ecx, DWORD PTR [ebx+24]
	push	esi
	mov	esi, DWORD PTR [eax+268]
	call	?getHandicapType@CvTeam@@QBE?AW4HandicapTypes@@XZ ; CvTeam::getHandicapType
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getHandicapInfo@CvGlobals@@QAEPAVCvHandicapInfo@@W4HandicapTypes@@@Z ; CvGlobals::getHandicapInfo

; 2243 : 	if(pkHandicapInfo)

	test	eax, eax
	je	SHORT $LN1@GetResearc@3

; 2244 : 	{
; 2245 : 		iCost *= pkHandicapInfo->getResearchPercent();

	mov	ecx, eax
	call	?getResearchPercent@CvHandicapInfo@@QBEHXZ ; CvHandicapInfo::getResearchPercent
	mov	ecx, eax
	imul	ecx, esi

; 2246 : 		iCost /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	mov	esi, ecx
$LN1@GetResearc@3:

; 2247 : 	}
; 2248 : 
; 2249 : 	//here
; 2250 : 
; 2251 : 	iCost *= GC.getMap().getWorldInfo().getResearchPercent();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	push	edi
	call	?getWorldInfo@CvMap@@QBEABVCvWorldInfo@@XZ ; CvMap::getWorldInfo
	mov	ecx, eax
	call	?getResearchPercent@CvWorldInfo@@QBEHXZ	; CvWorldInfo::getResearchPercent
	mov	ecx, eax
	imul	ecx, esi

; 2252 : 	iCost /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx

; 2253 : 
; 2254 : 	iCost *= GC.getGame().getGameSpeedInfo().getResearchPercent();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	sar	edx, 5
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	call	?getGameSpeedInfo@CvGame@@QBEAAVCvGameSpeedInfo@@XZ ; CvGame::getGameSpeedInfo
	mov	ecx, eax
	call	?getResearchPercent@CvGameSpeedInfo@@QBEHXZ ; CvGameSpeedInfo::getResearchPercent
	mov	ecx, eax
	imul	ecx, esi

; 2255 : 	iCost /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx

; 2256 : 
; 2257 : 	iCost *= GC.getGame().getStartEraInfo().getResearchPercent();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	sar	edx, 5
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	call	?getStartEraInfo@CvGame@@QBEAAVCvEraInfo@@XZ ; CvGame::getStartEraInfo
	mov	ecx, eax
	call	?getResearchPercent@CvEraInfo@@QBEHXZ	; CvEraInfo::getResearchPercent
	mov	ecx, eax
	imul	ecx, esi

; 2258 : 	iCost /= 100;
; 2259 : 
; 2260 : 	iCost *= std::max(0, ((GC.getTECH_COST_EXTRA_TEAM_MEMBER_MODIFIER() * (m_pTeam->getNumMembers() - 1)) + 100));

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6676
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	mov	ecx, DWORD PTR [ebx+24]
	sar	edx, 5
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	call	?getNumMembers@CvTeam@@QBEHXZ		; CvTeam::getNumMembers
	dec	eax
	imul	eax, edi
	add	eax, 100				; 00000064H
	mov	DWORD PTR $T228744[esp+12], eax
	test	eax, eax
	mov	DWORD PTR $T228745[esp+16], 0
	pop	edi
	lea	eax, DWORD PTR $T228744[esp+8]
	jg	SHORT $LN18@GetResearc@3
	lea	eax, DWORD PTR $T228745[esp+12]
$LN18@GetResearc@3:
	mov	ecx, DWORD PTR [eax]
	imul	ecx, esi

; 2261 : 	iCost /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _iCost$[esp+8], eax

; 2262 : 
; 2263 : #ifdef AUI_TECH_FIX_TEAMER_RESEARCH_COSTS
; 2264 : 	// Adjust to the players' research modifier
; 2265 : 	int iResearchMod = MAX(1, m_pTeam->calculateResearchModifier(eTech));
; 2266 : 	iCost = (iCost * 10000) / iResearchMod;
; 2267 : 
; 2268 : 	// Mod for City Count
; 2269 : 	int iCityCountMod = GC.getMap().getWorldInfo().GetNumCitiesTechCostMod();	// Default is 40, gets smaller on larger maps
; 2270 : 
; 2271 : 	// NQMP GJS - new Dictatorship of the Proletariat i.e. Communism BEGIN
; 2272 : 	int iWeightedResearchModDiscount = 0;
; 2273 : 	int iCityCount = 0;
; 2274 : 	int iLoopCityCount = 0;
; 2275 : 	for (int iI = 0; iI < MAX_CIV_PLAYERS; iI++)
; 2276 : 	{
; 2277 : 		CvPlayer& kLoopPlayer = GET_PLAYER((PlayerTypes)iI);
; 2278 : 		if (kLoopPlayer.getTeam() == m_pTeam->GetID())
; 2279 : 		{
; 2280 : 			iLoopCityCount = kLoopPlayer.GetMaxEffectiveCities(/*bIncludePuppets*/ true);
; 2281 : 			iCityCount += iLoopCityCount;
; 2282 : 			iWeightedResearchModDiscount += kLoopPlayer.GetNumCitiesResearchCostDiscount() * iLoopCityCount;
; 2283 : 		}
; 2284 : 	}
; 2285 : 	if (iCityCount > 0)
; 2286 : 	{
; 2287 : 		if (iWeightedResearchModDiscount != 0)
; 2288 : 		{
; 2289 : 			iCityCountMod = iCityCountMod * ((100 * iCityCount) + iWeightedResearchModDiscount) / iCityCount;
; 2290 : 			iCityCountMod /= 100;
; 2291 : 		}
; 2292 : 	}
; 2293 : 	// NQMP GJS - new Dictatorship of the Proletariat i.e. Communism END
; 2294 : 
; 2295 : 	iCityCountMod *= iCityCount;
; 2296 : 	iCost = iCost * (100 + iCityCountMod) / 100;
; 2297 : 
; 2298 : 	// We're going to round up so that the user wont get confused when the research progress seems to be equal to the research cost, but it is not acutally done.
; 2299 : 	// This is because the 'real' calculations use the GameCore's fixed point math where things are multiplied by 100
; 2300 : 	if ((iCost % 100) != 0)
; 2301 : 		iCost = (iCost / 100) + 1;
; 2302 : 	else
; 2303 : 		iCost = (iCost / 100);
; 2304 : #endif
; 2305 : 
; 2306 : 	return std::max(1, iCost);

	cmp	eax, 1
	mov	DWORD PTR $T228746[esp+12], 1
	pop	esi
	lea	eax, DWORD PTR _iCost$[esp+4]
	jg	SHORT $LN22@GetResearc@3
	lea	eax, DWORD PTR $T228746[esp+8]
$LN22@GetResearc@3:
	mov	eax, DWORD PTR [eax]
	pop	ebx

; 2307 : }

	pop	ecx
	ret	4
?GetResearchCost@CvTeamTechs@@QBEHW4TechTypes@@@Z ENDP	; CvTeamTechs::GetResearchCost
_TEXT	ENDS
PUBLIC	?GetResearchLeft@CvTeamTechs@@QBEHW4TechTypes@@@Z ; CvTeamTechs::GetResearchLeft
; Function compile flags: /Ogtpy
;	COMDAT ?GetResearchLeft@CvTeamTechs@@QBEHW4TechTypes@@@Z
_TEXT	SEGMENT
$T228789 = -4						; size = 4
$T228788 = 8						; size = 4
_eTech$ = 8						; size = 4
?GetResearchLeft@CvTeamTechs@@QBEHW4TechTypes@@@Z PROC	; CvTeamTechs::GetResearchLeft, COMDAT
; _this$ = ecx

; 2311 : {

	push	ecx
	push	esi
	push	edi

; 2312 : 	return std::max(0, (GetResearchCost(eTech) - GetResearchProgress(eTech)));

	mov	edi, DWORD PTR _eTech$[esp+8]
	cmp	edi, -1
	je	SHORT $LN4@GetResearc@4
	mov	eax, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR [eax+edi*4]
	mov	eax, 1374389535				; 51eb851fH
	imul	edx
	sar	edx, 5
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	jmp	SHORT $LN3@GetResearc@4
$LN4@GetResearc@4:
	xor	esi, esi
$LN3@GetResearc@4:
	push	edi
	call	?GetResearchCost@CvTeamTechs@@QBEHW4TechTypes@@@Z ; CvTeamTechs::GetResearchCost
	sub	eax, esi
	pop	edi
	mov	DWORD PTR $T228788[esp+4], eax
	test	eax, eax
	mov	DWORD PTR $T228789[esp+8], 0
	pop	esi
	lea	eax, DWORD PTR $T228788[esp]
	jg	SHORT $LN11@GetResearc@4
	lea	eax, DWORD PTR $T228789[esp+4]
$LN11@GetResearc@4:
	mov	eax, DWORD PTR [eax]

; 2313 : }

	pop	ecx
	ret	4
?GetResearchLeft@CvTeamTechs@@QBEHW4TechTypes@@@Z ENDP	; CvTeamTechs::GetResearchLeft
_TEXT	ENDS
PUBLIC	?GetMaxResearchOverflow@CvTeamTechs@@ABEHW4TechTypes@@W4PlayerTypes@@@Z ; CvTeamTechs::GetMaxResearchOverflow
EXTRN	?GetScienceTimes100@CvPlayer@@QBEHXZ:PROC	; CvPlayer::GetScienceTimes100
; Function compile flags: /Ogtpy
;	COMDAT ?GetMaxResearchOverflow@CvTeamTechs@@ABEHW4TechTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_iCost$ = 8						; size = 4
_eTech$ = 8						; size = 4
_iReturnValue$ = 12					; size = 4
_ePlayer$ = 12						; size = 4
?GetMaxResearchOverflow@CvTeamTechs@@ABEHW4TechTypes@@W4PlayerTypes@@@Z PROC ; CvTeamTechs::GetMaxResearchOverflow, COMDAT
; _this$ = ecx

; 2367 : 	CvPlayer &kPlayer = GET_PLAYER(ePlayer);

	mov	ecx, DWORD PTR _ePlayer$[esp-4]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	esi

; 2368 : 
; 2369 : 	// 5 turns of science is a reasonable allowance of overflow (about equal to a standard research agreement award)
; 2370 : 	int iReturnValue = kPlayer.GetScienceTimes100() * 5;   

	call	?GetScienceTimes100@CvPlayer@@QBEHXZ	; CvPlayer::GetScienceTimes100
	lea	esi, DWORD PTR [eax+eax*4]

; 2371 : 
; 2372 : 	// Alternatively let it be the raw cost of the tech (times 100)
; 2373 : 	CvTechEntry* pkTechInfo = GC.getTechInfo(eTech);

	mov	eax, DWORD PTR _eTech$[esp]
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR _iReturnValue$[esp+4], esi
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo

; 2374 : 	if(pkTechInfo == NULL)

	test	eax, eax
	jne	SHORT $LN1@GetMaxRese
	pop	esi

; 2384 : }

	ret	8
$LN1@GetMaxRese:

; 2375 : 	{
; 2376 : 		return 0;
; 2377 : 	}
; 2378 : 
; 2379 : 	int iCost = pkTechInfo->GetResearchCost() * 100;

	mov	eax, DWORD PTR [eax+268]
	imul	eax, 100				; 00000064H
	mov	DWORD PTR _iCost$[esp], eax

; 2380 : 
; 2381 : 	iReturnValue = max(iCost, iReturnValue);

	cmp	eax, esi
	lea	eax, DWORD PTR _iReturnValue$[esp]
	jl	SHORT $LN11@GetMaxRese
	lea	eax, DWORD PTR _iCost$[esp]
$LN11@GetMaxRese:

; 2382 : 
; 2383 : 	return iReturnValue;

	mov	eax, DWORD PTR [eax]
	pop	esi

; 2384 : }

	ret	8
?GetMaxResearchOverflow@CvTeamTechs@@ABEHW4TechTypes@@W4PlayerTypes@@@Z ENDP ; CvTeamTechs::GetMaxResearchOverflow
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QBEAAPAVCvTechEntry@@XZ ; std::_Vector_iterator<CvTechEntry *,std::allocator<CvTechEntry *> >::operator*
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QBEAAPAVCvTechEntry@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QBEAAPAVCvTechEntry@@XZ PROC ; std::_Vector_iterator<CvTechEntry *,std::allocator<CvTechEntry *> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QBEAAPAVCvTechEntry@@XZ ENDP ; std::_Vector_iterator<CvTechEntry *,std::allocator<CvTechEntry *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<CvTechEntry *,std::allocator<CvTechEntry *> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<CvTechEntry *,std::allocator<CvTechEntry *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<CvTechEntry *,std::allocator<CvTechEntry *> >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvTechEntry *,std::allocator<CvTechEntry *> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvTechEntry *,std::allocator<CvTechEntry *> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvTechEntry *,std::allocator<CvTechEntry *> >::operator!=
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvTechEntry *,std::allocator<CvTechEntry *> >::~_Vector_val<CvTechEntry *,std::allocator<CvTechEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvTechEntry *,std::allocator<CvTechEntry *> >::~_Vector_val<CvTechEntry *,std::allocator<CvTechEntry *> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvTechEntry *,std::allocator<CvTechEntry *> >::~_Vector_val<CvTechEntry *,std::allocator<CvTechEntry *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@IAE@V?$allocator@PAVCvTechEntry@@@1@@Z ; std::_Vector_val<CvTechEntry *,std::allocator<CvTechEntry *> >::_Vector_val<CvTechEntry *,std::allocator<CvTechEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@IAE@V?$allocator@PAVCvTechEntry@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@IAE@V?$allocator@PAVCvTechEntry@@@1@@Z PROC ; std::_Vector_val<CvTechEntry *,std::allocator<CvTechEntry *> >::_Vector_val<CvTechEntry *,std::allocator<CvTechEntry *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@IAE@V?$allocator@PAVCvTechEntry@@@1@@Z ENDP ; std::_Vector_val<CvTechEntry *,std::allocator<CvTechEntry *> >::_Vector_val<CvTechEntry *,std::allocator<CvTechEntry *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE@PAPAVCvTechEntry@@@Z ; std::_Vector_iterator<CvTechEntry *,std::allocator<CvTechEntry *> >::_Vector_iterator<CvTechEntry *,std::allocator<CvTechEntry *> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE@PAPAVCvTechEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE@PAPAVCvTechEntry@@@Z PROC ; std::_Vector_iterator<CvTechEntry *,std::allocator<CvTechEntry *> >::_Vector_iterator<CvTechEntry *,std::allocator<CvTechEntry *> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE@PAPAVCvTechEntry@@@Z ENDP ; std::_Vector_iterator<CvTechEntry *,std::allocator<CvTechEntry *> >::_Vector_iterator<CvTechEntry *,std::allocator<CvTechEntry *> >
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@2@@Z ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@2@@Z PROC ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@2@@Z ENDP ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QBEIXZ ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVCvTechEntry@@@std@@QAEPAPAVCvTechEntry@@I@Z ; std::allocator<CvTechEntry *>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVCvTechEntry@@@std@@QAEPAPAVCvTechEntry@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVCvTechEntry@@@std@@QAEPAPAVCvTechEntry@@I@Z PROC ; std::allocator<CvTechEntry *>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@PAVCvTechEntry@@@std@@YAPAPAVCvTechEntry@@IPAPAV1@@Z ; std::_Allocate<CvTechEntry *>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@PAVCvTechEntry@@@std@@QAEPAPAVCvTechEntry@@I@Z ENDP ; std::allocator<CvTechEntry *>::allocate
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvTechAI@@@@YAXAAPAVCvTechAI@@@Z ; SAFE_DELETE<CvTechAI>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE@VCvTechAI@@@@YAXAAPAVCvTechAI@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvTechAI@@@@YAXAAPAVCvTechAI@@@Z PROC	; SAFE_DELETE<CvTechAI>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN8@SAFE_DELET
	mov	ecx, esi
	call	??1CvTechAI@@QAE@XZ			; CvTechAI::~CvTechAI
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@SAFE_DELET:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvTechAI@@@@YAXAAPAVCvTechAI@@@Z ENDP	; SAFE_DELETE<CvTechAI>
_TEXT	ENDS
PUBLIC	??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<bool>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfosserializationhelper.h
;	COMDAT ??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z
_TEXT	SEGMENT
_tValue$225614 = -7					; size = 1
_bValid$225611 = -6					; size = 1
_tValue$225619 = -5					; size = 1
_uiNumEntries$ = -4					; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_iArraySize$ = 16					; size = 4
??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z PROC ; CvInfosSerializationHelper::ReadHashedDataArray<bool>, COMDAT

; 248  : {

	sub	esp, 8
	push	ebx
	push	edi

; 249  : 	uint uiNumEntries;
; 250  : 
; 251  : 	kStream >> uiNumEntries;

	mov	edi, DWORD PTR _kStream$[esp+12]
	lea	eax, DWORD PTR _uiNumEntries$[esp+16]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 252  : 
; 253  : 	for(uint iI = 0; iI < uiNumEntries; iI++)

	xor	ebx, ebx
	cmp	DWORD PTR _uiNumEntries$[esp+16], ebx
	jbe	SHORT $LN5@ReadHashed@2
	push	ebp
	mov	ebp, DWORD PTR _iArraySize$[esp+16]
	push	esi
$LL7@ReadHashed@2:

; 254  : 	{
; 255  : 		bool bValid;
; 256  : 		int iType = ReadHashed(kStream, &bValid);

	lea	ecx, DWORD PTR _bValid$225611[esp+24]
	push	ecx
	push	edi
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	mov	esi, eax
	add	esp, 8

; 257  : 		if(iType != -1)

	cmp	esi, -1
	je	SHORT $LN4@ReadHashed@2

; 258  : 		{
; 259  : 			TData tValue;
; 260  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$225614[esp+24]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 261  : 			if((int)iType < iArraySize)

	cmp	esi, ebp
	jge	SHORT $LN6@ReadHashed@2

; 262  : 				paArray[iType] = tValue;

	mov	al, BYTE PTR _tValue$225614[esp+24]
	mov	ecx, DWORD PTR _paArray$[esp+20]
	mov	BYTE PTR [esi+ecx], al

; 263  : 		}

	jmp	SHORT $LN6@ReadHashed@2
$LN4@ReadHashed@2:

; 264  : 		else if(!bValid)

	cmp	BYTE PTR _bValid$225611[esp+24], 0
	jne	SHORT $LN6@ReadHashed@2

; 265  : 		{
; 266  : 			TData tValue;
; 267  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$225619[esp+24]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read
$LN6@ReadHashed@2:
	inc	ebx
	cmp	ebx, DWORD PTR _uiNumEntries$[esp+24]
	jb	SHORT $LL7@ReadHashed@2
	pop	esi
	pop	ebp
$LN5@ReadHashed@2:
	pop	edi
	pop	ebx

; 268  : 		}
; 269  : 	}
; 270  : }

	add	esp, 8
	ret	0
??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z ENDP ; CvInfosSerializationHelper::ReadHashedDataArray<bool>
_TEXT	ENDS
PUBLIC	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>
; Function compile flags: /Ogtpy
;	COMDAT ??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z
_TEXT	SEGMENT
_bValid$225626 = -13					; size = 1
_uiNumEntries$ = -12					; size = 4
_tValue$225629 = -8					; size = 4
_tValue$225634 = -4					; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_iArraySize$ = 16					; size = 4
??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z PROC ; CvInfosSerializationHelper::ReadHashedDataArray<int>, COMDAT

; 248  : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	edi

; 249  : 	uint uiNumEntries;
; 250  : 
; 251  : 	kStream >> uiNumEntries;

	mov	edi, DWORD PTR _kStream$[esp+20]
	lea	eax, DWORD PTR _uiNumEntries$[esp+24]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 252  : 
; 253  : 	for(uint iI = 0; iI < uiNumEntries; iI++)

	xor	ebx, ebx
	cmp	DWORD PTR _uiNumEntries$[esp+24], ebx
	jbe	SHORT $LN5@ReadHashed@3
	push	ebp
	mov	ebp, DWORD PTR _iArraySize$[esp+24]
	push	esi
$LL7@ReadHashed@3:

; 254  : 	{
; 255  : 		bool bValid;
; 256  : 		int iType = ReadHashed(kStream, &bValid);

	lea	ecx, DWORD PTR _bValid$225626[esp+32]
	push	ecx
	push	edi
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	mov	esi, eax
	add	esp, 8

; 257  : 		if(iType != -1)

	cmp	esi, -1
	je	SHORT $LN4@ReadHashed@3

; 258  : 		{
; 259  : 			TData tValue;
; 260  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$225629[esp+32]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 261  : 			if((int)iType < iArraySize)

	cmp	esi, ebp
	jge	SHORT $LN6@ReadHashed@3

; 262  : 				paArray[iType] = tValue;

	mov	eax, DWORD PTR _tValue$225629[esp+32]
	mov	ecx, DWORD PTR _paArray$[esp+28]
	mov	DWORD PTR [ecx+esi*4], eax

; 263  : 		}

	jmp	SHORT $LN6@ReadHashed@3
$LN4@ReadHashed@3:

; 264  : 		else if(!bValid)

	cmp	BYTE PTR _bValid$225626[esp+32], 0
	jne	SHORT $LN6@ReadHashed@3

; 265  : 		{
; 266  : 			TData tValue;
; 267  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$225634[esp+32]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
$LN6@ReadHashed@3:
	inc	ebx
	cmp	ebx, DWORD PTR _uiNumEntries$[esp+32]
	jb	SHORT $LL7@ReadHashed@3
	pop	esi
	pop	ebp
$LN5@ReadHashed@3:
	pop	edi
	pop	ebx

; 268  : 		}
; 269  : 	}
; 270  : }

	add	esp, 16					; 00000010H
	ret	0
??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ENDP ; CvInfosSerializationHelper::ReadHashedDataArray<int>
_TEXT	ENDS
PUBLIC	??$ReadHashedDataArray@W4ResourceTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4ResourceTypes@@H@Z ; CvInfosSerializationHelper::ReadHashedDataArray<enum ResourceTypes>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4ResourceTypes@@@Z:PROC ; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ??$ReadHashedDataArray@W4ResourceTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4ResourceTypes@@H@Z
_TEXT	SEGMENT
_bValid$225641 = -13					; size = 1
_uiNumEntries$ = -12					; size = 4
_tValue$225644 = -8					; size = 4
_tValue$225652 = -4					; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_iArraySize$ = 16					; size = 4
??$ReadHashedDataArray@W4ResourceTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4ResourceTypes@@H@Z PROC ; CvInfosSerializationHelper::ReadHashedDataArray<enum ResourceTypes>, COMDAT

; 248  : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	edi

; 249  : 	uint uiNumEntries;
; 250  : 
; 251  : 	kStream >> uiNumEntries;

	mov	edi, DWORD PTR _kStream$[esp+20]
	lea	eax, DWORD PTR _uiNumEntries$[esp+24]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 252  : 
; 253  : 	for(uint iI = 0; iI < uiNumEntries; iI++)

	xor	ebx, ebx
	cmp	DWORD PTR _uiNumEntries$[esp+24], ebx
	jbe	SHORT $LN5@ReadHashed@4
	push	ebp
	mov	ebp, DWORD PTR _iArraySize$[esp+24]
	push	esi
$LL7@ReadHashed@4:

; 254  : 	{
; 255  : 		bool bValid;
; 256  : 		int iType = ReadHashed(kStream, &bValid);

	lea	ecx, DWORD PTR _bValid$225641[esp+32]
	push	ecx
	push	edi
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	mov	esi, eax
	add	esp, 8

; 257  : 		if(iType != -1)

	cmp	esi, -1
	je	SHORT $LN4@ReadHashed@4

; 258  : 		{
; 259  : 			TData tValue;
; 260  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$225644[esp+32]
	push	edx
	push	edi
	call	??5@YAAAVFDataStream@@AAV0@AAW4ResourceTypes@@@Z ; operator>>
	add	esp, 8

; 261  : 			if((int)iType < iArraySize)

	cmp	esi, ebp
	jge	SHORT $LN6@ReadHashed@4

; 262  : 				paArray[iType] = tValue;

	mov	eax, DWORD PTR _tValue$225644[esp+32]
	mov	ecx, DWORD PTR _paArray$[esp+28]
	mov	DWORD PTR [ecx+esi*4], eax

; 263  : 		}

	jmp	SHORT $LN6@ReadHashed@4
$LN4@ReadHashed@4:

; 264  : 		else if(!bValid)

	cmp	BYTE PTR _bValid$225641[esp+32], 0
	jne	SHORT $LN6@ReadHashed@4

; 265  : 		{
; 266  : 			TData tValue;
; 267  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$225652[esp+32]
	push	edx
	push	edi
	call	??5@YAAAVFDataStream@@AAV0@AAW4ResourceTypes@@@Z ; operator>>
	add	esp, 8
$LN6@ReadHashed@4:
	inc	ebx
	cmp	ebx, DWORD PTR _uiNumEntries$[esp+32]
	jb	SHORT $LL7@ReadHashed@4
	pop	esi
	pop	ebp
$LN5@ReadHashed@4:
	pop	edi
	pop	ebx

; 268  : 		}
; 269  : 	}
; 270  : }

	add	esp, 16					; 00000010H
	ret	0
??$ReadHashedDataArray@W4ResourceTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4ResourceTypes@@H@Z ENDP ; CvInfosSerializationHelper::ReadHashedDataArray<enum ResourceTypes>
_TEXT	ENDS
PUBLIC	??$ReadHashedDataArray@W4UnitTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4UnitTypes@@H@Z ; CvInfosSerializationHelper::ReadHashedDataArray<enum UnitTypes>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4UnitTypes@@@Z:PROC ; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ??$ReadHashedDataArray@W4UnitTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4UnitTypes@@H@Z
_TEXT	SEGMENT
_bValid$225659 = -13					; size = 1
_uiNumEntries$ = -12					; size = 4
_tValue$225662 = -8					; size = 4
_tValue$225667 = -4					; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_iArraySize$ = 16					; size = 4
??$ReadHashedDataArray@W4UnitTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4UnitTypes@@H@Z PROC ; CvInfosSerializationHelper::ReadHashedDataArray<enum UnitTypes>, COMDAT

; 248  : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	edi

; 249  : 	uint uiNumEntries;
; 250  : 
; 251  : 	kStream >> uiNumEntries;

	mov	edi, DWORD PTR _kStream$[esp+20]
	lea	eax, DWORD PTR _uiNumEntries$[esp+24]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 252  : 
; 253  : 	for(uint iI = 0; iI < uiNumEntries; iI++)

	xor	ebx, ebx
	cmp	DWORD PTR _uiNumEntries$[esp+24], ebx
	jbe	SHORT $LN5@ReadHashed@5
	push	ebp
	mov	ebp, DWORD PTR _iArraySize$[esp+24]
	push	esi
$LL7@ReadHashed@5:

; 254  : 	{
; 255  : 		bool bValid;
; 256  : 		int iType = ReadHashed(kStream, &bValid);

	lea	ecx, DWORD PTR _bValid$225659[esp+32]
	push	ecx
	push	edi
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	mov	esi, eax
	add	esp, 8

; 257  : 		if(iType != -1)

	cmp	esi, -1
	je	SHORT $LN4@ReadHashed@5

; 258  : 		{
; 259  : 			TData tValue;
; 260  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$225662[esp+32]
	push	edx
	push	edi
	call	??5@YAAAVFDataStream@@AAV0@AAW4UnitTypes@@@Z ; operator>>
	add	esp, 8

; 261  : 			if((int)iType < iArraySize)

	cmp	esi, ebp
	jge	SHORT $LN6@ReadHashed@5

; 262  : 				paArray[iType] = tValue;

	mov	eax, DWORD PTR _tValue$225662[esp+32]
	mov	ecx, DWORD PTR _paArray$[esp+28]
	mov	DWORD PTR [ecx+esi*4], eax

; 263  : 		}

	jmp	SHORT $LN6@ReadHashed@5
$LN4@ReadHashed@5:

; 264  : 		else if(!bValid)

	cmp	BYTE PTR _bValid$225659[esp+32], 0
	jne	SHORT $LN6@ReadHashed@5

; 265  : 		{
; 266  : 			TData tValue;
; 267  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$225667[esp+32]
	push	edx
	push	edi
	call	??5@YAAAVFDataStream@@AAV0@AAW4UnitTypes@@@Z ; operator>>
	add	esp, 8
$LN6@ReadHashed@5:
	inc	ebx
	cmp	ebx, DWORD PTR _uiNumEntries$[esp+32]
	jb	SHORT $LL7@ReadHashed@5
	pop	esi
	pop	ebp
$LN5@ReadHashed@5:
	pop	edi
	pop	ebx

; 268  : 		}
; 269  : 	}
; 270  : }

	add	esp, 16					; 00000010H
	ret	0
??$ReadHashedDataArray@W4UnitTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4UnitTypes@@H@Z ENDP ; CvInfosSerializationHelper::ReadHashedDataArray<enum UnitTypes>
_TEXT	ENDS
PUBLIC	??$ReadHashedDataArray@W4BuildingTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4BuildingTypes@@H@Z ; CvInfosSerializationHelper::ReadHashedDataArray<enum BuildingTypes>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4BuildingTypes@@@Z:PROC ; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ??$ReadHashedDataArray@W4BuildingTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4BuildingTypes@@H@Z
_TEXT	SEGMENT
_bValid$225674 = -13					; size = 1
_uiNumEntries$ = -12					; size = 4
_tValue$225677 = -8					; size = 4
_tValue$225685 = -4					; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_iArraySize$ = 16					; size = 4
??$ReadHashedDataArray@W4BuildingTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4BuildingTypes@@H@Z PROC ; CvInfosSerializationHelper::ReadHashedDataArray<enum BuildingTypes>, COMDAT

; 248  : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	edi

; 249  : 	uint uiNumEntries;
; 250  : 
; 251  : 	kStream >> uiNumEntries;

	mov	edi, DWORD PTR _kStream$[esp+20]
	lea	eax, DWORD PTR _uiNumEntries$[esp+24]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 252  : 
; 253  : 	for(uint iI = 0; iI < uiNumEntries; iI++)

	xor	ebx, ebx
	cmp	DWORD PTR _uiNumEntries$[esp+24], ebx
	jbe	SHORT $LN5@ReadHashed@6
	push	ebp
	mov	ebp, DWORD PTR _iArraySize$[esp+24]
	push	esi
$LL7@ReadHashed@6:

; 254  : 	{
; 255  : 		bool bValid;
; 256  : 		int iType = ReadHashed(kStream, &bValid);

	lea	ecx, DWORD PTR _bValid$225674[esp+32]
	push	ecx
	push	edi
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	mov	esi, eax
	add	esp, 8

; 257  : 		if(iType != -1)

	cmp	esi, -1
	je	SHORT $LN4@ReadHashed@6

; 258  : 		{
; 259  : 			TData tValue;
; 260  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$225677[esp+32]
	push	edx
	push	edi
	call	??5@YAAAVFDataStream@@AAV0@AAW4BuildingTypes@@@Z ; operator>>
	add	esp, 8

; 261  : 			if((int)iType < iArraySize)

	cmp	esi, ebp
	jge	SHORT $LN6@ReadHashed@6

; 262  : 				paArray[iType] = tValue;

	mov	eax, DWORD PTR _tValue$225677[esp+32]
	mov	ecx, DWORD PTR _paArray$[esp+28]
	mov	DWORD PTR [ecx+esi*4], eax

; 263  : 		}

	jmp	SHORT $LN6@ReadHashed@6
$LN4@ReadHashed@6:

; 264  : 		else if(!bValid)

	cmp	BYTE PTR _bValid$225674[esp+32], 0
	jne	SHORT $LN6@ReadHashed@6

; 265  : 		{
; 266  : 			TData tValue;
; 267  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$225685[esp+32]
	push	edx
	push	edi
	call	??5@YAAAVFDataStream@@AAV0@AAW4BuildingTypes@@@Z ; operator>>
	add	esp, 8
$LN6@ReadHashed@6:
	inc	ebx
	cmp	ebx, DWORD PTR _uiNumEntries$[esp+32]
	jb	SHORT $LL7@ReadHashed@6
	pop	esi
	pop	ebp
$LN5@ReadHashed@6:
	pop	edi
	pop	ebx

; 268  : 		}
; 269  : 	}
; 270  : }

	add	esp, 16					; 00000010H
	ret	0
??$ReadHashedDataArray@W4BuildingTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4BuildingTypes@@H@Z ENDP ; CvInfosSerializationHelper::ReadHashedDataArray<enum BuildingTypes>
_TEXT	ENDS
PUBLIC	??$ReadHashedDataArray@W4ImprovementTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4ImprovementTypes@@H@Z ; CvInfosSerializationHelper::ReadHashedDataArray<enum ImprovementTypes>
EXTRN	??5@YAAAVFDataStream@@AAV0@AAW4ImprovementTypes@@@Z:PROC ; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ??$ReadHashedDataArray@W4ImprovementTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4ImprovementTypes@@H@Z
_TEXT	SEGMENT
_bValid$225692 = -13					; size = 1
_uiNumEntries$ = -12					; size = 4
_tValue$225695 = -8					; size = 4
_tValue$225703 = -4					; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_iArraySize$ = 16					; size = 4
??$ReadHashedDataArray@W4ImprovementTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4ImprovementTypes@@H@Z PROC ; CvInfosSerializationHelper::ReadHashedDataArray<enum ImprovementTypes>, COMDAT

; 248  : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	edi

; 249  : 	uint uiNumEntries;
; 250  : 
; 251  : 	kStream >> uiNumEntries;

	mov	edi, DWORD PTR _kStream$[esp+20]
	lea	eax, DWORD PTR _uiNumEntries$[esp+24]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 252  : 
; 253  : 	for(uint iI = 0; iI < uiNumEntries; iI++)

	xor	ebx, ebx
	cmp	DWORD PTR _uiNumEntries$[esp+24], ebx
	jbe	SHORT $LN5@ReadHashed@7
	push	ebp
	mov	ebp, DWORD PTR _iArraySize$[esp+24]
	push	esi
$LL7@ReadHashed@7:

; 254  : 	{
; 255  : 		bool bValid;
; 256  : 		int iType = ReadHashed(kStream, &bValid);

	lea	ecx, DWORD PTR _bValid$225692[esp+32]
	push	ecx
	push	edi
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	mov	esi, eax
	add	esp, 8

; 257  : 		if(iType != -1)

	cmp	esi, -1
	je	SHORT $LN4@ReadHashed@7

; 258  : 		{
; 259  : 			TData tValue;
; 260  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$225695[esp+32]
	push	edx
	push	edi
	call	??5@YAAAVFDataStream@@AAV0@AAW4ImprovementTypes@@@Z ; operator>>
	add	esp, 8

; 261  : 			if((int)iType < iArraySize)

	cmp	esi, ebp
	jge	SHORT $LN6@ReadHashed@7

; 262  : 				paArray[iType] = tValue;

	mov	eax, DWORD PTR _tValue$225695[esp+32]
	mov	ecx, DWORD PTR _paArray$[esp+28]
	mov	DWORD PTR [ecx+esi*4], eax

; 263  : 		}

	jmp	SHORT $LN6@ReadHashed@7
$LN4@ReadHashed@7:

; 264  : 		else if(!bValid)

	cmp	BYTE PTR _bValid$225692[esp+32], 0
	jne	SHORT $LN6@ReadHashed@7

; 265  : 		{
; 266  : 			TData tValue;
; 267  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$225703[esp+32]
	push	edx
	push	edi
	call	??5@YAAAVFDataStream@@AAV0@AAW4ImprovementTypes@@@Z ; operator>>
	add	esp, 8
$LN6@ReadHashed@7:
	inc	ebx
	cmp	ebx, DWORD PTR _uiNumEntries$[esp+32]
	jb	SHORT $LL7@ReadHashed@7
	pop	esi
	pop	ebp
$LN5@ReadHashed@7:
	pop	edi
	pop	ebx

; 268  : 		}
; 269  : 	}
; 270  : }

	add	esp, 16					; 00000010H
	ret	0
??$ReadHashedDataArray@W4ImprovementTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4ImprovementTypes@@H@Z ENDP ; CvInfosSerializationHelper::ReadHashedDataArray<enum ImprovementTypes>
_TEXT	ENDS
PUBLIC	??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ; operator>><int>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_v$ = 12						; size = 4
??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z PROC ; operator>><int>, COMDAT

; 516  : 	int i = 0;
; 517  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[esp-4]
	push	esi

; 518  : 	ValueType * values = v.getArray();

	mov	esi, DWORD PTR [eax]
	push	edi
	mov	edi, DWORD PTR [eax+4]

; 519  : 	for(i = 0; i < count; ++i)

	test	edi, edi
	jle	SHORT $LN14@operator@2
	push	ebx
	mov	ebx, DWORD PTR _loadFrom$[esp+8]
$LL3@operator@2:

; 520  : 	{
; 521  : 		loadFrom >> values[i];

	push	esi
	mov	ecx, ebx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	esi, 4
	sub	edi, 1
	jne	SHORT $LL3@operator@2

; 522  : 	}
; 523  : 	return loadFrom;

	mov	eax, ebx
	pop	ebx
	pop	edi
	pop	esi

; 524  : }

	ret	0
$LN14@operator@2:

; 522  : 	}
; 523  : 	return loadFrom;

	mov	eax, DWORD PTR _loadFrom$[esp+4]
	pop	edi
	pop	esi

; 524  : }

	ret	0
??$?5H@@YAAAVFDataStream@@AAV0@AAV?$ArrayWrapper@H@@@Z ENDP ; operator>><int>
_TEXT	ENDS
PUBLIC	??$WriteHashedDataArray@W4TechTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,bool>
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4TechTypes@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvinfosserializationhelper.h
;	COMDAT ??$WriteHashedDataArray@W4TechTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z
_TEXT	SEGMENT
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$WriteHashedDataArray@W4TechTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z PROC ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,bool>, COMDAT

; 559  : {

	push	esi
	push	edi

; 560  : 	kStream << uiArraySize;

	mov	edi, DWORD PTR _kStream$[esp+4]
	lea	eax, DWORD PTR _uiArraySize$[esp+4]
	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 561  : 
; 562  : 	for(uint iI = 0; iI < uiArraySize; iI++)

	xor	esi, esi
	cmp	DWORD PTR _uiArraySize$[esp+4], esi
	jbe	SHORT $LN2@WriteHashe
	push	ebx
	mov	ebx, DWORD PTR _paArray$[esp+8]
	npad	1
$LL4@WriteHashe:

; 563  : 	{
; 564  : 		const TType eType = static_cast<TType>(iI);
; 565  : 		if(WriteHashed(kStream, eType))

	push	esi
	push	edi
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4TechTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	test	al, al
	je	SHORT $LN3@WriteHashe

; 566  : 		{
; 567  : 			kStream << paArray[iI];

	lea	ecx, DWORD PTR [esi+ebx]
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
$LN3@WriteHashe:
	inc	esi
	cmp	esi, DWORD PTR _uiArraySize$[esp+8]
	jb	SHORT $LL4@WriteHashe
	pop	ebx
$LN2@WriteHashe:
	pop	edi
	pop	esi

; 568  : 		}
; 569  : 	}
; 570  : }

	ret	0
??$WriteHashedDataArray@W4TechTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ENDP ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,bool>
_TEXT	ENDS
PUBLIC	??$WriteHashedDataArray@W4TechTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$WriteHashedDataArray@W4TechTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z
_TEXT	SEGMENT
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$WriteHashedDataArray@W4TechTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z PROC ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,int>, COMDAT

; 559  : {

	push	ebx

; 560  : 	kStream << uiArraySize;

	mov	ebx, DWORD PTR _kStream$[esp]
	push	esi
	lea	eax, DWORD PTR _uiArraySize$[esp+4]
	push	eax
	mov	ecx, ebx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 561  : 
; 562  : 	for(uint iI = 0; iI < uiArraySize; iI++)

	xor	esi, esi
	cmp	DWORD PTR _uiArraySize$[esp+4], esi
	jbe	SHORT $LN2@WriteHashe@2
	push	edi
	mov	edi, DWORD PTR _paArray$[esp+8]
	npad	1
$LL4@WriteHashe@2:

; 563  : 	{
; 564  : 		const TType eType = static_cast<TType>(iI);
; 565  : 		if(WriteHashed(kStream, eType))

	push	esi
	push	ebx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4TechTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	test	al, al
	je	SHORT $LN3@WriteHashe@2

; 566  : 		{
; 567  : 			kStream << paArray[iI];

	push	edi
	mov	ecx, ebx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
$LN3@WriteHashe@2:
	inc	esi
	add	edi, 4
	cmp	esi, DWORD PTR _uiArraySize$[esp+8]
	jb	SHORT $LL4@WriteHashe@2
	pop	edi
$LN2@WriteHashe@2:
	pop	esi
	pop	ebx

; 568  : 		}
; 569  : 	}
; 570  : }

	ret	0
??$WriteHashedDataArray@W4TechTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ENDP ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,int>
_TEXT	ENDS
PUBLIC	??$WriteHashedDataArray@W4TechTypes@@W4ResourceTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4ResourceTypes@@I@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,enum ResourceTypes>
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4ResourceTypes@@@Z:PROC ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??$WriteHashedDataArray@W4TechTypes@@W4ResourceTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4ResourceTypes@@I@Z
_TEXT	SEGMENT
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$WriteHashedDataArray@W4TechTypes@@W4ResourceTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4ResourceTypes@@I@Z PROC ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,enum ResourceTypes>, COMDAT

; 559  : {

	push	ebx

; 560  : 	kStream << uiArraySize;

	mov	ebx, DWORD PTR _kStream$[esp]
	push	esi
	lea	eax, DWORD PTR _uiArraySize$[esp+4]
	push	eax
	mov	ecx, ebx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 561  : 
; 562  : 	for(uint iI = 0; iI < uiArraySize; iI++)

	xor	esi, esi
	cmp	DWORD PTR _uiArraySize$[esp+4], esi
	jbe	SHORT $LN2@WriteHashe@3
	push	edi
	mov	edi, DWORD PTR _paArray$[esp+8]
	npad	1
$LL4@WriteHashe@3:

; 563  : 	{
; 564  : 		const TType eType = static_cast<TType>(iI);
; 565  : 		if(WriteHashed(kStream, eType))

	push	esi
	push	ebx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4TechTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	test	al, al
	je	SHORT $LN3@WriteHashe@3

; 566  : 		{
; 567  : 			kStream << paArray[iI];

	push	edi
	push	ebx
	call	??6@YAAAVFDataStream@@AAV0@ABW4ResourceTypes@@@Z ; operator<<
	add	esp, 8
$LN3@WriteHashe@3:
	inc	esi
	add	edi, 4
	cmp	esi, DWORD PTR _uiArraySize$[esp+8]
	jb	SHORT $LL4@WriteHashe@3
	pop	edi
$LN2@WriteHashe@3:
	pop	esi
	pop	ebx

; 568  : 		}
; 569  : 	}
; 570  : }

	ret	0
??$WriteHashedDataArray@W4TechTypes@@W4ResourceTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4ResourceTypes@@I@Z ENDP ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,enum ResourceTypes>
_TEXT	ENDS
PUBLIC	??$WriteHashedDataArray@W4TechTypes@@W4UnitTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4UnitTypes@@I@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,enum UnitTypes>
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4UnitTypes@@@Z:PROC ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??$WriteHashedDataArray@W4TechTypes@@W4UnitTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4UnitTypes@@I@Z
_TEXT	SEGMENT
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$WriteHashedDataArray@W4TechTypes@@W4UnitTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4UnitTypes@@I@Z PROC ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,enum UnitTypes>, COMDAT

; 559  : {

	push	ebx

; 560  : 	kStream << uiArraySize;

	mov	ebx, DWORD PTR _kStream$[esp]
	push	esi
	lea	eax, DWORD PTR _uiArraySize$[esp+4]
	push	eax
	mov	ecx, ebx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 561  : 
; 562  : 	for(uint iI = 0; iI < uiArraySize; iI++)

	xor	esi, esi
	cmp	DWORD PTR _uiArraySize$[esp+4], esi
	jbe	SHORT $LN2@WriteHashe@4
	push	edi
	mov	edi, DWORD PTR _paArray$[esp+8]
	npad	1
$LL4@WriteHashe@4:

; 563  : 	{
; 564  : 		const TType eType = static_cast<TType>(iI);
; 565  : 		if(WriteHashed(kStream, eType))

	push	esi
	push	ebx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4TechTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	test	al, al
	je	SHORT $LN3@WriteHashe@4

; 566  : 		{
; 567  : 			kStream << paArray[iI];

	push	edi
	push	ebx
	call	??6@YAAAVFDataStream@@AAV0@ABW4UnitTypes@@@Z ; operator<<
	add	esp, 8
$LN3@WriteHashe@4:
	inc	esi
	add	edi, 4
	cmp	esi, DWORD PTR _uiArraySize$[esp+8]
	jb	SHORT $LL4@WriteHashe@4
	pop	edi
$LN2@WriteHashe@4:
	pop	esi
	pop	ebx

; 568  : 		}
; 569  : 	}
; 570  : }

	ret	0
??$WriteHashedDataArray@W4TechTypes@@W4UnitTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4UnitTypes@@I@Z ENDP ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,enum UnitTypes>
_TEXT	ENDS
PUBLIC	??$WriteHashedDataArray@W4TechTypes@@W4BuildingTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4BuildingTypes@@I@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,enum BuildingTypes>
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4BuildingTypes@@@Z:PROC ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??$WriteHashedDataArray@W4TechTypes@@W4BuildingTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4BuildingTypes@@I@Z
_TEXT	SEGMENT
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$WriteHashedDataArray@W4TechTypes@@W4BuildingTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4BuildingTypes@@I@Z PROC ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,enum BuildingTypes>, COMDAT

; 559  : {

	push	ebx

; 560  : 	kStream << uiArraySize;

	mov	ebx, DWORD PTR _kStream$[esp]
	push	esi
	lea	eax, DWORD PTR _uiArraySize$[esp+4]
	push	eax
	mov	ecx, ebx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 561  : 
; 562  : 	for(uint iI = 0; iI < uiArraySize; iI++)

	xor	esi, esi
	cmp	DWORD PTR _uiArraySize$[esp+4], esi
	jbe	SHORT $LN2@WriteHashe@5
	push	edi
	mov	edi, DWORD PTR _paArray$[esp+8]
	npad	1
$LL4@WriteHashe@5:

; 563  : 	{
; 564  : 		const TType eType = static_cast<TType>(iI);
; 565  : 		if(WriteHashed(kStream, eType))

	push	esi
	push	ebx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4TechTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	test	al, al
	je	SHORT $LN3@WriteHashe@5

; 566  : 		{
; 567  : 			kStream << paArray[iI];

	push	edi
	push	ebx
	call	??6@YAAAVFDataStream@@AAV0@ABW4BuildingTypes@@@Z ; operator<<
	add	esp, 8
$LN3@WriteHashe@5:
	inc	esi
	add	edi, 4
	cmp	esi, DWORD PTR _uiArraySize$[esp+8]
	jb	SHORT $LL4@WriteHashe@5
	pop	edi
$LN2@WriteHashe@5:
	pop	esi
	pop	ebx

; 568  : 		}
; 569  : 	}
; 570  : }

	ret	0
??$WriteHashedDataArray@W4TechTypes@@W4BuildingTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4BuildingTypes@@I@Z ENDP ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,enum BuildingTypes>
_TEXT	ENDS
PUBLIC	??$WriteHashedDataArray@W4TechTypes@@W4ImprovementTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4ImprovementTypes@@I@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,enum ImprovementTypes>
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4ImprovementTypes@@@Z:PROC ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??$WriteHashedDataArray@W4TechTypes@@W4ImprovementTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4ImprovementTypes@@I@Z
_TEXT	SEGMENT
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$WriteHashedDataArray@W4TechTypes@@W4ImprovementTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4ImprovementTypes@@I@Z PROC ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,enum ImprovementTypes>, COMDAT

; 559  : {

	push	ebx

; 560  : 	kStream << uiArraySize;

	mov	ebx, DWORD PTR _kStream$[esp]
	push	esi
	lea	eax, DWORD PTR _uiArraySize$[esp+4]
	push	eax
	mov	ecx, ebx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 561  : 
; 562  : 	for(uint iI = 0; iI < uiArraySize; iI++)

	xor	esi, esi
	cmp	DWORD PTR _uiArraySize$[esp+4], esi
	jbe	SHORT $LN2@WriteHashe@6
	push	edi
	mov	edi, DWORD PTR _paArray$[esp+8]
	npad	1
$LL4@WriteHashe@6:

; 563  : 	{
; 564  : 		const TType eType = static_cast<TType>(iI);
; 565  : 		if(WriteHashed(kStream, eType))

	push	esi
	push	ebx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4TechTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	test	al, al
	je	SHORT $LN3@WriteHashe@6

; 566  : 		{
; 567  : 			kStream << paArray[iI];

	push	edi
	push	ebx
	call	??6@YAAAVFDataStream@@AAV0@ABW4ImprovementTypes@@@Z ; operator<<
	add	esp, 8
$LN3@WriteHashe@6:
	inc	esi
	add	edi, 4
	cmp	esi, DWORD PTR _uiArraySize$[esp+8]
	jb	SHORT $LL4@WriteHashe@6
	pop	edi
$LN2@WriteHashe@6:
	pop	esi
	pop	ebx

; 568  : 		}
; 569  : 	}
; 570  : }

	ret	0
??$WriteHashedDataArray@W4TechTypes@@W4ImprovementTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4ImprovementTypes@@I@Z ENDP ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,enum ImprovementTypes>
_TEXT	ENDS
PUBLIC	??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z ; operator<<<int>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_v$ = 12						; size = 4
??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z PROC ; operator<<<int>, COMDAT

; 503  : 	int i = 0;
; 504  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[esp-4]
	push	esi

; 505  : 	const ValueType * values = v.getArray();

	mov	esi, DWORD PTR [eax]
	push	edi
	mov	edi, DWORD PTR [eax+4]

; 506  : 	for(i = 0; i < count; ++i)

	test	edi, edi
	jle	SHORT $LN14@operator@3
	push	ebx
	mov	ebx, DWORD PTR _saveTo$[esp+8]
$LL3@operator@3:

; 507  : 	{
; 508  : 		saveTo << values[i];

	push	esi
	mov	ecx, ebx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	esi, 4
	sub	edi, 1
	jne	SHORT $LL3@operator@3

; 509  : 	}
; 510  : 	return saveTo;

	mov	eax, ebx
	pop	ebx
	pop	edi
	pop	esi

; 511  : }

	ret	0
$LN14@operator@3:

; 509  : 	}
; 510  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[esp+4]
	pop	edi
	pop	esi

; 511  : }

	ret	0
??$?6H@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@H@@@Z ENDP ; operator<<<int>
_TEXT	ENDS
PUBLIC	??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@_N@@@Z ; operator<<<bool>
; Function compile flags: /Ogtpy
;	COMDAT ??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@_N@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_v$ = 12						; size = 4
??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@_N@@@Z PROC ; operator<<<bool>, COMDAT

; 503  : 	int i = 0;
; 504  : 	int count = v.getCount();

	mov	eax, DWORD PTR _v$[esp-4]
	push	ebx

; 505  : 	const ValueType * values = v.getArray();

	mov	ebx, DWORD PTR [eax]
	push	esi
	push	edi
	mov	edi, DWORD PTR [eax+4]

; 506  : 	for(i = 0; i < count; ++i)

	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN14@operator@4
	push	ebp
	mov	ebp, DWORD PTR _saveTo$[esp+12]
$LL3@operator@4:

; 507  : 	{
; 508  : 		saveTo << values[i];

	lea	eax, DWORD PTR [ebx+esi]
	push	eax
	mov	ecx, ebp
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
	inc	esi
	cmp	esi, edi
	jl	SHORT $LL3@operator@4

; 509  : 	}
; 510  : 	return saveTo;

	mov	eax, ebp
	pop	ebp
	pop	edi
	pop	esi
	pop	ebx

; 511  : }

	ret	0
$LN14@operator@4:

; 509  : 	}
; 510  : 	return saveTo;

	mov	eax, DWORD PTR _saveTo$[esp+8]
	pop	edi
	pop	esi
	pop	ebx

; 511  : }

	ret	0
??$?6_N@@YAAAVFDataStream@@AAV0@ABV?$ArrayWrapper@_N@@@Z ENDP ; operator<<<bool>
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVCvTechEntry@@PAPAV1@@stdext@@YAPAPAVCvTechEntry@@PAPAV1@00@Z ; stdext::unchecked_copy<CvTechEntry * *,CvTechEntry * *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAPAVCvTechEntry@@PAPAV1@@stdext@@YAPAPAVCvTechEntry@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVCvTechEntry@@PAPAV1@@stdext@@YAPAPAVCvTechEntry@@PAPAV1@00@Z PROC ; stdext::unchecked_copy<CvTechEntry * *,CvTechEntry * *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAPAVCvTechEntry@@PAPAV1@@stdext@@YAPAPAVCvTechEntry@@PAPAV1@00@Z ENDP ; stdext::unchecked_copy<CvTechEntry * *,CvTechEntry * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVCvTechEntry@@@std@@@std@@YAXPAPAVCvTechEntry@@0AAV?$allocator@PAVCvTechEntry@@@0@@Z ; std::_Destroy_range<std::allocator<CvTechEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCvTechEntry@@@std@@@std@@YAXPAPAVCvTechEntry@@0AAV?$allocator@PAVCvTechEntry@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCvTechEntry@@@std@@@std@@YAXPAPAVCvTechEntry@@0AAV?$allocator@PAVCvTechEntry@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvTechEntry *> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVCvTechEntry@@@std@@@std@@YAXPAPAVCvTechEntry@@0AAV?$allocator@PAVCvTechEntry@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvTechEntry *> >
_TEXT	ENDS
PUBLIC	??_GCvTechEntry@@QAEPAXI@Z			; CvTechEntry::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvTechEntry@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvTechEntry@@QAEPAXI@Z PROC				; CvTechEntry::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1CvTechEntry@@QAE@XZ			; CvTechEntry::~CvTechEntry
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@5
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@5:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvTechEntry@@QAEPAXI@Z ENDP				; CvTechEntry::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??G?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBEHABV?$_Vector_const_iterator@HV?$allocator@H@std@@@1@@Z ; std::_Vector_iterator<int,std::allocator<int> >::operator-
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??G?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBEHABV?$_Vector_const_iterator@HV?$allocator@H@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBEHABV?$_Vector_const_iterator@HV?$allocator@H@std@@@1@@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator-, COMDAT
; _this$ = ecx

; 398  : 		return (*(_Mybase *)this - _Right);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 399  : 		}

	ret	4
??G?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBEHABV?$_Vector_const_iterator@HV?$allocator@H@std@@@1@@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator-
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBEAAHXZ ; std::_Vector_iterator<int,std::allocator<int> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBEAAHXZ
_TEXT	SEGMENT
??D?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBEAAHXZ PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator*, COMDAT
; _this$ = ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 340  : 		}

	ret	0
??D?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBEAAHXZ ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<int,std::allocator<int> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	mov	eax, ecx

; 349  : 		++(*(_Mybase *)this);

	add	DWORD PTR [eax], 4

; 350  : 		return (*this);
; 351  : 		}

	ret	0
??E?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator++
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<int,std::allocator<int> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator++, COMDAT
; _this$ = ecx

; 355  : 		_Myt _Tmp = *this;

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 356  : 		++*this;

	add	edx, 4
	mov	DWORD PTR [ecx], edx

; 357  : 		return (_Tmp);
; 358  : 		}

	ret	8
??E?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator++
_TEXT	ENDS
PUBLIC	??F?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<int,std::allocator<int> >::operator--
; Function compile flags: /Ogtpy
;	COMDAT ??F?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator--, COMDAT
; _this$ = ecx

; 361  : 		{	// predecrement

	mov	eax, ecx

; 362  : 		--(*(_Mybase *)this);

	add	DWORD PTR [eax], -4			; fffffffcH

; 363  : 		return (*this);
; 364  : 		}

	ret	0
??F?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator--
_TEXT	ENDS
PUBLIC	??$iter_swap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@V12@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z ; std::iter_swap<std::_Vector_iterator<int,std::allocator<int> >,std::_Vector_iterator<int,std::allocator<int> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$iter_swap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@V12@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$iter_swap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@V12@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z PROC ; std::iter_swap<std::_Vector_iterator<int,std::allocator<int> >,std::_Vector_iterator<int,std::allocator<int> > >, COMDAT

; 594  : 	swap(*_Left, *_Right);

	mov	ecx, DWORD PTR __Right$[esp-4]
	mov	eax, DWORD PTR __Left$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN11@iter_swap
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [ecx], edx
	pop	esi
$LN11@iter_swap:

; 595  : 	}

	ret	0
??$iter_swap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@V12@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z ENDP ; std::iter_swap<std::_Vector_iterator<int,std::allocator<int> >,std::_Vector_iterator<int,std::allocator<int> > >
_TEXT	ENDS
PUBLIC	??$_Med3@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@00@Z ; std::_Med3<std::_Vector_iterator<int,std::allocator<int> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Med3@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Med3@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@00@Z PROC ; std::_Med3<std::_Vector_iterator<int,std::allocator<int> > >, COMDAT

; 2999 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	eax, DWORD PTR __Mid$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __First$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	push	esi
	jge	SHORT $LN24@Med3

; 3000 : 		std::iter_swap(_Mid, _First);

	cmp	eax, ecx
	je	SHORT $LN24@Med3
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR __Mid$[esp]
	mov	ecx, DWORD PTR __First$[esp]
$LN24@Med3:

; 3001 : 	if (_DEBUG_LT(*_Last, *_Mid))

	mov	edx, DWORD PTR __Last$[esp]
	mov	esi, DWORD PTR [edx]
	cmp	esi, DWORD PTR [eax]
	jge	SHORT $LN45@Med3

; 3002 : 		std::iter_swap(_Last, _Mid);

	cmp	edx, eax
	je	SHORT $LN45@Med3
	mov	ecx, esi
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [edx], esi
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR __Mid$[esp]
	mov	ecx, DWORD PTR __First$[esp]
$LN45@Med3:

; 3003 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN66@Med3

; 3004 : 		std::iter_swap(_Mid, _First);

	cmp	eax, ecx
	je	SHORT $LN66@Med3
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [ecx], edx
$LN66@Med3:
	pop	esi

; 3005 : 	}

	ret	0
??$_Med3@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@00@Z ENDP ; std::_Med3<std::_Vector_iterator<int,std::allocator<int> > >
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT
; _p$ = eax

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 302  : }

	ret	0
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1

; 302  : }

	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
PUBLIC	?getX@CvCity@@QBEHXZ				; CvCity::getX
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvcity.h
;	COMDAT ?getX@CvCity@@QBEHXZ
_TEXT	SEGMENT
?getX@CvCity@@QBEHXZ PROC				; CvCity::getX, COMDAT
; _this$ = ecx

; 340  : 		return m_iX;

	mov	eax, DWORD PTR [ecx+96]

; 341  : 	}

	ret	0
?getX@CvCity@@QBEHXZ ENDP				; CvCity::getX
_TEXT	ENDS
PUBLIC	?getY@CvCity@@QBEHXZ				; CvCity::getY
; Function compile flags: /Ogtpy
;	COMDAT ?getY@CvCity@@QBEHXZ
_TEXT	SEGMENT
?getY@CvCity@@QBEHXZ PROC				; CvCity::getY, COMDAT
; _this$ = ecx

; 345  : 		return m_iY;

	mov	eax, DWORD PTR [ecx+108]

; 346  : 	}

	ret	0
?getY@CvCity@@QBEHXZ ENDP				; CvCity::getY
_TEXT	ENDS
PUBLIC	?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ	; CvCity::getOwner
; Function compile flags: /Ogtpy
;	COMDAT ?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ PROC		; CvCity::getOwner, COMDAT
; _this$ = ecx

; 604  : 		return m_eOwner;

	mov	eax, DWORD PTR [ecx+84]

; 605  : 	}

	ret	0
?getOwner@CvCity@@QBE?AW4PlayerTypes@@XZ ENDP		; CvCity::getOwner
_TEXT	ENDS
PUBLIC	?isAlive@CvPlayer@@QBE_NXZ			; CvPlayer::isAlive
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvplayer.h
;	COMDAT ?isAlive@CvPlayer@@QBE_NXZ
_TEXT	SEGMENT
?isAlive@CvPlayer@@QBE_NXZ PROC				; CvPlayer::isAlive, COMDAT
; _this$ = ecx

; 1096 : 		return m_bAlive;

	mov	al, BYTE PTR [ecx+2256]

; 1097 : 	}

	ret	0
?isAlive@CvPlayer@@QBE_NXZ ENDP				; CvPlayer::isAlive
_TEXT	ENDS
PUBLIC	?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ		; CvPlayer::GetID
; Function compile flags: /Ogtpy
;	COMDAT ?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ
_TEXT	SEGMENT
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ PROC		; CvPlayer::GetID, COMDAT
; _this$ = ecx

; 1172 : 		return m_eID;

	mov	eax, DWORD PTR [ecx+44]

; 1173 : 	}

	ret	0
?GetID@CvPlayer@@QBE?AW4PlayerTypes@@XZ ENDP		; CvPlayer::GetID
_TEXT	ENDS
PUBLIC	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ		; CvPlayer::getTeam
; Function compile flags: /Ogtpy
;	COMDAT ?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ PROC		; CvPlayer::getTeam, COMDAT
; _this$ = ecx

; 1182 : 		return CvPreGame::teamType(m_eID);

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN5@getTeam
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1183 : 	}

	ret	0

; 1182 : 		return CvPreGame::teamType(m_eID);

$LN5@getTeam:
	or	eax, -1

; 1183 : 	}

	ret	0
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ ENDP		; CvPlayer::getTeam
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z PROC ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ENDP ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@H@std@@QAEPAHI@Z		; std::allocator<int>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@H@std@@QAEPAHI@Z PROC		; std::allocator<int>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@H@std@@QAEPAHI@Z ENDP		; std::allocator<int>::allocate
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator!=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<int,std::allocator<int> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator+=
_TEXT	ENDS
PUBLIC	??$fill@PAHH@std@@YAXPAH0ABH@Z			; std::fill<int *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAHH@std@@YAXPAH0ABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAHH@std@@YAXPAH0ABH@Z PROC			; std::fill<int *,int>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@fill
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL5@fill
	pop	esi
$LN3@fill:

; 3188 : 	}

	ret	0
??$fill@PAHH@std@@YAXPAH0ABH@Z ENDP			; std::fill<int *,int>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN8@Move_backw
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@Move_backw:
	mov	eax, esi
	pop	esi

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<int *,unsigned int,int,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<int *,unsigned int,int,std::random_access_iterator_tag>, COMDAT

; 3242 : 		_Fill_n(_First, _Count, _Val, _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN3@Fill_n@2
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@Fill_n@2:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL5@Fill_n@2
	pop	esi
$LN3@Fill_n@2:

; 3243 : 	}

	ret	0
??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<int *,unsigned int,int,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >, COMDAT

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN8@unchecked_@2
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@unchecked_@2:
	pop	edi
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0CvTechEntry@@QAE@XZ				; CvTechEntry::CvTechEntry
EXTRN	??0CvBaseInfo@@QAE@XZ:PROC			; CvBaseInfo::CvBaseInfo
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$??0CvTechEntry@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvTechEntry@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvTechEntry@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CvTechEntry@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CvTechEntry@@QAE@XZ$3
__ehfuncinfo$??0CvTechEntry@@QAE@XZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0CvTechEntry@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtechclasses.cpp
xdata$x	ENDS
;	COMDAT ??0CvTechEntry@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvTechEntry@@QAE@XZ PROC				; CvTechEntry::CvTechEntry, COMDAT
; _this$ = ecx

; 78   : {

	push	-1
	push	__ehhandler$??0CvTechEntry@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+24], esi
	call	??0CvBaseInfo@@QAE@XZ			; CvBaseInfo::CvBaseInfo
	xor	ebx, ebx
	or	eax, -1
	lea	ecx, DWORD PTR [esi+360]
	mov	DWORD PTR __$EHRec$[esp+32], ebx
	mov	DWORD PTR [esi], OFFSET ??_7CvTechEntry@@6B@
	mov	DWORD PTR [esi+260], ebx
	mov	DWORD PTR [esi+264], ebx
	mov	DWORD PTR [esi+268], ebx
	mov	DWORD PTR [esi+272], ebx
	mov	DWORD PTR [esi+276], eax
	mov	DWORD PTR [esi+280], ebx
	mov	DWORD PTR [esi+284], ebx
	mov	DWORD PTR [esi+288], ebx
	mov	DWORD PTR [esi+292], ebx
	mov	DWORD PTR [esi+296], eax
	mov	DWORD PTR [esi+300], ebx
	mov	DWORD PTR [esi+304], ebx
	mov	DWORD PTR [esi+308], ebx
	mov	DWORD PTR [esi+312], ebx
	mov	DWORD PTR [esi+316], ebx
	mov	DWORD PTR [esi+320], ebx
	mov	DWORD PTR [esi+324], ebx
	mov	DWORD PTR [esi+328], ebx
	mov	BYTE PTR [esi+332], bl
	mov	BYTE PTR [esi+333], bl
	mov	BYTE PTR [esi+334], bl
	mov	BYTE PTR [esi+335], bl
	mov	BYTE PTR [esi+336], bl
	mov	BYTE PTR [esi+337], bl
	mov	BYTE PTR [esi+338], bl
	mov	BYTE PTR [esi+339], bl
	mov	BYTE PTR [esi+340], bl
	mov	BYTE PTR [esi+341], bl
	mov	BYTE PTR [esi+342], bl
	mov	BYTE PTR [esi+343], bl
	mov	BYTE PTR [esi+344], bl
	mov	BYTE PTR [esi+345], bl
	mov	BYTE PTR [esi+346], bl
	mov	BYTE PTR [esi+347], bl
	mov	BYTE PTR [esi+348], bl
	mov	BYTE PTR [esi+349], bl
	mov	BYTE PTR [esi+350], bl
	mov	BYTE PTR [esi+351], bl
	mov	BYTE PTR [esi+352], bl
	mov	BYTE PTR [esi+353], bl
	mov	BYTE PTR [esi+354], bl
	mov	BYTE PTR [esi+355], bl
	mov	BYTE PTR [esi+356], bl
	mov	BYTE PTR [esi+357], bl
	mov	BYTE PTR [esi+358], bl
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+388]
	mov	BYTE PTR __$EHRec$[esp+32], 1
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+416]
	mov	BYTE PTR __$EHRec$[esp+32], 2
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+444]
	mov	BYTE PTR __$EHRec$[esp+32], 3
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 79   : }

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR [esi+472], ebx
	mov	DWORD PTR [esi+476], ebx
	mov	DWORD PTR [esi+480], ebx
	mov	DWORD PTR [esi+484], ebx
	mov	DWORD PTR [esi+488], ebx
	mov	DWORD PTR [esi+492], ebx
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvTechEntry@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1CvBaseInfo@@QAE@XZ
__unwindfunclet$??0CvTechEntry@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 360				; 00000168H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvTechEntry@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 388				; 00000184H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$??0CvTechEntry@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 416				; 000001a0H
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$??0CvTechEntry@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvTechEntry@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvTechEntry@@QAE@XZ ENDP				; CvTechEntry::CvTechEntry
EXTRN	__imp_?Reset@Results@Database@@QAE_NXZ:PROC
EXTRN	__imp_?GetInt@Results@Database@@QAEHH@Z:PROC
EXTRN	__imp_?Step@Results@Database@@QAE_NXZ:PROC
EXTRN	__imp_?Bind@Results@Database@@QAE_NHPBDH_N@Z:PROC
EXTRN	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z:PROC ; CvDatabaseUtility::PrepareResults
EXTRN	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; CvDatabaseUtility::GetResults
EXTRN	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z:PROC	; CvDatabaseUtility::MaxRows
EXTRN	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z:PROC ; CvDatabaseUtility::SetFlavors
EXTRN	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z:PROC ; CvDatabaseUtility::PopulateArrayByExistence
EXTRN	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z:PROC ; CvDatabaseUtility::PopulateArrayByValue
EXTRN	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z:PROC ; CvGlobals::getInfoTypeForString
EXTRN	__imp_?GetText@Results@Database@@QAEPBDPBD@Z:PROC
EXTRN	__imp_?GetBool@Results@Database@@QAE_NPBD@Z:PROC
EXTRN	__imp_?GetInt@Results@Database@@QAEHPBD@Z:PROC
EXTRN	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:PROC ; CvBaseInfo::CacheResults
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvdatabaseutility.h
xdata$x	SEGMENT
__unwindtable$?CacheResults@CvTechEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvTechEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CacheResults@CvTechEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$1
__ehfuncinfo$?CacheResults@CvTechEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?CacheResults@CvTechEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtechclasses.cpp
xdata$x	ENDS
;	COMDAT ?CacheResults@CvTechEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
_TEXT	SEGMENT
_strKey$224001 = -68					; size = 28
_strKey$224010 = -40					; size = 28
__$EHRec$ = -12						; size = 12
tv806 = 8						; size = 4
_kResults$ = 8						; size = 4
_kUtility$ = 12						; size = 4
?CacheResults@CvTechEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z PROC ; CvTechEntry::CacheResults, COMDAT
; _this$ = ecx

; 93   : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?CacheResults@CvTechEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	push	eax

; 94   : 	if(!CvBaseInfo::CacheResults(kResults, kUtility))

	mov	eax, DWORD PTR _kUtility$[esp+8]
	mov	DWORD PTR fs:0, esp
	sub	esp, 56					; 00000038H
	push	esi
	push	edi
	mov	edi, DWORD PTR _kResults$[esp+72]
	push	eax
	push	edi
	mov	esi, ecx
	call	?CacheResults@CvBaseInfo@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ; CvBaseInfo::CacheResults
	test	al, al
	jne	SHORT $LN7@CacheResul
	pop	edi
	pop	esi

; 219  : 	return true;
; 220  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+68]
	mov	DWORD PTR fs:0, ecx
	add	esp, 68					; 00000044H
	ret	8
$LN7@CacheResul:
	push	ebx
	push	ebp

; 95   : 		return false;
; 96   : 
; 97   : 	//Basic Properties
; 98   : 	m_iAIWeight = kResults.GetInt("AIWeight");

	mov	ebp, DWORD PTR __imp_?GetInt@Results@Database@@QAEHPBD@Z
	push	OFFSET $SG223933
	mov	ecx, edi
	call	ebp

; 99   : 	m_iAITradeModifier = kResults.GetInt("AITradeModifier");

	push	OFFSET $SG223934
	mov	ecx, edi
	mov	DWORD PTR [esi+260], eax
	call	ebp

; 100  : 	m_iResearchCost = kResults.GetInt("Cost");

	push	OFFSET $SG223935
	mov	ecx, edi
	mov	DWORD PTR [esi+264], eax
	call	ebp

; 101  : 	m_iAdvancedStartCost = kResults.GetInt("AdvancedStartCost");

	push	OFFSET $SG223936
	mov	ecx, edi
	mov	DWORD PTR [esi+268], eax
	call	ebp

; 102  : 	m_iFeatureProductionModifier = kResults.GetInt("FeatureProductionModifier");

	push	OFFSET $SG223937
	mov	ecx, edi
	mov	DWORD PTR [esi+272], eax
	call	ebp

; 103  : 	m_iUnitFortificationModifier = kResults.GetInt("UnitFortificationModifier");

	push	OFFSET $SG223938
	mov	ecx, edi
	mov	DWORD PTR [esi+280], eax
	call	ebp

; 104  : 	m_iUnitBaseHealModifier = kResults.GetInt("UnitBaseHealModifier");

	push	OFFSET $SG223939
	mov	ecx, edi
	mov	DWORD PTR [esi+284], eax
	call	ebp

; 105  : 	m_iWorkerSpeedModifier = kResults.GetInt("WorkerSpeedModifier");

	push	OFFSET $SG223940
	mov	ecx, edi
	mov	DWORD PTR [esi+288], eax
	call	ebp

; 106  : 	m_iFirstFreeTechs = kResults.GetInt("FirstFreeTechs");

	push	OFFSET $SG223941
	mov	ecx, edi
	mov	DWORD PTR [esi+292], eax
	call	ebp

; 107  : 	m_iEmbarkedMoveChange = kResults.GetInt("EmbarkedMoveChange");

	push	OFFSET $SG223942
	mov	ecx, edi
	mov	DWORD PTR [esi+300], eax
	call	ebp

; 108  : 	//EAP: Extra sight for embarked units on tech
; 109  : 	m_iEmbarkedSightChange = kResults.GetInt("EmbarkedSightChange");

	push	OFFSET $SG223943
	mov	ecx, edi
	mov	DWORD PTR [esi+304], eax
	call	ebp

; 110  : 
; 111  : 	m_iInternationalTradeRoutesChange = kResults.GetInt("InternationalTradeRoutesChange");

	push	OFFSET $SG223944
	mov	ecx, edi
	mov	DWORD PTR [esi+308], eax
	call	ebp

; 112  : 	m_iInfluenceSpreadModifier = kResults.GetInt("InfluenceSpreadModifier");

	push	OFFSET $SG223945
	mov	ecx, edi
	mov	DWORD PTR [esi+312], eax
	call	ebp

; 113  : 	m_iExtraVotesPerDiplomat = kResults.GetInt("ExtraVotesPerDiplomat");

	push	OFFSET $SG223946
	mov	ecx, edi
	mov	DWORD PTR [esi+316], eax
	call	ebp

; 114  : 	m_bEndsGame = kResults.GetBool("EndsGame");

	mov	ebx, DWORD PTR __imp_?GetBool@Results@Database@@QAE_NPBD@Z
	push	OFFSET $SG223947
	mov	ecx, edi
	mov	DWORD PTR [esi+320], eax
	call	ebx

; 115  : 	m_bAllowsEmbarking = kResults.GetBool("AllowsEmbarking");

	push	OFFSET $SG223948
	mov	ecx, edi
	mov	BYTE PTR [esi+332], al
	call	ebx

; 116  : 
; 117  : 	//EAP: Civilian Embark
; 118  : 	m_bAllowsEmbarkingCivilian = kResults.GetBool("AllowsEmbarkingCivilian");

	push	OFFSET $SG223949
	mov	ecx, edi
	mov	BYTE PTR [esi+333], al
	call	ebx

; 119  : 
; 120  : 	m_bAllowsDefensiveEmbarking = kResults.GetBool("AllowsDefensiveEmbarking");

	push	OFFSET $SG223950
	mov	ecx, edi
	mov	BYTE PTR [esi+334], al
	call	ebx

; 121  : 	m_bEmbarkedAllWaterPassage = kResults.GetBool("EmbarkedAllWaterPassage");

	push	OFFSET $SG223951
	mov	ecx, edi
	mov	BYTE PTR [esi+335], al
	call	ebx
	mov	BYTE PTR [esi+336], al

; 122  : 	m_bAllowsBarbarianBoats = kResults.GetBool("AllowsBarbarianBoats");

	push	OFFSET $SG223952
	mov	ecx, edi
	call	ebx

; 123  : 	m_bRepeat = kResults.GetBool("Repeat");

	push	OFFSET $SG223953
	mov	ecx, edi
	mov	BYTE PTR [esi+337], al
	call	ebx

; 124  : 	m_bTrade = kResults.GetBool("Trade");

	push	OFFSET $SG223954
	mov	ecx, edi
	mov	BYTE PTR [esi+338], al
	call	ebx

; 125  : 	m_bDisable = kResults.GetBool("Disable");

	push	OFFSET $SG223955
	mov	ecx, edi
	mov	BYTE PTR [esi+339], al
	call	ebx

; 126  : 	m_bDisableTechSteal = kResults.GetBool("DisableTechSteal");

	push	OFFSET $SG223956
	mov	ecx, edi
	mov	BYTE PTR [esi+340], al
	call	ebx

; 127  : 	m_bGoodyTech = kResults.GetBool("GoodyTech");

	push	OFFSET $SG223957
	mov	ecx, edi
	mov	BYTE PTR [esi+341], al
	call	ebx

; 128  : 	m_bTriggersArchaeologicalSites = kResults.GetBool("TriggersArchaeologicalSites");

	push	OFFSET $SG223958
	mov	ecx, edi
	mov	BYTE PTR [esi+342], al
	call	ebx

; 129  : 	m_bAllowsWorldCongress = kResults.GetBool("AllowsWorldCongress");

	push	OFFSET $SG223959
	mov	ecx, edi
	mov	BYTE PTR [esi+357], al
	call	ebx

; 130  : 	m_bExtraWaterSeeFrom = kResults.GetBool("ExtraWaterSeeFrom");

	push	OFFSET $SG223960
	mov	ecx, edi
	mov	BYTE PTR [esi+358], al
	call	ebx

; 131  : 	m_bMapCentering = kResults.GetBool("MapCentering");

	push	OFFSET $SG223961
	mov	ecx, edi
	mov	BYTE PTR [esi+343], al
	call	ebx

; 132  : 	m_bMapVisible = kResults.GetBool("MapVisible");

	push	OFFSET $SG223962
	mov	ecx, edi
	mov	BYTE PTR [esi+344], al
	call	ebx

; 133  : 	m_bMapTrading = kResults.GetBool("MapTrading");

	push	OFFSET $SG223963
	mov	ecx, edi
	mov	BYTE PTR [esi+345], al
	call	ebx

; 134  : 	m_bTechTrading = kResults.GetBool("TechTrading");

	push	OFFSET $SG223964
	mov	ecx, edi
	mov	BYTE PTR [esi+346], al
	call	ebx

; 135  : 	m_bGoldTrading = kResults.GetBool("GoldTrading");

	push	OFFSET $SG223965
	mov	ecx, edi
	mov	BYTE PTR [esi+347], al
	call	ebx

; 136  : 	m_bAllowEmbassyTradingAllowed = kResults.GetBool("AllowEmbassyTradingAllowed");

	push	OFFSET $SG223966
	mov	ecx, edi
	mov	BYTE PTR [esi+348], al
	call	ebx

; 137  : 	m_bOpenBordersTradingAllowed = kResults.GetBool("OpenBordersTradingAllowed");

	push	OFFSET $SG223967
	mov	ecx, edi
	mov	BYTE PTR [esi+349], al
	call	ebx

; 138  : 	m_bDefensivePactTradingAllowed = kResults.GetBool("DefensivePactTradingAllowed");

	push	OFFSET $SG223968
	mov	ecx, edi
	mov	BYTE PTR [esi+350], al
	call	ebx

; 139  : 	m_bResearchAgreementTradingAllowed = kResults.GetBool("ResearchAgreementTradingAllowed");

	push	OFFSET $SG223969
	mov	ecx, edi
	mov	BYTE PTR [esi+351], al
	call	ebx

; 140  : 	m_bTradeAgreementTradingAllowed = kResults.GetBool("TradeAgreementTradingAllowed");

	push	OFFSET $SG223970
	mov	ecx, edi
	mov	BYTE PTR [esi+352], al
	call	ebx

; 141  : 	m_bPermanentAllianceTrading = kResults.GetBool("PermanentAllianceTradingAllowed");

	push	OFFSET $SG223971
	mov	ecx, edi
	mov	BYTE PTR [esi+353], al
	call	ebx
	mov	BYTE PTR [esi+354], al

; 142  : 	m_bBridgeBuilding = kResults.GetBool("BridgeBuilding");

	push	OFFSET $SG223972
	mov	ecx, edi
	call	ebx

; 143  : 	m_bWaterWork = kResults.GetBool("WaterWork");

	push	OFFSET $SG223973
	mov	ecx, edi
	mov	BYTE PTR [esi+355], al
	call	ebx

; 144  : 	m_iGridX = kResults.GetInt("GridX");

	push	OFFSET $SG223974
	mov	ecx, edi
	mov	BYTE PTR [esi+356], al
	call	ebp

; 145  : 	m_iGridY = kResults.GetInt("GridY");

	push	OFFSET $SG223975
	mov	ecx, edi
	mov	DWORD PTR [esi+324], eax
	call	ebp

; 146  : 
; 147  : 	//References
; 148  : 	const char* szTextVal = NULL;
; 149  : 	szTextVal = kResults.GetText("Era");

	mov	ebx, DWORD PTR __imp_?GetText@Results@Database@@QAEPBDPBD@Z
	push	OFFSET $SG223977
	mov	ecx, edi
	mov	DWORD PTR [esi+328], eax
	call	ebx

; 150  : 	m_iEra = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 151  : 
; 152  : 	szTextVal = kResults.GetText("FirstFreeUnitClass");

	push	OFFSET $SG223978
	mov	ecx, edi
	mov	DWORD PTR [esi+276], eax
	call	ebx

; 153  : 	m_iFirstFreeUnitClass = GC.getInfoTypeForString(szTextVal, true);

	push	1
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getInfoTypeForString@CvGlobals@@QBEHPBD_N@Z ; CvGlobals::getInfoTypeForString

; 154  : 
; 155  : 	szTextVal = kResults.GetText("Quote");

	push	OFFSET $SG223979
	mov	ecx, edi
	mov	DWORD PTR [esi+296], eax
	call	ebx

; 156  : 	SetQuoteKey(szTextVal);

	push	eax
	mov	ecx, esi
	call	?SetQuoteKey@CvTechEntry@@QAEXPBD@Z	; CvTechEntry::SetQuoteKey

; 157  : 
; 158  : 	szTextVal = kResults.GetText("AudioIntro");

	push	OFFSET $SG223980
	mov	ecx, edi
	call	ebx

; 159  : 	SetSound(szTextVal);

	lea	ecx, DWORD PTR [esi+416]
	test	eax, eax
	je	SHORT $LN15@CacheResul
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN14@CacheResul
$LN15@CacheResul:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN14@CacheResul:

; 160  : 
; 161  : 	szTextVal = kResults.GetText("AudioIntroHeader");

	push	OFFSET $SG223981
	mov	ecx, edi
	call	ebx

; 162  : 	SetSoundMP(szTextVal);

	lea	ecx, DWORD PTR [esi+444]
	test	eax, eax
	je	SHORT $LN21@CacheResul
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN20@CacheResul
$LN21@CacheResul:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN20@CacheResul:

; 163  : 
; 164  : 	//Arrays
; 165  : 	const char* szTechType = GetType();

	lea	ecx, DWORD PTR [esi+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 166  : 	kUtility.PopulateArrayByValue(m_piDomainExtraMoves, "Domains", "Technology_DomainExtraMoves", "DomainType", "TechType", szTechType, "Moves", 0, NUM_DOMAIN_TYPES);

	mov	edi, DWORD PTR _kUtility$[esp+80]
	push	5
	push	0
	push	OFFSET $SG223983
	mov	ebx, eax
	push	ebx
	push	OFFSET $SG223984
	push	OFFSET $SG223985
	push	OFFSET $SG223986
	push	OFFSET $SG223987
	lea	ecx, DWORD PTR [esi+472]
	push	ecx
	mov	ecx, edi
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 167  : 	kUtility.PopulateArrayByValue(m_piTradeRouteDomainExtraRange, "Domains", "Technology_TradeRouteDomainExtraRange", "DomainType", "TechType", szTechType, "Range", 0, NUM_DOMAIN_TYPES);

	push	5
	push	0
	push	OFFSET $SG223988
	push	ebx
	push	OFFSET $SG223989
	push	OFFSET $SG223990
	push	OFFSET $SG223991
	push	OFFSET $SG223992
	lea	edx, DWORD PTR [esi+476]
	push	edx
	mov	ecx, edi
	call	?PopulateArrayByValue@CvDatabaseUtility@@QAE_NAAPAHPBD11111HH@Z ; CvDatabaseUtility::PopulateArrayByValue

; 168  : 	kUtility.PopulateArrayByExistence(m_pabFreePromotion, "UnitPromotions", "Technology_FreePromotions", "PromotionType", "TechType", szTechType);

	push	ebx
	push	OFFSET $SG223993
	push	OFFSET $SG223994
	push	OFFSET $SG223995
	push	OFFSET $SG223996
	lea	eax, DWORD PTR [esi+492]
	push	eax
	mov	ecx, edi
	call	?PopulateArrayByExistence@CvDatabaseUtility@@QAE_NAAPA_NPBD1111@Z ; CvDatabaseUtility::PopulateArrayByExistence

; 169  : 	kUtility.SetFlavors(m_piFlavorValue, "Technology_Flavors", "TechType", szTechType);

	push	0
	push	ebx
	push	OFFSET $SG223997
	push	OFFSET $SG223998
	lea	ecx, DWORD PTR [esi+480]
	push	ecx
	mov	ecx, edi
	call	?SetFlavors@CvDatabaseUtility@@QAE_NAAPAHPBD11H@Z ; CvDatabaseUtility::SetFlavors

; 170  : 
; 171  : 	const size_t TechnologiesCount = kUtility.MaxRows("Technologies");

	push	OFFSET $SG224000
	mov	ecx, edi
	call	?MaxRows@CvDatabaseUtility@@QAEHPBD@Z	; CvDatabaseUtility::MaxRows

; 172  : 
; 173  : 	//ORPrereqTechs
; 174  : 	{
; 175  : 		//PrereqTech array must be initialized to NO_TECH.
; 176  : 
; 177  : 		kUtility.InitializeArray(m_piPrereqOrTechs, TechnologiesCount, NO_TECH);

	xor	ecx, ecx
	mov	ebp, eax
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+484], eax
	add	esp, 4
	xor	eax, eax
	test	ebp, ebp
	jbe	SHORT $LN26@CacheResul
	npad	13
$LL28@CacheResul:
	mov	ecx, DWORD PTR [esi+484]
	mov	DWORD PTR [ecx+eax*4], -1
	inc	eax
	cmp	eax, ebp
	jb	SHORT $LL28@CacheResul
$LN26@CacheResul:

; 178  : 
; 179  : 		std::string strKey = "Technologies - Technology_ORPrereqTechs";

	push	OFFSET $SG224002
	lea	ecx, DWORD PTR _strKey$224001[esp+88]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 180  : 		Database::Results* pResults = kUtility.GetResults(strKey);

	mov	ecx, DWORD PTR _kUtility$[esp+80]
	lea	edx, DWORD PTR _strKey$224001[esp+84]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+96], 0
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	edi, eax

; 181  : 		if(pResults == NULL)

	test	edi, edi
	jne	SHORT $LN6@CacheResul

; 182  : 		{
; 183  : 			pResults = kUtility.PrepareResults(strKey, "select Technologies.ID from Technology_ORPrereqTechs inner join Technologies on Technologies.Type = PrereqTech where TechType = ?;");

	mov	ecx, DWORD PTR _kUtility$[esp+80]
	push	OFFSET $SG224005
	lea	eax, DWORD PTR _strKey$224001[esp+88]
	push	eax
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	edi, eax
$LN6@CacheResul:

; 184  : 		}
; 185  : 
; 186  : 		pResults->Bind(1, szTechType, -1, false);

	push	0
	push	-1
	push	ebx
	push	1
	mov	ecx, edi
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBDH_N@Z

; 187  : 
; 188  : 		int i = 0;
; 189  : 		while(pResults->Step())

	mov	ecx, edi
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	je	SHORT $LN4@CacheResul

; 184  : 		}
; 185  : 
; 186  : 		pResults->Bind(1, szTechType, -1, false);

	mov	DWORD PTR tv806[esp+80], 0
$LL5@CacheResul:

; 190  : 		{
; 191  : 			m_piPrereqOrTechs[i++] = pResults->GetInt(0);

	push	0
	mov	ecx, edi
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	ecx, DWORD PTR tv806[esp+80]
	mov	edx, DWORD PTR [esi+484]
	mov	DWORD PTR [ecx+edx], eax
	add	ecx, 4
	mov	DWORD PTR tv806[esp+80], ecx
	mov	ecx, edi
	call	DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	test	al, al
	jne	SHORT $LL5@CacheResul
$LN4@CacheResul:

; 192  : 		}
; 193  : 
; 194  : 		pResults->Reset();

	mov	ecx, edi
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 195  : 	}

	lea	ecx, DWORD PTR _strKey$224001[esp+84]
	mov	DWORD PTR __$EHRec$[esp+92], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 196  : 
; 197  : 	//PrereqTechs
; 198  : 	{
; 199  : 		//PrereqTech array must be initialized to NO_TECH.
; 200  : 		kUtility.InitializeArray(m_piPrereqAndTechs, TechnologiesCount, NO_TECH);

	xor	ecx, ecx
	mov	eax, ebp
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+488], eax
	add	esp, 4
	xor	eax, eax
	test	ebp, ebp
	jbe	SHORT $LN33@CacheResul
$LL35@CacheResul:
	mov	ecx, DWORD PTR [esi+488]
	mov	DWORD PTR [ecx+eax*4], -1
	inc	eax
	cmp	eax, ebp
	jb	SHORT $LL35@CacheResul
$LN33@CacheResul:

; 201  : 
; 202  : 		std::string strKey = "Technologies - Technology_PrereqTechs";

	push	OFFSET $SG224011
	lea	ecx, DWORD PTR _strKey$224010[esp+88]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 203  : 		Database::Results* pResults = kUtility.GetResults(strKey);

	mov	ebp, DWORD PTR _kUtility$[esp+80]
	lea	edx, DWORD PTR _strKey$224010[esp+84]
	push	edx
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+96], 1
	call	?GetResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CvDatabaseUtility::GetResults
	mov	edi, eax

; 204  : 		if(pResults == NULL)

	test	edi, edi
	jne	SHORT $LN3@CacheResul

; 205  : 		{
; 206  : 			pResults = kUtility.PrepareResults(strKey, "select Technologies.ID from Technology_PrereqTechs inner join Technologies on Technologies.Type = PrereqTech where TechType = ?;");

	push	OFFSET $SG224014
	lea	eax, DWORD PTR _strKey$224010[esp+88]
	push	eax
	mov	ecx, ebp
	call	?PrepareResults@CvDatabaseUtility@@QAEPAVResults@Database@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; CvDatabaseUtility::PrepareResults
	mov	edi, eax
$LN3@CacheResul:

; 207  : 		}
; 208  : 
; 209  : 		pResults->Bind(1, szTechType, -1, false);

	push	0
	push	-1
	push	ebx
	push	1
	mov	ecx, edi
	call	DWORD PTR __imp_?Bind@Results@Database@@QAE_NHPBDH_N@Z

; 210  : 
; 211  : 		int i = 0;
; 212  : 		while(pResults->Step())

	mov	ebp, DWORD PTR __imp_?Step@Results@Database@@QAE_NXZ
	mov	ecx, edi
	call	ebp
	test	al, al
	je	SHORT $LN1@CacheResul

; 207  : 		}
; 208  : 
; 209  : 		pResults->Bind(1, szTechType, -1, false);

	xor	ebx, ebx
$LL2@CacheResul:

; 213  : 		{
; 214  : 			m_piPrereqAndTechs[i++] = pResults->GetInt(0);

	push	0
	mov	ecx, edi
	call	DWORD PTR __imp_?GetInt@Results@Database@@QAEHH@Z
	mov	ecx, DWORD PTR [esi+488]
	mov	DWORD PTR [ebx+ecx], eax
	mov	ecx, edi
	add	ebx, 4
	call	ebp
	test	al, al
	jne	SHORT $LL2@CacheResul
$LN1@CacheResul:

; 215  : 		}
; 216  : 
; 217  : 		pResults->Reset();

	mov	ecx, edi
	call	DWORD PTR __imp_?Reset@Results@Database@@QAE_NXZ

; 218  : 	}

	lea	ecx, DWORD PTR _strKey$224010[esp+84]
	mov	DWORD PTR __$EHRec$[esp+92], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 219  : 	return true;
; 220  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+84]
	pop	ebp
	pop	ebx
	pop	edi
	mov	al, 1
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 68					; 00000044H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CacheResults@CvTechEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$0:
	lea	ecx, DWORD PTR _strKey$224001[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?CacheResults@CvTechEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z$1:
	lea	ecx, DWORD PTR _strKey$224010[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?CacheResults@CvTechEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?CacheResults@CvTechEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CacheResults@CvTechEntry@@UAE_NAAVResults@Database@@AAVCvDatabaseUtility@@@Z ENDP ; CvTechEntry::CacheResults
PUBLIC	?Init@CvPlayerTechs@@QAEXPAVCvTechXMLEntries@@PAVCvPlayer@@_N@Z ; CvPlayerTechs::Init
EXTRN	??0CvTechAI@@QAE@PAVCvPlayerTechs@@@Z:PROC	; CvTechAI::CvTechAI
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$?Init@CvPlayerTechs@@QAEXPAVCvTechXMLEntries@@PAVCvPlayer@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Init@CvPlayerTechs@@QAEXPAVCvTechXMLEntries@@PAVCvPlayer@@_N@Z$0
__ehfuncinfo$?Init@CvPlayerTechs@@QAEXPAVCvTechXMLEntries@@PAVCvPlayer@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Init@CvPlayerTechs@@QAEXPAVCvTechXMLEntries@@PAVCvPlayer@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtechclasses.cpp
xdata$x	ENDS
;	COMDAT ?Init@CvPlayerTechs@@QAEXPAVCvTechXMLEntries@@PAVCvPlayer@@_N@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_pTechs$ = 8						; size = 4
_pPlayer$ = 12						; size = 4
$T229641 = 16						; size = 4
_bIsCity$ = 16						; size = 1
?Init@CvPlayerTechs@@QAEXPAVCvTechXMLEntries@@PAVCvPlayer@@_N@Z PROC ; CvPlayerTechs::Init, COMDAT
; _this$ = ecx

; 643  : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?Init@CvPlayerTechs@@QAEXPAVCvTechXMLEntries@@PAVCvPlayer@@_N@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	push	edi
	mov	esi, ecx

; 644  : 	// Init base class
; 645  : 	CvFlavorRecipient::Init();

	call	?Init@CvFlavorRecipient@@UAEXXZ		; CvFlavorRecipient::Init

; 646  : 
; 647  : 	// Store off the pointers to objects we'll need later
; 648  : 	m_bIsCity = bIsCity;

	mov	al, BYTE PTR _bIsCity$[esp+16]

; 649  : 	m_pTechs = pTechs;
; 650  : 	m_pPlayer = pPlayer;

	mov	ecx, DWORD PTR _pPlayer$[esp+16]
	mov	BYTE PTR [esi+4], al
	mov	eax, DWORD PTR _pTechs$[esp+16]
	mov	DWORD PTR [esi+40], eax
	mov	DWORD PTR [esi+44], ecx

; 651  : 
; 652  : 	// Initialize arrays
; 653  : 	const int iNumTechs = m_pTechs->GetNumTechs();

	mov	edi, DWORD PTR [eax+8]
	sub	edi, DWORD PTR [eax+4]
	sar	edi, 2

; 654  : 
; 655  : 	CvAssertMsg(m_pabResearchingTech==NULL, "about to leak memory, CvPlayerTechs::m_pabResearchingTech");
; 656  : 	m_pabResearchingTech = FNEW(bool[iNumTechs], c_eCiv5GameplayDLL, 0);

	push	edi
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+12], eax

; 657  : 	CvAssertMsg(m_piCivTechPriority==NULL, "about to leak memory, CvPlayerTechs::m_piCivTechPriority");
; 658  : 	m_piCivTechPriority = FNEW(int[iNumTechs], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+16], eax

; 659  : 	CvAssertMsg(m_piLocaleTechPriority==NULL, "about to leak memory, CvPlayerTechs::m_piLocaleTechPriority");
; 660  : 	m_piLocaleTechPriority = FNEW(int[iNumTechs], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+20], eax

; 661  : 	CvAssertMsg(m_peLocaleTechResources==NULL, "about to leak memory, CvPlayerTechs::m_peLocaleTechResources");
; 662  : 	m_peLocaleTechResources = FNEW(ResourceTypes[iNumTechs], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+24], eax

; 663  : 	CvAssertMsg(m_peCivTechUniqueUnits==NULL, "about to leak memory, CvPlayerTechs::m_peCivTechUniqueUnits");
; 664  : 	m_peCivTechUniqueUnits = FNEW(UnitTypes[iNumTechs], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+28], eax

; 665  : 	CvAssertMsg(m_peCivTechUniqueBuildings==NULL, "about to leak memory, CvPlayerTechs::m_peCivTechUniqueBuildings");
; 666  : 	m_peCivTechUniqueBuildings = FNEW(BuildingTypes[iNumTechs], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+32], eax

; 667  : 	CvAssertMsg(m_peCivTechUniqueImprovements==NULL, "about to leak memory, CvPlayerTechs::m_peCivTechUniqueImprovements");
; 668  : 	m_peCivTechUniqueImprovements = FNEW(ImprovementTypes[iNumTechs], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+36], eax

; 669  : 
; 670  : 	// Create AI object
; 671  : 	m_pTechAI = FNEW(CvTechAI(this), c_eCiv5GameplayDLL, 0);

	push	1316					; 00000524H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 32					; 00000020H
	mov	DWORD PTR $T229641[esp+16], eax
	mov	DWORD PTR __$EHRec$[esp+28], 0
	test	eax, eax
	je	SHORT $LN3@Init
	push	esi
	mov	ecx, eax
	call	??0CvTechAI@@QAE@PAVCvPlayerTechs@@@Z	; CvTechAI::CvTechAI
	jmp	SHORT $LN4@Init
$LN3@Init:
	xor	eax, eax
$LN4@Init:

; 672  : 
; 673  : 	Reset();

	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+28], -1
	mov	DWORD PTR [esi+48], eax
	call	?Reset@CvPlayerTechs@@QAEXXZ		; CvPlayerTechs::Reset

; 674  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	edi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Init@CvPlayerTechs@@QAEXPAVCvTechXMLEntries@@PAVCvPlayer@@_N@Z$0:
	mov	eax, DWORD PTR $T229641[ebp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?Init@CvPlayerTechs@@QAEXPAVCvTechXMLEntries@@PAVCvPlayer@@_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?Init@CvPlayerTechs@@QAEXPAVCvTechXMLEntries@@PAVCvPlayer@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Init@CvPlayerTechs@@QAEXPAVCvTechXMLEntries@@PAVCvPlayer@@_N@Z ENDP ; CvPlayerTechs::Init
EXTRN	?Uninit@CvFlavorRecipient@@UAEXXZ:PROC		; CvFlavorRecipient::Uninit
; Function compile flags: /Ogtpy
;	COMDAT ?Uninit@CvPlayerTechs@@UAEXXZ
_TEXT	SEGMENT
?Uninit@CvPlayerTechs@@UAEXXZ PROC			; CvPlayerTechs::Uninit, COMDAT
; _this$ = ecx

; 678  : {

	push	ebx
	push	esi
	push	edi
	mov	esi, ecx

; 679  : 	// Uninit base class
; 680  : 	CvFlavorRecipient::Uninit();

	call	?Uninit@CvFlavorRecipient@@UAEXXZ	; CvFlavorRecipient::Uninit

; 681  : 
; 682  : 	SAFE_DELETE_ARRAY(m_pabResearchingTech);

	mov	eax, DWORD PTR [esi+12]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	xor	edi, edi
	mov	DWORD PTR [esi+12], edi

; 683  : 	SAFE_DELETE_ARRAY(m_piCivTechPriority);

	mov	ecx, DWORD PTR [esi+16]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+16], edi

; 684  : 	SAFE_DELETE_ARRAY(m_piLocaleTechPriority);

	mov	edx, DWORD PTR [esi+20]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+20], edi

; 685  : 	SAFE_DELETE_ARRAY(m_peLocaleTechResources);

	mov	eax, DWORD PTR [esi+24]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+24], edi

; 686  : 	SAFE_DELETE_ARRAY(m_peCivTechUniqueBuildings);

	mov	ecx, DWORD PTR [esi+32]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+32], edi

; 687  : 	SAFE_DELETE_ARRAY(m_peCivTechUniqueUnits);

	mov	edx, DWORD PTR [esi+28]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+28], edi

; 688  : 	SAFE_DELETE_ARRAY(m_peCivTechUniqueImprovements);

	mov	eax, DWORD PTR [esi+36]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+36], edi

; 689  : 	SAFE_DELETE(m_pTechAI);

	mov	ebx, DWORD PTR [esi+48]
	add	esp, 28					; 0000001cH
	cmp	ebx, edi
	je	SHORT $LN24@Uninit
	mov	ecx, ebx
	call	??1CvTechAI@@QAE@XZ			; CvTechAI::~CvTechAI
	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN24@Uninit:
	mov	DWORD PTR [esi+48], edi
	pop	edi
	pop	esi
	pop	ebx

; 690  : }

	ret	0
?Uninit@CvPlayerTechs@@UAEXXZ ENDP			; CvPlayerTechs::Uninit
_TEXT	ENDS
PUBLIC	?Read@CvPlayerTechs@@QAEXAAVFDataStream@@@Z	; CvPlayerTechs::Read
EXTRN	?Read@CvTechAI@@QAEXAAVFDataStream@@@Z:PROC	; CvTechAI::Read
; Function compile flags: /Ogtpy
;	COMDAT ?Read@CvPlayerTechs@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
_iNumFlavors$ = 8					; size = 4
_kStream$ = 8						; size = 4
?Read@CvPlayerTechs@@QAEXAAVFDataStream@@@Z PROC	; CvPlayerTechs::Read, COMDAT
; _this$ = ecx

; 860  : {

	push	ecx
	push	ebx
	push	esi

; 861  : 	// Version number to maintain backwards compatibility
; 862  : 	uint uiVersion;
; 863  : 	kStream >> uiVersion;

	mov	esi, DWORD PTR _kStream$[esp+8]
	push	edi
	lea	eax, DWORD PTR _uiVersion$[esp+16]
	mov	ebx, ecx
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 864  : 
; 865  : 	// TODO: If m_pTechs is NULL then the stream will not be advanced causing errors to occur.
; 866  : 	CvAssertMsg(m_pTechs != NULL && m_pTechs->GetNumTechs() > 0, "Number of techs to serialize is expected to greater than 0");
; 867  : 	if(m_pTechs != NULL)

	mov	eax, DWORD PTR [ebx+40]
	test	eax, eax
	je	SHORT $LN1@Read@2

; 868  : 	{
; 869  : 		const int iNumTechs = m_pTechs->GetNumTechs();

	mov	edi, DWORD PTR [eax+8]
	sub	edi, DWORD PTR [eax+4]

; 870  : 
; 871  : 		CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_pabResearchingTech, iNumTechs);

	mov	ecx, DWORD PTR [ebx+12]
	sar	edi, 2
	push	edi
	push	ecx
	push	esi
	call	??$ReadHashedDataArray@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<bool>

; 872  : 		CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_piCivTechPriority, iNumTechs);

	mov	edx, DWORD PTR [ebx+16]
	push	edi
	push	edx
	push	esi
	call	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>

; 873  : 		CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_piLocaleTechPriority, iNumTechs);

	mov	eax, DWORD PTR [ebx+20]
	push	edi
	push	eax
	push	esi
	call	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>

; 874  : 		CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_peLocaleTechResources, iNumTechs);

	mov	ecx, DWORD PTR [ebx+24]
	push	edi
	push	ecx
	push	esi
	call	??$ReadHashedDataArray@W4ResourceTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4ResourceTypes@@H@Z ; CvInfosSerializationHelper::ReadHashedDataArray<enum ResourceTypes>

; 875  : 		CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_peCivTechUniqueUnits, iNumTechs);

	mov	edx, DWORD PTR [ebx+28]
	push	edi
	push	edx
	push	esi
	call	??$ReadHashedDataArray@W4UnitTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4UnitTypes@@H@Z ; CvInfosSerializationHelper::ReadHashedDataArray<enum UnitTypes>

; 876  : 		CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_peCivTechUniqueBuildings, iNumTechs);

	mov	eax, DWORD PTR [ebx+32]
	push	edi
	push	eax
	push	esi
	call	??$ReadHashedDataArray@W4BuildingTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4BuildingTypes@@H@Z ; CvInfosSerializationHelper::ReadHashedDataArray<enum BuildingTypes>

; 877  : 		CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_peCivTechUniqueImprovements, iNumTechs);

	mov	ecx, DWORD PTR [ebx+36]
	add	esp, 72					; 00000048H
	push	edi
	push	ecx
	push	esi
	call	??$ReadHashedDataArray@W4ImprovementTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4ImprovementTypes@@H@Z ; CvInfosSerializationHelper::ReadHashedDataArray<enum ImprovementTypes>
	add	esp, 12					; 0000000cH
$LN1@Read@2:

; 878  : 	}
; 879  : 
; 880  : 	// Now for AI
; 881  : 	m_pTechAI->Read(kStream);

	mov	ecx, DWORD PTR [ebx+48]
	push	esi
	call	?Read@CvTechAI@@QAEXAAVFDataStream@@@Z	; CvTechAI::Read

; 882  : 
; 883  : 	CvAssertMsg(m_piLatestFlavorValues != NULL && GC.getNumFlavorTypes() > 0, "Number of flavor values to serialize is expected to greater than 0");
; 884  : 
; 885  : 	int iNumFlavors;
; 886  : 	kStream >> iNumFlavors;

	lea	edx, DWORD PTR _iNumFlavors$[esp+12]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 887  : 
; 888  : 	ArrayWrapper<int> kLatestFlavorWrapper(iNumFlavors, m_piLatestFlavorValues);

	mov	edi, DWORD PTR [ebx+8]

; 889  : 	kStream >> kLatestFlavorWrapper;

	mov	ebx, DWORD PTR _iNumFlavors$[esp+12]
	test	ebx, ebx
	jle	SHORT $LN14@Read@2
	npad	7
$LL16@Read@2:
	push	edi
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	edi, 4
	sub	ebx, 1
	jne	SHORT $LL16@Read@2
$LN14@Read@2:
	pop	edi
	pop	esi
	pop	ebx

; 890  : }

	pop	ecx
	ret	4
?Read@CvPlayerTechs@@QAEXAAVFDataStream@@@Z ENDP	; CvPlayerTechs::Read
_TEXT	ENDS
PUBLIC	?Write@CvPlayerTechs@@QAEXAAVFDataStream@@@Z	; CvPlayerTechs::Write
EXTRN	?Write@CvTechAI@@QBEXAAVFDataStream@@@Z:PROC	; CvTechAI::Write
; Function compile flags: /Ogtpy
;	COMDAT ?Write@CvPlayerTechs@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
$T229777 = 8						; size = 4
_kStream$ = 8						; size = 4
?Write@CvPlayerTechs@@QAEXAAVFDataStream@@@Z PROC	; CvPlayerTechs::Write, COMDAT
; _this$ = ecx

; 894  : {

	push	ecx
	push	ebx
	push	esi

; 895  : 	// Current version number
; 896  : 	uint uiVersion = 1;
; 897  : 	kStream << uiVersion;

	mov	esi, DWORD PTR _kStream$[esp+8]
	push	edi
	lea	eax, DWORD PTR _uiVersion$[esp+16]
	mov	ebx, ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _uiVersion$[esp+20], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 898  : 
; 899  : 	// TODO: If m_pTechs is NULL then the stream will not advance
; 900  : 	CvAssertMsg(m_pTechs != NULL && m_pTechs->GetNumTechs() > 0, "Number of techs to serialize is expected to greater than 0");
; 901  : 	if(m_pTechs != NULL)

	mov	eax, DWORD PTR [ebx+40]
	test	eax, eax
	je	SHORT $LN1@Write

; 902  : 	{
; 903  : 		const int iNumTechs = m_pTechs->GetNumTechs();

	mov	edi, DWORD PTR [eax+8]
	sub	edi, DWORD PTR [eax+4]

; 904  : 
; 905  : 		CvInfosSerializationHelper::WriteHashedDataArray<TechTypes, bool>(kStream, m_pabResearchingTech, iNumTechs);

	mov	ecx, DWORD PTR [ebx+12]
	sar	edi, 2
	push	edi
	push	ecx
	push	esi
	call	??$WriteHashedDataArray@W4TechTypes@@_N@CvInfosSerializationHelper@@YAXAAVFDataStream@@PA_NI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,bool>

; 906  : 		CvInfosSerializationHelper::WriteHashedDataArray<TechTypes, int>(kStream, m_piCivTechPriority, iNumTechs);

	mov	edx, DWORD PTR [ebx+16]
	push	edi
	push	edx
	push	esi
	call	??$WriteHashedDataArray@W4TechTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,int>

; 907  : 		CvInfosSerializationHelper::WriteHashedDataArray<TechTypes, int>(kStream, m_piLocaleTechPriority, iNumTechs);

	mov	eax, DWORD PTR [ebx+20]
	push	edi
	push	eax
	push	esi
	call	??$WriteHashedDataArray@W4TechTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,int>

; 908  : 		CvInfosSerializationHelper::WriteHashedDataArray<TechTypes, ResourceTypes>(kStream, m_peLocaleTechResources, iNumTechs);

	mov	ecx, DWORD PTR [ebx+24]
	push	edi
	push	ecx
	push	esi
	call	??$WriteHashedDataArray@W4TechTypes@@W4ResourceTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4ResourceTypes@@I@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,enum ResourceTypes>

; 909  : 		CvInfosSerializationHelper::WriteHashedDataArray<TechTypes, UnitTypes>(kStream, m_peCivTechUniqueUnits, iNumTechs);

	mov	edx, DWORD PTR [ebx+28]
	push	edi
	push	edx
	push	esi
	call	??$WriteHashedDataArray@W4TechTypes@@W4UnitTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4UnitTypes@@I@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,enum UnitTypes>

; 910  : 		CvInfosSerializationHelper::WriteHashedDataArray<TechTypes, BuildingTypes>(kStream, m_peCivTechUniqueBuildings, iNumTechs);

	mov	eax, DWORD PTR [ebx+32]
	push	edi
	push	eax
	push	esi
	call	??$WriteHashedDataArray@W4TechTypes@@W4BuildingTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4BuildingTypes@@I@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,enum BuildingTypes>

; 911  : 		CvInfosSerializationHelper::WriteHashedDataArray<TechTypes, ImprovementTypes>(kStream, m_peCivTechUniqueImprovements, iNumTechs);

	mov	ecx, DWORD PTR [ebx+36]
	add	esp, 72					; 00000048H
	push	edi
	push	ecx
	push	esi
	call	??$WriteHashedDataArray@W4TechTypes@@W4ImprovementTypes@@@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAW4ImprovementTypes@@I@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum TechTypes,enum ImprovementTypes>
	add	esp, 12					; 0000000cH
$LN1@Write:

; 912  : 	}
; 913  : 
; 914  : 	// Now for AI
; 915  : 	m_pTechAI->Write(kStream);

	mov	ecx, DWORD PTR [ebx+48]
	push	esi
	call	?Write@CvTechAI@@QBEXAAVFDataStream@@@Z	; CvTechAI::Write

; 916  : 
; 917  : 	CvAssertMsg(m_piLatestFlavorValues != NULL && GC.getNumFlavorTypes() > 0, "Number of flavor values to serialize is expected to greater than 0");
; 918  : 	kStream << GC.getNumFlavorTypes();

	mov	edx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	lea	eax, DWORD PTR $T229777[esp+12]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR $T229777[esp+16], edx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 919  : 	kStream << ArrayWrapper<int>(GC.getNumFlavorTypes(), m_piLatestFlavorValues);

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1764
	mov	edi, DWORD PTR [ebx+8]
	test	eax, eax
	jle	SHORT $LN18@Write

; 912  : 	}
; 913  : 
; 914  : 	// Now for AI
; 915  : 	m_pTechAI->Write(kStream);

	mov	ebx, eax
	npad	2

; 919  : 	kStream << ArrayWrapper<int>(GC.getNumFlavorTypes(), m_piLatestFlavorValues);

$LL20@Write:
	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	edi, 4
	sub	ebx, 1
	jne	SHORT $LL20@Write
$LN18@Write:
	pop	edi
	pop	esi
	pop	ebx

; 920  : }

	pop	ecx
	ret	4
?Write@CvPlayerTechs@@QAEXAAVFDataStream@@@Z ENDP	; CvPlayerTechs::Write
_TEXT	ENDS
PUBLIC	?SetLocalePriorities@CvPlayerTechs@@QAEXXZ	; CvPlayerTechs::SetLocalePriorities
EXTRN	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::nextCity
EXTRN	?canBuild@CvPlayer@@QBE_NPBVCvPlot@@W4BuildTypes@@_N222@Z:PROC ; CvPlayer::canBuild
EXTRN	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z:PROC ; CvImprovementEntry::IsImprovementResourceTrade
EXTRN	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z:PROC ; CvPlot::getResourceType
EXTRN	?plotCity@@YAPAVCvPlot@@HHH@Z:PROC		; plotCity
EXTRN	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z:PROC	; CvPlayer::firstCity
; Function compile flags: /Ogtpy
;	COMDAT ?SetLocalePriorities@CvPlayerTechs@@QAEXXZ
_TEXT	SEGMENT
_pCity$ = -12						; size = 4
_iPlotLoop$224732 = -8					; size = 4
_iLoop$ = -4						; size = 4
?SetLocalePriorities@CvPlayerTechs@@QAEXXZ PROC		; CvPlayerTechs::SetLocalePriorities, COMDAT
; _this$ = ecx

; 1029 : {

	sub	esp, 12					; 0000000cH
	push	ebp
	mov	ebp, ecx

; 1030 : 	int iLoop;
; 1031 : 	CvCity* pCity;
; 1032 : #ifdef AUI_WARNING_FIXES
; 1033 : 	uint iI;
; 1034 : #else
; 1035 : 	int iI;
; 1036 : #endif
; 1037 : 
; 1038 : 	for(iI = 0; iI < m_pTechs->GetNumTechs(); iI++)

	mov	ecx, DWORD PTR [ebp+40]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx+4]
	xor	eax, eax
	push	esi
	test	edx, -4					; fffffffcH
	jle	SHORT $LN22@SetLocaleP
	npad	6
$LL24@SetLocaleP:

; 1039 : 	{
; 1040 : 		m_piLocaleTechPriority[iI] = 1;

	mov	ecx, DWORD PTR [ebp+20]
	mov	DWORD PTR [ecx+eax*4], 1

; 1041 : 		m_peLocaleTechResources[iI] = NO_RESOURCE;

	mov	edx, DWORD PTR [ebp+24]
	mov	DWORD PTR [edx+eax*4], -1
	mov	ecx, DWORD PTR [ebp+40]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx+4]
	inc	eax
	sar	edx, 2
	cmp	eax, edx
	jl	SHORT $LL24@SetLocaleP
$LN22@SetLocaleP:

; 1042 : 	}
; 1043 : 
; 1044 : 	// Loop through all our cities
; 1045 : 	for(pCity = m_pPlayer->firstCity(&iLoop); pCity != NULL; pCity = m_pPlayer->nextCity(&iLoop))

	mov	ecx, DWORD PTR [ebp+44]
	push	0
	lea	eax, DWORD PTR _iLoop$[esp+24]
	push	eax
	call	?firstCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::firstCity
	mov	esi, eax
	mov	DWORD PTR _pCity$[esp+20], esi
	test	esi, esi
	je	$LN19@SetLocaleP
	push	ebx
	push	edi
	jmp	SHORT $LN21@SetLocaleP
$LL83@SetLocaleP:
	mov	esi, DWORD PTR _pCity$[esp+28]
$LN21@SetLocaleP:

; 1046 : 	{
; 1047 : 		// Look at all Tiles this City could potentially work to see if there are any non-water resources that could be improved
; 1048 : 		for(int iPlotLoop = 0; iPlotLoop < NUM_CITY_PLOTS; iPlotLoop++)

	xor	edx, edx
	mov	DWORD PTR _iPlotLoop$224732[esp+28], edx
$LL89@SetLocaleP:

; 1049 : 		{
; 1050 : 			CvPlot* pLoopPlot = plotCity(pCity->getX(), pCity->getY(), iPlotLoop);

	mov	eax, DWORD PTR [esi+108]
	mov	ecx, DWORD PTR [esi+96]
	push	edx
	push	eax
	push	ecx
	call	?plotCity@@YAPAVCvPlot@@HHH@Z		; plotCity
	mov	edi, eax
	add	esp, 12					; 0000000cH

; 1051 : 
; 1052 : 			if(pLoopPlot != NULL)

	test	edi, edi
	je	$LN17@SetLocaleP

; 1053 : 			{
; 1054 : 				int iDistance = plotDistance(pLoopPlot->getX(), pLoopPlot->getY(), pCity->getX(), pCity->getY());
; 1055 : 
; 1056 : 				if(pLoopPlot->getOwner() == pCity->getOwner() || (iDistance <= 2 && pLoopPlot->getOwner() == NO_PLAYER))

	mov	bl, BYTE PTR [edi+4]
	movsx	ecx, bl
	cmp	ecx, DWORD PTR [esi+84]
	je	SHORT $LN13@SetLocaleP
	mov	edx, DWORD PTR [esi+108]
	mov	eax, DWORD PTR [esi+96]
	movsx	ecx, WORD PTR [edi+2]
	push	edx
	movsx	edx, WORD PTR [edi]
	push	eax
	push	ecx
	push	edx
	call	?plotDistance@@YAHHHHH@Z		; plotDistance
	add	esp, 16					; 00000010H
	cmp	eax, 2
	jg	$LN17@SetLocaleP
	cmp	bl, -1
	jne	$LN17@SetLocaleP
$LN13@SetLocaleP:

; 1057 : 				{
; 1058 : 					if(!pLoopPlot->isWater())

	cmp	BYTE PTR [edi+5], 3
	je	$LN17@SetLocaleP

; 1059 : 					{
; 1060 : 						ResourceTypes eResource = pLoopPlot->getResourceType(m_pPlayer->getTeam());

	mov	eax, DWORD PTR [ebp+44]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN65@SetLocaleP
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN66@SetLocaleP
$LN65@SetLocaleP:
	or	eax, -1
$LN66@SetLocaleP:
	push	eax
	mov	ecx, edi
	call	?getResourceType@CvPlot@@QBE?AW4ResourceTypes@@W4TeamTypes@@@Z ; CvPlot::getResourceType
	mov	ebx, eax

; 1061 : 						if(eResource == NO_RESOURCE)

	cmp	ebx, -1
	je	$LN17@SetLocaleP

; 1062 : 						{
; 1063 : 							continue;
; 1064 : 						}
; 1065 : 
; 1066 : 						// Loop through the build types to find one that we can use
; 1067 : 						ImprovementTypes eCorrectImprovement = NO_IMPROVEMENT;
; 1068 : 						BuildTypes eCorrectBuild = NO_BUILD;
; 1069 : #ifdef AUI_WARNING_FIXES
; 1070 : 						uint iBuildIndex;
; 1071 : #else
; 1072 : 						int iBuildIndex;
; 1073 : #endif
; 1074 : 						for(iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	test	eax, eax
	jle	$LN87@SetLocaleP
	npad	2
$LL10@SetLocaleP:

; 1075 : 						{
; 1076 : 							const BuildTypes eBuild = static_cast<BuildTypes>(iBuildIndex);
; 1077 : 							CvBuildInfo* pkBuildInfo = GC.getBuildInfo(eBuild);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo

; 1078 : 							if(pkBuildInfo)

	test	eax, eax
	je	SHORT $LN9@SetLocaleP

; 1079 : 							{
; 1080 : 								// If this is the improvement we're looking for
; 1081 : 								const ImprovementTypes eImprovement = (ImprovementTypes)pkBuildInfo->getImprovement();

	mov	ecx, eax
	call	?getImprovement@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getImprovement

; 1082 : 								if(eImprovement != NO_IMPROVEMENT)

	cmp	eax, -1
	je	SHORT $LN9@SetLocaleP

; 1083 : 								{
; 1084 : 									CvImprovementEntry* pkImprovementInfo = GC.getImprovementInfo(eImprovement);

	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getImprovementInfo@CvGlobals@@QAEPAVCvImprovementEntry@@W4ImprovementTypes@@@Z ; CvGlobals::getImprovementInfo

; 1085 : 									if(pkImprovementInfo && pkImprovementInfo->IsImprovementResourceTrade(eResource))

	test	eax, eax
	je	SHORT $LN9@SetLocaleP
	push	ebx
	mov	ecx, eax
	call	?IsImprovementResourceTrade@CvImprovementEntry@@QBE_NH@Z ; CvImprovementEntry::IsImprovementResourceTrade
	test	al, al
	jne	SHORT $LN78@SetLocaleP
$LN9@SetLocaleP:

; 1062 : 						{
; 1063 : 							continue;
; 1064 : 						}
; 1065 : 
; 1066 : 						// Loop through the build types to find one that we can use
; 1067 : 						ImprovementTypes eCorrectImprovement = NO_IMPROVEMENT;
; 1068 : 						BuildTypes eCorrectBuild = NO_BUILD;
; 1069 : #ifdef AUI_WARNING_FIXES
; 1070 : 						uint iBuildIndex;
; 1071 : #else
; 1072 : 						int iBuildIndex;
; 1073 : #endif
; 1074 : 						for(iBuildIndex = 0; iBuildIndex < GC.getNumBuildInfos(); iBuildIndex++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumBuildInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumBuildInfos
	cmp	esi, eax
	jl	SHORT $LL10@SetLocaleP

; 1085 : 									if(pkImprovementInfo && pkImprovementInfo->IsImprovementResourceTrade(eResource))

	jmp	SHORT $LN87@SetLocaleP
$LN78@SetLocaleP:

; 1086 : 									{
; 1087 : 										eCorrectBuild = eBuild;
; 1088 : 										eCorrectImprovement = eImprovement;
; 1089 : 										break;
; 1090 : 									}
; 1091 : 								}
; 1092 : 							}
; 1093 : 						}
; 1094 : 
; 1095 : 						// No valid build found
; 1096 : 						if(eCorrectBuild == NO_BUILD || eCorrectImprovement == NO_IMPROVEMENT)

	cmp	esi, -1
	je	SHORT $LN87@SetLocaleP

; 1097 : 						{
; 1098 : 							continue;
; 1099 : 						}
; 1100 : 
; 1101 : 
; 1102 : 						// Looking for cases where we can't build the improvement for the resource
; 1103 : 						if(!m_pPlayer->canBuild(pLoopPlot, eCorrectBuild, false, false))

	mov	ecx, DWORD PTR [ebp+44]
	push	1
	push	1
	push	0
	push	0
	push	esi
	push	edi
	call	?canBuild@CvPlayer@@QBE_NPBVCvPlot@@W4BuildTypes@@_N222@Z ; CvPlayer::canBuild
	test	al, al
	jne	SHORT $LN87@SetLocaleP

; 1104 : 						{
; 1105 : 							// Find the tech associated with this build and increment its multiplier
; 1106 : #ifdef AUI_WARNING_FIXES
; 1107 : 							uint iTech = (uint)GC.getBuildInfo(eCorrectBuild)->getTechPrereq();
; 1108 : 							CvAssert(iTech < m_pTechs->GetNumTechs());		// Just assert on a value off the top end, a -1 is ok to just skip silently
; 1109 : 							if (iTech < m_pTechs->GetNumTechs())
; 1110 : #else
; 1111 : 							int iTech = GC.getBuildInfo(eCorrectBuild)->getTechPrereq();

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getBuildInfo@CvGlobals@@QAEPAVCvBuildInfo@@W4BuildTypes@@@Z ; CvGlobals::getBuildInfo
	mov	ecx, eax
	call	?getTechPrereq@CvBuildInfo@@QBEHXZ	; CvBuildInfo::getTechPrereq

; 1112 : 							CvAssert(iTech < m_pTechs->GetNumTechs());		// Just assert on a value off the top end, a -1 is ok to just skip silently
; 1113 : 							if (iTech >= 0 && iTech < m_pTechs->GetNumTechs())

	test	eax, eax
	jl	SHORT $LN87@SetLocaleP
	mov	ecx, DWORD PTR [ebp+40]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR [ecx+4]
	sar	edx, 2
	cmp	eax, edx
	jge	SHORT $LN87@SetLocaleP

; 1114 : #endif
; 1115 : 							{
; 1116 : 								m_piLocaleTechPriority[iTech]++;

	mov	ecx, DWORD PTR [ebp+20]
	inc	DWORD PTR [ecx+eax*4]

; 1117 : 								m_peLocaleTechResources[iTech] = eResource;

	mov	edx, DWORD PTR [ebp+24]
	lea	ecx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edx+eax*4], ebx
$LN87@SetLocaleP:
	mov	esi, DWORD PTR _pCity$[esp+28]
$LN17@SetLocaleP:

; 1046 : 	{
; 1047 : 		// Look at all Tiles this City could potentially work to see if there are any non-water resources that could be improved
; 1048 : 		for(int iPlotLoop = 0; iPlotLoop < NUM_CITY_PLOTS; iPlotLoop++)

	mov	edx, DWORD PTR _iPlotLoop$224732[esp+28]
	inc	edx
	cmp	edx, 37					; 00000025H
	mov	DWORD PTR _iPlotLoop$224732[esp+28], edx
	jl	$LL89@SetLocaleP
	mov	ecx, DWORD PTR [ebp+44]
	push	0
	lea	eax, DWORD PTR _iLoop$[esp+32]
	push	eax
	call	?nextCity@CvPlayer@@QAEPAVCvCity@@PAH_N@Z ; CvPlayer::nextCity
	mov	DWORD PTR _pCity$[esp+28], eax
	test	eax, eax
	jne	$LL83@SetLocaleP
	pop	edi
	pop	ebx
$LN19@SetLocaleP:
	pop	esi
	pop	ebp

; 1118 : 							}
; 1119 : 						}
; 1120 : 					}
; 1121 : 				}
; 1122 : 			}
; 1123 : 		}
; 1124 : 	}
; 1125 : }

	add	esp, 12					; 0000000cH
	ret	0
?SetLocalePriorities@CvPlayerTechs@@QAEXXZ ENDP		; CvPlayerTechs::SetLocalePriorities
_TEXT	ENDS
PUBLIC	?CanEverResearch@CvPlayerTechs@@QBE_NW4TechTypes@@@Z ; CvPlayerTechs::CanEverResearch
EXTRN	?CallTestAll@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z:PROC ; LuaSupport::CallTestAll
EXTRN	?isCivilizationDisableTechs@CvCivilizationInfo@@QBE_NH@Z:PROC ; CvCivilizationInfo::isCivilizationDisableTechs
EXTRN	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ:PROC ; CvPlayer::getCivilizationInfo
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\lua\cvluaargshandle.h
xdata$x	SEGMENT
__unwindtable$?CanEverResearch@CvPlayerTechs@@QBE_NW4TechTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CanEverResearch@CvPlayerTechs@@QBE_NW4TechTypes@@@Z$0
__ehfuncinfo$?CanEverResearch@CvPlayerTechs@@QBE_NW4TechTypes@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CanEverResearch@CvPlayerTechs@@QBE_NW4TechTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtechclasses.cpp
xdata$x	ENDS
;	COMDAT ?CanEverResearch@CvPlayerTechs@@QBE_NW4TechTypes@@@Z
_TEXT	SEGMENT
_args$224778 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_bResult$224779 = 8					; size = 1
_eTech$ = 8						; size = 4
?CanEverResearch@CvPlayerTechs@@QBE_NW4TechTypes@@@Z PROC ; CvPlayerTechs::CanEverResearch, COMDAT
; _this$ = ecx

; 1147 : {

	push	-1
	push	__ehhandler$?CanEverResearch@CvPlayerTechs@@QBE_NW4TechTypes@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebp

; 1148 : 	CvTechEntry* pkTechInfo = GC.getTechInfo(eTech);

	mov	ebp, DWORD PTR _eTech$[esp+16]
	push	edi
	mov	edi, ecx
	push	ebp
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo

; 1149 : 	if(pkTechInfo == NULL)

	test	eax, eax
	jne	SHORT $LN6@CanEverRes
$LN26@CanEverRes:
	pop	edi

; 1150 : 	{
; 1151 : 		return false;

	xor	al, al
	pop	ebp

; 1183 : 
; 1184 : 
; 1185 : 	return true;
; 1186 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
$LN6@CanEverRes:

; 1152 : 	}
; 1153 : 
; 1154 : 	if(pkTechInfo->IsDisable())

	cmp	BYTE PTR [eax+340], 0

; 1155 : 	{
; 1156 : 		return false;

	jne	SHORT $LN26@CanEverRes

; 1157 : 	}
; 1158 : 
; 1159 : 	if(m_pPlayer->getCivilizationInfo().isCivilizationDisableTechs(eTech))

	mov	ecx, DWORD PTR [edi+44]
	push	ebp
	call	?getCivilizationInfo@CvPlayer@@QBEAAVCvCivilizationInfo@@XZ ; CvPlayer::getCivilizationInfo
	mov	ecx, eax
	call	?isCivilizationDisableTechs@CvCivilizationInfo@@QBE_NH@Z ; CvCivilizationInfo::isCivilizationDisableTechs
	test	al, al

; 1160 : 	{
; 1161 : 		return false;

	jne	SHORT $LN26@CanEverRes

; 1162 : 	}
; 1163 : 
; 1164 : 	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+12]
	push	esi
	call	edx
	mov	esi, eax

; 1165 : 	if(pkScriptSystem)

	test	esi, esi
	je	$LN3@CanEverRes

; 1166 : 	{
; 1167 : 		CvLuaArgsHandle args;

	lea	ecx, DWORD PTR _args$224778[esp+28]
	call	??0CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::CvLuaArgsHandle

; 1168 : 		args->Push(m_pPlayer->GetID());

	mov	eax, DWORD PTR [edi+44]
	mov	eax, DWORD PTR [eax+44]
	mov	ecx, DWORD PTR _args$224778[esp+28]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __$EHRec$[esp+40], 0
	call	eax

; 1169 : 		args->Push(eTech);

	mov	ecx, DWORD PTR _args$224778[esp+28]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]
	push	ebp
	call	eax

; 1170 : 
; 1171 : 		// Attempt to execute the game events.
; 1172 : 		// Will return false if there are no registered listeners.
; 1173 : 		bool bResult = false;
; 1174 : 		if(LuaSupport::CallTestAll(pkScriptSystem, "PlayerCanEverResearch", args.get(), bResult))

	mov	edx, DWORD PTR _args$224778[esp+28]
	lea	ecx, DWORD PTR _bResult$224779[esp+24]
	push	ecx
	push	edx
	push	OFFSET $SG224781
	push	esi
	mov	BYTE PTR _bResult$224779[esp+40], 0
	call	?CallTestAll@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallTestAll
	add	esp, 16					; 00000010H
	test	al, al
	je	SHORT $LN1@CanEverRes

; 1175 : 		{
; 1176 : 			// Check the result.
; 1177 : 			if(bResult == false)

	cmp	BYTE PTR _bResult$224779[esp+24], 0
	jne	SHORT $LN1@CanEverRes

; 1178 : 			{
; 1179 : 				return false;

	lea	ecx, DWORD PTR _args$224778[esp+28]
	mov	DWORD PTR __$EHRec$[esp+36], -1
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
	pop	esi
	pop	edi
	xor	al, al
	pop	ebp

; 1183 : 
; 1184 : 
; 1185 : 	return true;
; 1186 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
$LN1@CanEverRes:

; 1180 : 			}
; 1181 : 		}
; 1182 : 	}

	lea	ecx, DWORD PTR _args$224778[esp+28]
	mov	DWORD PTR __$EHRec$[esp+36], -1
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN3@CanEverRes:

; 1183 : 
; 1184 : 
; 1185 : 	return true;
; 1186 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	pop	esi
	pop	edi
	mov	al, 1
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CanEverResearch@CvPlayerTechs@@QBE_NW4TechTypes@@@Z$0:
	lea	ecx, DWORD PTR _args$224778[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__ehhandler$?CanEverResearch@CvPlayerTechs@@QBE_NW4TechTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?CanEverResearch@CvPlayerTechs@@QBE_NW4TechTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CanEverResearch@CvPlayerTechs@@QBE_NW4TechTypes@@@Z ENDP ; CvPlayerTechs::CanEverResearch
PUBLIC	?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z ; CvPlayerTechs::CanResearch
EXTRN	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ:PROC ; CvTeam::GetTeamTechs
EXTRN	?getAdvancedStartPoints@CvPlayer@@QBEHXZ:PROC	; CvPlayer::getAdvancedStartPoints
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\lua\cvluaargshandle.h
xdata$x	SEGMENT
__unwindtable$?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z$0
__ehfuncinfo$?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtechclasses.cpp
xdata$x	ENDS
;	COMDAT ?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z
_TEXT	SEGMENT
_args$224817 = -16					; size = 4
_pkTechEntry$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_eTech$ = 8						; size = 4
_bResult$224818 = 12					; size = 1
_bTrade$ = 12						; size = 1
?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z PROC	; CvPlayerTechs::CanResearch, COMDAT
; _this$ = ecx

; 1190 : {

	push	-1
	push	__ehhandler$?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebp
	push	esi
	push	edi

; 1191 : 	bool bFoundPossible;
; 1192 : 	bool bFoundValid;
; 1193 : 	int iI;
; 1194 : 
; 1195 : 	CvTechEntry* pkTechEntry = GC.getTechInfo(eTech);

	mov	edi, DWORD PTR _eTech$[esp+24]
	mov	ebp, ecx
	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo
	mov	esi, eax
	mov	DWORD PTR _pkTechEntry$[esp+28], esi

; 1196 : 	if(pkTechEntry == NULL)

	test	esi, esi
	jne	SHORT $LN21@CanResearc
$LN146@CanResearc:
	pop	edi
	pop	esi

; 1197 : 		return false;

	xor	al, al
	pop	ebp

; 1280 : 
; 1281 : 	return true;
; 1282 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	8
$LN21@CanResearc:

; 1198 : 
; 1199 : 	if(!IsResearch() && m_pPlayer->getAdvancedStartPoints() < 0)

	mov	ecx, DWORD PTR [ebp+44]
	call	?isFoundedFirstCity@CvPlayer@@QBE_NXZ	; CvPlayer::isFoundedFirstCity
	test	al, al
	jne	SHORT $LN20@CanResearc
	mov	ecx, DWORD PTR [ebp+44]
	call	?getAdvancedStartPoints@CvPlayer@@QBEHXZ ; CvPlayer::getAdvancedStartPoints
	test	eax, eax

; 1200 : 	{
; 1201 : 		return false;

	jl	SHORT $LN146@CanResearc
$LN20@CanResearc:

; 1202 : 	}
; 1203 : 
; 1204 : 	// Do we already have this tech?
; 1205 : 	if(GET_TEAM(m_pPlayer->getTeam()).GetTeamTechs()->HasTech(eTech))

	mov	eax, DWORD PTR [ebp+44]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN32@CanResearc
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN33@CanResearc
$LN32@CanResearc:
	or	eax, -1
$LN33@CanResearc:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	cmp	edi, -1
	je	SHORT $LN146@CanResearc
	mov	eax, DWORD PTR [eax+4]
	test	eax, eax
	je	SHORT $LN19@CanResearc
	cmp	BYTE PTR [eax+edi], 0

; 1206 : 	{
; 1207 : 		return false;

	jne	SHORT $LN146@CanResearc
$LN19@CanResearc:
	push	ebx

; 1208 : 	}
; 1209 : 
; 1210 : 	bFoundPossible = false;
; 1211 : 	bFoundValid = false;
; 1212 : 
; 1213 : 	// See if it is possible based on OR prereqs
; 1214 : 	for(iI = 0; iI < GC.getNUM_OR_TECH_PREREQS(); iI++)

	xor	edi, edi
	xor	bl, bl
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+6268, edi
	jle	$LN140@CanResearc
	jmp	SHORT $LN18@CanResearc
	npad	10
$LL142@CanResearc:
	mov	esi, DWORD PTR _pkTechEntry$[esp+32]
$LN18@CanResearc:

; 1215 : 	{
; 1216 : 		TechTypes ePrereq = (TechTypes)pkTechEntry->GetPrereqOrTechs(iI);

	mov	eax, DWORD PTR [esi+484]
	test	eax, eax
	je	$LN17@CanResearc
	mov	esi, DWORD PTR [eax+edi*4]

; 1217 : 		if(ePrereq != NO_TECH)

	cmp	esi, -1
	je	SHORT $LN17@CanResearc

; 1218 : 		{
; 1219 : 			bFoundPossible = true;
; 1220 : 
; 1221 : 			if(GET_TEAM(m_pPlayer->getTeam()).GetTeamTechs()->HasTech(ePrereq))

	mov	eax, DWORD PTR [ebp+44]
	mov	eax, DWORD PTR [eax+44]
	mov	bl, 1
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN54@CanResearc
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN55@CanResearc
$LN54@CanResearc:
	or	eax, -1
$LN55@CanResearc:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	eax, DWORD PTR [eax+4]
	test	eax, eax
	je	SHORT $LN17@CanResearc
	cmp	BYTE PTR [eax+esi], 0
	je	SHORT $LN17@CanResearc

; 1222 : 			{
; 1223 : 				if(!bTrade || !GET_TEAM(m_pPlayer->getTeam()).GetTeamTechs()->IsNoTradeTech(ePrereq))

	cmp	BYTE PTR _bTrade$[esp+28], 0
	je	SHORT $LN140@CanResearc
	mov	eax, DWORD PTR [ebp+44]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN70@CanResearc
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN71@CanResearc
$LN70@CanResearc:
	or	eax, -1
$LN71@CanResearc:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	eax, DWORD PTR [eax+8]
	cmp	BYTE PTR [esi+eax], 0
	je	SHORT $LN140@CanResearc
$LN17@CanResearc:

; 1208 : 	}
; 1209 : 
; 1210 : 	bFoundPossible = false;
; 1211 : 	bFoundValid = false;
; 1212 : 
; 1213 : 	// See if it is possible based on OR prereqs
; 1214 : 	for(iI = 0; iI < GC.getNUM_OR_TECH_PREREQS(); iI++)

	inc	edi
	cmp	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6268
	jl	$LL142@CanResearc

; 1224 : 				{
; 1225 : 					bFoundValid = true;
; 1226 : 					break;
; 1227 : 				}
; 1228 : 			}
; 1229 : 		}
; 1230 : 	}
; 1231 : 
; 1232 : 	if(bFoundPossible && !bFoundValid)

	test	bl, bl

; 1233 : 	{
; 1234 : 		return false;

	jne	$LN145@CanResearc
$LN140@CanResearc:

; 1235 : 	}
; 1236 : 
; 1237 : 	// See if it is possible based on AND prereqs
; 1238 : 	for(iI = 0; iI < GC.getNUM_AND_TECH_PREREQS(); iI++)

	xor	edi, edi
	cmp	DWORD PTR ?gGlobals@@3VCvGlobals@@A+6272, edi
	jle	$LN8@CanResearc
	npad	6
$LL10@CanResearc:

; 1239 : 	{
; 1240 : 		TechTypes ePrereq = (TechTypes)pkTechEntry->GetPrereqAndTechs(iI);

	mov	ecx, DWORD PTR _pkTechEntry$[esp+32]
	mov	eax, DWORD PTR [ecx+488]
	test	eax, eax
	je	$LN9@CanResearc
	mov	esi, DWORD PTR [eax+edi*4]

; 1241 : 		if(ePrereq != NO_TECH)

	cmp	esi, -1
	je	$LN9@CanResearc

; 1242 : 		{
; 1243 : 			if(!GET_TEAM(m_pPlayer->getTeam()).GetTeamTechs()->HasTech(ePrereq))

	mov	edx, DWORD PTR [ebp+44]
	mov	eax, DWORD PTR [edx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN89@CanResearc
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN90@CanResearc
$LN89@CanResearc:
	or	eax, -1
$LN90@CanResearc:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	eax, DWORD PTR [eax+4]
	test	eax, eax
	je	$LN145@CanResearc
	cmp	BYTE PTR [eax+esi], 0
	je	$LN145@CanResearc

; 1244 : 			{
; 1245 : 				return false;
; 1246 : 			}
; 1247 : 
; 1248 : 			if(bTrade && GET_TEAM(m_pPlayer->getTeam()).GetTeamTechs()->IsNoTradeTech(ePrereq))

	cmp	BYTE PTR _bTrade$[esp+28], 0
	je	SHORT $LN9@CanResearc
	mov	eax, DWORD PTR [ebp+44]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN105@CanResearc
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN106@CanResearc
$LN105@CanResearc:
	or	eax, -1
$LN106@CanResearc:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	eax, DWORD PTR [eax+8]
	cmp	BYTE PTR [esi+eax], 0
	jne	$LN145@CanResearc
$LN9@CanResearc:

; 1235 : 	}
; 1236 : 
; 1237 : 	// See if it is possible based on AND prereqs
; 1238 : 	for(iI = 0; iI < GC.getNUM_AND_TECH_PREREQS(); iI++)

	inc	edi
	cmp	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+6272
	jl	$LL10@CanResearc
$LN8@CanResearc:

; 1249 : 			{
; 1250 : 				return false;
; 1251 : 			}
; 1252 : 		}
; 1253 : 	}
; 1254 : 
; 1255 : 	// Is it disabled for some reason?
; 1256 : 	if(!CanEverResearch(eTech))

	mov	ecx, DWORD PTR _eTech$[esp+28]
	push	ecx
	mov	ecx, ebp
	call	?CanEverResearch@CvPlayerTechs@@QBE_NW4TechTypes@@@Z ; CvPlayerTechs::CanEverResearch
	test	al, al

; 1257 : 	{
; 1258 : 		return false;

	je	$LN145@CanResearc

; 1259 : 	}
; 1260 : 
; 1261 : 	ICvEngineScriptSystem1* pkScriptSystem = gDLL->GetScriptSystem();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	mov	esi, eax

; 1262 : 	if(pkScriptSystem)

	test	esi, esi
	je	$LN3@CanResearc

; 1263 : 	{
; 1264 : 		CvLuaArgsHandle args;

	lea	ecx, DWORD PTR _args$224817[esp+32]
	call	??0CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::CvLuaArgsHandle

; 1265 : 		args->Push(m_pPlayer->GetID());

	mov	ecx, DWORD PTR [ebp+44]
	mov	eax, DWORD PTR [ecx+44]
	mov	ecx, DWORD PTR _args$224817[esp+32]
	mov	edx, DWORD PTR [ecx]
	push	eax
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __$EHRec$[esp+44], 0
	call	eax

; 1266 : 		args->Push(eTech);

	mov	ecx, DWORD PTR _args$224817[esp+32]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _eTech$[esp+28]
	mov	edx, DWORD PTR [edx+8]
	push	eax
	call	edx

; 1267 : 
; 1268 : 		// Attempt to execute the game events.
; 1269 : 		// Will return false if there are no registered listeners.
; 1270 : 		bool bResult = false;
; 1271 : 		if(LuaSupport::CallTestAll(pkScriptSystem, "PlayerCanResearch", args.get(), bResult))

	mov	ecx, DWORD PTR _args$224817[esp+32]
	lea	eax, DWORD PTR _bResult$224818[esp+28]
	push	eax
	push	ecx
	push	OFFSET $SG224820
	push	esi
	mov	BYTE PTR _bResult$224818[esp+44], 0
	call	?CallTestAll@LuaSupport@@YA_NPAVICvEngineScriptSystem1@@PBDPAVICvEngineScriptSystemArgs1@@AA_N@Z ; LuaSupport::CallTestAll
	add	esp, 16					; 00000010H
	test	al, al
	je	SHORT $LN1@CanResearc

; 1272 : 		{
; 1273 : 			// Check the result.
; 1274 : 			if(bResult == false)

	cmp	BYTE PTR _bResult$224818[esp+28], 0
	jne	SHORT $LN1@CanResearc

; 1275 : 			{
; 1276 : 				return false;

	lea	ecx, DWORD PTR _args$224817[esp+32]
	mov	DWORD PTR __$EHRec$[esp+40], -1
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN145@CanResearc:
	pop	ebx
	pop	edi
	pop	esi
	xor	al, al
	pop	ebp

; 1280 : 
; 1281 : 	return true;
; 1282 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	8
$LN1@CanResearc:

; 1277 : 			}
; 1278 : 		}
; 1279 : 	}

	lea	ecx, DWORD PTR _args$224817[esp+32]
	mov	DWORD PTR __$EHRec$[esp+40], -1
	call	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
$LN3@CanResearc:

; 1280 : 
; 1281 : 	return true;
; 1282 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	pop	ebx
	pop	edi
	pop	esi
	mov	al, 1
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z$0:
	lea	ecx, DWORD PTR _args$224817[ebp]
	jmp	??1CvLuaArgsHandle@@QAE@XZ		; CvLuaArgsHandle::~CvLuaArgsHandle
__ehhandler$?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z:
	mov	eax, OFFSET __ehfuncinfo$?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z ENDP	; CvPlayerTechs::CanResearch
PUBLIC	?CanResearchForFree@CvPlayerTechs@@QBE_NW4TechTypes@@@Z ; CvPlayerTechs::CanResearchForFree
; Function compile flags: /Ogtpy
;	COMDAT ?CanResearchForFree@CvPlayerTechs@@QBE_NW4TechTypes@@@Z
_TEXT	SEGMENT
_eTech$ = 8						; size = 4
?CanResearchForFree@CvPlayerTechs@@QBE_NW4TechTypes@@@Z PROC ; CvPlayerTechs::CanResearchForFree, COMDAT
; _this$ = ecx

; 1286 : {

	push	esi

; 1287 : #ifdef AUI_WARNING_FIXES
; 1288 : 	CvAssertMsg(uint(eTech) < GC.getNumTechInfos(), "eTech is expected to be within maximum bounds (invalid Index)");
; 1289 : 	if (uint(eTech) >= GC.getNumTechInfos()) return false;
; 1290 : #else
; 1291 : 	CvAssertMsg(eTech >= 0, "eTech is expected to be non-negative (invalid Index)");
; 1292 : 	CvAssertMsg(eTech < GC.getNumTechInfos(), "eTech is expected to be within maximum bounds (invalid Index)");
; 1293 : 	if(eTech < 0 || eTech >= GC.getNumTechInfos()) return false;

	mov	esi, DWORD PTR _eTech$[esp]
	push	edi
	mov	edi, ecx
	test	esi, esi
	jl	SHORT $LN1@CanResearc@2
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	cmp	esi, eax
	jge	SHORT $LN1@CanResearc@2

; 1294 : #endif
; 1295 : 
; 1296 : 	// We can pick any tech that we are able to research
; 1297 : 	return CanResearch(eTech);

	push	0
	push	esi
	mov	ecx, edi
	call	?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z ; CvPlayerTechs::CanResearch
	pop	edi
	pop	esi

; 1298 : }

	ret	4
$LN1@CanResearc@2:
	pop	edi

; 1287 : #ifdef AUI_WARNING_FIXES
; 1288 : 	CvAssertMsg(uint(eTech) < GC.getNumTechInfos(), "eTech is expected to be within maximum bounds (invalid Index)");
; 1289 : 	if (uint(eTech) >= GC.getNumTechInfos()) return false;
; 1290 : #else
; 1291 : 	CvAssertMsg(eTech >= 0, "eTech is expected to be non-negative (invalid Index)");
; 1292 : 	CvAssertMsg(eTech < GC.getNumTechInfos(), "eTech is expected to be within maximum bounds (invalid Index)");
; 1293 : 	if(eTech < 0 || eTech >= GC.getNumTechInfos()) return false;

	xor	al, al
	pop	esi

; 1298 : }

	ret	4
?CanResearchForFree@CvPlayerTechs@@QBE_NW4TechTypes@@@Z ENDP ; CvPlayerTechs::CanResearchForFree
_TEXT	ENDS
PUBLIC	?IsNoResearchAvailable@CvPlayerTechs@@QBE_NXZ	; CvPlayerTechs::IsNoResearchAvailable
; Function compile flags: /Ogtpy
;	COMDAT ?IsNoResearchAvailable@CvPlayerTechs@@QBE_NXZ
_TEXT	SEGMENT
?IsNoResearchAvailable@CvPlayerTechs@@QBE_NXZ PROC	; CvPlayerTechs::IsNoResearchAvailable, COMDAT
; _this$ = ecx

; 1337 : {

	push	edi
	mov	edi, ecx

; 1338 : #ifdef AUI_WARNING_FIXES
; 1339 : 	uint iI;
; 1340 : #else
; 1341 : 	int iI;
; 1342 : #endif
; 1343 : 
; 1344 : 	if(GetCurrentResearch() != NO_TECH)

	mov	ecx, DWORD PTR [edi+44]
	call	?headResearchQueueNode@CvPlayer@@QAEPAV?$CLLNode@W4TechTypes@@@@XZ ; CvPlayer::headResearchQueueNode
	test	eax, eax
	je	SHORT $LN5@IsNoResear
	cmp	DWORD PTR [eax+4], -1
	je	SHORT $LN5@IsNoResear

; 1345 : 	{
; 1346 : 		return false;

	xor	al, al
	pop	edi

; 1357 : }

	ret	0
$LN5@IsNoResear:
	push	esi

; 1347 : 	}
; 1348 : 
; 1349 : 	for(iI = 0; iI < GC.getNumTechInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	test	eax, eax
	jle	SHORT $LN2@IsNoResear
	npad	6
$LL4@IsNoResear:

; 1350 : 	{
; 1351 : 		if(CanResearch((TechTypes)iI))

	push	0
	push	esi
	mov	ecx, edi
	call	?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z ; CvPlayerTechs::CanResearch
	test	al, al
	jne	SHORT $LN13@IsNoResear
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	cmp	esi, eax
	jl	SHORT $LL4@IsNoResear
$LN2@IsNoResear:
	pop	esi

; 1354 : 		}
; 1355 : 	}
; 1356 : 	return true;

	mov	al, 1
	pop	edi

; 1357 : }

	ret	0
$LN13@IsNoResear:
	pop	esi

; 1352 : 		{
; 1353 : 			return false;

	xor	al, al
	pop	edi

; 1357 : }

	ret	0
?IsNoResearchAvailable@CvPlayerTechs@@QBE_NXZ ENDP	; CvPlayerTechs::IsNoResearchAvailable
_TEXT	ENDS
PUBLIC	?CheckForTechAchievement@CvPlayerTechs@@QBEXXZ	; CvPlayerTechs::CheckForTechAchievement
EXTRN	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ:PROC ; CvPlayer::GetPlayerTechs
EXTRN	__imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z:PROC
EXTRN	?getLeaderTypeKey@CvPlayer@@QBEPBDXZ:PROC	; CvPlayer::getLeaderTypeKey
EXTRN	?isGameMultiPlayer@CvGame@@QBE_NXZ:PROC		; CvGame::isGameMultiPlayer
EXTRN	?isHuman@CvPlayer@@QBE_NXZ:PROC			; CvPlayer::isHuman
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
xdata$x	SEGMENT
__unwindtable$?CheckForTechAchievement@CvPlayerTechs@@QBEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CheckForTechAchievement@CvPlayerTechs@@QBEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?CheckForTechAchievement@CvPlayerTechs@@QBEXXZ$1
__ehfuncinfo$?CheckForTechAchievement@CvPlayerTechs@@QBEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?CheckForTechAchievement@CvPlayerTechs@@QBEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtechclasses.cpp
xdata$x	ENDS
;	COMDAT ?CheckForTechAchievement@CvPlayerTechs@@QBEXXZ
_TEXT	SEGMENT
_this$ = -72						; size = 4
$T230269 = -68						; size = 28
_szCurrentTech$224870 = -40				; size = 28
__$EHRec$ = -12						; size = 12
?CheckForTechAchievement@CvPlayerTechs@@QBEXXZ PROC	; CvPlayerTechs::CheckForTechAchievement, COMDAT
; _this$ = ecx

; 1362 : {

	push	-1
	push	__ehhandler$?CheckForTechAchievement@CvPlayerTechs@@QBEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 60					; 0000003cH
	push	esi
	mov	esi, ecx

; 1363 : 	if(m_pPlayer->isHuman() && !GC.getGame().isGameMultiPlayer())

	mov	ecx, DWORD PTR [esi+44]
	mov	DWORD PTR _this$[esp+76], esi
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	$LN7@CheckForTe
	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?isGameMultiPlayer@CvGame@@QBE_NXZ	; CvGame::isGameMultiPlayer
	test	al, al
	jne	$LN7@CheckForTe

; 1364 : 	{
; 1365 : 		//Check for Catherine Achievement
; 1366 : 		if((CvString)m_pPlayer->getLeaderTypeKey() == "LEADER_CATHERINE")

	mov	ecx, DWORD PTR [esi+44]
	push	edi
	call	?getLeaderTypeKey@CvPlayer@@QBEPBDXZ	; CvPlayer::getLeaderTypeKey
	xor	edi, edi
	cmp	eax, edi
	jne	SHORT $LN31@CheckForTe
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN31@CheckForTe:
	push	ebx
	push	ebp
	push	eax
	lea	ecx, DWORD PTR $T230269[esp+92]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ebp, DWORD PTR __imp_??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
	lea	eax, DWORD PTR $T230269[esp+88]
	push	OFFSET $SG224861
	push	eax
	mov	DWORD PTR __$EHRec$[esp+104], edi
	call	ebp
	add	esp, 8
	lea	ecx, DWORD PTR $T230269[esp+88]
	mov	bl, al
	mov	DWORD PTR __$EHRec$[esp+96], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	test	bl, bl
	je	$LN144@CheckForTe

; 1367 : 		{
; 1368 : #ifdef AUI_WARNING_FIXES
; 1369 : 			for (uint iI = 0; iI < GC.getNumTechInfos(); iI++)
; 1370 : #else
; 1371 : 			for(int iI = 0; iI < GC.getNumTechInfos(); iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	test	eax, eax
	jle	$LN144@CheckForTe
	npad	6
$LL19@CheckForTe:

; 1372 : #endif
; 1373 : 			{
; 1374 : 				const TechTypes eTech = static_cast<TechTypes>(iI);
; 1375 : 				CvTechEntry* pkTechInfo = GC.getTechInfo(eTech);

	push	edi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo

; 1376 : 				if(pkTechInfo)

	test	eax, eax
	je	$LN18@CheckForTe

; 1377 : 				{
; 1378 : 					CvString szCurrentTech = (CvString) pkTechInfo->GetType();

	lea	ecx, DWORD PTR [eax+176]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	test	eax, eax
	jne	SHORT $LN41@CheckForTe
	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
$LN41@CheckForTe:
	push	eax
	lea	ecx, DWORD PTR _szCurrentTech$224870[esp+92]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z

; 1379 : 					if(szCurrentTech == "TECH_HORSEBACK_RIDING")

	lea	ecx, DWORD PTR _szCurrentTech$224870[esp+88]
	push	OFFSET $SG224874
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+104], 1
	call	ebp
	add	esp, 8
	test	al, al
	je	$LN145@CheckForTe

; 1380 : 					{
; 1381 : 						if(GET_TEAM(m_pPlayer->getTeam()).GetTeamTechs()->HasTech(eTech))

	mov	edx, DWORD PTR [esi+44]
	mov	eax, DWORD PTR [edx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN47@CheckForTe
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN48@CheckForTe
$LN47@CheckForTe:
	or	eax, -1
$LN48@CheckForTe:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	cmp	edi, -1
	je	SHORT $LN138@CheckForTe
	mov	eax, DWORD PTR [eax+4]
	test	eax, eax
	je	$LN145@CheckForTe
	cmp	BYTE PTR [eax+edi], 0
	je	$LN145@CheckForTe
$LN138@CheckForTe:

; 1382 : 						{
; 1383 : 							int iJ;
; 1384 : 							int iNumPlayersWith = 0;

	xor	ebx, ebx
	xor	esi, esi
	npad	1
$LL13@CheckForTe:

; 1386 : 							{
; 1387 : 								if(!GET_PLAYER((PlayerTypes)iJ).isBarbarian() && !GET_PLAYER((PlayerTypes)iJ).isMinorCiv())

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [esi+eax]
	call	?isBarbarian@CvPlayer@@QBE_NXZ		; CvPlayer::isBarbarian
	test	al, al
	jne	SHORT $LN12@CheckForTe
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	ecx, esi
	call	?isMinorCiv@CvPlayer@@QBE_NXZ		; CvPlayer::isMinorCiv
	test	al, al
	jne	SHORT $LN12@CheckForTe

; 1388 : 								{
; 1389 : 									if(GET_TEAM(GET_PLAYER((PlayerTypes)iJ).getTeam()).GetTeamTechs()->HasTech(eTech))

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [esi+edx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN69@CheckForTe
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN70@CheckForTe
$LN69@CheckForTe:
	or	eax, -1
$LN70@CheckForTe:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	cmp	edi, -1
	je	SHORT $LN139@CheckForTe
	mov	eax, DWORD PTR [eax+4]
	test	eax, eax
	je	SHORT $LN12@CheckForTe
	cmp	BYTE PTR [eax+edi], 0
	je	SHORT $LN12@CheckForTe
$LN139@CheckForTe:

; 1390 : 									{
; 1391 : 										iNumPlayersWith++;

	inc	ebx
$LN12@CheckForTe:

; 1385 : 							for(iJ = 0; iJ < MAX_MAJOR_CIVS; iJ++)

	add	esi, 63236				; 0000f704H
	cmp	esi, 1391192				; 00153a58H
	jl	SHORT $LL13@CheckForTe

; 1392 : 									}
; 1393 : 								}
; 1394 : 							}
; 1395 : 							if(iNumPlayersWith <= 1)  //For only the human player

	cmp	ebx, 1
	jg	SHORT $LN142@CheckForTe

; 1396 : 							{
; 1397 : 								gDLL->UnlockAchievement(ACHIEVEMENT_SPECIAL_PONY);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+828]
	push	114					; 00000072H
	call	edx
$LN142@CheckForTe:
	mov	esi, DWORD PTR _this$[esp+88]
$LN145@CheckForTe:

; 1398 : 							}
; 1399 : 						}
; 1400 : 					}
; 1401 : 				}

	lea	ecx, DWORD PTR _szCurrentTech$224870[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN18@CheckForTe:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	cmp	edi, eax
	jl	$LL19@CheckForTe
$LN144@CheckForTe:

; 1402 : 			}
; 1403 : 		}
; 1404 : 		//Check for all achievements
; 1405 : 		if(m_pPlayer->GetPlayerTechs()->IsCurrentResearchRepeat())

	mov	ecx, DWORD PTR [esi+44]
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, DWORD PTR [eax+44]
	call	?headResearchQueueNode@CvPlayer@@QAEPAV?$CLLNode@W4TechTypes@@@@XZ ; CvPlayer::headResearchQueueNode
	pop	ebp
	pop	ebx
	test	eax, eax
	je	$LN148@CheckForTe
	mov	eax, DWORD PTR [eax+4]
	cmp	eax, -1
	je	$LN148@CheckForTe
	push	eax
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo
	test	eax, eax
	je	$LN148@CheckForTe
	cmp	BYTE PTR [eax+338], 0
	je	$LN148@CheckForTe

; 1406 : 		{
; 1407 : #ifdef AUI_WARNING_FIXES
; 1408 : 			for (uint iI = 0; iI < GC.getNumTechInfos() - 1; iI++)
; 1409 : #else
; 1410 : 			for(int iI = 0; iI < GC.getNumTechInfos() - 1; iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	dec	eax
	test	eax, eax
	jle	SHORT $LN4@CheckForTe
	npad	3
$LL6@CheckForTe:

; 1411 : #endif
; 1412 : 			{
; 1413 : 				const TechTypes eTech = static_cast<TechTypes>(iI);
; 1414 : 				CvTechEntry* pkTechInfo = GC.getTechInfo(eTech);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getTechInfo@CvGlobals@@QAEPAVCvTechEntry@@W4TechTypes@@@Z ; CvGlobals::getTechInfo

; 1415 : 				if(pkTechInfo)

	test	eax, eax
	je	SHORT $LN5@CheckForTe

; 1416 : 				{
; 1417 : 					if(!GET_TEAM(m_pPlayer->getTeam()).GetTeamTechs()->HasTech(eTech))

	mov	eax, DWORD PTR _this$[esp+80]
	mov	ecx, DWORD PTR [eax+44]
	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN100@CheckForTe
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN101@CheckForTe
$LN100@CheckForTe:
	or	eax, -1
$LN101@CheckForTe:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	cmp	esi, -1
	je	SHORT $LN5@CheckForTe
	mov	eax, DWORD PTR [eax+4]
	test	eax, eax
	je	$LN148@CheckForTe
	cmp	BYTE PTR [eax+esi], 0
	je	SHORT $LN148@CheckForTe
$LN5@CheckForTe:

; 1406 : 		{
; 1407 : #ifdef AUI_WARNING_FIXES
; 1408 : 			for (uint iI = 0; iI < GC.getNumTechInfos() - 1; iI++)
; 1409 : #else
; 1410 : 			for(int iI = 0; iI < GC.getNumTechInfos() - 1; iI++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	esi
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	dec	eax
	cmp	esi, eax
	jl	SHORT $LL6@CheckForTe
$LN4@CheckForTe:

; 1418 : 					{
; 1419 : 						return;
; 1420 : 					}
; 1421 : 				}
; 1422 : 
; 1423 : 			}
; 1424 : 
; 1425 : 			if(GET_TEAM(m_pPlayer->getTeam()).GetTeamTechs()->GetTechCount((TechTypes)m_pPlayer->GetPlayerTechs()->GetCurrentResearch()) < 1)

	mov	edi, DWORD PTR _this$[esp+80]
	mov	ecx, DWORD PTR [edi+44]
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, DWORD PTR [eax+44]
	call	?headResearchQueueNode@CvPlayer@@QAEPAV?$CLLNode@W4TechTypes@@@@XZ ; CvPlayer::headResearchQueueNode
	test	eax, eax
	je	SHORT $LN113@CheckForTe
	mov	esi, DWORD PTR [eax+4]
	jmp	SHORT $LN112@CheckForTe
$LN113@CheckForTe:
	or	esi, -1
$LN112@CheckForTe:
	mov	edx, DWORD PTR [edi+44]
	mov	eax, DWORD PTR [edx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN120@CheckForTe
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN121@CheckForTe
$LN120@CheckForTe:
	or	eax, -1
$LN121@CheckForTe:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	eax, DWORD PTR [eax+16]
	cmp	DWORD PTR [eax+esi*4], 1
	jl	SHORT $LN148@CheckForTe

; 1426 : 			{
; 1427 : 				return;
; 1428 : 			}
; 1429 : 			gDLL->UnlockAchievement(ACHIEVEMENT_ALL_TECHS);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8596
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+828]
	push	51					; 00000033H
	call	eax
$LN148@CheckForTe:
	pop	edi
$LN7@CheckForTe:

; 1430 : 		}
; 1431 : 	}
; 1432 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+76]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 72					; 00000048H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CheckForTechAchievement@CvPlayerTechs@@QBEXXZ$0:
	lea	ecx, DWORD PTR $T230269[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?CheckForTechAchievement@CvPlayerTechs@@QBEXXZ$1:
	lea	ecx, DWORD PTR _szCurrentTech$224870[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?CheckForTechAchievement@CvPlayerTechs@@QBEXXZ:
	mov	eax, OFFSET __ehfuncinfo$?CheckForTechAchievement@CvPlayerTechs@@QBEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?CheckForTechAchievement@CvPlayerTechs@@QBEXXZ ENDP	; CvPlayerTechs::CheckForTechAchievement
PUBLIC	?GetNumTechsCanBeResearched@CvPlayerTechs@@QBEHXZ ; CvPlayerTechs::GetNumTechsCanBeResearched
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumTechsCanBeResearched@CvPlayerTechs@@QBEHXZ
_TEXT	SEGMENT
?GetNumTechsCanBeResearched@CvPlayerTechs@@QBEHXZ PROC	; CvPlayerTechs::GetNumTechsCanBeResearched, COMDAT
; _this$ = ecx

; 1513 : {

	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 1514 : 	int rtnValue = 0;
; 1515 : 
; 1516 : #ifdef AUI_WARNING_FIXES
; 1517 : 	for (uint iTechLoop = 0; iTechLoop < GetTechs()->GetNumTechs(); iTechLoop++)
; 1518 : #else
; 1519 : 	for(int iTechLoop = 0; iTechLoop < GetTechs()->GetNumTechs(); iTechLoop++)

	mov	eax, DWORD PTR [edi+40]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR [eax+4]
	xor	ebx, ebx
	xor	esi, esi
	test	ecx, -4					; fffffffcH
	jle	SHORT $LN15@GetNumTech@2
	npad	6
$LL4@GetNumTech@2:

; 1520 : #endif
; 1521 : 	{
; 1522 : 		if(CanResearch((TechTypes)iTechLoop))

	push	0
	push	esi
	mov	ecx, edi
	call	?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z ; CvPlayerTechs::CanResearch
	test	al, al
	je	SHORT $LN3@GetNumTech@2

; 1523 : 		{
; 1524 : 			rtnValue++;

	inc	ebx
$LN3@GetNumTech@2:

; 1514 : 	int rtnValue = 0;
; 1515 : 
; 1516 : #ifdef AUI_WARNING_FIXES
; 1517 : 	for (uint iTechLoop = 0; iTechLoop < GetTechs()->GetNumTechs(); iTechLoop++)
; 1518 : #else
; 1519 : 	for(int iTechLoop = 0; iTechLoop < GetTechs()->GetNumTechs(); iTechLoop++)

	mov	eax, DWORD PTR [edi+40]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [eax+4]
	inc	esi
	sar	edx, 2
	cmp	esi, edx
	jl	SHORT $LL4@GetNumTech@2
$LN15@GetNumTech@2:
	pop	edi
	pop	esi

; 1525 : 		}
; 1526 : 	}
; 1527 : 
; 1528 : 	return rtnValue;

	mov	eax, ebx
	pop	ebx

; 1529 : }

	ret	0
?GetNumTechsCanBeResearched@CvPlayerTechs@@QBEHXZ ENDP	; CvPlayerTechs::GetNumTechsCanBeResearched
_TEXT	ENDS
PUBLIC	?GetResearchCost@CvPlayerTechs@@QBEHW4TechTypes@@@Z ; CvPlayerTechs::GetResearchCost
EXTRN	?GetMaxEffectiveCities@CvPlayer@@QAEH_N@Z:PROC	; CvPlayer::GetMaxEffectiveCities
EXTRN	?GetNumCitiesResearchCostDiscount@CvPlayer@@QBEHXZ:PROC ; CvPlayer::GetNumCitiesResearchCostDiscount
EXTRN	?GetNumCitiesTechCostMod@CvWorldInfo@@QBEHXZ:PROC ; CvWorldInfo::GetNumCitiesTechCostMod
EXTRN	?calculateResearchModifier@CvPlayer@@QAEHW4TechTypes@@@Z:PROC ; CvPlayer::calculateResearchModifier
; Function compile flags: /Ogtpy
;	COMDAT ?GetResearchCost@CvPlayerTechs@@QBEHW4TechTypes@@@Z
_TEXT	SEGMENT
$T230545 = -4						; size = 4
$T230544 = 8						; size = 4
_eTech$ = 8						; size = 4
?GetResearchCost@CvPlayerTechs@@QBEHW4TechTypes@@@Z PROC ; CvPlayerTechs::GetResearchCost, COMDAT
; _this$ = ecx

; 1541 : {

	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 1542 : #ifdef AUI_TECH_FIX_TEAMER_RESEARCH_COSTS
; 1543 : 	return GET_TEAM(m_pPlayer->getTeam()).GetTeamTechs()->GetResearchCost(eTech);
; 1544 : #else
; 1545 : 	// Get the research cost for the team
; 1546 : 	int iResearchCost = GET_TEAM(m_pPlayer->getTeam()).GetTeamTechs()->GetResearchCost(eTech);

	mov	eax, DWORD PTR [edi+44]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN10@GetResearc@5
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN11@GetResearc@5
$LN10@GetResearc@5:
	or	eax, -1
$LN11@GetResearc@5:
	mov	esi, DWORD PTR _eTech$[esp+12]
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	push	esi
	mov	ecx, eax
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, eax
	call	?GetResearchCost@CvTeamTechs@@QBEHW4TechTypes@@@Z ; CvTeamTechs::GetResearchCost

; 1547 : 	
; 1548 : 	// Adjust to the player's research modifier
; 1549 : 	int iResearchMod = std::max(1, m_pPlayer->calculateResearchModifier(eTech));

	mov	ecx, DWORD PTR [edi+44]
	push	esi
	mov	ebx, eax
	call	?calculateResearchModifier@CvPlayer@@QAEHW4TechTypes@@@Z ; CvPlayer::calculateResearchModifier
	cmp	eax, 1
	mov	DWORD PTR $T230544[esp+12], eax
	mov	DWORD PTR $T230545[esp+16], 1
	lea	ecx, DWORD PTR $T230544[esp+12]
	jg	SHORT $LN20@GetResearc@5
	lea	ecx, DWORD PTR $T230545[esp+16]
$LN20@GetResearc@5:

; 1550 : 	iResearchCost = ((iResearchCost * 10000) / iResearchMod);

	mov	eax, ebx
	imul	eax, 10000				; 00002710H
	cdq
	idiv	DWORD PTR [ecx]

; 1551 : 
; 1552 : 	// Mod for City Count
; 1553 : 	int iMod = GC.getMap().getWorldInfo().GetNumCitiesTechCostMod();	// Default is 40, gets smaller on larger maps

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	ebx, eax
	call	?getWorldInfo@CvMap@@QBEABVCvWorldInfo@@XZ ; CvMap::getWorldInfo
	mov	ecx, eax
	call	?GetNumCitiesTechCostMod@CvWorldInfo@@QBEHXZ ; CvWorldInfo::GetNumCitiesTechCostMod

; 1554 : 
; 1555 : 	// NQMP GJS - new Dictatorship of the Proletariat i.e. Communism BEGIN
; 1556 : 	int iResearchModDiscount = m_pPlayer->GetNumCitiesResearchCostDiscount();

	mov	ecx, DWORD PTR [edi+44]
	mov	esi, eax
	call	?GetNumCitiesResearchCostDiscount@CvPlayer@@QBEHXZ ; CvPlayer::GetNumCitiesResearchCostDiscount

; 1557 : 	if (iResearchModDiscount != 0)

	test	eax, eax
	je	SHORT $LN3@GetResearc@5

; 1558 : 	{
; 1559 : 		iMod = iMod * (100 + iResearchModDiscount);

	lea	ecx, DWORD PTR [eax+100]
	imul	ecx, esi

; 1560 : 		iMod /= 100;

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	esi, eax
$LN3@GetResearc@5:

; 1561 : 	}
; 1562 : 	// NQMP GJS - new Dictatorship of the Proletariat i.e. Communism END
; 1563 : 
; 1564 : #ifdef NQ_IGNORE_PUPPETS_FOR_RESEARCH_COSTS_FROM_POLICIES
; 1565 : 	bool bIncludePuppets = (GC.getGame().isOption("GAMEOPTION_FAST_HAND"));
; 1566 : 	iMod = iMod * m_pPlayer->GetMaxEffectiveCities(bIncludePuppets);
; 1567 : #else
; 1568 : 	iMod = iMod * m_pPlayer->GetMaxEffectiveCities(/*bIncludePuppets*/ true);

	mov	ecx, DWORD PTR [edi+44]
	push	1
	call	?GetMaxEffectiveCities@CvPlayer@@QAEH_N@Z ; CvPlayer::GetMaxEffectiveCities
	mov	ecx, eax
	imul	ecx, esi

; 1569 : #endif
; 1570 : 	iResearchCost = iResearchCost * (100 + iMod) / 100;

	add	ecx, 100				; 00000064H
	imul	ecx, ebx
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx

; 1571 : 
; 1572 : 	// We're going to round up so that the user wont get confused when the research progress seems to be equal to the research cost, but it is not acutally done.
; 1573 : 	// This is because the 'real' calculations use the GameCore's fixed point math where things are multiplied by 100
; 1574 : 	if((iResearchCost % 100) != 0)

	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	edx, eax
	imul	edx, 100				; 00000064H
	sub	ecx, edx
	pop	edi
	pop	esi
	pop	ebx
	je	SHORT $LN1@GetResearc@5

; 1575 : 		iResearchCost = (iResearchCost / 100) + 1;

	inc	eax
$LN1@GetResearc@5:

; 1576 : 	else
; 1577 : 		iResearchCost = (iResearchCost / 100);
; 1578 : 
; 1579 : 	return iResearchCost;
; 1580 : #endif
; 1581 : }

	pop	ecx
	ret	4
?GetResearchCost@CvPlayerTechs@@QBEHW4TechTypes@@@Z ENDP ; CvPlayerTechs::GetResearchCost
_TEXT	ENDS
PUBLIC	?GetResearchProgress@CvPlayerTechs@@QBEHW4TechTypes@@@Z ; CvPlayerTechs::GetResearchProgress
EXTRN	?getOverflowResearch@CvPlayer@@QBEHXZ:PROC	; CvPlayer::getOverflowResearch
; Function compile flags: /Ogtpy
;	COMDAT ?GetResearchProgress@CvPlayerTechs@@QBEHW4TechTypes@@@Z
_TEXT	SEGMENT
_eTech$ = 8						; size = 4
?GetResearchProgress@CvPlayerTechs@@QBEHW4TechTypes@@@Z PROC ; CvPlayerTechs::GetResearchProgress, COMDAT
; _this$ = ecx

; 1586 : {

	push	esi
	push	edi
	mov	edi, ecx

; 1587 : 	// Get the research progress for the team
; 1588 : 	int iResearchProgress = GET_TEAM(m_pPlayer->getTeam()).GetTeamTechs()->GetResearchProgress(eTech);

	mov	eax, DWORD PTR [edi+44]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN7@GetResearc@6
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN8@GetResearc@6
$LN7@GetResearc@6:
	or	eax, -1
$LN8@GetResearc@6:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	mov	ecx, DWORD PTR _eTech$[esp+4]
	cmp	ecx, -1
	je	SHORT $LN15@GetResearc@6
	mov	eax, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx

; 1589 : 	// Add in any overflow we have yet to accumulate into the research progress.
; 1590 : 	// Overflow is the leftover research from the previous research.  It is automatically rolled into the main progress value
; 1591 : 	// the next time research is 'updated'.
; 1592 : 	iResearchProgress += m_pPlayer->getOverflowResearch();

	mov	ecx, DWORD PTR [edi+44]
	sar	edx, 5
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	call	?getOverflowResearch@CvPlayer@@QBEHXZ	; CvPlayer::getOverflowResearch
	pop	edi
	add	eax, esi
	pop	esi

; 1593 : 
; 1594 : 	return iResearchProgress;
; 1595 : }

	ret	4

; 1587 : 	// Get the research progress for the team
; 1588 : 	int iResearchProgress = GET_TEAM(m_pPlayer->getTeam()).GetTeamTechs()->GetResearchProgress(eTech);

$LN15@GetResearc@6:

; 1589 : 	// Add in any overflow we have yet to accumulate into the research progress.
; 1590 : 	// Overflow is the leftover research from the previous research.  It is automatically rolled into the main progress value
; 1591 : 	// the next time research is 'updated'.
; 1592 : 	iResearchProgress += m_pPlayer->getOverflowResearch();

	mov	ecx, DWORD PTR [edi+44]
	xor	esi, esi
	call	?getOverflowResearch@CvPlayer@@QBEHXZ	; CvPlayer::getOverflowResearch
	pop	edi
	add	eax, esi
	pop	esi

; 1593 : 
; 1594 : 	return iResearchProgress;
; 1595 : }

	ret	4
?GetResearchProgress@CvPlayerTechs@@QBEHW4TechTypes@@@Z ENDP ; CvPlayerTechs::GetResearchProgress
_TEXT	ENDS
PUBLIC	?Init@CvTeamTechs@@QAEXPAVCvTechXMLEntries@@PAVCvTeam@@@Z ; CvTeamTechs::Init
; Function compile flags: /Ogtpy
;	COMDAT ?Init@CvTeamTechs@@QAEXPAVCvTechXMLEntries@@PAVCvTeam@@@Z
_TEXT	SEGMENT
_pTechs$ = 8						; size = 4
_pTeam$ = 12						; size = 4
?Init@CvTeamTechs@@QAEXPAVCvTechXMLEntries@@PAVCvTeam@@@Z PROC ; CvTeamTechs::Init, COMDAT
; _this$ = ecx

; 1754 : 	// Store off the pointer to the techs active for this game and pointer to our team
; 1755 : 	m_pTechs = pTechs;
; 1756 : 	m_pTeam = pTeam;

	mov	eax, DWORD PTR _pTeam$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR _pTechs$[esp]
	mov	DWORD PTR [esi+24], eax
	mov	DWORD PTR [esi+20], ecx

; 1757 : 
; 1758 : 	// Initialize status arrays
; 1759 : 	CvAssertMsg(m_pabHasTech==NULL, "about to leak memory, CvTeamTechs::m_pabHasTech");
; 1760 : 	m_pabHasTech = FNEW(bool[m_pTechs->GetNumTechs()], c_eCiv5GameplayDLL, 0);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]

; 1761 : 	CvAssertMsg(m_pabNoTradeTech==NULL, "about to leak memory, CvTeamTechs::m_pabNoTradeTech");
; 1762 : 	m_pabNoTradeTech = FNEW(bool[m_pTechs->GetNumTechs()], c_eCiv5GameplayDLL, 0);

	mov	ecx, DWORD PTR [esi+20]
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]

; 1763 : 	CvAssertMsg(m_paiResearchProgress==NULL, "about to leak memory, CvTeamTechs::m_paiResearchProgress");
; 1764 : 	m_paiResearchProgress = FNEW(int [m_pTechs->GetNumTechs()], c_eCiv5GameplayDLL, 0);

	mov	ecx, DWORD PTR [esi+20]
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	sar	eax, 2
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 1765 : 	CvAssertMsg(m_paiTechCount==NULL, "about to leak memory, CvTeamTechs::m_paiTechCount");
; 1766 : 	m_paiTechCount = FNEW(int [m_pTechs->GetNumTechs()], c_eCiv5GameplayDLL, 0);

	mov	ecx, DWORD PTR [esi+20]
	mov	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	sar	eax, 2
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 16					; 00000010H

; 1767 : 
; 1768 : 	Reset();

	mov	ecx, esi
	mov	DWORD PTR [esi+16], eax
	call	?Reset@CvTeamTechs@@QAEXXZ		; CvTeamTechs::Reset
	pop	esi

; 1769 : }

	ret	8
?Init@CvTeamTechs@@QAEXPAVCvTechXMLEntries@@PAVCvTeam@@@Z ENDP ; CvTeamTechs::Init
_TEXT	ENDS
PUBLIC	?Write@CvTeamTechs@@QAEXAAVFDataStream@@@Z	; CvTeamTechs::Write
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@PBVCvBaseInfo@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4TechTypes@@@Z:PROC ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ?Write@CvTeamTechs@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -8					; size = 4
_count$230765 = -4					; size = 4
_count$230736 = -4					; size = 4
$T230678 = 8						; size = 4
_iNumTechs$225223 = 8					; size = 4
_kStream$ = 8						; size = 4
?Write@CvTeamTechs@@QAEXAAVFDataStream@@@Z PROC		; CvTeamTechs::Write, COMDAT
; _this$ = ecx

; 1930 : {

	sub	esp, 8
	push	ebx
	push	esi

; 1931 : 	// Current version number
; 1932 : 	uint uiVersion = 1;
; 1933 : 	kStream << uiVersion;

	mov	esi, DWORD PTR _kStream$[esp+12]
	push	edi
	lea	eax, DWORD PTR _uiVersion$[esp+20]
	mov	ebx, ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _uiVersion$[esp+24], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 1934 : 
; 1935 : 	kStream << m_eLastTechAcquired;

	push	ebx
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4TechTypes@@@Z ; operator<<

; 1936 : 
; 1937 : 	if(m_pTechs != NULL && m_pTechs->GetNumTechs())

	mov	eax, DWORD PTR [ebx+20]
	xor	edi, edi
	add	esp, 8
	cmp	eax, edi
	je	$LN5@Write@2
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, DWORD PTR [eax+4]
	test	ecx, -4					; fffffffcH
	je	$LN5@Write@2

; 1938 : 	{
; 1939 : 		// Write out an array of all the active tech's hash types so we can re-map on loading if need be.
; 1940 : #ifdef AUI_WARNING_FIXES
; 1941 : 		uint iNumTechs = m_pTechs->GetNumTechs();
; 1942 : 		kStream << iNumTechs;
; 1943 : 
; 1944 : 		for (uint i = 0; i < iNumTechs; ++i)
; 1945 : #else
; 1946 : 		int iNumTechs = m_pTechs->GetNumTechs();

	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [eax+4]

; 1947 : 		kStream << (int)iNumTechs;

	lea	eax, DWORD PTR _iNumTechs$225223[esp+16]
	sar	edx, 2
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _iNumTechs$225223[esp+20], edx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 1948 : 
; 1949 : 		for(int i = 0; i < iNumTechs; ++i)

	mov	eax, DWORD PTR _iNumTechs$225223[esp+16]
	cmp	eax, edi
	jle	SHORT $LN2@Write@2
	npad	6
$LL4@Write@2:

; 1950 : #endif
; 1951 : 			CvInfosSerializationHelper::WriteHashed(kStream, m_pTechs->GetEntry(i));

	mov	ecx, DWORD PTR [ebx+20]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+edi*4]
	push	eax
	push	esi
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@PBVCvBaseInfo@@@Z ; CvInfosSerializationHelper::WriteHashed
	mov	eax, DWORD PTR _iNumTechs$225223[esp+24]
	inc	edi
	add	esp, 8
	cmp	edi, eax
	jl	SHORT $LL4@Write@2
$LN2@Write@2:

; 1952 : 
; 1953 : 		kStream << ArrayWrapper<bool>(iNumTechs, m_pabHasTech);

	xor	edi, edi
	push	ebp
	mov	ebp, DWORD PTR [ebx+4]
	mov	DWORD PTR _count$230736[esp+24], eax
	test	eax, eax
	jle	SHORT $LN26@Write@2
	npad	6
$LL28@Write@2:
	lea	ecx, DWORD PTR [edi+ebp]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
	inc	edi
	cmp	edi, DWORD PTR _count$230736[esp+24]
	jl	SHORT $LL28@Write@2
	mov	eax, DWORD PTR _iNumTechs$225223[esp+20]
$LN26@Write@2:

; 1954 : 		kStream << ArrayWrapper<bool>(iNumTechs, m_pabNoTradeTech);

	mov	ebp, DWORD PTR [ebx+8]
	xor	edi, edi
	mov	DWORD PTR _count$230765[esp+24], eax
	test	eax, eax
	jle	SHORT $LN39@Write@2
$LL41@Write@2:
	lea	edx, DWORD PTR [edi+ebp]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
	inc	edi
	cmp	edi, DWORD PTR _count$230765[esp+24]
	jl	SHORT $LL41@Write@2
	mov	eax, DWORD PTR _iNumTechs$225223[esp+20]
$LN39@Write@2:

; 1955 : 		kStream << ArrayWrapper<int>(iNumTechs, m_paiResearchProgress);

	mov	edi, DWORD PTR [ebx+12]
	test	eax, eax
	jle	SHORT $LN52@Write@2
	mov	ebp, eax
$LL54@Write@2:
	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	edi, 4
	sub	ebp, 1
	jne	SHORT $LL54@Write@2
	mov	eax, DWORD PTR _iNumTechs$225223[esp+20]
$LN52@Write@2:

; 1956 : 		kStream << ArrayWrapper<int>(iNumTechs, m_paiTechCount);

	mov	ebx, DWORD PTR [ebx+16]
	pop	ebp
	test	eax, eax
	jle	SHORT $LN76@Write@2
	mov	edi, ebx
	mov	ebx, eax
$LL67@Write@2:
	push	edi
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	edi, 4
	sub	ebx, 1
	jne	SHORT $LL67@Write@2
	pop	edi
	pop	esi
	pop	ebx

; 1961 : 	}
; 1962 : }

	add	esp, 8
	ret	4
$LN5@Write@2:

; 1957 : 	}
; 1958 : 	else
; 1959 : 	{
; 1960 : 		kStream << (int)0;

	lea	eax, DWORD PTR $T230678[esp+16]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR $T230678[esp+20], edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
$LN76@Write@2:
	pop	edi
	pop	esi
	pop	ebx

; 1961 : 	}
; 1962 : }

	add	esp, 8
	ret	4
?Write@CvTeamTechs@@QAEXAAVFDataStream@@@Z ENDP		; CvTeamTechs::Write
_TEXT	ENDS
PUBLIC	?SetResearchProgressTimes100@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z ; CvTeamTechs::SetResearchProgressTimes100
EXTRN	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z:PROC ; CvNotifications::Add
EXTRN	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z:PROC ; CvGame::isOption
EXTRN	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ:PROC ; CvPlayer::GetNotifications
EXTRN	?GetNumPoliciesCanBeAdopted@CvPlayerPolicies@@QAEHXZ:PROC ; CvPlayerPolicies::GetNumPoliciesCanBeAdopted
EXTRN	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ:PROC ; CvPlayer::GetPlayerPolicies
EXTRN	?getJONSCulture@CvPlayer@@QBEHXZ:PROC		; CvPlayer::getJONSCulture
EXTRN	?getNextPolicyCost@CvPlayer@@QBEHXZ:PROC	; CvPlayer::getNextPolicyCost
EXTRN	?getNumCities@CvPlayer@@QBEHXZ:PROC		; CvPlayer::getNumCities
EXTRN	?changeJONSCulture@CvPlayer@@QAEXH@Z:PROC	; CvPlayer::changeJONSCulture
EXTRN	?GetCulturePerTechResearched@CvPlayer@@QBEHXZ:PROC ; CvPlayer::GetCulturePerTechResearched
EXTRN	?SetSpecializationsDirty@CvCitySpecializationAI@@QAEXW4CitySpecializationUpdateType@@@Z:PROC ; CvCitySpecializationAI::SetSpecializationsDirty
EXTRN	?GetCitySpecializationAI@CvPlayer@@QBEPAVCvCitySpecializationAI@@XZ:PROC ; CvPlayer::GetCitySpecializationAI
EXTRN	?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z:PROC ; CvTeam::setHasTech
EXTRN	?changeOverflowResearchTimes100@CvPlayer@@QAEXH@Z:PROC ; CvPlayer::changeOverflowResearchTimes100
EXTRN	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ:PROC ; CvGame::getActiveTeam
;	COMDAT xdata$x
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?SetResearchProgressTimes100@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetResearchProgressTimes100@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SetResearchProgressTimes100@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?SetResearchProgressTimes100@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?SetResearchProgressTimes100@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z$3
__ehfuncinfo$?SetResearchProgressTimes100@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?SetResearchProgressTimes100@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtechclasses.cpp
xdata$x	ENDS
;	COMDAT ?SetResearchProgressTimes100@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z
_TEXT	SEGMENT
_eTeamID$225363 = -128					; size = 4
_strBuffer$225377 = -124				; size = 28
_strSummary$225384 = -96				; size = 28
$T230844 = -68						; size = 28
$T230845 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_eIndex$ = 8						; size = 4
_iNewValue$ = 12					; size = 4
_ePlayer$ = 16						; size = 4
?SetResearchProgressTimes100@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z PROC ; CvTeamTechs::SetResearchProgressTimes100, COMDAT
; _this$ = ecx

; 2106 : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?SetResearchProgressTimes100@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 116				; 00000074H
	push	ebp
	push	edi

; 2107 : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 2108 : 	CvAssertMsg(eIndex < GC.getNumTechInfos(), "eIndex is expected to be within maximum bounds (invalid Index)");
; 2109 : 	CvAssertMsg(ePlayer >= 0, "eIndex is expected to be non-negative (invalid Index)");
; 2110 : 	CvAssertMsg(ePlayer < MAX_PLAYERS, "ePlayer is expected to be within maximum bounds (invalid Index)");
; 2111 : 
; 2112 : 	if(GetResearchProgressTimes100(eIndex) != iNewValue)

	mov	edi, DWORD PTR _eIndex$[esp+132]
	mov	ebp, ecx
	cmp	edi, -1
	je	SHORT $LN23@SetResearc@2
	mov	eax, DWORD PTR [ebp+12]
	mov	ecx, DWORD PTR [eax+edi*4]
	jmp	SHORT $LN22@SetResearc@2
$LN23@SetResearc@2:
	xor	ecx, ecx
$LN22@SetResearc@2:
	mov	eax, DWORD PTR _iNewValue$[esp+132]
	cmp	ecx, eax
	je	$LN9@SetResearc@2

; 2113 : 	{
; 2114 : 		m_paiResearchProgress[eIndex] = iNewValue;

	mov	ecx, DWORD PTR [ebp+12]
	push	ebx
	mov	DWORD PTR [ecx+edi*4], eax

; 2115 : 		CvAssert(GetResearchProgressTimes100(eIndex) >= 0);
; 2116 : 
; 2117 : 		if(m_pTeam->GetID() == GC.getGame().getActiveTeam())

	mov	ecx, DWORD PTR [ebp+24]
	push	esi
	mov	esi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	mov	ecx, esi
	mov	ebx, eax
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	cmp	ebx, eax
	jne	SHORT $LN14@SetResearc@2

; 2118 : 		{
; 2119 : 			GC.GetEngineUserInterface()->setDirty(GameData_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	11					; 0000000bH
	call	eax

; 2120 : 			GC.GetEngineUserInterface()->setDirty(Score_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+260]
	push	1
	push	12					; 0000000cH
	call	eax
$LN14@SetResearc@2:

; 2121 : 		}
; 2122 : 
; 2123 : 		int iResearchProgress = GetResearchProgressTimes100(eIndex);

	cmp	edi, -1
	je	SHORT $LN33@SetResearc@2
	mov	ecx, DWORD PTR [ebp+12]
	mov	ebx, DWORD PTR [ecx+edi*4]
	jmp	SHORT $LN32@SetResearc@2
$LN33@SetResearc@2:
	xor	ebx, ebx
$LN32@SetResearc@2:

; 2124 : #ifdef AUI_TECH_FIX_PLAYER_BASED_RESEARCH_COST_ONLY_AESTHETIC
; 2125 : 		int iResearchCost = GET_PLAYER(ePlayer).GetPlayerTechs()->GetResearchCost(eIndex) * 100;

	mov	esi, DWORD PTR _ePlayer$[esp+140]
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	esi, 63236				; 0000f704H
	lea	ecx, DWORD PTR [esi+edx]
	push	edi
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?GetResearchCost@CvPlayerTechs@@QBEHW4TechTypes@@@Z ; CvPlayerTechs::GetResearchCost
	imul	eax, 100				; 00000064H

; 2126 : #else
; 2127 : 		int iResearchCost = GetResearchCost(eIndex) * 100;
; 2128 : 
; 2129 : 		// Player modifiers to cost
; 2130 : 		int iResearchMod = std::max(1, GET_PLAYER(ePlayer).calculateResearchModifier(eIndex));
; 2131 : 		iResearchCost = (iResearchCost * 100) / iResearchMod;
; 2132 : 		int iNumCitiesMod = GC.getMap().getWorldInfo().GetNumCitiesTechCostMod();	// Default is 40, gets smaller on larger maps
; 2133 : 		iNumCitiesMod = iNumCitiesMod * GET_PLAYER(ePlayer).GetMaxEffectiveCities(/*bIncludePuppets*/ true);
; 2134 : 		iResearchCost = iResearchCost * (100 + iNumCitiesMod) / 100;
; 2135 : #endif
; 2136 : 		
; 2137 : 		int iOverflow = iResearchProgress - iResearchCost;

	sub	ebx, eax

; 2138 : 
; 2139 : 		// April 2014 Balance Patch change - EFB
; 2140 : 		//    Don't allow the overflow to get out of hand
; 2141 : 		int iMaxOverflow = GetMaxResearchOverflow(eIndex, ePlayer);

	mov	eax, DWORD PTR _ePlayer$[esp+140]
	push	eax
	push	edi
	mov	ecx, ebp
	call	?GetMaxResearchOverflow@CvTeamTechs@@ABEHW4TechTypes@@W4PlayerTypes@@@Z ; CvTeamTechs::GetMaxResearchOverflow

; 2142 : 		if (iOverflow > iMaxOverflow)

	cmp	ebx, eax
	jle	SHORT $LN13@SetResearc@2

; 2143 : 		{
; 2144 : 			iOverflow = iMaxOverflow;

	mov	ebx, eax
$LN13@SetResearc@2:

; 2145 : 		}
; 2146 : 
; 2147 : 		if(iOverflow >= 0)

	test	ebx, ebx
	jl	$LN93@SetResearc@2

; 2148 : 		{
; 2149 : 			GET_PLAYER(ePlayer).changeOverflowResearchTimes100(iOverflow);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	push	ebx
	add	ecx, esi
	call	?changeOverflowResearchTimes100@CvPlayer@@QAEXH@Z ; CvPlayer::changeOverflowResearchTimes100

; 2150 : 			m_pTeam->setHasTech(eIndex, true, ePlayer, true, true);

	mov	edx, DWORD PTR _ePlayer$[esp+140]
	mov	ecx, DWORD PTR [ebp+24]
	push	1
	push	1
	push	edx
	push	1
	push	edi
	call	?setHasTech@CvTeam@@QAEXW4TechTypes@@_NW4PlayerTypes@@11@Z ; CvTeam::setHasTech

; 2151 : 			SetNoTradeTech(eIndex, true);

	mov	eax, DWORD PTR [ebp+8]
	add	edi, eax
	cmp	BYTE PTR [edi], 1
	je	SHORT $LN40@SetResearc@2
	mov	BYTE PTR [edi], 1
$LN40@SetResearc@2:

; 2152 : 
; 2153 : 			// Mark city specialization dirty
; 2154 : 			GET_PLAYER(ePlayer).GetCitySpecializationAI()->SetSpecializationsDirty(SPECIALIZATION_UPDATE_RESEARCH_COMPLETE);

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	add	esi, ecx
	push	7
	mov	ecx, esi
	call	?GetCitySpecializationAI@CvPlayer@@QBEPAVCvCitySpecializationAI@@XZ ; CvPlayer::GetCitySpecializationAI
	mov	ecx, eax
	call	?SetSpecializationsDirty@CvCitySpecializationAI@@QAEXW4CitySpecializationUpdateType@@@Z ; CvCitySpecializationAI::SetSpecializationsDirty

; 2155 : 
; 2156 : 			// Culture bonus for Player researching a Tech
; 2157 : 			PlayerTypes eLoopPlayer;
; 2158 : 			int iCulture;
; 2159 : 			TeamTypes eTeamID = m_pTeam->GetID();

	mov	ecx, DWORD PTR [ebp+24]
	call	?GetID@CvTeam@@QBE?AW4TeamTypes@@XZ	; CvTeam::GetID
	xor	ebp, ebp
	mov	DWORD PTR _eTeamID$225363[esp+144], eax
	xor	edi, edi
	npad	5
$LL91@SetResearc@2:

; 2160 : 			for(int iPlayerLoop = 0; iPlayerLoop < MAX_MAJOR_CIVS; iPlayerLoop++)
; 2161 : 			{
; 2162 : 				eLoopPlayer = (PlayerTypes) iPlayerLoop;
; 2163 : 				CvPlayerAI& kLoopPlayer = GET_PLAYER(eLoopPlayer);

	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 2164 : 
; 2165 : 				if(kLoopPlayer.getTeam() == eTeamID)

	mov	eax, DWORD PTR [edi+edx+44]
	lea	esi, DWORD PTR [edi+edx]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN51@SetResearc@2
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN52@SetResearc@2
$LN51@SetResearc@2:
	or	eax, -1
$LN52@SetResearc@2:
	cmp	eax, DWORD PTR _eTeamID$225363[esp+144]
	jne	$LN10@SetResearc@2

; 2166 : 				{
; 2167 : 					iCulture = kLoopPlayer.GetCulturePerTechResearched();

	mov	ecx, esi
	call	?GetCulturePerTechResearched@CvPlayer@@QBEHXZ ; CvPlayer::GetCulturePerTechResearched

; 2168 : 					if(iCulture != 0)

	cmp	eax, ebp
	je	$LN10@SetResearc@2

; 2169 : 					{
; 2170 : 						kLoopPlayer.changeJONSCulture(iCulture);

	push	eax
	mov	ecx, esi
	call	?changeJONSCulture@CvPlayer@@QAEXH@Z	; CvPlayer::changeJONSCulture

; 2171 : 
; 2172 : #ifdef UPDATE_CULTURE_NOTIFICATION_DURING_TURN
; 2173 : 						// if this is the human player, have the popup come up so that he can choose a new policy
; 2174 : 						if (kLoopPlayer.isAlive() && kLoopPlayer.isHuman() && kLoopPlayer.getNumCities() > 0)

	cmp	BYTE PTR [esi+2256], 0
	je	$LN10@SetResearc@2
	mov	ecx, esi
	call	?isHuman@CvPlayer@@QBE_NXZ		; CvPlayer::isHuman
	test	al, al
	je	$LN10@SetResearc@2
	mov	ecx, esi
	call	?getNumCities@CvPlayer@@QBEHXZ		; CvPlayer::getNumCities
	test	eax, eax
	jle	$LN10@SetResearc@2

; 2175 : 						{
; 2176 : 							if (!GC.GetEngineUserInterface()->IsPolicyNotificationSeen())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8600
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+508]
	call	edx
	test	al, al
	jne	$LN10@SetResearc@2

; 2177 : 							{
; 2178 : 								if (kLoopPlayer.getNextPolicyCost() <= kLoopPlayer.getJONSCulture() && kLoopPlayer.GetPlayerPolicies()->GetNumPoliciesCanBeAdopted() > 0)

	mov	ecx, esi
	call	?getNextPolicyCost@CvPlayer@@QBEHXZ	; CvPlayer::getNextPolicyCost
	mov	ecx, esi
	mov	ebx, eax
	call	?getJONSCulture@CvPlayer@@QBEHXZ	; CvPlayer::getJONSCulture
	cmp	ebx, eax
	jg	$LN10@SetResearc@2
	mov	ecx, esi
	call	?GetPlayerPolicies@CvPlayer@@QBEPAVCvPlayerPolicies@@XZ ; CvPlayer::GetPlayerPolicies
	mov	ecx, eax
	call	?GetNumPoliciesCanBeAdopted@CvPlayerPolicies@@QAEHXZ ; CvPlayerPolicies::GetNumPoliciesCanBeAdopted
	test	eax, eax
	jle	$LN10@SetResearc@2

; 2179 : 								{
; 2180 : 									CvNotifications* pNotifications = kLoopPlayer.GetNotifications();

	mov	ecx, esi
	call	?GetNotifications@CvPlayer@@QBEPAVCvNotifications@@XZ ; CvPlayer::GetNotifications
	mov	esi, eax

; 2181 : 									if (pNotifications)

	cmp	esi, ebp
	je	$LN10@SetResearc@2

; 2182 : 									{
; 2183 : 										CvString strBuffer;

	lea	ecx, DWORD PTR _strBuffer$225377[esp+144]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2184 : 
; 2185 : 										if (GC.getGame().isOption(GAMEOPTION_POLICY_SAVING))

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	push	12					; 0000000cH
	mov	DWORD PTR __$EHRec$[esp+156], ebp
	call	?isOption@CvGame@@QBE_NW4GameOptionTypes@@@Z ; CvGame::isOption
	test	al, al
	je	SHORT $LN2@SetResearc@2

; 2186 : 											strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_ENOUGH_CULTURE_FOR_POLICY_DISMISS");

	lea	eax, DWORD PTR $T230844[esp+144]
	push	OFFSET $SG225380
	push	eax
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strBuffer$225377[esp+148]
	mov	BYTE PTR __$EHRec$[esp+156], 1
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T230844[esp+144]

; 2187 : 										else

	jmp	SHORT $LN95@SetResearc@2
$LN2@SetResearc@2:

; 2188 : 											strBuffer = GetLocalizedText("TXT_KEY_NOTIFICATION_ENOUGH_CULTURE_FOR_POLICY");

	lea	ecx, DWORD PTR $T230845[esp+144]
	push	OFFSET $SG225383
	push	ecx
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8
	push	eax
	lea	ecx, DWORD PTR _strBuffer$225377[esp+148]
	mov	BYTE PTR __$EHRec$[esp+156], 2
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	lea	ecx, DWORD PTR $T230845[esp+144]
$LN95@SetResearc@2:
	mov	BYTE PTR __$EHRec$[esp+152], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 2189 : 
; 2190 : 										CvString strSummary = GetLocalizedText("TXT_KEY_NOTIFICATION_SUMMARY_ENOUGH_CULTURE_FOR_POLICY");

	lea	edx, DWORD PTR _strSummary$225384[esp+144]
	push	OFFSET $SG225386
	push	edx
	call	?GetLocalizedText@@YA?AVCvString@@PBD@Z	; GetLocalizedText
	add	esp, 8

; 2191 : 										pNotifications->Add(NOTIFICATION_POLICY, strBuffer, strSummary, -1, -1, -1);

	lea	ecx, DWORD PTR _strSummary$225384[esp+144]
	mov	BYTE PTR __$EHRec$[esp+152], 3
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	-1
	push	-1
	push	-1
	push	-1
	push	eax
	lea	ecx, DWORD PTR _strBuffer$225377[esp+164]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	623640104				; 252bfe28H
	mov	ecx, esi
	call	?Add@CvNotifications@@QAEHW4NotificationTypes@@PBD1HHHH@Z ; CvNotifications::Add

; 2192 : 									}

	lea	ecx, DWORD PTR _strSummary$225384[esp+144]
	mov	BYTE PTR __$EHRec$[esp+152], 0
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR _strBuffer$225377[esp+144]
	mov	DWORD PTR __$EHRec$[esp+152], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN10@SetResearc@2:
	add	edi, 63236				; 0000f704H
	cmp	edi, 1391192				; 00153a58H
	jl	$LL91@SetResearc@2
$LN93@SetResearc@2:
	pop	esi
	pop	ebx
$LN9@SetResearc@2:

; 2193 : 								}
; 2194 : 							}
; 2195 : 						}
; 2196 : #endif
; 2197 : 					}
; 2198 : 				}
; 2199 : 			}
; 2200 : 		}
; 2201 : 	}
; 2202 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+136]
	pop	edi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 128				; 00000080H
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetResearchProgressTimes100@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z$0:
	lea	ecx, DWORD PTR _strBuffer$225377[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?SetResearchProgressTimes100@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z$1:
	lea	ecx, DWORD PTR $T230844[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?SetResearchProgressTimes100@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z$2:
	lea	ecx, DWORD PTR $T230845[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?SetResearchProgressTimes100@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z$3:
	lea	ecx, DWORD PTR _strSummary$225384[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?SetResearchProgressTimes100@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?SetResearchProgressTimes100@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetResearchProgressTimes100@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z ENDP ; CvTeamTechs::SetResearchProgressTimes100
PUBLIC	?ChangeResearchProgressTimes100@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z ; CvTeamTechs::ChangeResearchProgressTimes100
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeResearchProgressTimes100@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
_ePlayer$ = 16						; size = 4
?ChangeResearchProgressTimes100@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z PROC ; CvTeamTechs::ChangeResearchProgressTimes100, COMDAT
; _this$ = ecx

; 2330 : 	SetResearchProgressTimes100(eIndex, (GetResearchProgressTimes100(eIndex) + iChange), ePlayer);

	mov	eax, DWORD PTR _eIndex$[esp-4]
	cmp	eax, -1
	je	SHORT $LN4@ChangeRese
	mov	edx, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN3@ChangeRese
$LN4@ChangeRese:
	xor	edx, edx
$LN3@ChangeRese:
	push	esi
	mov	esi, DWORD PTR _ePlayer$[esp]
	push	esi
	mov	esi, DWORD PTR _iChange$[esp+4]
	add	edx, esi
	push	edx
	push	eax
	call	?SetResearchProgressTimes100@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z ; CvTeamTechs::SetResearchProgressTimes100
	pop	esi

; 2331 : }

	ret	12					; 0000000cH
?ChangeResearchProgressTimes100@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z ENDP ; CvTeamTechs::ChangeResearchProgressTimes100
_TEXT	ENDS
PUBLIC	?begin@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@2@XZ ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@2@XZ PROC ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@2@XZ ENDP ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@2@XZ ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@2@XZ PROC ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@2@XZ ENDP ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::end
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@IAE_NI@Z ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::_Buy
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@KAXXZ ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::_Xlen
$LN16@Buy:
$LN2@Buy:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@PAVCvTechEntry@@@std@@YAPAPAVCvTechEntry@@IPAPAV1@@Z ; std::_Allocate<CvTechEntry *>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy:
?_Buy@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::_Buy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@IAEXPAPAVCvTechEntry@@0@Z ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@IAEXPAPAVCvTechEntry@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@IAEXPAPAVCvTechEntry@@0@Z PROC ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@IAEXPAPAVCvTechEntry@@0@Z ENDP ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::_Destroy
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE@VCvTechEntry@@@@YAXAAPAVCvTechEntry@@@Z ; SAFE_DELETE<CvTechEntry>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE@VCvTechEntry@@@@YAXAAPAVCvTechEntry@@@Z
_TEXT	SEGMENT
_pkInstance$ = 8					; size = 4
??$SAFE_DELETE@VCvTechEntry@@@@YAXAAPAVCvTechEntry@@@Z PROC ; SAFE_DELETE<CvTechEntry>, COMDAT

; 305  : {

	push	esi
	push	edi

; 306  : 	delete pkInstance;

	mov	edi, DWORD PTR _pkInstance$[esp+4]
	mov	esi, DWORD PTR [edi]
	test	esi, esi
	je	SHORT $LN8@SAFE_DELET@2
	mov	ecx, esi
	call	??1CvTechEntry@@QAE@XZ			; CvTechEntry::~CvTechEntry
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@SAFE_DELET@2:

; 307  : 	pkInstance = NULL;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi

; 308  : };

	ret	0
??$SAFE_DELETE@VCvTechEntry@@@@YAXAAPAVCvTechEntry@@@Z ENDP ; SAFE_DELETE<CvTechEntry>
_TEXT	ENDS
PUBLIC	??Z?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<int,std::allocator<int> >::operator-=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??Z?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Z?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator-=, COMDAT
; _this$ = ecx

; 386  : 		{	// decrement by integer

	mov	eax, ecx

; 387  : 		return (*this += -_Off);

	mov	ecx, DWORD PTR __Off$[esp-4]
	neg	ecx
	add	ecx, ecx
	add	ecx, ecx
	add	DWORD PTR [eax], ecx

; 388  : 		}

	ret	4
??Z?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator-=
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@HV?$allocator@H@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<int,std::allocator<int> >,std::_Vector_iterator<int,std::allocator<int> >,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_backward_opt@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@HV?$allocator@H@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
___formal$ = 32						; size = 1
??$_Copy_backward_opt@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@HV?$allocator@H@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<std::_Vector_iterator<int,std::allocator<int> >,std::_Vector_iterator<int,std::allocator<int> >,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	eax, DWORD PTR __Last$[esp-4]
	cmp	DWORD PTR __First$[esp-4], eax
	je	SHORT $LN27@Copy_backw@2
	npad	6
$LL2@Copy_backw@2:

; 2676 : 		*--_Dest = *--_Last;

	mov	ecx, DWORD PTR __Dest$[esp-4]
	sub	eax, 4
	sub	ecx, 4
	mov	DWORD PTR __Last$[esp-4], eax
	mov	DWORD PTR __Dest$[esp-4], ecx
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __Last$[esp-4]
	cmp	DWORD PTR __First$[esp-4], eax
	jne	SHORT $LL2@Copy_backw@2

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [eax], ecx

; 2678 : 	}

	ret	0
$LN27@Copy_backw@2:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR __Dest$[esp-4]
	mov	DWORD PTR [eax], edx

; 2678 : 	}

	ret	0
??$_Copy_backward_opt@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@HV?$allocator@H@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<std::_Vector_iterator<int,std::allocator<int> >,std::_Vector_iterator<int,std::allocator<int> >,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z PROC	; std::vector<int,std::allocator<int> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@2
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@2:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@2

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
$LN16@Buy@2:
$LN2@Buy@2:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@2:
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ENDP	; std::vector<int,std::allocator<int> >::_Buy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z PROC ; std::vector<int,std::allocator<int> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Destroy
_TEXT	ENDS
PUBLIC	?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::end
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<int,std::allocator<int> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator+
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z PROC ; stdext::_Unchecked_move_backward<int *,int *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN14@Unchecked_
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_:
	mov	eax, esi
	pop	esi

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ENDP ; stdext::_Unchecked_move_backward<int *,int *>
_TEXT	ENDS
PUBLIC	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z	; stdext::unchecked_fill_n<int *,unsigned int,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z PROC	; stdext::unchecked_fill_n<int *,unsigned int,int>, COMDAT

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN7@unchecked_@3
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL9@unchecked_@3:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL9@unchecked_@3
	pop	esi
$LN7@unchecked_@3:

; 3722 : 	}

	ret	0
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ENDP	; stdext::unchecked_fill_n<int *,unsigned int,int>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>, COMDAT

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN10@Uninit_mov
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@Uninit_mov:
	pop	edi
	mov	eax, esi
	pop	esi

; 208  : 	}

	ret	0
??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtechclasses.cpp
_TEXT	ENDS
;	COMDAT ?FlavorUpdate@CvPlayerTechs@@UAEXXZ
_TEXT	SEGMENT
?FlavorUpdate@CvPlayerTechs@@UAEXXZ PROC		; CvPlayerTechs::FlavorUpdate, COMDAT
; _this$ = ecx

; 924  : {

	push	esi
	mov	esi, ecx

; 925  : 	SetLocalePriorities();

	call	?SetLocalePriorities@CvPlayerTechs@@QAEXXZ ; CvPlayerTechs::SetLocalePriorities

; 926  : 	AddFlavorAsStrategies(GC.getTECH_WEIGHT_PROPAGATION_PERCENT());

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+1836
	push	eax
	mov	ecx, esi
	call	?AddFlavorAsStrategies@CvPlayerTechs@@AAEXH@Z ; CvPlayerTechs::AddFlavorAsStrategies
	pop	esi

; 927  : }

	ret	0
?FlavorUpdate@CvPlayerTechs@@UAEXXZ ENDP		; CvPlayerTechs::FlavorUpdate
_TEXT	ENDS
PUBLIC	?GetResearchTurnsLeftTimes100@CvPlayerTechs@@QBEHW4TechTypes@@_N@Z ; CvPlayerTechs::GetResearchTurnsLeftTimes100
; Function compile flags: /Ogtpy
;	COMDAT ?GetResearchTurnsLeftTimes100@CvPlayerTechs@@QBEHW4TechTypes@@_N@Z
_TEXT	SEGMENT
_iResearchRate$ = -12					; size = 4
_iOverflow$ = -8					; size = 4
$T231298 = -4						; size = 4
$T231299 = 8						; size = 4
$T231297 = 8						; size = 4
_eTech$ = 8						; size = 4
_iTurnsLeft$ = 12					; size = 4
_bOverflow$ = 12					; size = 1
?GetResearchTurnsLeftTimes100@CvPlayerTechs@@QBEHW4TechTypes@@_N@Z PROC ; CvPlayerTechs::GetResearchTurnsLeftTimes100, COMDAT
; _this$ = ecx

; 1451 : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi
	push	edi

; 1452 : 	int iResearchRate;
; 1453 : 	int iOverflow;
; 1454 : 	int iTurnsLeft;
; 1455 : 	int iI;
; 1456 : 
; 1457 : 	iResearchRate = 0;

	xor	edi, edi
	mov	ebp, ecx
	mov	DWORD PTR _iResearchRate$[esp+28], edi

; 1458 : 	iOverflow = 0;

	mov	DWORD PTR _iOverflow$[esp+28], edi

; 1459 : 
; 1460 : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	xor	ebx, ebx
	npad	11
$LL10@GetResearc@7:

; 1461 : 	{
; 1462 : 		CvPlayerAI& kPlayer = GET_PLAYER((PlayerTypes)iI);

	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 1463 : 		if(kPlayer.isAlive())

	cmp	BYTE PTR [edi+eax+2256], 0
	lea	esi, DWORD PTR [edi+eax]
	je	SHORT $LN9@GetResearc@7

; 1464 : 		{
; 1465 : 			// Find everyone on our team
; 1466 : 			if(kPlayer.getTeam() == m_pPlayer->getTeam())

	mov	eax, DWORD PTR [esi+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN23@GetResearc@7
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN24@GetResearc@7
$LN23@GetResearc@7:
	or	edx, -1
$LN24@GetResearc@7:
	mov	eax, DWORD PTR [ebp+44]
	mov	eax, DWORD PTR [eax+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN32@GetResearc@7
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN33@GetResearc@7
$LN32@GetResearc@7:
	or	ecx, -1
$LN33@GetResearc@7:
	cmp	edx, ecx
	jne	SHORT $LN9@GetResearc@7

; 1467 : 			{
; 1468 : 				// If this is us or if the tech matches, then increment totals
; 1469 : 				if((iI == m_pPlayer->GetID()) || kPlayer.GetPlayerTechs()->GetCurrentResearch() == eTech)

	cmp	ebx, eax
	je	SHORT $LN4@GetResearc@7
	mov	ecx, esi
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, DWORD PTR [eax+44]
	call	?headResearchQueueNode@CvPlayer@@QAEPAV?$CLLNode@W4TechTypes@@@@XZ ; CvPlayer::headResearchQueueNode
	test	eax, eax
	je	SHORT $LN42@GetResearc@7
	mov	eax, DWORD PTR [eax+4]
	jmp	SHORT $LN41@GetResearc@7
$LN42@GetResearc@7:
	or	eax, -1
$LN41@GetResearc@7:
	cmp	eax, DWORD PTR _eTech$[esp+24]
	jne	SHORT $LN9@GetResearc@7
$LN4@GetResearc@7:

; 1470 : 				{
; 1471 : 					iResearchRate += kPlayer.GetScienceTimes100();

	mov	ecx, esi
	call	?GetScienceTimes100@CvPlayer@@QBEHXZ	; CvPlayer::GetScienceTimes100
	add	DWORD PTR _iResearchRate$[esp+28], eax

; 1472 : #ifdef AUI_PLAYER_FIX_NO_RESEARCH_OVERFLOW_DOUBLE_DIP
; 1473 : 					iOverflow += kPlayer.getOverflowResearch();

	mov	ecx, esi
	call	?getOverflowResearch@CvPlayer@@QBEHXZ	; CvPlayer::getOverflowResearch
	add	DWORD PTR _iOverflow$[esp+28], eax
$LN9@GetResearc@7:
	add	edi, 63236				; 0000f704H
	inc	ebx
	cmp	edi, 4047104				; 003dc100H
	jl	$LL10@GetResearc@7

; 1474 : #else
; 1475 : 					iOverflow += (kPlayer.getOverflowResearch() * m_pPlayer->calculateResearchModifier(eTech)) / 100;
; 1476 : #endif
; 1477 : 				}
; 1478 : 			}
; 1479 : 		}
; 1480 : 	}
; 1481 : 
; 1482 : 	if(iResearchRate == 0)

	cmp	DWORD PTR _iResearchRate$[esp+28], 0
	jne	SHORT $LN3@GetResearc@7
	pop	edi
	pop	esi
	pop	ebp

; 1483 : 	{
; 1484 : 		return INT_MAX;

	mov	eax, 2147483647				; 7fffffffH
	pop	ebx

; 1509 : }

	add	esp, 12					; 0000000cH
	ret	8
$LN3@GetResearc@7:

; 1485 : 	}
; 1486 : 
; 1487 : 	int iResearchCost = GetResearchCost(eTech);				// Get our research cost (not the 'team' one which doesn't use our player modifier)

	mov	edi, DWORD PTR _eTech$[esp+24]
	push	edi
	mov	ecx, ebp
	call	?GetResearchCost@CvPlayerTechs@@QBEHW4TechTypes@@@Z ; CvPlayerTechs::GetResearchCost

; 1488 : 	// Get the team progress
; 1489 : 	int iResearchProgress = GET_TEAM(m_pPlayer->getTeam()).GetTeamTechs()->GetResearchProgress(eTech);

	mov	edx, DWORD PTR [ebp+44]
	mov	esi, eax
	mov	eax, DWORD PTR [edx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN49@GetResearc@7
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN50@GetResearc@7
$LN49@GetResearc@7:
	or	eax, -1
$LN50@GetResearc@7:
	imul	eax, 2984				; 00000ba8H
	add	eax, DWORD PTR ?m_aTeams@CvTeam@@1PAV1@A ; CvTeam::m_aTeams
	mov	ecx, eax
	call	?GetTeamTechs@CvTeam@@QBEPAVCvTeamTechs@@XZ ; CvTeam::GetTeamTechs
	cmp	edi, -1
	je	SHORT $LN57@GetResearc@7
	mov	eax, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR [eax+edi*4]
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	jmp	SHORT $LN56@GetResearc@7
$LN57@GetResearc@7:
	xor	eax, eax
$LN56@GetResearc@7:

; 1490 : 	// Get the raw amount left
; 1491 : 	int iResearchLeft = std::max(0, (iResearchCost - iResearchProgress));

	sub	esi, eax
	mov	DWORD PTR $T231297[esp+24], esi
	mov	DWORD PTR $T231298[esp+28], 0
	lea	eax, DWORD PTR $T231297[esp+24]
	test	esi, esi
	jg	SHORT $LN63@GetResearc@7
	lea	eax, DWORD PTR $T231298[esp+28]
$LN63@GetResearc@7:

; 1492 : 
; 1493 : 	// Removed any current overflow if requested.
; 1494 : 	if(bOverflow)

	cmp	BYTE PTR _bOverflow$[esp+24], 0
	mov	eax, DWORD PTR [eax]
	je	SHORT $LN2@GetResearc@7

; 1495 : 	{
; 1496 : 		iResearchLeft -= iOverflow;

	sub	eax, DWORD PTR _iOverflow$[esp+28]
$LN2@GetResearc@7:

; 1497 : 	}
; 1498 : 
; 1499 : 	iResearchLeft *= 10000;
; 1500 : 
; 1501 : 	iTurnsLeft = (iResearchLeft / iResearchRate);

	mov	esi, DWORD PTR _iResearchRate$[esp+28]
	imul	eax, 10000				; 00002710H
	mov	ecx, eax
	cdq
	idiv	esi

; 1502 : 
; 1503 : 	if(iTurnsLeft * iResearchRate < iResearchLeft)

	mov	edx, eax
	imul	edx, esi
	cmp	edx, ecx
	mov	DWORD PTR _iTurnsLeft$[esp+24], eax
	jge	SHORT $LN72@GetResearc@7

; 1504 : 	{
; 1505 : 		++iTurnsLeft;

	inc	eax
	mov	DWORD PTR _iTurnsLeft$[esp+24], eax
$LN72@GetResearc@7:

; 1506 : 	}
; 1507 : 
; 1508 : 	return std::max(1, iTurnsLeft);

	cmp	eax, 1
	mov	DWORD PTR $T231299[esp+24], 1
	lea	eax, DWORD PTR _iTurnsLeft$[esp+24]
	jg	SHORT $LN67@GetResearc@7
	lea	eax, DWORD PTR $T231299[esp+24]
$LN67@GetResearc@7:
	mov	eax, DWORD PTR [eax]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1509 : }

	add	esp, 12					; 0000000cH
	ret	8
?GetResearchTurnsLeftTimes100@CvPlayerTechs@@QBEHW4TechTypes@@_N@Z ENDP ; CvPlayerTechs::GetResearchTurnsLeftTimes100
_TEXT	ENDS
PUBLIC	?SetResearchProgress@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z ; CvTeamTechs::SetResearchProgress
; Function compile flags: /Ogtpy
;	COMDAT ?SetResearchProgress@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_iNewValue$ = 12					; size = 4
_ePlayer$ = 16						; size = 4
?SetResearchProgress@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z PROC ; CvTeamTechs::SetResearchProgress, COMDAT
; _this$ = ecx

; 2101 : 	SetResearchProgressTimes100(eIndex, iNewValue * 100, ePlayer);

	mov	edx, DWORD PTR _iNewValue$[esp-4]
	imul	edx, 100				; 00000064H
	mov	DWORD PTR _iNewValue$[esp-4], edx
	jmp	?SetResearchProgressTimes100@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z ; CvTeamTechs::SetResearchProgressTimes100
?SetResearchProgress@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z ENDP ; CvTeamTechs::SetResearchProgress
_TEXT	ENDS
PUBLIC	?ChangeResearchProgress@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z ; CvTeamTechs::ChangeResearchProgress
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeResearchProgress@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
_ePlayer$ = 16						; size = 4
?ChangeResearchProgress@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z PROC ; CvTeamTechs::ChangeResearchProgress, COMDAT
; _this$ = ecx

; 2324 : 	ChangeResearchProgressTimes100(eIndex, iChange * 100, ePlayer);

	mov	eax, DWORD PTR _eIndex$[esp-4]
	cmp	eax, -1
	je	SHORT $LN6@ChangeRese@2
	mov	edx, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR [edx+eax*4]
	jmp	SHORT $LN5@ChangeRese@2
$LN6@ChangeRese@2:
	xor	edx, edx
$LN5@ChangeRese@2:
	push	esi
	mov	esi, DWORD PTR _ePlayer$[esp]
	push	esi
	mov	esi, DWORD PTR _iChange$[esp+4]
	imul	esi, 100				; 00000064H
	add	esi, edx
	push	esi
	push	eax
	call	?SetResearchProgressTimes100@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z ; CvTeamTechs::SetResearchProgressTimes100
	pop	esi

; 2325 : }

	ret	12					; 0000000cH
?ChangeResearchProgress@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z ENDP ; CvTeamTechs::ChangeResearchProgress
_TEXT	ENDS
PUBLIC	?ChangeResearchProgressPercent@CvTeamTechs@@QAEHW4TechTypes@@HW4PlayerTypes@@@Z ; CvTeamTechs::ChangeResearchProgressPercent
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeResearchProgressPercent@CvTeamTechs@@QAEHW4TechTypes@@HW4PlayerTypes@@@Z
_TEXT	SEGMENT
$T231460 = 8						; size = 4
_eIndex$ = 8						; size = 4
$T231459 = 12						; size = 4
$T231457 = 12						; size = 4
_iPercent$ = 12						; size = 4
_ePlayer$ = 16						; size = 4
?ChangeResearchProgressPercent@CvTeamTechs@@QAEHW4TechTypes@@HW4PlayerTypes@@@Z PROC ; CvTeamTechs::ChangeResearchProgressPercent, COMDAT
; _this$ = ecx

; 2335 : {

	push	ebx

; 2336 : 	int iBeakers = 0;
; 2337 : 
; 2338 : 	if(0 != iPercent && !HasTech(eIndex))

	mov	ebx, DWORD PTR _iPercent$[esp]
	xor	eax, eax
	push	ebp
	mov	ebp, ecx
	test	ebx, ebx
	je	$LN27@ChangeRese@3
	push	esi
	mov	esi, DWORD PTR _eIndex$[esp+8]
	cmp	esi, -1
	je	$LN37@ChangeRese@3
	mov	ecx, DWORD PTR [ebp+4]
	test	ecx, ecx
	je	SHORT $LN33@ChangeRese@3
	cmp	BYTE PTR [ecx+esi], al
	jne	$LN37@ChangeRese@3
$LN33@ChangeRese@3:
	push	edi

; 2339 : 	{
; 2340 : 		if(iPercent > 0)
; 2341 : 		{
; 2342 : #ifdef AUI_TECH_FIX_PLAYER_BASED_RESEARCH_COST_ONLY_AESTHETIC
; 2343 : 			iBeakers = std::min(GetResearchLeft(eIndex), (GET_PLAYER(ePlayer).GetPlayerTechs()->GetResearchCost(eIndex) * iPercent) / 100);

	push	esi
	test	ebx, ebx
	jle	SHORT $LN2@ChangeRese@3
	mov	ecx, DWORD PTR _ePlayer$[esp+16]
	imul	ecx, 63236				; 0000f704H
	add	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?GetResearchCost@CvPlayerTechs@@QBEHW4TechTypes@@@Z ; CvPlayerTechs::GetResearchCost
	mov	ecx, eax
	imul	ecx, ebx
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	add	edi, edx
	push	esi
	mov	ecx, ebp
	mov	DWORD PTR $T231457[esp+16], edi
	call	?GetResearchLeft@CvTeamTechs@@QBEHW4TechTypes@@@Z ; CvTeamTechs::GetResearchLeft
	cmp	edi, eax

; 2344 : #else
; 2345 : 			iBeakers = std::min(GetResearchLeft(eIndex), (GetResearchCost(eIndex) * iPercent) / 100);
; 2346 : #endif
; 2347 : 		}
; 2348 : 		else

	jmp	SHORT $LN39@ChangeRese@3
$LN2@ChangeRese@3:

; 2349 : 		{
; 2350 : #ifdef AUI_TECH_FIX_PLAYER_BASED_RESEARCH_COST_ONLY_AESTHETIC
; 2351 : 			iBeakers = std::max(GetResearchLeft(eIndex) - GET_PLAYER(ePlayer).GetPlayerTechs()->GetResearchCost(eIndex), (GET_PLAYER(ePlayer).GetPlayerTechs()->GetResearchCost(eIndex) * iPercent) / 100);

	mov	edi, DWORD PTR _ePlayer$[esp+16]
	mov	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	edi, 63236				; 0000f704H
	lea	ecx, DWORD PTR [edi+eax]
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?GetResearchCost@CvPlayerTechs@@QBEHW4TechTypes@@@Z ; CvPlayerTechs::GetResearchCost
	mov	ecx, eax
	imul	ecx, ebx
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	sar	edx, 5
	mov	ebx, edx
	shr	ebx, 31					; 0000001fH
	add	ebx, edx
	add	ecx, edi
	push	esi
	mov	DWORD PTR $T231459[esp+16], ebx
	call	?GetPlayerTechs@CvPlayer@@QBEPAVCvPlayerTechs@@XZ ; CvPlayer::GetPlayerTechs
	mov	ecx, eax
	call	?GetResearchCost@CvPlayerTechs@@QBEHW4TechTypes@@@Z ; CvPlayerTechs::GetResearchCost
	push	esi
	mov	ecx, ebp
	mov	edi, eax
	call	?GetResearchLeft@CvTeamTechs@@QBEHW4TechTypes@@@Z ; CvTeamTechs::GetResearchLeft
	sub	eax, edi
	cmp	eax, ebx
$LN39@ChangeRese@3:
	mov	DWORD PTR $T231460[esp+12], eax
	lea	eax, DWORD PTR $T231459[esp+12]
	jl	SHORT $LN24@ChangeRese@3
	lea	eax, DWORD PTR $T231460[esp+12]
$LN24@ChangeRese@3:

; 2352 : #else
; 2353 : 			iBeakers = std::max(GetResearchLeft(eIndex) - GetResearchCost(eIndex), (GetResearchCost(eIndex) * iPercent) / 100);
; 2354 : #endif
; 2355 : 		}
; 2356 : 
; 2357 : 		ChangeResearchProgress(eIndex, iBeakers, ePlayer);

	mov	edx, DWORD PTR [ebp+12]
	mov	edi, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+esi*4]
	mov	ecx, DWORD PTR _ePlayer$[esp+12]
	mov	edx, edi
	imul	edx, 100				; 00000064H
	push	ecx
	add	edx, eax
	push	edx
	push	esi
	mov	ecx, ebp
	call	?SetResearchProgressTimes100@CvTeamTechs@@QAEXW4TechTypes@@HW4PlayerTypes@@@Z ; CvTeamTechs::SetResearchProgressTimes100

; 2358 : 	}
; 2359 : 
; 2360 : 	return iBeakers;

	mov	eax, edi
	pop	edi
$LN37@ChangeRese@3:
	pop	esi

; 2352 : #else
; 2353 : 			iBeakers = std::max(GetResearchLeft(eIndex) - GetResearchCost(eIndex), (GetResearchCost(eIndex) * iPercent) / 100);
; 2354 : #endif
; 2355 : 		}
; 2356 : 
; 2357 : 		ChangeResearchProgress(eIndex, iBeakers, ePlayer);

$LN27@ChangeRese@3:
	pop	ebp
	pop	ebx

; 2361 : }

	ret	12					; 0000000cH
?ChangeResearchProgressPercent@CvTeamTechs@@QAEHW4TechTypes@@HW4PlayerTypes@@@Z ENDP ; CvTeamTechs::ChangeResearchProgressPercent
_TEXT	ENDS
PUBLIC	??0?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE@XZ ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::vector<CvTechEntry *,std::allocator<CvTechEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::vector<CvTechEntry *,std::allocator<CvTechEntry *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::vector<CvTechEntry *,std::allocator<CvTechEntry *> >
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@2@0@Z ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@2@0@Z PROC ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@2@V?$_Vector_const_iterator@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@2@0@Z ENDP ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@IAEXXZ ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@IAEXXZ PROC ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::_Tidy
_TEXT	ENDS
PUBLIC	??G?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<int,std::allocator<int> >::operator-
; Function compile flags: /Ogtpy
;	COMDAT ??G?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??G?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator-, COMDAT
; _this$ = ecx

; 392  : 		_Myt _Tmp = *this;
; 393  : 		return (_Tmp -= _Off);

	mov	eax, DWORD PTR __Off$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	edx, DWORD PTR [eax*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	sub	ecx, edx
	mov	DWORD PTR [eax], ecx

; 394  : 		}

	ret	8
??G?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator-
_TEXT	ENDS
PUBLIC	??$_Median@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@00@Z ; std::_Median<std::_Vector_iterator<int,std::allocator<int> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Median@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Median@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@00@Z PROC ; std::_Median<std::_Vector_iterator<int,std::allocator<int> > >, COMDAT

; 3010 : 	if (40 < _Last - _First)

	mov	edx, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, edx
	sub	eax, ecx
	sar	eax, 2
	cmp	eax, 40					; 00000028H
	jle	SHORT $LN2@Median

; 3011 : 		{	// median of nine
; 3012 : 		size_t _Step = (_Last - _First + 1) / 8;

	inc	eax
	cdq
	and	edx, 7
	push	esi
	add	eax, edx
	sar	eax, 3
	push	edi

; 3013 : 		std::_Med3(_First, _First + _Step, _First + 2 * _Step);

	lea	edi, DWORD PTR [eax*8]
	lea	edx, DWORD PTR [edi+ecx]
	lea	esi, DWORD PTR [eax*4]
	push	edx
	lea	eax, DWORD PTR [esi+ecx]
	push	eax
	push	ecx
	call	??$_Med3@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@00@Z ; std::_Med3<std::_Vector_iterator<int,std::allocator<int> > >

; 3014 : 		std::_Med3(_Mid - _Step, _Mid, _Mid + _Step);

	mov	ecx, DWORD PTR __Mid$[esp+16]
	lea	edx, DWORD PTR [esi+ecx]
	push	edx
	mov	eax, ecx
	sub	eax, esi
	push	ecx
	push	eax
	call	??$_Med3@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@00@Z ; std::_Med3<std::_Vector_iterator<int,std::allocator<int> > >

; 3015 : 		std::_Med3(_Last - 2 * _Step, _Last - _Step, _Last);

	mov	edx, DWORD PTR __Last$[esp+28]
	mov	eax, edx
	push	edx
	sub	eax, esi
	mov	ecx, edx
	sub	ecx, edi
	push	eax
	push	ecx
	call	??$_Med3@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@00@Z ; std::_Med3<std::_Vector_iterator<int,std::allocator<int> > >

; 3016 : 		std::_Med3(_First + _Step, _Mid, _Last - _Step);

	mov	eax, DWORD PTR __Last$[esp+40]
	mov	ecx, DWORD PTR __First$[esp+40]
	mov	edx, DWORD PTR __Mid$[esp+40]
	sub	eax, esi
	push	eax
	add	ecx, esi
	push	edx
	push	ecx
	call	??$_Med3@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@00@Z ; std::_Med3<std::_Vector_iterator<int,std::allocator<int> > >
	add	esp, 48					; 00000030H
	pop	edi
	pop	esi

; 3020 : 	}

	ret	0
$LN2@Median:

; 3017 : 		}
; 3018 : 	else
; 3019 : 		std::_Med3(_First, _Mid, _Last);

	mov	eax, DWORD PTR __Mid$[esp-4]
	push	edx
	push	eax
	push	ecx
	call	??$_Med3@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@00@Z ; std::_Med3<std::_Vector_iterator<int,std::allocator<int> > >
	add	esp, 12					; 0000000cH

; 3020 : 	}

	ret	0
??$_Median@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@00@Z ENDP ; std::_Median<std::_Vector_iterator<int,std::allocator<int> > >
_TEXT	ENDS
PUBLIC	??$unchecked_copy_backward@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@HV?$allocator@H@std@@@std@@V12@00@Z ; stdext::unchecked_copy_backward<std::_Vector_iterator<int,std::allocator<int> >,std::_Vector_iterator<int,std::allocator<int> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy_backward@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@HV?$allocator@H@std@@@std@@V12@00@Z
_TEXT	SEGMENT
$T231932 = -4						; size = 1
__Cat$231937 = 8					; size = 1
$T231934 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
??$unchecked_copy_backward@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@HV?$allocator@H@std@@@std@@V12@00@Z PROC ; stdext::unchecked_copy_backward<std::_Vector_iterator<int,std::allocator<int> >,std::_Vector_iterator<int,std::allocator<int> > >, COMDAT

; 3636 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

	push	ecx

; 3637 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3638 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$231937[esp]
	mov	edx, DWORD PTR $T231934[esp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+4]
	mov	BYTE PTR $T231932[esp+8], 0
	mov	eax, DWORD PTR $T231932[esp+8]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	edx
	mov	edx, DWORD PTR __First$[esp+16]
	push	eax
	push	ecx
	push	edx
	push	esi
	call	??$_Copy_backward_opt@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@HV?$allocator@H@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<int,std::allocator<int> >,std::_Vector_iterator<int,std::allocator<int> >,std::random_access_iterator_tag>
	add	esp, 28					; 0000001cH
	mov	eax, esi
	pop	esi

; 3639 : 	}

	pop	ecx
	ret	0
??$unchecked_copy_backward@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@V12@@stdext@@YA?AV?$_Vector_iterator@HV?$allocator@H@std@@@std@@V12@00@Z ENDP ; stdext::unchecked_copy_backward<std::_Vector_iterator<int,std::allocator<int> >,std::_Vector_iterator<int,std::allocator<int> > >
_TEXT	ENDS
PUBLIC	??$_Push_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@HH@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@HHH@Z ; std::_Push_heap<std::_Vector_iterator<int,std::allocator<int> >,int,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Push_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@HH@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@HHH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Top$ = 16						; size = 4
__Val$ = 20						; size = 4
??$_Push_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@HH@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@HHH@Z PROC ; std::_Push_heap<std::_Vector_iterator<int,std::allocator<int> >,int,int>, COMDAT

; 1973 : 	for (_Diff _Idx = (_Hole - 1) / 2;

	mov	ecx, DWORD PTR __Hole$[esp-4]
	lea	eax, DWORD PTR [ecx-1]
	cdq
	push	ebx
	push	esi

; 1974 : 		_Top < _Hole && _DEBUG_LT(*(_First + _Idx), _Val);
; 1975 : 		_Idx = (_Hole - 1) / 2)

	mov	esi, DWORD PTR __Top$[esp+4]
	sub	eax, edx
	sar	eax, 1
	cmp	esi, ecx
	push	edi
	mov	edi, DWORD PTR __Val$[esp+8]
	jge	SHORT $LN48@Push_heap
	npad	5
$LL3@Push_heap:
	mov	edx, DWORD PTR __First$[esp+8]
	cmp	DWORD PTR [edx+eax*4], edi
	jge	SHORT $LN1@Push_heap

; 1976 : 		{	// move _Hole up to parent
; 1977 : 		*(_First + _Hole) = *(_First + _Idx);

	mov	ebx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [edx+ecx*4], ebx

; 1978 : 		_Hole = _Idx;

	mov	ecx, eax
	dec	eax
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	esi, ecx
	jl	SHORT $LL3@Push_heap
$LN48@Push_heap:

; 1974 : 		_Top < _Hole && _DEBUG_LT(*(_First + _Idx), _Val);
; 1975 : 		_Idx = (_Hole - 1) / 2)

	mov	edx, DWORD PTR __First$[esp+8]
$LN1@Push_heap:

; 1979 : 		}
; 1980 : 
; 1981 : 	*(_First + _Hole) = _Val;	// drop _Val into final hole

	mov	DWORD PTR [edx+ecx*4], edi
	pop	edi
	pop	esi
	pop	ebx

; 1982 : 	}

	ret	0
??$_Push_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@HH@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@HHH@Z ENDP ; std::_Push_heap<std::_Vector_iterator<int,std::allocator<int> >,int,int>
_TEXT	ENDS
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ PROC	; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy@2

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@2:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >, COMDAT

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN9@Uninit_fil
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL11@Uninit_fil:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL11@Uninit_fil
	pop	esi
$LN9@Uninit_fil:

; 420  : 	}

	ret	0
??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >, COMDAT

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN14@Unchecked_@2
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_@2:
	pop	edi
	mov	eax, esi
	pop	esi

; 865  : 	}

	ret	0
??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?GetResearchTurnsLeft@CvPlayerTechs@@QBEHW4TechTypes@@_N@Z ; CvPlayerTechs::GetResearchTurnsLeft
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtechclasses.cpp
;	COMDAT ?GetResearchTurnsLeft@CvPlayerTechs@@QBEHW4TechTypes@@_N@Z
_TEXT	SEGMENT
$T232270 = 8						; size = 4
_eTech$ = 8						; size = 4
_bOverflow$ = 12					; size = 1
_iTurnsLeft$ = 12					; size = 4
?GetResearchTurnsLeft@CvPlayerTechs@@QBEHW4TechTypes@@_N@Z PROC ; CvPlayerTechs::GetResearchTurnsLeft, COMDAT
; _this$ = ecx

; 1437 : 	int iTurnsLeft = GetResearchTurnsLeftTimes100(eTech, bOverflow);

	mov	eax, DWORD PTR _bOverflow$[esp-4]
	mov	edx, DWORD PTR _eTech$[esp-4]
	push	eax
	push	edx
	call	?GetResearchTurnsLeftTimes100@CvPlayerTechs@@QBEHW4TechTypes@@_N@Z ; CvPlayerTechs::GetResearchTurnsLeftTimes100

; 1438 : 
; 1439 : 	if(iTurnsLeft == INT_MAX)

	cmp	eax, 2147483647				; 7fffffffH
	jne	SHORT $LN1@GetResearc@8

; 1447 : }

	ret	8
$LN1@GetResearc@8:

; 1440 : 	{
; 1441 : 		return INT_MAX;
; 1442 : 	}
; 1443 : 
; 1444 : 	iTurnsLeft = (iTurnsLeft + 99) / 100; // round up

	lea	ecx, DWORD PTR [eax+99]
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR _iTurnsLeft$[esp-4], eax

; 1445 : 
; 1446 : 	return std::max(1, iTurnsLeft);

	cmp	eax, 1
	mov	DWORD PTR $T232270[esp-4], 1
	lea	eax, DWORD PTR _iTurnsLeft$[esp-4]
	jg	SHORT $LN7@GetResearc@8
	lea	eax, DWORD PTR $T232270[esp-4]
$LN7@GetResearc@8:
	mov	eax, DWORD PTR [eax]

; 1447 : }

	ret	8
?GetResearchTurnsLeft@CvPlayerTechs@@QBEHW4TechTypes@@_N@Z ENDP ; CvPlayerTechs::GetResearchTurnsLeft
_TEXT	ENDS
PUBLIC	??1?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE@XZ ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::~vector<CvTechEntry *,std::allocator<CvTechEntry *> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??1?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::~vector<CvTechEntry *,std::allocator<CvTechEntry *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::~vector<CvTechEntry *,std::allocator<CvTechEntry *> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAEXXZ ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAEXXZ PROC ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	esi
	push	edi
	mov	edi, ecx

; 1060 : 		erase(begin(), end());

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $LN15@clear
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN40@clear
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN40@clear:
	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN15@clear:
	pop	edi
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::clear
_TEXT	ENDS
PUBLIC	??$_Unguarded_partition@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YA?AU?$pair@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@V12@@0@V?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z ; std::_Unguarded_partition<std::_Vector_iterator<int,std::allocator<int> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Unguarded_partition@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YA?AU?$pair@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@V12@@0@V?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z
_TEXT	SEGMENT
__Tmp$233069 = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Unguarded_partition@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YA?AU?$pair@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@V12@@0@V?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z PROC ; std::_Unguarded_partition<std::_Vector_iterator<int,std::allocator<int> > >, COMDAT

; 3024 : 	{	// partition [_First, _Last), using operator<

	push	ecx

; 3025 : 	_RanIt _Mid = _First + (_Last - _First) / 2;	// sort median to _Mid

	mov	ecx, DWORD PTR __First$[esp]
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __Last$[esp+16]
	mov	eax, edi
	sub	eax, ecx
	sar	eax, 2
	cdq
	sub	eax, edx
	sar	eax, 1
	lea	esi, DWORD PTR [ecx+eax*4]

; 3026 : 	std::_Median(_First, _Mid, _Last - 1);

	lea	eax, DWORD PTR [edi-4]
	push	eax
	push	esi
	push	ecx
	call	??$_Median@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@00@Z ; std::_Median<std::_Vector_iterator<int,std::allocator<int> > >

; 3027 : 	_RanIt _Pfirst = _Mid;
; 3028 : 	_RanIt _Plast = _Pfirst + 1;
; 3029 : 
; 3030 : 	while (_First < _Pfirst
; 3031 : 		&& !_DEBUG_LT(*(_Pfirst - 1), *_Pfirst)
; 3032 : 		&& !(*_Pfirst < *(_Pfirst - 1)))

	mov	edi, DWORD PTR __First$[esp+28]
	add	esp, 12					; 0000000cH
	mov	ecx, esi
	lea	ebx, DWORD PTR [esi+4]
	cmp	edi, esi
	jae	SHORT $LN341@Unguarded_
$LL27@Unguarded_:
	mov	eax, DWORD PTR [ecx-4]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, eax
	jg	SHORT $LN341@Unguarded_
	jl	SHORT $LN341@Unguarded_
	add	ecx, -4					; fffffffcH
	cmp	edi, ecx
	jb	SHORT $LL27@Unguarded_
$LN341@Unguarded_:

; 3033 : 		--_Pfirst;
; 3034 : 	while (_Plast < _Last
; 3035 : 		&& !_DEBUG_LT(*_Plast, *_Pfirst)
; 3036 : 		&& !(*_Pfirst < *_Plast))

	mov	esi, DWORD PTR __Last$[esp+16]
	cmp	ebx, esi
	jae	SHORT $LN24@Unguarded_
	mov	edx, DWORD PTR [ecx]
$LL25@Unguarded_:
	mov	eax, DWORD PTR [ebx]
	cmp	edx, eax
	jg	SHORT $LN24@Unguarded_
	jl	SHORT $LN24@Unguarded_

; 3037 : 		++_Plast;

	add	ebx, 4
	cmp	ebx, esi
	jb	SHORT $LL25@Unguarded_
$LN24@Unguarded_:

; 3038 : 
; 3039 : 	_RanIt _Gfirst = _Plast;

	mov	edx, ebx

; 3040 : 	_RanIt _Glast = _Pfirst;

	mov	ebp, ecx
$LL23@Unguarded_:

; 3041 : 
; 3042 : 	for (; ; )
; 3043 : 		{	// partition
; 3044 : 		for (; _Gfirst < _Last; ++_Gfirst)

	cmp	edx, DWORD PTR __Last$[esp+16]
	jae	SHORT $LN352@Unguarded_
	npad	4
$LL116@Unguarded_:

; 3045 : 			if (_DEBUG_LT(*_Pfirst, *_Gfirst))

	mov	eax, DWORD PTR [ecx]
	mov	esi, DWORD PTR [edx]
	cmp	esi, eax
	jg	SHORT $LN20@Unguarded_

; 3046 : 				;
; 3047 : 			else if (*_Gfirst < *_Pfirst)

	jl	SHORT $LN352@Unguarded_

; 3048 : 				break;
; 3049 : 			else
; 3050 : 				std::iter_swap(_Plast++, _Gfirst);

	mov	eax, ebx
	add	ebx, 4
	cmp	eax, edx
	je	SHORT $LN20@Unguarded_
	mov	edi, DWORD PTR [edx]
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [edx], esi
$LN20@Unguarded_:
	add	edx, 4
	cmp	edx, DWORD PTR __Last$[esp+16]
	jb	SHORT $LL116@Unguarded_
$LN352@Unguarded_:

; 3051 : 		for (; _First < _Glast; --_Glast)

	cmp	ebp, DWORD PTR __First$[esp+16]
	jbe	SHORT $LN356@Unguarded_
	lea	eax, DWORD PTR [ebp-4]
	npad	3
$LL157@Unguarded_:

; 3052 : 			if (_DEBUG_LT(*(_Glast - 1), *_Pfirst))

	mov	esi, DWORD PTR [eax]
	mov	edi, DWORD PTR [ecx]
	cmp	edi, esi
	jg	SHORT $LN13@Unguarded_

; 3053 : 				;
; 3054 : 			else if (*_Pfirst < *(_Glast - 1))

	jl	SHORT $LN353@Unguarded_

; 3055 : 				break;
; 3056 : 			else
; 3057 : 				std::iter_swap(--_Pfirst, _Glast - 1);

	sub	ecx, 4
	cmp	ecx, eax
	je	SHORT $LN13@Unguarded_
	mov	edi, DWORD PTR [eax]
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], edi
	mov	DWORD PTR [eax], esi
$LN13@Unguarded_:
	sub	ebp, 4
	sub	eax, 4
	cmp	DWORD PTR __First$[esp+16], ebp
	jb	SHORT $LL157@Unguarded_
$LN353@Unguarded_:

; 3058 : 		if (_Glast == _First && _Gfirst == _Last)

	cmp	ebp, DWORD PTR __First$[esp+16]
$LN356@Unguarded_:
	jne	SHORT $LN6@Unguarded_
	cmp	edx, DWORD PTR __Last$[esp+16]
	je	$LN347@Unguarded_

; 3060 : 
; 3061 : 		if (_Glast == _First)
; 3062 : 			{	// no room at bottom, rotate pivot upward
; 3063 : 			if (_Plast != _Gfirst)

	cmp	ebx, edx
	je	SHORT $LN240@Unguarded_

; 3064 : 				std::iter_swap(_Pfirst, _Plast);

	cmp	ecx, ebx
	je	SHORT $LN240@Unguarded_
	mov	esi, DWORD PTR [ebx]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [ebx], eax
$LN240@Unguarded_:

; 3065 : 			++_Plast;
; 3066 : 			std::iter_swap(_Pfirst++, _Gfirst++);

	mov	eax, edx
	mov	esi, ecx
	add	ebx, 4
	add	edx, 4
	add	ecx, 4
	cmp	esi, eax
	je	$LL23@Unguarded_
	mov	edi, DWORD PTR [esi]
	mov	DWORD PTR __Tmp$233069[esp+20], edi
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [esi], edi
	mov	esi, DWORD PTR __Tmp$233069[esp+20]
	mov	DWORD PTR [eax], esi
	jmp	$LL23@Unguarded_
$LN6@Unguarded_:

; 3067 : 			}
; 3068 : 		else if (_Gfirst == _Last)
; 3069 : 			{	// no room at top, rotate pivot downward
; 3070 : 			if (--_Glast != --_Pfirst)

	sub	ebp, 4
	cmp	edx, DWORD PTR __Last$[esp+16]
	jne	SHORT $LN3@Unguarded_
	sub	ecx, 4
	cmp	ebp, ecx
	je	SHORT $LN296@Unguarded_

; 3071 : 				std::iter_swap(_Glast, _Pfirst);

	mov	esi, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ebp]
	mov	DWORD PTR [ebp], esi
	mov	DWORD PTR [ecx], eax
$LN296@Unguarded_:

; 3072 : 			std::iter_swap(_Pfirst, --_Plast);

	sub	ebx, 4
	cmp	ecx, ebx
	je	$LL23@Unguarded_
	mov	esi, DWORD PTR [ebx]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [ebx], eax

; 3073 : 			}
; 3074 : 		else

	jmp	$LL23@Unguarded_
$LN3@Unguarded_:

; 3075 : 			std::iter_swap(_Gfirst++, --_Glast);

	mov	eax, edx
	add	edx, 4
	cmp	eax, ebp
	je	$LL23@Unguarded_
	mov	edi, DWORD PTR [ebp]
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [ebp], esi

; 3076 : 		}

	jmp	$LL23@Unguarded_
$LN347@Unguarded_:

; 3059 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+16]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax], ecx
	pop	ebx

; 3077 : 	}

	pop	ecx
	ret	0
??$_Unguarded_partition@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YA?AU?$pair@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@V12@@0@V?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z ENDP ; std::_Unguarded_partition<std::_Vector_iterator<int,std::allocator<int> > >
_TEXT	ENDS
PUBLIC	??$_Insertion_sort1@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAH@Z ; std::_Insertion_sort1<std::_Vector_iterator<int,std::allocator<int> >,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Insertion_sort1@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAH@Z
_TEXT	SEGMENT
$T233335 = -8						; size = 1
$T233273 = -4						; size = 4
__Cat$233339 = 8					; size = 1
$T233337 = 8						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Insertion_sort1@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAH@Z PROC ; std::_Insertion_sort1<std::_Vector_iterator<int,std::allocator<int> >,int>, COMDAT

; 2968 : 	if (_First != _Last)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Last$[esp-4]
	sub	esp, 8
	cmp	ecx, eax
	je	SHORT $LN6@Insertion_
	push	edi

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	lea	edi, DWORD PTR [ecx+4]
	cmp	edi, eax
	je	SHORT $LN69@Insertion_
	push	ebx
	mov	ebx, DWORD PTR __Cat$233339[esp+12]
	push	ebp
	mov	ebp, DWORD PTR $T233337[esp+16]
	push	esi
	jmp	SHORT $LN7@Insertion_
$LL68@Insertion_:
	mov	ecx, DWORD PTR __First$[esp+20]
$LN7@Insertion_:

; 2970 : 			{	// order next element
; 2971 : 			_BidIt _Next1 = _Next;
; 2972 : 			_Ty _Val = *_Next;

	mov	esi, DWORD PTR [edi]

; 2973 : 
; 2974 : 			if (_DEBUG_LT(_Val, *_First))

	cmp	esi, DWORD PTR [ecx]
	mov	edx, edi
	jge	SHORT $LN5@Insertion_

; 2975 : 				{	// found new earliest element, move to front
; 2976 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	mov	BYTE PTR $T233335[esp+24], 0
	mov	edx, DWORD PTR $T233335[esp+24]
	push	edx
	push	ebx
	push	ebp
	lea	eax, DWORD PTR [edi+4]
	push	eax
	push	edi
	push	ecx
	lea	eax, DWORD PTR $T233273[esp+48]
	push	eax
	call	??$_Copy_backward_opt@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@V12@Urandom_access_iterator_tag@2@@std@@YA?AV?$_Vector_iterator@HV?$allocator@H@std@@@0@V10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Vector_iterator<int,std::allocator<int> >,std::_Vector_iterator<int,std::allocator<int> >,std::random_access_iterator_tag>

; 2977 : 				*_First = _Val;

	mov	ecx, DWORD PTR __First$[esp+48]
	add	esp, 28					; 0000001cH
	mov	DWORD PTR [ecx], esi

; 2978 : 				}
; 2979 : 			else

	jmp	SHORT $LN4@Insertion_
$LN5@Insertion_:

; 2980 : 				{	// look for insertion point after first
; 2981 : 				for (_BidIt _First1 = _Next1;
; 2982 : 					_DEBUG_LT(_Val, *--_First1);
; 2983 : 					_Next1 = _First1)

	mov	ecx, DWORD PTR [edi-4]
	cmp	esi, ecx
	lea	eax, DWORD PTR [edi-4]
	jge	SHORT $LN1@Insertion_
$LL3@Insertion_:

; 2984 : 					*_Next1 = *_First1;	// move hole down

	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax-4]
	mov	edx, eax
	sub	eax, 4
	cmp	esi, ecx
	jl	SHORT $LL3@Insertion_
$LN1@Insertion_:

; 2985 : 				*_Next1 = _Val;	// insert element in hole

	mov	DWORD PTR [edx], esi
$LN4@Insertion_:

; 2969 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	add	edi, 4
	cmp	edi, DWORD PTR __Last$[esp+20]
	jne	SHORT $LL68@Insertion_
	pop	esi
	pop	ebp
	pop	ebx
$LN69@Insertion_:
	pop	edi
$LN6@Insertion_:

; 2986 : 				}
; 2987 : 			}
; 2988 : 	}

	add	esp, 8
	ret	0
??$_Insertion_sort1@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAH@Z ENDP ; std::_Insertion_sort1<std::_Vector_iterator<int,std::allocator<int> >,int>
_TEXT	ENDS
PUBLIC	??$_Adjust_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@HH@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@HHH@Z ; std::_Adjust_heap<std::_Vector_iterator<int,std::allocator<int> >,int,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Adjust_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@HH@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@HHH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 4
??$_Adjust_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@HH@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@HHH@Z PROC ; std::_Adjust_heap<std::_Vector_iterator<int,std::allocator<int> >,int,int>, COMDAT

; 2056 : 	_Diff _Top = _Hole;

	mov	ecx, DWORD PTR __Hole$[esp-4]
	push	esi

; 2057 : 	_Diff _Idx = 2 * _Hole + 2;
; 2058 : 
; 2059 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

	mov	esi, DWORD PTR __Bottom$[esp]
	lea	eax, DWORD PTR [ecx+ecx+2]
	cmp	eax, esi
	push	edi
	mov	edi, ecx
	jge	SHORT $LN70@Adjust_hea
	push	ebx
$LL5@Adjust_hea:
	mov	edx, DWORD PTR __First$[esp+8]

; 2060 : 		{	// move _Hole down to larger child
; 2061 : 		if (_DEBUG_LT(*(_First + _Idx), *(_First + (_Idx - 1))))

	mov	ebx, DWORD PTR [edx+eax*4]
	cmp	ebx, DWORD PTR [edx+eax*4-4]
	jge	SHORT $LN2@Adjust_hea

; 2062 : 			--_Idx;

	dec	eax
$LN2@Adjust_hea:

; 2063 : 		*(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;

	mov	ebx, DWORD PTR [edx+eax*4]
	mov	DWORD PTR [edx+ecx*4], ebx
	mov	ecx, eax
	lea	eax, DWORD PTR [eax+eax+2]
	cmp	eax, esi
	jl	SHORT $LL5@Adjust_hea
	pop	ebx
$LN70@Adjust_hea:

; 2064 : 		}
; 2065 : 
; 2066 : 	if (_Idx == _Bottom)

	jne	SHORT $LN1@Adjust_hea

; 2067 : 		{	// only child at bottom, move _Hole down to it
; 2068 : 		*(_First + _Hole) = *(_First + (_Bottom - 1));

	mov	eax, DWORD PTR __First$[esp+4]
	mov	edx, DWORD PTR [eax+esi*4-4]
	mov	DWORD PTR [eax+ecx*4], edx

; 2069 : 		_Hole = _Bottom - 1;

	lea	ecx, DWORD PTR [esi-1]
$LN1@Adjust_hea:

; 2070 : 		}
; 2071 : 	std::_Push_heap(_First, _Hole, _Top, _Val);

	mov	eax, DWORD PTR __Val$[esp+4]
	push	eax
	push	edi
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+16]
	push	ecx
	call	??$_Push_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@HH@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@HHH@Z ; std::_Push_heap<std::_Vector_iterator<int,std::allocator<int> >,int,int>
	add	esp, 16					; 00000010H
	pop	edi
	pop	esi

; 2072 : 	}

	ret	0
??$_Adjust_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@HH@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@HHH@Z ENDP ; std::_Adjust_heap<std::_Vector_iterator<int,std::allocator<int> >,int,int>
_TEXT	ENDS
PUBLIC	??$_Pop_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@HH@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@00HPAH@Z ; std::_Pop_heap<std::_Vector_iterator<int,std::allocator<int> >,int,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Pop_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@HH@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@00HPAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Val$ = 20						; size = 4
___formal$ = 24						; size = 4
??$_Pop_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@HH@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@00HPAH@Z PROC ; std::_Pop_heap<std::_Vector_iterator<int,std::allocator<int> >,int,int>, COMDAT

; 2080 : 	*_Dest = *_First;

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Dest$[esp-4]

; 2081 : 	std::_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First), _Val);

	mov	eax, DWORD PTR __Val$[esp-4]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR __Last$[esp-4]
	push	eax
	mov	eax, DWORD PTR __First$[esp]
	sub	ecx, eax
	sar	ecx, 2
	push	ecx
	push	0
	push	eax
	call	??$_Adjust_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@HH@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@HHH@Z ; std::_Adjust_heap<std::_Vector_iterator<int,std::allocator<int> >,int,int>
	add	esp, 16					; 00000010H

; 2082 : 	}

	ret	0
??$_Pop_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@HH@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@00HPAH@Z ENDP ; std::_Pop_heap<std::_Vector_iterator<int,std::allocator<int> >,int,int>
_TEXT	ENDS
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector@2:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >, COMDAT

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN13@unchecked_@4
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL15@unchecked_@4:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL15@unchecked_@4
	pop	esi
$LN13@unchecked_@4:

; 943  : 	}

	ret	0
??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z PROC ; std::vector<int,std::allocator<int> >::_Umove<int *>, COMDAT
; _this$ = ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN16@Umove
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN16@Umove:
	pop	edi
	mov	eax, esi
	pop	esi

; 1149 : 		}

	ret	12					; 0000000cH
??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ENDP ; std::vector<int,std::allocator<int> >::_Umove<int *>
_TEXT	ENDS
PUBLIC	??0CvTechXMLEntries@@QAE@XZ			; CvTechXMLEntries::CvTechXMLEntries
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtechclasses.cpp
;	COMDAT ??0CvTechXMLEntries@@QAE@XZ
_TEXT	SEGMENT
??0CvTechXMLEntries@@QAE@XZ PROC			; CvTechXMLEntries::CvTechXMLEntries, COMDAT
; _this$ = ecx

; 570  : {

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 571  : 
; 572  : }

	ret	0
??0CvTechXMLEntries@@QAE@XZ ENDP			; CvTechXMLEntries::CvTechXMLEntries
_TEXT	ENDS
PUBLIC	?DeleteArray@CvTechXMLEntries@@QAEXXZ		; CvTechXMLEntries::DeleteArray
; Function compile flags: /Ogtpy
;	COMDAT ?DeleteArray@CvTechXMLEntries@@QAEXXZ
_TEXT	SEGMENT
?DeleteArray@CvTechXMLEntries@@QAEXXZ PROC		; CvTechXMLEntries::DeleteArray, COMDAT
; _this$ = ecx

; 598  : {

	push	ebx
	mov	ebx, ecx
	push	esi

; 599  : 	for(std::vector<CvTechEntry*>::iterator it = m_paTechEntries.begin(); it != m_paTechEntries.end(); ++it)

	mov	esi, DWORD PTR [ebx+4]
	push	edi
	cmp	esi, DWORD PTR [ebx+8]
	je	SHORT $LN1@DeleteArra
	npad	3
$LL14@DeleteArra:

; 600  : 	{
; 601  : 		SAFE_DELETE(*it);

	mov	edi, DWORD PTR [esi]
	test	edi, edi
	je	SHORT $LN32@DeleteArra
	mov	ecx, edi
	call	??1CvTechEntry@@QAE@XZ			; CvTechEntry::~CvTechEntry
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN32@DeleteArra:
	mov	DWORD PTR [esi], 0
	add	esi, 4
	cmp	esi, DWORD PTR [ebx+8]
	jne	SHORT $LL14@DeleteArra
$LN1@DeleteArra:

; 602  : 	}
; 603  : 
; 604  : 	m_paTechEntries.clear();

	mov	ecx, DWORD PTR [ebx+8]
	mov	esi, DWORD PTR [ebx+4]
	cmp	esi, ecx
	je	SHORT $LN51@DeleteArra
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	edi, DWORD PTR [edx+esi]
	test	eax, eax
	jle	SHORT $LN76@DeleteArra
	push	edx
	push	ecx
	push	edx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN76@DeleteArra:
	mov	DWORD PTR [ebx+8], edi
$LN51@DeleteArra:
	pop	edi
	pop	esi
	pop	ebx

; 605  : }

	ret	0
?DeleteArray@CvTechXMLEntries@@QAEXXZ ENDP		; CvTechXMLEntries::DeleteArray
_TEXT	ENDS
PUBLIC	??$_Insertion_sort@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z ; std::_Insertion_sort<std::_Vector_iterator<int,std::allocator<int> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Insertion_sort@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Insertion_sort@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z PROC ; std::_Insertion_sort<std::_Vector_iterator<int,std::allocator<int> > >, COMDAT

; 2993 : 	std::_Insertion_sort1(_First, _Last, _Val_type(_First));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	0
	push	eax
	push	ecx
	call	??$_Insertion_sort1@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAH@Z ; std::_Insertion_sort1<std::_Vector_iterator<int,std::allocator<int> >,int>
	add	esp, 12					; 0000000cH

; 2994 : 	}

	ret	0
??$_Insertion_sort@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z ENDP ; std::_Insertion_sort<std::_Vector_iterator<int,std::allocator<int> > >
_TEXT	ENDS
PUBLIC	??$_Make_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@HH@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAH1@Z ; std::_Make_heap<std::_Vector_iterator<int,std::allocator<int> >,int,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Make_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@HH@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAH1@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
??$_Make_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@HH@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAH1@Z PROC ; std::_Make_heap<std::_Vector_iterator<int,std::allocator<int> >,int,int>, COMDAT

; 2165 : 	_Diff _Bottom = _Last - _First;

	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
	push	edi
	mov	edi, DWORD PTR __Last$[esp+4]
	sub	edi, ecx
	sar	edi, 2

; 2166 : 
; 2167 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

	mov	eax, edi
	cdq
	sub	eax, edx
	mov	esi, eax
	sar	esi, 1
	test	esi, esi
	jle	SHORT $LN1@Make_heap
	jmp	SHORT $LN2@Make_heap
	npad	2
$LL21@Make_heap:
	mov	ecx, DWORD PTR __First$[esp+4]
$LN2@Make_heap:

; 2168 : 		{	// reheap top half, bottom to top
; 2169 : 		--_Hole;
; 2170 : 		std::_Adjust_heap(_First, _Hole, _Bottom,
; 2171 : 			_Ty(*(_First + _Hole)));

	mov	eax, DWORD PTR [ecx+esi*4-4]
	dec	esi
	push	eax
	push	edi
	push	esi
	push	ecx
	call	??$_Adjust_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@HH@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@HHH@Z ; std::_Adjust_heap<std::_Vector_iterator<int,std::allocator<int> >,int,int>
	add	esp, 16					; 00000010H
	test	esi, esi
	jg	SHORT $LL21@Make_heap
$LN1@Make_heap:
	pop	edi
	pop	esi

; 2172 : 		}
; 2173 : 	}

	ret	0
??$_Make_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@HH@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAH1@Z ENDP ; std::_Make_heap<std::_Vector_iterator<int,std::allocator<int> >,int,int>
_TEXT	ENDS
PUBLIC	??$_Pop_heap_0@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAH@Z ; std::_Pop_heap_0<std::_Vector_iterator<int,std::allocator<int> >,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Pop_heap_0@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Pop_heap_0@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAH@Z PROC ; std::_Pop_heap_0<std::_Vector_iterator<int,std::allocator<int> >,int>, COMDAT

; 2088 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2089 : 		_Ty(*(_Last - 1)), _Dist_type(_First));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR [ecx-4]
	lea	eax, DWORD PTR [ecx-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	push	edx
	sub	eax, ecx
	sar	eax, 2
	push	eax
	push	0
	push	ecx
	call	??$_Adjust_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@HH@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@HHH@Z ; std::_Adjust_heap<std::_Vector_iterator<int,std::allocator<int> >,int,int>
	add	esp, 16					; 00000010H
	pop	esi

; 2090 : 	}

	ret	0
??$_Pop_heap_0@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAH@Z ENDP ; std::_Pop_heap_0<std::_Vector_iterator<int,std::allocator<int> >,int>
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z PROC ; std::vector<int,std::allocator<int> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	esi

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	esi, DWORD PTR __Count$[esp]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	mov	eax, esi
	mov	ecx, edi
	test	esi, esi
	jbe	SHORT $LN22@Ufill
	mov	edx, DWORD PTR __Val$[esp+4]
	push	ebx
$LL17@Ufill:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebx
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL17@Ufill
	pop	ebx
$LN22@Ufill:

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*4]
	pop	edi
	pop	esi

; 1256 : 		}

	ret	12					; 0000000cH
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
; Function compile flags: /Ogtpy
;	COMDAT ?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
_TEXT	SEGMENT
__Capacity$ = -4					; size = 4
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Tmp$215406 = 16					; size = 4
__Tmp$215396 = 16					; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z PROC ; std::vector<int,std::allocator<int> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ecx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	test	edx, edx
	jne	SHORT $LN29@Insert_n
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n
$LN29@Insert_n:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 2
	mov	ecx, eax
$LN30@Insert_n:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[esp+8]
	test	edi, edi
	je	$LN1@Insert_n
	push	ebx

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	eax, ebx
	sub	eax, edx
	sar	eax, 2
	mov	edx, 1073741823				; 3fffffffH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
$LN64@Insert_n:
$LN12@Insert_n:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	push	ebp
	cmp	ecx, edx
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 1073741823				; 3fffffffH
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR __Capacity$[esp+20], 0
	mov	ecx, DWORD PTR __Capacity$[esp+20]
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[esp+20], ecx
$LN18@Insert_n:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[esp+20], edx
	mov	ecx, edx
$LN9@Insert_n:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebx, DWORD PTR __Where$[esp+24]
	sub	ebx, DWORD PTR [esi+4]
	add	esp, 8
	mov	ebp, eax

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Val$[esp+16]
	push	eax
	sar	ebx, 2
	push	edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	mov	ecx, esi
	call	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Where$[esp+16]
	mov	eax, DWORD PTR [esi+4]
	push	ebp
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR __Where$[esp+16]
	add	ebx, edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);
; 1191 : 			_RERAISE;
; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 2
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN57@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN57@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[esp+20]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [ebp+edi*4]
	lea	eax, DWORD PTR [ebp+edx*4]

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], ebp
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], ecx
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	eax, DWORD PTR __Where$[esp+16]

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[esp+16]
	mov	edx, ebx
	sub	edx, eax
	sar	edx, 2
	cmp	edx, edi
	mov	edx, DWORD PTR [ecx]

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	ebp, DWORD PTR [edi*4]
	mov	DWORD PTR __Tmp$215396[esp+16], edx
	jae	SHORT $LN3@Insert_n
	lea	ecx, DWORD PTR [eax+ebp]
	push	ecx
	push	ebx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$215396[esp+16]
	sar	ecx, 2
	push	edx
	sub	edi, ecx
	push	edi
	push	eax
	mov	ecx, esi
	call	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	add	DWORD PTR [esi+8], ebp
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	eax, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$215396[esp+16]
	push	edx
	sub	esi, ebp
	push	esi
	push	eax
	call	??$fill@PAHH@std@@YAXPAH0ABH@Z		; std::fill<int *,int>
	add	esp, 12					; 0000000cH
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN3@Insert_n:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence
; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	push	ebx
	mov	edi, ebx
	push	ebx
	sub	edi, ebp
	push	edi
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	push	ebx
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Where$[esp+20]
	push	edi
	push	eax
	call	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[esp+28]
	lea	ecx, DWORD PTR __Tmp$215406[esp+28]
	push	ecx
	add	ebp, eax
	push	ebp
	push	eax
	call	??$fill@PAHH@std@@YAXPAH0ABH@Z		; std::fill<int *,int>
	add	esp, 24					; 00000018H
	pop	ebp
	pop	ebx
$LN1@Insert_n:
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN63@Insert_n:
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Insert_n
_TEXT	ENDS
PUBLIC	??1CvTechXMLEntries@@QAE@XZ			; CvTechXMLEntries::~CvTechXMLEntries
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??1CvTechXMLEntries@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvTechXMLEntries@@QAE@XZ$0
__ehfuncinfo$??1CvTechXMLEntries@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CvTechXMLEntries@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtechclasses.cpp
xdata$x	ENDS
;	COMDAT ??1CvTechXMLEntries@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvTechXMLEntries@@QAE@XZ PROC			; CvTechXMLEntries::~CvTechXMLEntries, COMDAT
; _this$ = ecx

; 576  : {

	push	-1
	push	__ehhandler$??1CvTechXMLEntries@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+24], esi
	xor	edi, edi
	mov	DWORD PTR __$EHRec$[esp+32], edi

; 577  : 	DeleteArray();

	call	?DeleteArray@CvTechXMLEntries@@QAEXXZ	; CvTechXMLEntries::DeleteArray

; 578  : }

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, edi
	je	SHORT $LN9@CvTechXMLE
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN9@CvTechXMLE:
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi+12], edi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvTechXMLEntries@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$vector@PAVCvTechEntry@@V?$allocator@PAVCvTechEntry@@@std@@@std@@QAE@XZ ; std::vector<CvTechEntry *,std::allocator<CvTechEntry *> >::~vector<CvTechEntry *,std::allocator<CvTechEntry *> >
__ehhandler$??1CvTechXMLEntries@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvTechXMLEntries@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvTechXMLEntries@@QAE@XZ ENDP			; CvTechXMLEntries::~CvTechXMLEntries
PUBLIC	??$make_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z ; std::make_heap<std::_Vector_iterator<int,std::allocator<int> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$make_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$make_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z PROC ; std::make_heap<std::_Vector_iterator<int,std::allocator<int> > >, COMDAT

; 2178 : 	_DEBUG_RANGE(_First, _Last);
; 2179 : 	if (1 < _Last - _First)

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, eax
	sub	edx, ecx
	and	edx, -4					; fffffffcH
	cmp	edx, 4
	jle	SHORT $LN1@make_heap

; 2180 : 		_Make_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last),
; 2181 : 			_Dist_type(_First), _Val_type(_First));

	push	0
	push	0
	push	eax
	push	ecx
	call	??$_Make_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@HH@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAH1@Z ; std::_Make_heap<std::_Vector_iterator<int,std::allocator<int> >,int,int>
	add	esp, 16					; 00000010H
$LN1@make_heap:

; 2182 : 	}

	ret	0
??$make_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z ENDP ; std::make_heap<std::_Vector_iterator<int,std::allocator<int> > >
_TEXT	ENDS
PUBLIC	??$pop_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z ; std::pop_heap<std::_Vector_iterator<int,std::allocator<int> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$pop_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$pop_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z PROC ; std::pop_heap<std::_Vector_iterator<int,std::allocator<int> > >, COMDAT

; 2095 : 	_DEBUG_RANGE(_First, _Last);
; 2096 : 	_DEBUG_HEAP(_First, _Last);
; 2097 : 	if (1 < _Last - _First)

	mov	edx, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	eax, edx
	sub	eax, ecx
	and	eax, -4					; fffffffcH
	cmp	eax, 4
	jle	SHORT $LN42@pop_heap
	push	esi

; 2098 : 		_Pop_heap_0(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val_type(_First));

	mov	esi, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx-4]
	mov	edx, DWORD PTR [edx-4]
	mov	DWORD PTR [eax], esi
	push	edx
	sub	eax, ecx
	sar	eax, 2
	push	eax
	push	0
	push	ecx
	call	??$_Adjust_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@HH@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@HHH@Z ; std::_Adjust_heap<std::_Vector_iterator<int,std::allocator<int> >,int,int>
	add	esp, 16					; 00000010H
	pop	esi
$LN42@pop_heap:

; 2099 : 	}

	ret	0
??$pop_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z ENDP ; std::pop_heap<std::_Vector_iterator<int,std::allocator<int> > >
_TEXT	ENDS
PUBLIC	?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ; std::vector<int,std::allocator<int> >::insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z PROC ; std::vector<int,std::allocator<int> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	esi
	push	edi
	mov	edi, ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
	test	ecx, -4					; fffffffcH
	mov	ecx, DWORD PTR __Where$[esp+4]
	jne	SHORT $LN3@insert
	xor	esi, esi
	jmp	SHORT $LN4@insert
$LN3@insert:
	mov	esi, ecx
	sub	esi, eax
	sar	esi, 2
$LN4@insert:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[esp+4]
	push	edx
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax+esi*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ENDP ; std::vector<int,std::allocator<int> >::insert
_TEXT	ENDS
PUBLIC	??$_Sort_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z ; std::_Sort_heap<std::_Vector_iterator<int,std::allocator<int> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Sort_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Sort_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z PROC ; std::_Sort_heap<std::_Vector_iterator<int,std::allocator<int> > >, COMDAT

; 2215 : 	_DEBUG_RANGE(_First, _Last);
; 2216 : 	_DEBUG_HEAP(_First, _Last);
; 2217 : 	for (; 1 < _Last - _First; --_Last)

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, ecx
	sub	eax, edx
	sar	eax, 2
	cmp	eax, 1
	jle	SHORT $LN1@Sort_heap
	push	esi
$LN72@Sort_heap:

; 2218 : 		std::pop_heap(_First, _Last);

	mov	esi, DWORD PTR [edx]
	lea	eax, DWORD PTR [ecx-4]
	mov	ecx, DWORD PTR [ecx-4]
	mov	DWORD PTR [eax], esi
	push	ecx
	sub	eax, edx
	sar	eax, 2
	push	eax
	push	0
	push	edx
	call	??$_Adjust_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@HH@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@HHH@Z ; std::_Adjust_heap<std::_Vector_iterator<int,std::allocator<int> >,int,int>
	mov	ecx, DWORD PTR __Last$[esp+16]
	mov	edx, DWORD PTR __First$[esp+16]
	sub	ecx, 4
	mov	eax, ecx
	sub	eax, edx
	sar	eax, 2
	add	esp, 16					; 00000010H
	cmp	eax, 1
	mov	DWORD PTR __Last$[esp], ecx
	jg	SHORT $LN72@Sort_heap
	pop	esi
$LN1@Sort_heap:

; 2219 : 	}

	ret	0
??$_Sort_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z ENDP ; std::_Sort_heap<std::_Vector_iterator<int,std::allocator<int> > >
_TEXT	ENDS
PUBLIC	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z PROC ; std::vector<int,std::allocator<int> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	esi

; 810  : 		if (size() < capacity())

	mov	esi, DWORD PTR [ecx+4]
	push	edi
	test	esi, esi
	jne	SHORT $LN9@push_back
	xor	eax, eax
	jmp	SHORT $LN10@push_back
$LN9@push_back:
	mov	eax, DWORD PTR [ecx+12]
	sub	eax, esi
	sar	eax, 2
$LN10@push_back:
	mov	edx, DWORD PTR [ecx+8]
	mov	edi, edx
	sub	edi, esi
	sar	edi, 2
	cmp	edi, eax

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR __Val$[esp+4]
	pop	edi
	pop	esi
	jae	SHORT $LN2@push_back
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	add	edx, 4
	mov	DWORD PTR [ecx+8], edx

; 824  : 		}

	ret	4
$LN2@push_back:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	push	eax
	push	1
	push	edx
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n

; 824  : 		}

	ret	4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::vector<int,std::allocator<int> >::push_back
_TEXT	ENDS
PUBLIC	??$sort_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z ; std::sort_heap<std::_Vector_iterator<int,std::allocator<int> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$sort_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z PROC ; std::sort_heap<std::_Vector_iterator<int,std::allocator<int> > >, COMDAT

; 2224 : 	_DEBUG_HEAP(_First, _Last);
; 2225 : 	_Sort_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	eax
	push	ecx
	call	??$_Sort_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z ; std::_Sort_heap<std::_Vector_iterator<int,std::allocator<int> > >
	add	esp, 8

; 2226 : 	}

	ret	0
??$sort_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z ENDP ; std::sort_heap<std::_Vector_iterator<int,std::allocator<int> > >
_TEXT	ENDS
PUBLIC	??$_Sort@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0H@Z ; std::_Sort<std::_Vector_iterator<int,std::allocator<int> >,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Sort@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0H@Z
_TEXT	SEGMENT
__Mid$225996 = -8					; size = 8
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
??$_Sort@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0H@Z PROC ; std::_Sort<std::_Vector_iterator<int,std::allocator<int> >,int>, COMDAT

; 3083 : 	_Diff _Count;
; 3084 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	esp, 8
	push	ebx
	mov	eax, ecx
	sub	eax, edx
	push	ebp
	sar	eax, 2
	cmp	eax, 32					; 00000020H
	push	esi
	push	edi
	jle	$LN3@Sort
	mov	esi, DWORD PTR __Ideal$[esp+20]
$LL7@Sort:
	test	esi, esi
	jle	$LN6@Sort

; 3085 : 		{	// divide and conquer by quicksort
; 3086 : 		pair<_RanIt, _RanIt> _Mid =
; 3087 : 			std::_Unguarded_partition(_First, _Last);

	push	ecx
	push	edx
	lea	eax, DWORD PTR __Mid$225996[esp+32]
	push	eax
	call	??$_Unguarded_partition@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YA?AU?$pair@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@V12@@0@V?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z ; std::_Unguarded_partition<std::_Vector_iterator<int,std::allocator<int> > >

; 3088 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions
; 3089 : 
; 3090 : 		if (_Mid.first - _First < _Last - _Mid.second)

	mov	ebx, DWORD PTR __Mid$225996[esp+36]
	mov	edi, DWORD PTR __Mid$225996[esp+40]
	mov	ecx, DWORD PTR __First$[esp+32]
	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	cdq
	sub	eax, edx
	sar	eax, 1
	add	esi, eax
	mov	eax, DWORD PTR __Last$[esp+32]
	mov	edx, eax
	mov	ebp, ebx
	sub	edx, edi
	sub	ebp, ecx
	add	esp, 12					; 0000000cH
	and	edx, -4					; fffffffcH
	and	ebp, -4					; fffffffcH
	cmp	ebp, edx

; 3091 : 			{	// loop on second half
; 3092 : 			std::_Sort(_First, _Mid.first, _Ideal);

	push	esi
	jge	SHORT $LN5@Sort
	push	ebx
	push	ecx
	call	??$_Sort@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0H@Z ; std::_Sort<std::_Vector_iterator<int,std::allocator<int> >,int>

; 3093 : 			_First = _Mid.second;
; 3094 : 			}
; 3095 : 		else

	mov	ecx, DWORD PTR __Last$[esp+32]
	mov	edx, edi
	mov	DWORD PTR __First$[esp+32], edx
	jmp	SHORT $LN41@Sort
$LN5@Sort:

; 3096 : 			{	// loop on first half
; 3097 : 			std::_Sort(_Mid.second, _Last, _Ideal);

	push	eax
	push	edi
	call	??$_Sort@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0H@Z ; std::_Sort<std::_Vector_iterator<int,std::allocator<int> >,int>

; 3098 : 			_Last = _Mid.first;

	mov	edx, DWORD PTR __First$[esp+32]
	mov	ecx, ebx
	mov	DWORD PTR __Last$[esp+32], ecx
$LN41@Sort:
	mov	eax, ecx
	sub	eax, edx
	sar	eax, 2
	add	esp, 12					; 0000000cH
	cmp	eax, 32					; 00000020H
	jg	SHORT $LL7@Sort
$LN3@Sort:

; 3106 : 		}
; 3107 : 	else if (1 < _Count)

	cmp	eax, 1
	jle	SHORT $LN35@Sort

; 3108 : 		std::_Insertion_sort(_First, _Last);	// small

	push	0
	push	ecx
	push	edx
	call	??$_Insertion_sort1@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAH@Z ; std::_Insertion_sort1<std::_Vector_iterator<int,std::allocator<int> >,int>
	add	esp, 12					; 0000000cH
$LN35@Sort:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3109 : 	}

	add	esp, 8
	ret	0
$LN6@Sort:

; 3099 : 			}
; 3100 : 		}
; 3101 : 
; 3102 : 	if (_ISORT_MAX < _Count)

	cmp	eax, 32					; 00000020H
	jle	SHORT $LN3@Sort

; 3103 : 		{	// heap sort if too many divisions
; 3104 : 		std::make_heap(_First, _Last);

	mov	eax, ecx
	sub	eax, edx
	and	eax, -4					; fffffffcH
	cmp	eax, 4
	jle	SHORT $LN22@Sort
	push	0
	push	0
	push	ecx
	push	edx
	call	??$_Make_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@HH@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0PAH1@Z ; std::_Make_heap<std::_Vector_iterator<int,std::allocator<int> >,int,int>
	mov	ecx, DWORD PTR __Last$[esp+36]
	mov	edx, DWORD PTR __First$[esp+36]
	add	esp, 16					; 00000010H
$LN22@Sort:

; 3105 : 		std::sort_heap(_First, _Last);

	push	ecx
	push	edx
	call	??$_Sort_heap@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z ; std::_Sort_heap<std::_Vector_iterator<int,std::allocator<int> > >
	add	esp, 8
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 3109 : 	}

	add	esp, 8
	ret	0
??$_Sort@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0H@Z ENDP ; std::_Sort<std::_Vector_iterator<int,std::allocator<int> >,int>
_TEXT	ENDS
PUBLIC	??$sort@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z ; std::sort<std::_Vector_iterator<int,std::allocator<int> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$sort@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z PROC ; std::sort<std::_Vector_iterator<int,std::allocator<int> > >, COMDAT

; 3114 : 	_DEBUG_RANGE(_First, _Last);
; 3115 : 	std::_Sort(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, eax
	sub	edx, ecx
	sar	edx, 2
	push	edx
	push	eax
	push	ecx
	call	??$_Sort@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0H@Z ; std::_Sort<std::_Vector_iterator<int,std::allocator<int> >,int>
	add	esp, 12					; 0000000cH

; 3116 : 	}

	ret	0
??$sort@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z ENDP ; std::sort<std::_Vector_iterator<int,std::allocator<int> > >
_TEXT	ENDS
PUBLIC	?GetMedianTechResearch@CvPlayerTechs@@QBEHXZ	; CvPlayerTechs::GetMedianTechResearch
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$?GetMedianTechResearch@CvPlayerTechs@@QBEHXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetMedianTechResearch@CvPlayerTechs@@QBEHXZ$0
__ehfuncinfo$?GetMedianTechResearch@CvPlayerTechs@@QBEHXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetMedianTechResearch@CvPlayerTechs@@QBEHXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvtechclasses.cpp
xdata$x	ENDS
;	COMDAT ?GetMedianTechResearch@CvPlayerTechs@@QBEHXZ
_TEXT	SEGMENT
_iRtnValue$ = -36					; size = 4
$T235498 = -32						; size = 4
_aiTechCosts$ = -28					; size = 16
__$EHRec$ = -12						; size = 12
?GetMedianTechResearch@CvPlayerTechs@@QBEHXZ PROC	; CvPlayerTechs::GetMedianTechResearch, COMDAT
; _this$ = ecx

; 1599 : {

	push	-1
	push	__ehhandler$?GetMedianTechResearch@CvPlayerTechs@@QBEHXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 24					; 00000018H
	push	ebx
	push	ebp
	push	esi

; 1600 : 	vector<int> aiTechCosts;

	xor	esi, esi
	xor	ebx, ebx
	push	edi
	mov	ebp, ecx
	mov	DWORD PTR _aiTechCosts$[esp+56], esi
	mov	DWORD PTR _aiTechCosts$[esp+60], ebx
	mov	DWORD PTR _aiTechCosts$[esp+64], esi

; 1601 : 	int iRtnValue = 0;
; 1602 : 
; 1603 : #ifdef AUI_WARNING_FIXES
; 1604 : 	for (uint iTechLoop = 0; iTechLoop < GC.getNumTechInfos(); iTechLoop++)
; 1605 : #else
; 1606 : 	for(int iTechLoop = 0; iTechLoop < GC.getNumTechInfos(); iTechLoop++)

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	mov	DWORD PTR __$EHRec$[esp+60], esi
	mov	DWORD PTR _iRtnValue$[esp+52], esi
	xor	edi, edi
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	test	eax, eax
	jle	SHORT $LN5@GetMedianT
$LL7@GetMedianT:

; 1607 : #endif
; 1608 : 	{
; 1609 : 		TechTypes eTech = (TechTypes)iTechLoop;
; 1610 : 
; 1611 : 		if(CanResearch(eTech))

	push	0
	push	edi
	mov	ecx, ebp
	call	?CanResearch@CvPlayerTechs@@QBE_NW4TechTypes@@_N@Z ; CvPlayerTechs::CanResearch
	test	al, al
	je	SHORT $LN6@GetMedianT

; 1612 : 		{
; 1613 : 			aiTechCosts.push_back(GetResearchCost(eTech));

	push	edi
	mov	ecx, ebp
	call	?GetResearchCost@CvPlayerTechs@@QBEHW4TechTypes@@@Z ; CvPlayerTechs::GetResearchCost
	mov	DWORD PTR $T235498[esp+52], eax
	test	esi, esi
	jne	SHORT $LN56@GetMedianT
	xor	ecx, ecx
	jmp	SHORT $LN57@GetMedianT
$LN56@GetMedianT:
	mov	ecx, DWORD PTR _aiTechCosts$[esp+64]
	sub	ecx, esi
	sar	ecx, 2
$LN57@GetMedianT:
	mov	edx, ebx
	sub	edx, esi
	sar	edx, 2
	cmp	edx, ecx
	jae	SHORT $LN49@GetMedianT
	mov	DWORD PTR [ebx], eax
	add	ebx, 4
	mov	DWORD PTR _aiTechCosts$[esp+60], ebx
	jmp	SHORT $LN6@GetMedianT
$LN49@GetMedianT:
	lea	eax, DWORD PTR $T235498[esp+52]
	push	eax
	push	1
	push	ebx
	lea	ecx, DWORD PTR _aiTechCosts$[esp+64]
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
	mov	ebx, DWORD PTR _aiTechCosts$[esp+60]
	mov	esi, DWORD PTR _aiTechCosts$[esp+56]
$LN6@GetMedianT:
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	inc	edi
	call	?getNumTechInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumTechInfos
	cmp	edi, eax
	jl	SHORT $LL7@GetMedianT
$LN5@GetMedianT:

; 1614 : 		}
; 1615 : 	}
; 1616 : 
; 1617 : 	int iNumEntries = aiTechCosts.size();

	mov	edi, ebx
	sub	edi, esi
	sar	edi, 2

; 1618 : 	if(iNumEntries > 0)

	test	edi, edi
	jle	SHORT $LN147@GetMedianT

; 1619 : 	{
; 1620 : 		std::sort(aiTechCosts.begin(), aiTechCosts.end());

	push	edi
	push	ebx
	push	esi
	call	??$_Sort@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@H@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0H@Z ; std::_Sort<std::_Vector_iterator<int,std::allocator<int> >,int>

; 1621 : 
; 1622 : 		// Odd number, take middle?
; 1623 : 		if((iNumEntries / 2) * 2 != iNumEntries)

	mov	eax, edi
	cdq
	sub	eax, edx
	mov	ecx, eax
	sar	ecx, 1
	lea	edx, DWORD PTR [ecx+ecx]
	add	esp, 12					; 0000000cH
	cmp	edx, edi
	je	SHORT $LN2@GetMedianT

; 1624 : 		{
; 1625 : 			iRtnValue = aiTechCosts[iNumEntries / 2];

	mov	edi, DWORD PTR [esi+ecx*4]

; 1626 : 		}
; 1627 : 
; 1628 : 		// Even number, average middle 2
; 1629 : 		else

	jmp	SHORT $LN1@GetMedianT
$LN2@GetMedianT:

; 1630 : 		{
; 1631 : 			iRtnValue = (aiTechCosts[(iNumEntries - 1) / 2] + aiTechCosts[iNumEntries / 2]) / 2;

	lea	eax, DWORD PTR [edi-1]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	eax, DWORD PTR [esi+eax*4]
	add	eax, DWORD PTR [esi+ecx*4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _iRtnValue$[esp+52], eax
$LN147@GetMedianT:
	mov	edi, DWORD PTR _iRtnValue$[esp+52]
$LN1@GetMedianT:

; 1632 : 		}
; 1633 : 	}
; 1634 : 
; 1635 : 	return iRtnValue;

	test	esi, esi
	je	SHORT $LN146@GetMedianT
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN146@GetMedianT:

; 1636 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+52]
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 36					; 00000024H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetMedianTechResearch@CvPlayerTechs@@QBEHXZ$0:
	lea	ecx, DWORD PTR _aiTechCosts$[ebp]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__ehhandler$?GetMedianTechResearch@CvPlayerTechs@@QBEHXZ:
	mov	eax, OFFSET __ehfuncinfo$?GetMedianTechResearch@CvPlayerTechs@@QBEHXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetMedianTechResearch@CvPlayerTechs@@QBEHXZ ENDP	; CvPlayerTechs::GetMedianTechResearch
END
