; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	s:\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvPopupReturn.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int> >::operator[]
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z PROC	; std::vector<int,std::allocator<int> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 786  : 		}

	ret	4
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ENDP	; std::vector<int,std::allocator<int> >::operator[]
_TEXT	ENDS
PUBLIC	?size@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEIXZ ; std::vector<CvString,std::allocator<CvString> >::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEIXZ PROC ; std::vector<CvString,std::allocator<CvString> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	esi

; 726  : 		return (_Mylast - _Myfirst);

	mov	esi, DWORD PTR [ecx+8]
	sub	esi, DWORD PTR [ecx+4]
	mov	eax, -1840700269			; 92492493H
	imul	esi
	add	edx, esi
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	pop	esi

; 727  : 		}

	ret	0
?size@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvString,std::allocator<CvString> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEABVCvString@@I@Z ; std::vector<CvString,std::allocator<CvString> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEABVCvString@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEABVCvString@@I@Z PROC ; std::vector<CvString,std::allocator<CvString> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [eax+edx*4]

; 771  : 		}

	ret	4
??A?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEABVCvString@@I@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::operator[]
_TEXT	ENDS
PUBLIC	??A?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEAAVCvString@@I@Z ; std::vector<CvString,std::allocator<CvString> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEAAVCvString@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEAAVCvString@@I@Z PROC ; std::vector<CvString,std::allocator<CvString> >::operator[], COMDAT
; _this$ = ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR __Pos$[esp-4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [eax+edx*4]

; 786  : 		}

	ret	4
??A?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEAAVCvString@@I@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::operator[]
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvString@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvString> >::~_Container_base_aux_alloc_empty<std::allocator<CvString> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvString@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvString@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvString> >::~_Container_base_aux_alloc_empty<std::allocator<CvString> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@VCvString@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvString> >::~_Container_base_aux_alloc_empty<std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	??0?$allocator@VCvString@@@std@@QAE@XZ		; std::allocator<CvString>::allocator<CvString>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??0?$allocator@VCvString@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@VCvString@@@std@@QAE@XZ PROC		; std::allocator<CvString>::allocator<CvString>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@VCvString@@@std@@QAE@XZ ENDP		; std::allocator<CvString>::allocator<CvString>
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File s:\msvs2008\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	esi
	lea	eax, DWORD PTR __Message$[esp]
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[esp-4]

; 60   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 64   : 	}

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvString@@@std@@@std@@IAE@V?$allocator@VCvString@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvString> >::_Container_base_aux_alloc_empty<std::allocator<CvString> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvString@@@std@@@std@@IAE@V?$allocator@VCvString@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvString@@@std@@@std@@IAE@V?$allocator@VCvString@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvString> >::_Container_base_aux_alloc_empty<std::allocator<CvString> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@VCvString@@@std@@@std@@IAE@V?$allocator@VCvString@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvString> >::_Container_base_aux_alloc_empty<std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	??0?$allocator@VCvString@@@std@@QAE@ABV01@@Z	; std::allocator<CvString>::allocator<CvString>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??0?$allocator@VCvString@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@VCvString@@@std@@QAE@ABV01@@Z PROC	; std::allocator<CvString>::allocator<CvString>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@VCvString@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<CvString>::allocator<CvString>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@VCvString@@@std@@QAEXPAVCvString@@I@Z ; std::allocator<CvString>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@VCvString@@@std@@QAEXPAVCvString@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@VCvString@@@std@@QAEXPAVCvString@@I@Z PROC ; std::allocator<CvString>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@VCvString@@@std@@QAEXPAVCvString@@I@Z ENDP ; std::allocator<CvString>::deallocate
_TEXT	ENDS
PUBLIC	?capacity@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEIXZ ; std::vector<CvString,std::allocator<CvString> >::capacity
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?capacity@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEIXZ PROC ; std::vector<CvString,std::allocator<CvString> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jne	SHORT $LN3@capacity

; 636  : 		}

	ret	0
$LN3@capacity:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	ecx, DWORD PTR [ecx+12]
	sub	ecx, eax
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 636  : 		}

	ret	0
?capacity@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvString,std::allocator<CvString> >::capacity
_TEXT	ENDS
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
; File s:\msvs2008\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	eax, DWORD PTR __Message$[esp+16]
	push	eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	?max_size@?$allocator@VCvString@@@std@@QBEIXZ	; std::allocator<CvString>::max_size
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@VCvString@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@VCvString@@@std@@QBEIXZ PROC	; std::allocator<CvString>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 153391689				; 09249249H

; 167  : 		}

	ret	0
?max_size@?$allocator@VCvString@@@std@@QBEIXZ ENDP	; std::allocator<CvString>::max_size
_TEXT	ENDS
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\stdexcept
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 31   : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
_TEXT	ENDS
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 35   : 		return (_Str.c_str());

	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@PAVCvString@@@Z ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::_Vector_const_iterator<CvString,std::allocator<CvString> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@PAVCvString@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@PAVCvString@@@Z PROC ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::_Vector_const_iterator<CvString,std::allocator<CvString> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@PAVCvString@@@Z ENDP ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::_Vector_const_iterator<CvString,std::allocator<CvString> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	add	edx, edx
	add	edx, edx
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator+=
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator==
_TEXT	ENDS
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
; File s:\msvs2008\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@VCvString@@@std@@YAPAVCvString@@IPAV1@@Z ; std::_Allocate<CvString>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File s:\msvs2008\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@VCvString@@@std@@YAPAVCvString@@IPAV1@@Z
_TEXT	SEGMENT
$T218600 = -12						; size = 12
$T218605 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@VCvString@@@std@@YAPAVCvString@@IPAV1@@Z PROC ; std::_Allocate<CvString>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	add	edx, edx
	add	edx, edx
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 28					; 0000001cH
	jae	SHORT $LN1@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T218605[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T218600[esp+16]
	mov	DWORD PTR $T218605[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T218600[esp+16]
	push	ecx
	mov	DWORD PTR $T218600[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate:
$LN8@Allocate:
	int	3
??$_Allocate@VCvString@@@std@@YAPAVCvString@@IPAV1@@Z ENDP ; std::_Allocate<CvString>
_TEXT	ENDS
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\stdexcept
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 110  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@3:
	mov	eax, esi
	pop	esi
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAVCvString@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvString@@0@Z ; std::_Iter_random<CvString *,CvString *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Iter_random@PAVCvString@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvString@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAVCvString@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvString@@0@Z PROC ; std::_Iter_random<CvString *,CvString *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAVCvString@@PAV1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVCvString@@0@Z ENDP ; std::_Iter_random<CvString *,CvString *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAVCvString@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvString@@0@Z ; std::_Ptr_cat<CvString *,CvString *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAVCvString@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvString@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVCvString@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvString@@0@Z PROC ; std::_Ptr_cat<CvString *,CvString *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAVCvString@@PAV1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVCvString@@0@Z ENDP ; std::_Ptr_cat<CvString *,CvString *>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAVCvString@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvString@@@Z ; std::_Move_cat<CvString *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAVCvString@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvString@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAVCvString@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvString@@@Z PROC ; std::_Move_cat<CvString *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAVCvString@@@std@@YA?AU_Undefined_move_tag@0@ABQAVCvString@@@Z ENDP ; std::_Move_cat<CvString *>
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@XZ				; CvString::CvString
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredllutil\include\cvstring.h
;	COMDAT ??0CvString@@QAE@XZ
_TEXT	SEGMENT
??0CvString@@QAE@XZ PROC				; CvString::CvString, COMDAT
; _this$ = ecx

; 23   : 	CvString() {}

	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, esi
	pop	esi
	ret	0
??0CvString@@QAE@XZ ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	??1CvString@@QAE@XZ				; CvString::~CvString
; Function compile flags: /Ogtpy
;	COMDAT ??1CvString@@QAE@XZ
_TEXT	SEGMENT
??1CvString@@QAE@XZ PROC				; CvString::~CvString, COMDAT
; _this$ = ecx

; 28   : 	~CvString() {}

	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??1CvString@@QAE@XZ ENDP				; CvString::~CvString
_TEXT	ENDS
PUBLIC	??BCvString@@QBEPBDXZ				; CvString::operator char const *
; Function compile flags: /Ogtpy
;	COMDAT ??BCvString@@QBEPBDXZ
_TEXT	SEGMENT
??BCvString@@QBEPBDXZ PROC				; CvString::operator char const *, COMDAT
; _this$ = ecx

; 31   : 	operator const char*() const 	{ return c_str(); }												

	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
??BCvString@@QBEPBDXZ ENDP				; CvString::operator char const *
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@PBD@Z			; CvString::operator=
EXTRN	__imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@PBD@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
??4CvString@@QAEAAV0@PBD@Z PROC				; CvString::operator=, COMDAT
; _this$ = ecx

; 37   : 	CvString& operator=( const char* s) { if (s) assign(s); else clear();	return *this; }	

	mov	eax, DWORD PTR _s$[esp-4]
	push	esi
	mov	esi, ecx
	test	eax, eax
	je	SHORT $LN2@operator
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	mov	eax, esi
	pop	esi
	ret	4
$LN2@operator:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@PBD@Z ENDP				; CvString::operator=
_TEXT	ENDS
PUBLIC	??4CvString@@QAEAAV0@ABV0@@Z			; CvString::operator=
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??4CvString@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4CvString@@QAEAAV0@ABV0@@Z PROC			; CvString::operator=, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??4CvString@@QAEAAV0@ABV0@@Z ENDP			; CvString::operator=
_TEXT	ENDS
PUBLIC	??0CvString@@QAE@ABV0@@Z			; CvString::CvString
; Function compile flags: /Ogtpy
;	COMDAT ??0CvString@@QAE@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0CvString@@QAE@ABV0@@Z PROC				; CvString::CvString, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, esi
	pop	esi
	ret	4
??0CvString@@QAE@ABV0@@Z ENDP				; CvString::CvString
_TEXT	ENDS
PUBLIC	?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC	; std::vector<int,std::allocator<int> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP	; std::vector<int,std::allocator<int> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@HV?$allocator@H@std@@@std@@QBEABHI@Z ; std::vector<int,std::allocator<int> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@HV?$allocator@H@std@@@std@@QBEABHI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@HV?$allocator@H@std@@@std@@QBEABHI@Z PROC	; std::vector<int,std::allocator<int> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@HV?$allocator@H@std@@@std@@QBEABHI@Z ENDP	; std::vector<int,std::allocator<int> >::operator[]
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::~_Container_base_aux_alloc_empty<std::allocator<int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::~_Container_base_aux_alloc_empty<std::allocator<int> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::~_Container_base_aux_alloc_empty<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$allocator@H@std@@QAE@XZ			; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??0?$allocator@H@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@H@std@@QAE@XZ PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@H@std@@QAE@XZ ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
; File s:\msvs2008\vc\include\stdexcept
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T218675 = -80						; size = 28
$T218674 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ PROC	; std::vector<int,std::allocator<int> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T218675[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T218674[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T218675[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T218674[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T218674[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T218674[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T218674[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen:
$LN12@Xlen:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T218675[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T218674[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ENDP	; std::vector<int,std::allocator<int> >::_Xlen
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+20]
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	add	edi, 12					; 0000000cH
	push	edi
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
; Function compile flags: /Ogtpy
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::_Container_base_aux_alloc_empty<std::allocator<int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::_Container_base_aux_alloc_empty<std::allocator<int> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<int> >::_Container_base_aux_alloc_empty<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$allocator@H@std@@QAE@ABV01@@Z		; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??0?$allocator@H@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@H@std@@QAE@ABV01@@Z PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@H@std@@QAE@ABV01@@Z ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@H@std@@QAEXPAHI@Z	; std::allocator<int>::deallocate
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXPAHI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@H@std@@QAEXPAHI@Z PROC		; std::allocator<int>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@H@std@@QAEXPAHI@Z ENDP		; std::allocator<int>::deallocate
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@H@std@@QBEIXZ		; std::allocator<int>::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$allocator@H@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@H@std@@QBEIXZ PROC		; std::allocator<int>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@H@std@@QBEIXZ ENDP		; std::allocator<int>::max_size
_TEXT	ENDS
PUBLIC	??$?6H@FDataStream@@QAEAAV0@ABH@Z		; FDataStream::operator<<<int>
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6H@FDataStream@@QAEAAV0@ABH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6H@FDataStream@@QAEAAV0@ABH@Z PROC			; FDataStream::operator<<<int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6H@FDataStream@@QAEAAV0@ABH@Z ENDP			; FDataStream::operator<<<int>
_TEXT	ENDS
PUBLIC	??$?5H@FDataStream@@QAEAAV0@AAH@Z		; FDataStream::operator>><int>
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5H@FDataStream@@QAEAAV0@AAH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5H@FDataStream@@QAEAAV0@AAH@Z PROC			; FDataStream::operator>><int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5H@FDataStream@@QAEAAV0@AAH@Z ENDP			; FDataStream::operator>><int>
_TEXT	ENDS
PUBLIC	??$_Allocate@H@std@@YAPAHIPAH@Z			; std::_Allocate<int>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$_Allocate@H@std@@YAPAHIPAH@Z
_TEXT	SEGMENT
$T218734 = -12						; size = 12
$T218738 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@H@std@@YAPAHIPAH@Z PROC			; std::_Allocate<int>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN1@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T218738[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T218734[esp+16]
	mov	DWORD PTR $T218738[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T218734[esp+16]
	push	ecx
	mov	DWORD PTR $T218734[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate@2:
$LN8@Allocate@2:
	int	3
??$_Allocate@H@std@@YAPAHIPAH@Z ENDP			; std::_Allocate<int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator==
_TEXT	ENDS
PUBLIC	??$?5VCvString@@@FDataStream@@QAEAAV0@AAVCvString@@@Z ; FDataStream::operator>><CvString>
EXTRN	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; FDataStream::Read
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5VCvString@@@FDataStream@@QAEAAV0@AAVCvString@@@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5VCvString@@@FDataStream@@QAEAAV0@AAVCvString@@@Z PROC ; FDataStream::operator>><CvString>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5VCvString@@@FDataStream@@QAEAAV0@AAVCvString@@@Z ENDP ; FDataStream::operator>><CvString>
_TEXT	ENDS
PUBLIC	??$?6VCvString@@@FDataStream@@QAEAAV0@ABVCvString@@@Z ; FDataStream::operator<<<CvString>
EXTRN	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6VCvString@@@FDataStream@@QAEAAV0@ABVCvString@@@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6VCvString@@@FDataStream@@QAEAAV0@ABVCvString@@@Z PROC ; FDataStream::operator<<<CvString>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6VCvString@@@FDataStream@@QAEAAV0@ABVCvString@@@Z ENDP ; FDataStream::operator<<<CvString>
_TEXT	ENDS
PUBLIC	??$?5I@FDataStream@@QAEAAV0@AAI@Z		; FDataStream::operator>><unsigned int>
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5I@FDataStream@@QAEAAV0@AAI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5I@FDataStream@@QAEAAV0@AAI@Z PROC			; FDataStream::operator>><unsigned int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5I@FDataStream@@QAEAAV0@AAI@Z ENDP			; FDataStream::operator>><unsigned int>
_TEXT	ENDS
PUBLIC	??$?6I@FDataStream@@QAEAAV0@ABI@Z		; FDataStream::operator<<<unsigned int>
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6I@FDataStream@@QAEAAV0@ABI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6I@FDataStream@@QAEAAV0@ABI@Z PROC			; FDataStream::operator<<<unsigned int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6I@FDataStream@@QAEAAV0@ABI@Z ENDP			; FDataStream::operator<<<unsigned int>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z ; std::_Ptr_cat<int *,int *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z PROC ; std::_Ptr_cat<int *,int *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z ENDP ; std::_Ptr_cat<int *,int *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z ; std::_Iter_random<int *,int *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z PROC ; std::_Iter_random<int *,int *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z ENDP ; std::_Iter_random<int *,int *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<int *,int *,std::random_access_iterator_tag>
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<int *,int *,std::random_access_iterator_tag>, COMDAT

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 2505 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_opt

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_opt:
	pop	edi

; 2507 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2508 : 	}

	ret	0
??$_Copy_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<int *,int *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::capacity
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity@2
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@2:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::capacity
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=
_TEXT	ENDS
PUBLIC	??$_Fill@PAHH@std@@YAXPAH0ABH@Z			; std::_Fill<int *,int>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Fill@PAHH@std@@YAXPAH0ABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAHH@std@@YAXPAH0ABH@Z PROC			; std::_Fill<int *,int>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@Fill
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL3@Fill
	pop	esi
$LN1@Fill:

; 3160 : 	}

	ret	0
??$_Fill@PAHH@std@@YAXPAH0ABH@Z ENDP			; std::_Fill<int *,int>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z ; std::_Move_cat<int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z PROC ; std::_Move_cat<int *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z ENDP ; std::_Move_cat<int *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>, COMDAT

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi

; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;

	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx

; 2711 : 	if (_Off > 0)

	test	eax, eax
	jle	SHORT $LN4@Copy_backw

; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Copy_backw:

; 2713 : 	return _Result;

	mov	eax, esi
	pop	esi

; 2714 : 	}

	ret	0
??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z ; std::_Iter_cat<int *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z PROC ; std::_Iter_cat<int *>, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z ENDP ; std::_Iter_cat<int *>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<int *,unsigned int,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<int *,unsigned int,int>, COMDAT

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	mov	eax, DWORD PTR __Count$[esp-4]
	test	eax, eax
	jbe	SHORT $LN1@Fill_n
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
$LL3@Fill_n:

; 3198 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL3@Fill_n
	pop	esi
$LN1@Fill_n:

; 3199 : 	}

	ret	0
??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<int *,unsigned int,int>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<int *,int *,std::allocator<int> >, COMDAT

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]

; 150  : 	if (_Count > 0)

	test	eax, eax
	jbe	SHORT $LN4@Uninit_cop

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN4@Uninit_cop:
	pop	edi

; 152  : 	return (_Result);

	mov	eax, esi
	pop	esi

; 153  : 	}

	ret	0
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?getSelectedRadioButton@PopupReturn@@QBEHH@Z	; PopupReturn::getSelectedRadioButton
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvpopupreturn.h
;	COMDAT ?getSelectedRadioButton@PopupReturn@@QBEHH@Z
_TEXT	SEGMENT
_iGroup$ = 8						; size = 4
?getSelectedRadioButton@PopupReturn@@QBEHH@Z PROC	; PopupReturn::getSelectedRadioButton, COMDAT
; _this$ = ecx

; 49   : 		return m_aiSelectedRadioButton[iGroup];

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _iGroup$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 50   : 	}

	ret	4
?getSelectedRadioButton@PopupReturn@@QBEHH@Z ENDP	; PopupReturn::getSelectedRadioButton
_TEXT	ENDS
PUBLIC	?getRadioButtonSize@PopupReturn@@QBEHXZ		; PopupReturn::getRadioButtonSize
; Function compile flags: /Ogtpy
;	COMDAT ?getRadioButtonSize@PopupReturn@@QBEHXZ
_TEXT	SEGMENT
?getRadioButtonSize@PopupReturn@@QBEHXZ PROC		; PopupReturn::getRadioButtonSize, COMDAT
; _this$ = ecx

; 55   : 		return m_aiSelectedRadioButton.size();

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 56   : 	}

	ret	0
?getRadioButtonSize@PopupReturn@@QBEHXZ ENDP		; PopupReturn::getRadioButtonSize
_TEXT	ENDS
PUBLIC	?getCheckboxBitfield@PopupReturn@@QBEHH@Z	; PopupReturn::getCheckboxBitfield
; Function compile flags: /Ogtpy
;	COMDAT ?getCheckboxBitfield@PopupReturn@@QBEHH@Z
_TEXT	SEGMENT
_iGroup$ = 8						; size = 4
?getCheckboxBitfield@PopupReturn@@QBEHH@Z PROC		; PopupReturn::getCheckboxBitfield, COMDAT
; _this$ = ecx

; 68   : 		return m_aiBitField[iGroup];

	mov	eax, DWORD PTR [ecx+20]
	mov	ecx, DWORD PTR _iGroup$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 69   : 	}

	ret	4
?getCheckboxBitfield@PopupReturn@@QBEHH@Z ENDP		; PopupReturn::getCheckboxBitfield
_TEXT	ENDS
PUBLIC	?getCheckboxSize@PopupReturn@@QBEHXZ		; PopupReturn::getCheckboxSize
; Function compile flags: /Ogtpy
;	COMDAT ?getCheckboxSize@PopupReturn@@QBEHXZ
_TEXT	SEGMENT
?getCheckboxSize@PopupReturn@@QBEHXZ PROC		; PopupReturn::getCheckboxSize, COMDAT
; _this$ = ecx

; 74   : 		return m_aiBitField.size();

	mov	eax, DWORD PTR [ecx+24]
	sub	eax, DWORD PTR [ecx+20]
	sar	eax, 2

; 75   : 	}

	ret	0
?getCheckboxSize@PopupReturn@@QBEHXZ ENDP		; PopupReturn::getCheckboxSize
_TEXT	ENDS
PUBLIC	?getEditBoxString@PopupReturn@@QBEPBDH@Z	; PopupReturn::getEditBoxString
; Function compile flags: /Ogtpy
;	COMDAT ?getEditBoxString@PopupReturn@@QBEPBDH@Z
_TEXT	SEGMENT
_iGroup$ = 8						; size = 4
?getEditBoxString@PopupReturn@@QBEPBDH@Z PROC		; PopupReturn::getEditBoxString, COMDAT
; _this$ = ecx

; 90   : 	{

	push	esi

; 91   : //		return ((uint)iGroup<m_aszEditBoxString.size()) ? m_aszEditBoxString[iGroup] : NULL;
; 92   : 		if((uint)iGroup<m_aszEditBoxString.size())

	mov	esi, DWORD PTR [ecx+40]
	sub	esi, DWORD PTR [ecx+36]
	mov	eax, -1840700269			; 92492493H
	imul	esi
	mov	eax, DWORD PTR _iGroup$[esp]
	add	edx, esi
	sar	edx, 4
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	cmp	eax, esi
	pop	esi
	jae	SHORT $LN1@getEditBox

; 93   : 			return m_aszEditBoxString[iGroup];

	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx+36]
	lea	ecx, DWORD PTR [eax+edx*4]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 95   : 	}

	ret	4
$LN1@getEditBox:

; 94   : 		return NULL;

	xor	eax, eax

; 95   : 	}

	ret	4
?getEditBoxString@PopupReturn@@QBEPBDH@Z ENDP		; PopupReturn::getEditBoxString
_TEXT	ENDS
PUBLIC	?getEditboxSize@PopupReturn@@QBEHXZ		; PopupReturn::getEditboxSize
; Function compile flags: /Ogtpy
;	COMDAT ?getEditboxSize@PopupReturn@@QBEHXZ
_TEXT	SEGMENT
?getEditboxSize@PopupReturn@@QBEHXZ PROC		; PopupReturn::getEditboxSize, COMDAT
; _this$ = ecx

; 99   : 	{

	push	esi

; 100  : 		return m_aszEditBoxString.size();

	mov	esi, DWORD PTR [ecx+40]
	sub	esi, DWORD PTR [ecx+36]
	mov	eax, -1840700269			; 92492493H
	imul	esi
	add	edx, esi
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	pop	esi

; 101  : 	}

	ret	0
?getEditboxSize@PopupReturn@@QBEHXZ ENDP		; PopupReturn::getEditboxSize
_TEXT	ENDS
PUBLIC	?getSpinnerWidgetValue@PopupReturn@@QBEHH@Z	; PopupReturn::getSpinnerWidgetValue
; Function compile flags: /Ogtpy
;	COMDAT ?getSpinnerWidgetValue@PopupReturn@@QBEHH@Z
_TEXT	SEGMENT
_iGroup$ = 8						; size = 4
?getSpinnerWidgetValue@PopupReturn@@QBEHH@Z PROC	; PopupReturn::getSpinnerWidgetValue, COMDAT
; _this$ = ecx

; 113  : 		return ((uint)iGroup<m_aiSpinBoxID.size()) ? m_aiSpinBoxID[iGroup] : -1;

	mov	edx, DWORD PTR [ecx+120]
	sub	edx, DWORD PTR [ecx+116]
	mov	eax, DWORD PTR _iGroup$[esp-4]
	sar	edx, 2
	cmp	eax, edx
	jae	SHORT $LN3@getSpinner
	mov	ecx, DWORD PTR [ecx+116]
	mov	eax, DWORD PTR [ecx+eax*4]

; 114  : 	}

	ret	4
$LN3@getSpinner:

; 113  : 		return ((uint)iGroup<m_aiSpinBoxID.size()) ? m_aiSpinBoxID[iGroup] : -1;

	or	eax, -1

; 114  : 	}

	ret	4
?getSpinnerWidgetValue@PopupReturn@@QBEHH@Z ENDP	; PopupReturn::getSpinnerWidgetValue
_TEXT	ENDS
PUBLIC	?getSpinnerWidsize@PopupReturn@@QBEHXZ		; PopupReturn::getSpinnerWidsize
; Function compile flags: /Ogtpy
;	COMDAT ?getSpinnerWidsize@PopupReturn@@QBEHXZ
_TEXT	SEGMENT
?getSpinnerWidsize@PopupReturn@@QBEHXZ PROC		; PopupReturn::getSpinnerWidsize, COMDAT
; _this$ = ecx

; 119  : 		return m_aiSpinnerWidgetValues.size();

	mov	eax, DWORD PTR [ecx+56]
	sub	eax, DWORD PTR [ecx+52]
	sar	eax, 2

; 120  : 	}

	ret	0
?getSpinnerWidsize@PopupReturn@@QBEHXZ ENDP		; PopupReturn::getSpinnerWidsize
_TEXT	ENDS
PUBLIC	?getSelectedPullDownValue@PopupReturn@@QBEHH@Z	; PopupReturn::getSelectedPullDownValue
; Function compile flags: /Ogtpy
;	COMDAT ?getSelectedPullDownValue@PopupReturn@@QBEHH@Z
_TEXT	SEGMENT
_iGroup$ = 8						; size = 4
?getSelectedPullDownValue@PopupReturn@@QBEHH@Z PROC	; PopupReturn::getSelectedPullDownValue, COMDAT
; _this$ = ecx

; 131  : 		return m_aiPulldownID[iGroup];

	mov	eax, DWORD PTR [ecx+68]
	mov	ecx, DWORD PTR _iGroup$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 132  : 	}

	ret	4
?getSelectedPullDownValue@PopupReturn@@QBEHH@Z ENDP	; PopupReturn::getSelectedPullDownValue
_TEXT	ENDS
PUBLIC	?getPulldownSize@PopupReturn@@QBEHXZ		; PopupReturn::getPulldownSize
; Function compile flags: /Ogtpy
;	COMDAT ?getPulldownSize@PopupReturn@@QBEHXZ
_TEXT	SEGMENT
?getPulldownSize@PopupReturn@@QBEHXZ PROC		; PopupReturn::getPulldownSize, COMDAT
; _this$ = ecx

; 137  : 		return m_aiPulldownID.size();

	mov	eax, DWORD PTR [ecx+72]
	sub	eax, DWORD PTR [ecx+68]
	sar	eax, 2

; 138  : 	}

	ret	0
?getPulldownSize@PopupReturn@@QBEHXZ ENDP		; PopupReturn::getPulldownSize
_TEXT	ENDS
PUBLIC	?getSelectedListBoxValue@PopupReturn@@QBEHH@Z	; PopupReturn::getSelectedListBoxValue
; Function compile flags: /Ogtpy
;	COMDAT ?getSelectedListBoxValue@PopupReturn@@QBEHH@Z
_TEXT	SEGMENT
_iGroup$ = 8						; size = 4
?getSelectedListBoxValue@PopupReturn@@QBEHH@Z PROC	; PopupReturn::getSelectedListBoxValue, COMDAT
; _this$ = ecx

; 149  : 		return ((uint)iGroup<m_aiListBoxID.size()) ? m_aiListBoxID[iGroup] : -1;

	mov	edx, DWORD PTR [ecx+88]
	sub	edx, DWORD PTR [ecx+84]
	mov	eax, DWORD PTR _iGroup$[esp-4]
	sar	edx, 2
	cmp	eax, edx
	jae	SHORT $LN3@getSelecte
	mov	ecx, DWORD PTR [ecx+84]
	mov	eax, DWORD PTR [ecx+eax*4]

; 150  : 	}

	ret	4
$LN3@getSelecte:

; 149  : 		return ((uint)iGroup<m_aiListBoxID.size()) ? m_aiListBoxID[iGroup] : -1;

	or	eax, -1

; 150  : 	}

	ret	4
?getSelectedListBoxValue@PopupReturn@@QBEHH@Z ENDP	; PopupReturn::getSelectedListBoxValue
_TEXT	ENDS
PUBLIC	?getListBoxSize@PopupReturn@@QBEHXZ		; PopupReturn::getListBoxSize
; Function compile flags: /Ogtpy
;	COMDAT ?getListBoxSize@PopupReturn@@QBEHXZ
_TEXT	SEGMENT
?getListBoxSize@PopupReturn@@QBEHXZ PROC		; PopupReturn::getListBoxSize, COMDAT
; _this$ = ecx

; 155  : 		return m_aiListBoxID.size();

	mov	eax, DWORD PTR [ecx+88]
	sub	eax, DWORD PTR [ecx+84]
	sar	eax, 2

; 156  : 	}

	ret	0
?getListBoxSize@PopupReturn@@QBEHXZ ENDP		; PopupReturn::getListBoxSize
_TEXT	ENDS
PUBLIC	?getSpinBoxSize@PopupReturn@@QBEHXZ		; PopupReturn::getSpinBoxSize
; Function compile flags: /Ogtpy
;	COMDAT ?getSpinBoxSize@PopupReturn@@QBEHXZ
_TEXT	SEGMENT
?getSpinBoxSize@PopupReturn@@QBEHXZ PROC		; PopupReturn::getSpinBoxSize, COMDAT
; _this$ = ecx

; 173  : 		return m_aiSpinBoxID.size();

	mov	eax, DWORD PTR [ecx+120]
	sub	eax, DWORD PTR [ecx+116]
	sar	eax, 2

; 174  : 	}

	ret	0
?getSpinBoxSize@PopupReturn@@QBEHXZ ENDP		; PopupReturn::getSpinBoxSize
_TEXT	ENDS
PUBLIC	?GetButtonClicked@PopupReturn@@QBEHH@Z		; PopupReturn::GetButtonClicked
; Function compile flags: /Ogtpy
;	COMDAT ?GetButtonClicked@PopupReturn@@QBEHH@Z
_TEXT	SEGMENT
_iGroup$ = 8						; size = 4
?GetButtonClicked@PopupReturn@@QBEHH@Z PROC		; PopupReturn::GetButtonClicked, COMDAT
; _this$ = ecx

; 185  : 		return m_aiButtonID[iGroup];

	mov	eax, DWORD PTR [ecx+100]
	mov	ecx, DWORD PTR _iGroup$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 186  : 	}

	ret	4
?GetButtonClicked@PopupReturn@@QBEHH@Z ENDP		; PopupReturn::GetButtonClicked
_TEXT	ENDS
PUBLIC	?GetButtonSize@PopupReturn@@QBEHXZ		; PopupReturn::GetButtonSize
; Function compile flags: /Ogtpy
;	COMDAT ?GetButtonSize@PopupReturn@@QBEHXZ
_TEXT	SEGMENT
?GetButtonSize@PopupReturn@@QBEHXZ PROC			; PopupReturn::GetButtonSize, COMDAT
; _this$ = ecx

; 191  : 		return m_aiButtonID.size();

	mov	eax, DWORD PTR [ecx+104]
	sub	eax, DWORD PTR [ecx+100]
	sar	eax, 2

; 192  : 	}

	ret	0
?GetButtonSize@PopupReturn@@QBEHXZ ENDP			; PopupReturn::GetButtonSize
_TEXT	ENDS
PUBLIC	?write@PopupReturn@@QBEXAAVFDataStream@@@Z	; PopupReturn::write
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvpopupreturn.cpp
;	COMDAT ?write@PopupReturn@@QBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
$T218935 = 8						; size = 4
$T218934 = 8						; size = 4
$T218933 = 8						; size = 4
$T218932 = 8						; size = 4
$T218931 = 8						; size = 4
$T218930 = 8						; size = 4
$T218929 = 8						; size = 4
$T218928 = 8						; size = 4
_kStream$ = 8						; size = 4
?write@PopupReturn@@QBEXAAVFDataStream@@@Z PROC		; PopupReturn::write, COMDAT
; _this$ = ecx

; 186  : {

	push	ecx
	push	ebx
	push	esi
	push	edi

; 187  : 	// Current version number
; 188  : 	uint uiVersion = 1;
; 189  : 	kStream << uiVersion;

	mov	edi, DWORD PTR _kStream$[esp+12]
	lea	eax, DWORD PTR _uiVersion$[esp+16]
	mov	esi, ecx
	push	eax
	mov	ecx, edi
	mov	DWORD PTR _uiVersion$[esp+20], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 190  : 
; 191  : 	unsigned int iI;
; 192  : 	//char szString[1024];
; 193  : 
; 194  : 	kStream <<  m_aiSelectedRadioButton.size() ;

	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, DWORD PTR [esi+4]
	lea	edx, DWORD PTR $T218928[esp+12]
	sar	ecx, 2
	mov	DWORD PTR $T218928[esp+12], ecx
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 195  : 	for(iI = 0; iI < m_aiSelectedRadioButton.size(); iI++)

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 2
	xor	ebx, ebx
	test	ecx, ecx
	jbe	SHORT $LN22@write
$LL24@write:
	lea	edx, DWORD PTR [eax+ebx*4]

; 196  : 	{
; 197  : 		kStream <<  m_aiSelectedRadioButton[iI] ;

	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	inc	ebx
	sar	ecx, 2
	cmp	ebx, ecx
	jb	SHORT $LL24@write
$LN22@write:

; 198  : 	}
; 199  : 
; 200  : 	kStream <<  m_aiBitField.size() ;

	mov	edx, DWORD PTR [esi+24]
	sub	edx, DWORD PTR [esi+20]
	lea	eax, DWORD PTR $T218929[esp+12]
	sar	edx, 2
	push	eax
	mov	ecx, edi
	mov	DWORD PTR $T218929[esp+16], edx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 201  : 	for(iI = 0; iI < m_aiBitField.size(); iI++)

	mov	ecx, DWORD PTR [esi+24]
	sub	ecx, DWORD PTR [esi+20]
	xor	ebx, ebx
	sar	ecx, 2
	test	ecx, ecx
	jbe	SHORT $LN19@write
	npad	5
$LL21@write:
	mov	edx, DWORD PTR [esi+20]
	lea	eax, DWORD PTR [edx+ebx*4]

; 202  : 	{
; 203  : 		kStream <<  m_aiBitField[iI] ;

	push	eax
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	mov	ecx, DWORD PTR [esi+24]
	sub	ecx, DWORD PTR [esi+20]
	inc	ebx
	sar	ecx, 2
	cmp	ebx, ecx
	jb	SHORT $LL21@write
$LN19@write:

; 204  : 	}
; 205  : 
; 206  : 	kStream <<  m_aszEditBoxString.size() ;

	mov	ecx, DWORD PTR [esi+40]
	sub	ecx, DWORD PTR [esi+36]
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	lea	ecx, DWORD PTR $T218930[esp+12]
	add	eax, edx
	push	ecx
	mov	ecx, edi
	mov	DWORD PTR $T218930[esp+16], eax
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 207  : 	for(iI = 0; iI < m_aszEditBoxString.size(); iI++)

	mov	ecx, DWORD PTR [esi+40]
	sub	ecx, DWORD PTR [esi+36]
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	xor	ebx, ebx
	add	eax, edx
	je	SHORT $LN16@write
	push	ebp
	xor	ebp, ebp
$LL18@write:

; 208  : 	{
; 209  : 		kStream <<  m_aszEditBoxString[iI] ;

	mov	ecx, DWORD PTR [esi+36]
	add	ecx, ebp
	push	ecx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Write
	mov	ecx, DWORD PTR [esi+40]
	sub	ecx, DWORD PTR [esi+36]
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	inc	ebx
	add	eax, edx
	add	ebp, 28					; 0000001cH
	cmp	ebx, eax
	jb	SHORT $LL18@write
	pop	ebp
$LN16@write:

; 210  : 	}
; 211  : 
; 212  : 	kStream <<  m_aiSpinnerWidgetValues.size() ;

	mov	ecx, DWORD PTR [esi+56]
	sub	ecx, DWORD PTR [esi+52]
	lea	edx, DWORD PTR $T218931[esp+12]
	sar	ecx, 2
	mov	DWORD PTR $T218931[esp+12], ecx
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 213  : 	for(iI = 0; iI < m_aiSpinnerWidgetValues.size(); iI++)

	mov	eax, DWORD PTR [esi+56]
	sub	eax, DWORD PTR [esi+52]
	xor	ebx, ebx
	sar	eax, 2
	test	eax, eax
	jbe	SHORT $LN125@write
	npad	4
$LL15@write:
	mov	ecx, DWORD PTR [esi+52]
	lea	edx, DWORD PTR [ecx+ebx*4]

; 214  : 	{
; 215  : 		kStream <<  m_aiSpinnerWidgetValues[iI] ;

	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	mov	eax, DWORD PTR [esi+56]
	sub	eax, DWORD PTR [esi+52]
	inc	ebx
	sar	eax, 2
	cmp	ebx, eax
	jb	SHORT $LL15@write
$LN125@write:

; 216  : 	}
; 217  : 
; 218  : 	kStream <<  m_aiPulldownID.size() ;

	mov	ecx, DWORD PTR [esi+72]
	sub	ecx, DWORD PTR [esi+68]
	lea	edx, DWORD PTR $T218932[esp+12]
	sar	ecx, 2
	mov	DWORD PTR $T218932[esp+12], ecx
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 219  : 	for(iI = 0; iI < m_aiPulldownID.size(); iI++)

	mov	eax, DWORD PTR [esi+72]
	sub	eax, DWORD PTR [esi+68]
	xor	ebx, ebx
	sar	eax, 2
	test	eax, eax
	jbe	SHORT $LN126@write
$LL12@write:
	mov	ecx, DWORD PTR [esi+68]
	lea	edx, DWORD PTR [ecx+ebx*4]

; 220  : 	{
; 221  : 		kStream <<  m_aiPulldownID[iI] ;

	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	mov	eax, DWORD PTR [esi+72]
	sub	eax, DWORD PTR [esi+68]
	inc	ebx
	sar	eax, 2
	cmp	ebx, eax
	jb	SHORT $LL12@write
$LN126@write:

; 222  : 	}
; 223  : 
; 224  : 	kStream <<  m_aiListBoxID.size() ;

	mov	ecx, DWORD PTR [esi+88]
	sub	ecx, DWORD PTR [esi+84]
	lea	edx, DWORD PTR $T218933[esp+12]
	sar	ecx, 2
	mov	DWORD PTR $T218933[esp+12], ecx
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 225  : 	for(iI = 0; iI < m_aiListBoxID.size(); iI++)

	mov	eax, DWORD PTR [esi+88]
	sub	eax, DWORD PTR [esi+84]
	xor	ebx, ebx
	sar	eax, 2
	test	eax, eax
	jbe	SHORT $LN127@write
$LL9@write:
	mov	ecx, DWORD PTR [esi+84]
	lea	edx, DWORD PTR [ecx+ebx*4]

; 226  : 	{
; 227  : 		kStream <<  m_aiListBoxID[iI] ;

	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	mov	eax, DWORD PTR [esi+88]
	sub	eax, DWORD PTR [esi+84]
	inc	ebx
	sar	eax, 2
	cmp	ebx, eax
	jb	SHORT $LL9@write
$LN127@write:

; 228  : 	}
; 229  : 
; 230  : 	kStream <<  m_aiSpinBoxID.size() ;

	mov	ecx, DWORD PTR [esi+120]
	sub	ecx, DWORD PTR [esi+116]
	lea	edx, DWORD PTR $T218934[esp+12]
	sar	ecx, 2
	mov	DWORD PTR $T218934[esp+12], ecx
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 231  : 	for(iI = 0; iI < m_aiSpinBoxID.size(); iI++)

	mov	eax, DWORD PTR [esi+120]
	sub	eax, DWORD PTR [esi+116]
	xor	ebx, ebx
	sar	eax, 2
	test	eax, eax
	jbe	SHORT $LN128@write
	npad	4
$LL6@write:
	mov	ecx, DWORD PTR [esi+116]
	lea	edx, DWORD PTR [ecx+ebx*4]

; 232  : 	{
; 233  : 		kStream <<  m_aiSpinBoxID[iI] ;

	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	mov	eax, DWORD PTR [esi+120]
	sub	eax, DWORD PTR [esi+116]
	inc	ebx
	sar	eax, 2
	cmp	ebx, eax
	jb	SHORT $LL6@write
$LN128@write:

; 234  : 	}
; 235  : 
; 236  : 	kStream <<  m_aiButtonID.size() ;

	mov	ecx, DWORD PTR [esi+104]
	sub	ecx, DWORD PTR [esi+100]
	lea	edx, DWORD PTR $T218935[esp+12]
	sar	ecx, 2
	mov	DWORD PTR $T218935[esp+12], ecx
	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 237  : 	for(iI = 0; iI < m_aiButtonID.size(); iI++)

	mov	eax, DWORD PTR [esi+104]
	sub	eax, DWORD PTR [esi+100]
	xor	ebx, ebx
	sar	eax, 2
	test	eax, eax
	jbe	SHORT $LN1@write
$LL3@write:
	mov	ecx, DWORD PTR [esi+100]
	lea	edx, DWORD PTR [ecx+ebx*4]

; 238  : 	{
; 239  : 		kStream <<  m_aiButtonID[iI] ;

	push	edx
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	mov	eax, DWORD PTR [esi+104]
	sub	eax, DWORD PTR [esi+100]
	inc	ebx
	sar	eax, 2
	cmp	ebx, eax
	jb	SHORT $LL3@write
$LN1@write:
	pop	edi
	pop	esi
	pop	ebx

; 240  : 	}
; 241  : }

	pop	ecx
	ret	4
?write@PopupReturn@@QBEXAAVFDataStream@@@Z ENDP		; PopupReturn::write
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvString,std::allocator<CvString> >::~_Vector_val<CvString,std::allocator<CvString> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvString,std::allocator<CvString> >::~_Vector_val<CvString,std::allocator<CvString> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvString,std::allocator<CvString> >::~_Vector_val<CvString,std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAE@V?$allocator@VCvString@@@1@@Z ; std::_Vector_val<CvString,std::allocator<CvString> >::_Vector_val<CvString,std::allocator<CvString> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAE@V?$allocator@VCvString@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAE@V?$allocator@VCvString@@@1@@Z PROC ; std::_Vector_val<CvString,std::allocator<CvString> >::_Vector_val<CvString,std::allocator<CvString> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAE@V?$allocator@VCvString@@@1@@Z ENDP ; std::_Vector_val<CvString,std::allocator<CvString> >::_Vector_val<CvString,std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	?max_size@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEIXZ ; std::vector<CvString,std::allocator<CvString> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEIXZ PROC ; std::vector<CvString,std::allocator<CvString> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 153391689				; 09249249H

; 732  : 		}

	ret	0
?max_size@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvString,std::allocator<CvString> >::max_size
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ ; std::vector<CvString,std::allocator<CvString> >::_Xlen
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T219137 = -80						; size = 28
$T219136 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ PROC ; std::vector<CvString,std::allocator<CvString> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T219137[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T219136[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T219137[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T219136[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T219136[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T219136[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T219136[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen@2:
$LN12@Xlen@2:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T219137[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T219136[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ ENDP ; std::vector<CvString,std::allocator<CvString> >::_Xlen
PUBLIC	?allocate@?$allocator@VCvString@@@std@@QAEPAVCvString@@I@Z ; std::allocator<CvString>::allocate
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@VCvString@@@std@@QAEPAVCvString@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@VCvString@@@std@@QAEPAVCvString@@I@Z PROC ; std::allocator<CvString>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@VCvString@@@std@@YAPAVCvString@@IPAV1@@Z ; std::_Allocate<CvString>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@VCvString@@@std@@QAEPAVCvString@@I@Z ENDP ; std::allocator<CvString>::allocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@PAVCvString@@@Z ; std::_Vector_iterator<CvString,std::allocator<CvString> >::_Vector_iterator<CvString,std::allocator<CvString> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@PAVCvString@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@PAVCvString@@@Z PROC ; std::_Vector_iterator<CvString,std::allocator<CvString> >::_Vector_iterator<CvString,std::allocator<CvString> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@PAVCvString@@@Z ENDP ; std::_Vector_iterator<CvString,std::allocator<CvString> >::_Vector_iterator<CvString,std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<CvString,std::allocator<CvString> >::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??Y?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<CvString,std::allocator<CvString> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*8]
	sub	edx, ecx
	add	edx, edx
	add	edx, edx
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<CvString,std::allocator<CvString> >::operator+=
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvString,std::allocator<CvString> >::operator!=
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAVCvString@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvString@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvString *,CvString *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Copy_opt@PAVCvString@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvString@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAVCvString@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvString@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvString *,CvString *,std::random_access_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebx

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ebx, DWORD PTR __Last$[esp]
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]
	cmp	esi, ebx
	je	SHORT $LN10@Copy_opt@2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+8]
$LL3@Copy_opt@2:

; 2472 : 		*_Dest = *_First;

	push	esi
	mov	ecx, edi
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	add	esi, 28					; 0000001cH
	add	edi, 28					; 0000001cH
	cmp	esi, ebx
	jne	SHORT $LL3@Copy_opt@2

; 2473 : 	return (_Dest);

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 2474 : 	}

	ret	0
$LN10@Copy_opt@2:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[esp+4]
	pop	esi
	pop	ebx

; 2474 : 	}

	ret	0
??$_Copy_opt@PAVCvString@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvString@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvString *,CvString *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Fill@PAVCvString@@V1@@std@@YAXPAVCvString@@0ABV1@@Z ; std::_Fill<CvString *,CvString>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill@PAVCvString@@V1@@std@@YAXPAVCvString@@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAVCvString@@V1@@std@@YAXPAVCvString@@0ABV1@@Z PROC ; std::_Fill<CvString *,CvString>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	esi

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	esi, DWORD PTR __First$[esp]
	push	edi
	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	esi, edi
	je	SHORT $LN1@Fill@2
	push	ebx
	mov	ebx, DWORD PTR __Val$[esp+8]
$LL3@Fill@2:

; 3159 : 		*_First = _Val;

	push	ebx
	mov	ecx, esi
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $LL3@Fill@2
	pop	ebx
$LN1@Fill@2:
	pop	edi
	pop	esi

; 3160 : 	}

	ret	0
??$_Fill@PAVCvString@@V1@@std@@YAXPAVCvString@@0ABV1@@Z ENDP ; std::_Fill<CvString *,CvString>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAVCvString@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvString@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvString *,CvString *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_backward_opt@PAVCvString@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvString@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAVCvString@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvString@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvString *,CvString *,std::random_access_iterator_tag>, COMDAT

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebx

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	ebx, DWORD PTR __First$[esp]
	push	esi
	mov	esi, DWORD PTR __Last$[esp+4]
	cmp	ebx, esi
	je	SHORT $LN9@Copy_backw@2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+8]
$LL2@Copy_backw@2:

; 2676 : 		*--_Dest = *--_Last;

	sub	esi, 28					; 0000001cH
	sub	edi, 28					; 0000001cH
	push	esi
	mov	ecx, edi
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	cmp	esi, ebx
	jne	SHORT $LL2@Copy_backw@2

; 2677 : 	return (_Dest);

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 2678 : 	}

	ret	0
$LN9@Copy_backw@2:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[esp+4]
	pop	esi
	pop	ebx

; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAVCvString@@PAV1@Urandom_access_iterator_tag@std@@@std@@YAPAVCvString@@PAV1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvString *,CvString *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Construct@VCvString@@V1@@std@@YAXPAVCvString@@ABV1@@Z ; std::_Construct<CvString,CvString>
;	COMDAT xdata$x
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvbuildingclasses.h
xdata$x	SEGMENT
__unwindtable$??$_Construct@VCvString@@V1@@std@@YAXPAVCvString@@ABV1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@VCvString@@V1@@std@@YAXPAVCvString@@ABV1@@Z$0
__ehfuncinfo$??$_Construct@VCvString@@V1@@std@@YAXPAVCvString@@ABV1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@VCvString@@V1@@std@@YAXPAVCvString@@ABV1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Construct@VCvString@@V1@@std@@YAXPAVCvString@@ABV1@@Z
_TEXT	SEGMENT
$T219209 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Vptr$ = 8						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@VCvString@@V1@@std@@YAXPAVCvString@@ABV1@@Z PROC ; std::_Construct<CvString,CvString>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	-1
	push	__ehhandler$??$_Construct@VCvString@@V1@@std@@YAXPAVCvString@@ABV1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp+12]
	mov	DWORD PTR __Vptr$[esp+12], ecx

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	DWORD PTR $T219209[esp+16], ecx
	mov	DWORD PTR __$EHRec$[esp+24], 0
	test	ecx, ecx
	je	SHORT $LN3@Construct
	mov	eax, DWORD PTR __Val$[esp+12]
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
$LN3@Construct:

; 53   : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@VCvString@@V1@@std@@YAXPAVCvString@@ABV1@@Z$0:
	mov	eax, DWORD PTR __Vptr$[ebp-4]
	push	eax
	mov	ecx, DWORD PTR $T219209[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Construct@VCvString@@V1@@std@@YAXPAVCvString@@ABV1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Construct@VCvString@@V1@@std@@YAXPAVCvString@@ABV1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct@VCvString@@V1@@std@@YAXPAVCvString@@ABV1@@Z ENDP ; std::_Construct<CvString,CvString>
PUBLIC	??_GCvString@@QAEPAXI@Z				; CvString::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvString@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvString@@QAEPAXI@Z PROC				; CvString::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN7@scalar@4
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN7@scalar@4:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvString@@QAEPAXI@Z ENDP				; CvString::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z PROC ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ENDP ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::max_size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@H@std@@QAEPAHI@Z		; std::allocator<int>::allocate
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@H@std@@QAEPAHI@Z PROC		; std::allocator<int>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@H@std@@QAEPAHI@Z ENDP		; std::allocator<int>::allocate
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAH@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator!=
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z	; stdext::unchecked_copy<int *,int *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z PROC	; stdext::unchecked_copy<int *,int *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jle	SHORT $LN10@unchecked_
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@unchecked_:
	pop	edi
	mov	eax, esi
	pop	esi

; 3607 : 	}

	ret	0
??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z ENDP	; stdext::unchecked_copy<int *,int *>
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<int,std::allocator<int> >::operator+=
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator+=
_TEXT	ENDS
PUBLIC	??$fill@PAHH@std@@YAXPAH0ABH@Z			; std::fill<int *,int>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$fill@PAHH@std@@YAXPAH0ABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAHH@std@@YAXPAH0ABH@Z PROC			; std::fill<int *,int>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@fill
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL5@fill
	pop	esi
$LN3@fill:

; 3188 : 	}

	ret	0
??$fill@PAHH@std@@YAXPAH0ABH@Z ENDP			; std::fill<int *,int>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN8@Move_backw
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@Move_backw:
	mov	eax, esi
	pop	esi

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<int *,unsigned int,int,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<int *,unsigned int,int,std::random_access_iterator_tag>, COMDAT

; 3242 : 		_Fill_n(_First, _Count, _Val, _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN3@Fill_n@2
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@Fill_n@2:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL5@Fill_n@2
	pop	esi
$LN3@Fill_n@2:

; 3243 : 	}

	ret	0
??$_Fill_n@PAHIHUrandom_access_iterator_tag@std@@@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<int *,unsigned int,int,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >, COMDAT

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN8@unchecked_@2
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN8@unchecked_@2:
	pop	edi
	mov	eax, esi
	pop	esi

; 823  : 	}

	ret	0
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAE_NI@Z ; std::vector<CvString,std::allocator<CvString> >::_Buy
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?_Buy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvString,std::allocator<CvString> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 153391689				; 09249249H
	jbe	SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ ; std::vector<CvString,std::allocator<CvString> >::_Xlen
$LN16@Buy:
$LN2@Buy:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@VCvString@@@std@@YAPAVCvString@@IPAV1@@Z ; std::_Allocate<CvString>

; 1111 : 			_Mylast = _Myfirst;
; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	ecx, DWORD PTR [edi*8]
	sub	ecx, edi
	add	esp, 8
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	pop	edi
	mov	DWORD PTR [esi+12], edx

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy:
?_Buy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::_Buy
_TEXT	ENDS
PUBLIC	?begin@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@XZ ; std::vector<CvString,std::allocator<CvString> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@XZ PROC ; std::vector<CvString,std::allocator<CvString> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@XZ ENDP ; std::vector<CvString,std::allocator<CvString> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@XZ ; std::vector<CvString,std::allocator<CvString> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@XZ PROC ; std::vector<CvString,std::allocator<CvString> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@XZ ENDP ; std::vector<CvString,std::allocator<CvString> >::end
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<CvString,std::allocator<CvString> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<CvString,std::allocator<CvString> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax*8]
	sub	edx, eax
	mov	eax, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<CvString,std::allocator<CvString> >::operator+
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@@Z ; std::vector<CvString,std::allocator<CvString> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@@Z PROC ; std::vector<CvString,std::allocator<CvString> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QBE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::_Make_iter
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAVCvString@@PAV1@@stdext@@YAPAVCvString@@PAV1@00@Z ; stdext::unchecked_copy<CvString *,CvString *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAVCvString@@PAV1@@stdext@@YAPAVCvString@@PAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAVCvString@@PAV1@@stdext@@YAPAVCvString@@PAV1@00@Z PROC ; stdext::unchecked_copy<CvString *,CvString *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ebx, DWORD PTR __Last$[esp]
	push	esi
	mov	esi, DWORD PTR __First$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+8]
	cmp	esi, ebx
	je	SHORT $LN16@unchecked_@3
$LL9@unchecked_@3:
	push	esi
	mov	ecx, edi
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	add	esi, 28					; 0000001cH
	add	edi, 28					; 0000001cH
	cmp	esi, ebx
	jne	SHORT $LL9@unchecked_@3
$LN16@unchecked_@3:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 3607 : 	}

	ret	0
??$unchecked_copy@PAVCvString@@PAV1@@stdext@@YAPAVCvString@@PAV1@00@Z ENDP ; stdext::unchecked_copy<CvString *,CvString *>
_TEXT	ENDS
PUBLIC	??$fill@PAVCvString@@V1@@std@@YAXPAVCvString@@0ABV1@@Z ; std::fill<CvString *,CvString>
; Function compile flags: /Ogtpy
;	COMDAT ??$fill@PAVCvString@@V1@@std@@YAXPAVCvString@@0ABV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAVCvString@@V1@@std@@YAXPAVCvString@@0ABV1@@Z PROC ; std::fill<CvString *,CvString>, COMDAT

; 3186 : 	{	// copy _Val through [_First, _Last)

	push	esi

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	esi, DWORD PTR __First$[esp]
	push	edi
	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	esi, edi
	je	SHORT $LN3@fill@2
	push	ebx
	mov	ebx, DWORD PTR __Val$[esp+8]
$LL5@fill@2:
	push	ebx
	mov	ecx, esi
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $LL5@fill@2
	pop	ebx
$LN3@fill@2:
	pop	edi
	pop	esi

; 3188 : 	}

	ret	0
??$fill@PAVCvString@@V1@@std@@YAXPAVCvString@@0ABV1@@Z ENDP ; std::fill<CvString *,CvString>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAVCvString@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvString@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<CvString *,CvString *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAVCvString@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvString@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAVCvString@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvString@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<CvString *,CvString *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ebx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	ebx, DWORD PTR __First$[esp]
	push	esi
	mov	esi, DWORD PTR __Last$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+8]
	cmp	ebx, esi
	je	SHORT $LN13@Move_backw@2
$LL6@Move_backw@2:
	sub	esi, 28					; 0000001cH
	sub	edi, 28					; 0000001cH
	push	esi
	mov	ecx, edi
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	cmp	esi, ebx
	jne	SHORT $LL6@Move_backw@2
$LN13@Move_backw@2:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAVCvString@@PAV1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAVCvString@@PAV1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<CvString *,CvString *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@VCvString@@@std@@QAEXPAVCvString@@ABV3@@Z ; std::allocator<CvString>::construct
;	COMDAT xdata$x
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvbuildingclasses.h
xdata$x	SEGMENT
__unwindtable$?construct@?$allocator@VCvString@@@std@@QAEXPAVCvString@@ABV3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?construct@?$allocator@VCvString@@@std@@QAEXPAVCvString@@ABV3@@Z$0
__ehfuncinfo$?construct@?$allocator@VCvString@@@std@@QAEXPAVCvString@@ABV3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?construct@?$allocator@VCvString@@@std@@QAEXPAVCvString@@ABV3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ?construct@?$allocator@VCvString@@@std@@QAEXPAVCvString@@ABV3@@Z
_TEXT	SEGMENT
$T219553 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Vptr$219550 = 8					; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@VCvString@@@std@@QAEXPAVCvString@@ABV3@@Z PROC ; std::allocator<CvString>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	-1
	push	__ehhandler$?construct@?$allocator@VCvString@@@std@@QAEXPAVCvString@@ABV3@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	ecx, DWORD PTR __Ptr$[esp+12]
	mov	DWORD PTR __Vptr$219550[esp+12], ecx
	mov	DWORD PTR $T219553[esp+16], ecx
	mov	DWORD PTR __$EHRec$[esp+24], 0
	test	ecx, ecx
	je	SHORT $LN5@construct
	mov	eax, DWORD PTR __Val$[esp+12]
	push	eax
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
$LN5@construct:

; 156  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?construct@?$allocator@VCvString@@@std@@QAEXPAVCvString@@ABV3@@Z$0:
	mov	eax, DWORD PTR __Vptr$219550[ebp-4]
	push	eax
	mov	ecx, DWORD PTR $T219553[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?construct@?$allocator@VCvString@@@std@@QAEXPAVCvString@@ABV3@@Z:
	mov	eax, OFFSET __ehfuncinfo$?construct@?$allocator@VCvString@@@std@@QAEXPAVCvString@@ABV3@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?construct@?$allocator@VCvString@@@std@@QAEXPAVCvString@@ABV3@@Z ENDP ; std::allocator<CvString>::construct
PUBLIC	??$_Destroy@VCvString@@@std@@YAXPAVCvString@@@Z	; std::_Destroy<CvString>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@VCvString@@@std@@YAXPAVCvString@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@VCvString@@@std@@YAXPAVCvString@@@Z PROC	; std::_Destroy<CvString>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
??$_Destroy@VCvString@@@std@@YAXPAVCvString@@@Z ENDP	; std::_Destroy<CvString>
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z PROC	; std::vector<int,std::allocator<int> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy@2
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy@2:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy@2

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
$LN16@Buy@2:
$LN2@Buy@2:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy@2:
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ENDP	; std::vector<int,std::allocator<int> >::_Buy
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z PROC ; std::vector<int,std::allocator<int> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Destroy
_TEXT	ENDS
PUBLIC	?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::end
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z ; std::vector<int,std::allocator<int> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z PROC ; std::vector<int,std::allocator<int> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z ENDP ; std::vector<int,std::allocator<int> >::_Make_iter
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<int,std::allocator<int> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator+
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z PROC ; stdext::_Unchecked_move_backward<int *,int *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	sar	eax, 2
	push	esi
	mov	esi, DWORD PTR __Dest$[esp]
	lea	ecx, DWORD PTR [eax*4]
	sub	esi, ecx
	test	eax, eax
	jle	SHORT $LN14@Unchecked_
	push	ecx
	push	edx
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_:
	mov	eax, esi
	pop	esi

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ENDP ; stdext::_Unchecked_move_backward<int *,int *>
_TEXT	ENDS
PUBLIC	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z	; stdext::unchecked_fill_n<int *,unsigned int,int>
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z PROC	; stdext::unchecked_fill_n<int *,unsigned int,int>, COMDAT

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN7@unchecked_@4
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL9@unchecked_@4:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL9@unchecked_@4
	pop	esi
$LN7@unchecked_@4:

; 3722 : 	}

	ret	0
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ENDP	; stdext::unchecked_fill_n<int *,unsigned int,int>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>, COMDAT

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN10@Uninit_mov
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN10@Uninit_mov:
	pop	edi
	mov	eax, esi
	pop	esi

; 208  : 	}

	ret	0
??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ; std::vector<CvString,std::allocator<CvString> >::vector<CvString,std::allocator<CvString> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ PROC ; std::vector<CvString,std::allocator<CvString> >::vector<CvString,std::allocator<CvString> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvString,std::allocator<CvString> >::vector<CvString,std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAVCvString@@PAV1@@stdext@@YAPAVCvString@@PAV1@00@Z ; stdext::_Unchecked_move_backward<CvString *,CvString *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xutility
;	COMDAT ??$_Unchecked_move_backward@PAVCvString@@PAV1@@stdext@@YAPAVCvString@@PAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAVCvString@@PAV1@@stdext@@YAPAVCvString@@PAV1@00@Z PROC ; stdext::_Unchecked_move_backward<CvString *,CvString *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ebx, DWORD PTR __First$[esp]
	push	esi
	mov	esi, DWORD PTR __Last$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+8]
	cmp	ebx, esi
	je	SHORT $LN19@Unchecked_@2
$LL12@Unchecked_@2:
	sub	esi, 28					; 0000001cH
	sub	edi, 28					; 0000001cH
	push	esi
	mov	ecx, edi
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	cmp	esi, ebx
	jne	SHORT $LL12@Unchecked_@2
$LN19@Unchecked_@2:
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAVCvString@@PAV1@@stdext@@YAPAVCvString@@PAV1@00@Z ENDP ; stdext::_Unchecked_move_backward<CvString *,CvString *>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@VCvString@@@std@@QAEXPAVCvString@@@Z ; std::allocator<CvString>::destroy
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@VCvString@@@std@@QAEXPAVCvString@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@VCvString@@@std@@QAEXPAVCvString@@@Z PROC ; std::allocator<CvString>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 161  : 		}

	ret	4
?destroy@?$allocator@VCvString@@@std@@QAEXPAVCvString@@@Z ENDP ; std::allocator<CvString>::destroy
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvString *,CvString *,std::allocator<CvString> >
;	COMDAT xdata$x
; File s:\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$5
__unwindtable$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T219982 = -24						; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Vptr$219979 = 8					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CvString *,CvString *,std::allocator<CvString> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	edi, DWORD PTR __First$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Next$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+12], ebx
	npad	1
$LL6@Uninit_cop@2:

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	edi, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@2

; 131  : 		_Al.construct(_Dest, *_First);

	mov	DWORD PTR __Vptr$219979[ebp], esi
	mov	DWORD PTR $T219982[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	esi, ebx
	je	SHORT $LN18@Uninit_cop@2
	push	edi
	mov	ecx, esi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
$LN18@Uninit_cop@2:
	add	esi, 28					; 0000001cH
	mov	BYTE PTR __$EHRec$[ebp+12], bl
	mov	DWORD PTR __Dest$[ebp], esi
	add	edi, 28					; 0000001cH
	jmp	SHORT $LL6@Uninit_cop@2
__catch$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __Dest$[ebp]
	cmp	esi, edi
	je	SHORT $LN1@Uninit_cop@2
$LL3@Uninit_cop@2:

; 134  : 		_Al.destroy(_Next);

	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $LL3@Uninit_cop@2
$LN1@Uninit_cop@2:

; 135  : 	_RERAISE;

	xor	ebx, ebx
	push	ebx
	push	ebx
	call	__CxxThrowException@8
$LN42@Uninit_cop@2:
$LN4@Uninit_cop@2:

; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN41@Uninit_cop@2:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$219979[ebp]
	push	eax
	mov	ecx, DWORD PTR $T219982[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CvString *,CvString *,std::allocator<CvString> >
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ PROC	; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
_TEXT	ENDS
PUBLIC	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z PROC ; std::vector<int,std::allocator<int> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	edx, DWORD PTR __First_arg$[esp-4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	esi, DWORD PTR __Last_arg$[esp+4]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [ebp], edx
	cmp	edx, esi
	je	SHORT $LN29@erase

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [edi+8]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	ebx
	lea	ebx, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN26@erase
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN26@erase:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [edi+8], ebx
	pop	ebx
$LN29@erase:
	pop	edi
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, ebp
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ENDP ; std::vector<int,std::allocator<int> >::erase
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >, COMDAT

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN9@Uninit_fil
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL11@Uninit_fil:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL11@Uninit_fil
	pop	esi
$LN9@Uninit_fil:

; 420  : 	}

	ret	0
??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >, COMDAT

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Dest$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN14@Unchecked_@3
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN14@Unchecked_@3:
	pop	edi
	mov	eax, esi
	pop	esi

; 865  : 	}

	ret	0
??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@0AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvString> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@0AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@0AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvString> >, COMDAT

; 232  : 	{	// destroy [_First, _Last), arbitrary type

	push	esi

; 233  : 	for (; _First != _Last; ++_First)

	mov	esi, DWORD PTR __First$[esp]
	push	edi
	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	esi, edi
	je	SHORT $LN1@Destroy_ra
	npad	2
$LL3@Destroy_ra:

; 234  : 		_Al.destroy(_First);

	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $LL3@Destroy_ra
$LN1@Destroy_ra:
	pop	edi
	pop	esi

; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@0AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvString *,unsigned int,CvString,std::allocator<CvString> >
;	COMDAT xdata$x
; File s:\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$5
__unwindtable$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T220401 = -24						; size = 4
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Vptr$220398 = 12					; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<CvString *,unsigned int,CvString,std::allocator<CvString> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	esi, DWORD PTR __First$[ebp]
	push	edi

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	edi, DWORD PTR __Count$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Next$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+12], ebx
	npad	1
$LL6@Uninit_fil@2:

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	cmp	edi, ebx
	jbe	SHORT $LN4@Uninit_fil@2

; 404  : 		_Al.construct(_First, _Val);

	mov	DWORD PTR __Vptr$220398[ebp], esi
	mov	DWORD PTR $T220401[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	esi, ebx
	je	SHORT $LN18@Uninit_fil@2
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, esi
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
$LN18@Uninit_fil@2:
	dec	edi
	add	esi, 28					; 0000001cH
	mov	BYTE PTR __$EHRec$[ebp+12], bl
	mov	DWORD PTR __First$[ebp], esi
	jmp	SHORT $LL6@Uninit_fil@2
__catch$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __First$[ebp]
	cmp	esi, edi
	je	SHORT $LN1@Uninit_fil@2
$LL3@Uninit_fil@2:

; 407  : 		_Al.destroy(_Next);

	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $LL3@Uninit_fil@2
$LN1@Uninit_fil@2:

; 408  : 	_RERAISE;

	xor	ebx, ebx
	push	ebx
	push	ebx
	call	__CxxThrowException@8
$LN42@Uninit_fil@2:
$LN4@Uninit_fil@2:

; 409  : 	_CATCH_END
; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN41@Uninit_fil@2:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2:
	mov	eax, DWORD PTR __Vptr$220398[ebp]
	push	eax
	mov	ecx, DWORD PTR $T220401[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CvString *,unsigned int,CvString,std::allocator<CvString> >
PUBLIC	??$unchecked_uninitialized_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@stdext@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvString *,CvString *,std::allocator<CvString> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@stdext@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@std@@@Z
_TEXT	SEGMENT
$T220452 = -4						; size = 1
__Cat$220457 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@stdext@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<CvString *,CvString *,std::allocator<CvString> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T220452[esp+4], 0
	mov	eax, DWORD PTR $T220452[esp+4]
	mov	ecx, DWORD PTR __Cat$220457[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvString *,CvString *,std::allocator<CvString> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@stdext@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<CvString *,CvString *,std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >, COMDAT

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	eax, DWORD PTR __Count$[esp-4]
	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN13@unchecked_@5
	mov	edx, DWORD PTR __Val$[esp-4]
	push	esi
$LL15@unchecked_@5:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL15@unchecked_@5
	pop	esi
$LN13@unchecked_@5:

; 943  : 	}

	ret	0
??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z PROC ; std::vector<int,std::allocator<int> >::_Umove<int *>, COMDAT
; _this$ = ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	sub	eax, edx
	push	esi
	sar	eax, 2
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	lea	ecx, DWORD PTR [eax*4]
	lea	esi, DWORD PTR [ecx+edi]
	test	eax, eax
	jbe	SHORT $LN16@Umove
	push	ecx
	push	edx
	push	ecx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN16@Umove:
	pop	edi
	mov	eax, esi
	pop	esi

; 1149 : 		}

	ret	12					; 0000000cH
??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ENDP ; std::vector<int,std::allocator<int> >::_Umove<int *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@0AAV?$allocator@VCvString@@@0@@Z ; std::_Destroy_range<std::allocator<CvString> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@0AAV?$allocator@VCvString@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@0AAV?$allocator@VCvString@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvString> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	esi

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	mov	esi, DWORD PTR __First$[esp]
	push	edi
	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	esi, edi
	je	SHORT $LN5@Destroy_ra@2
	npad	2
$LL7@Destroy_ra@2:
	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $LL7@Destroy_ra@2
$LN5@Destroy_ra@2:
	pop	edi
	pop	esi

; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@0AAV?$allocator@VCvString@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@stdext@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<CvString *,unsigned int,CvString,std::allocator<CvString> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@stdext@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@std@@@Z
_TEXT	SEGMENT
$T220686 = -4						; size = 1
__Cat$220691 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@stdext@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<CvString *,unsigned int,CvString,std::allocator<CvString> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T220686[esp+4], 0
	mov	eax, DWORD PTR $T220686[esp+4]
	mov	ecx, DWORD PTR __Cat$220691[esp+4]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvString *,unsigned int,CvString,std::allocator<CvString> >

; 943  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@stdext@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<CvString *,unsigned int,CvString,std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<CvString *,CvString *,std::allocator<CvString>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_move@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T220704 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$220708 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<CvString *,CvString *,std::allocator<CvString>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$220708[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T220704[esp+4], 0
	mov	eax, DWORD PTR $T220704[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvString *,CvString *,std::allocator<CvString> >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@U_Undefined_move_tag@3@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CvString *,CvString *,std::allocator<CvString>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z PROC ; std::vector<int,std::allocator<int> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	esi

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	esi, DWORD PTR __Count$[esp]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+4]
	mov	eax, esi
	mov	ecx, edi
	test	esi, esi
	jbe	SHORT $LN22@Ufill
	mov	edx, DWORD PTR __Val$[esp+4]
	push	ebx
$LL17@Ufill:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebx
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL17@Ufill
	pop	ebx
$LN22@Ufill:

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*4]
	pop	edi
	pop	esi

; 1256 : 		}

	ret	12					; 0000000cH
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
; Function compile flags: /Ogtpy
;	COMDAT ?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
_TEXT	SEGMENT
__Capacity$ = -4					; size = 4
__Where$ = 8						; size = 4
__Count$ = 12						; size = 4
__Tmp$214846 = 16					; size = 4
__Tmp$214836 = 16					; size = 4
__Val$ = 16						; size = 4
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z PROC ; std::vector<int,std::allocator<int> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ecx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	test	edx, edx
	jne	SHORT $LN29@Insert_n
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n
$LN29@Insert_n:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 2
	mov	ecx, eax
$LN30@Insert_n:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[esp+8]
	test	edi, edi
	je	$LN1@Insert_n
	push	ebx

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	eax, ebx
	sub	eax, edx
	sar	eax, 2
	mov	edx, 1073741823				; 3fffffffH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN12@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
$LN64@Insert_n:
$LN12@Insert_n:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	push	ebp
	cmp	ecx, edx
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	ebx, 1073741823				; 3fffffffH
	sub	ebx, eax
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR __Capacity$[esp+20], 0
	mov	ecx, DWORD PTR __Capacity$[esp+20]
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[esp+20], ecx
$LN18@Insert_n:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[esp+20], edx
	mov	ecx, edx
$LN9@Insert_n:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@H@std@@YAPAHIPAH@Z		; std::_Allocate<int>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebx, DWORD PTR __Where$[esp+24]
	sub	ebx, DWORD PTR [esi+4]
	add	esp, 8
	mov	ebp, eax

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	eax, DWORD PTR __Val$[esp+16]
	push	eax
	sar	ebx, 2
	push	edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	mov	ecx, esi
	call	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Where$[esp+16]
	mov	eax, DWORD PTR [esi+4]
	push	ebp
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR __Where$[esp+16]
	add	ebx, edi
	lea	ecx, DWORD PTR [ebp+ebx*4]
	push	ecx
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);
; 1191 : 			_RERAISE;
; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 2
	add	edi, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN57@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN57@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[esp+20]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [ebp+edi*4]
	lea	eax, DWORD PTR [ebp+edx*4]

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], ebp
	pop	ebp
	pop	ebx
	pop	edi
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], ecx
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	eax, DWORD PTR __Where$[esp+16]

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[esp+16]
	mov	edx, ebx
	sub	edx, eax
	sar	edx, 2
	cmp	edx, edi
	mov	edx, DWORD PTR [ecx]

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	ebp, DWORD PTR [edi*4]
	mov	DWORD PTR __Tmp$214836[esp+16], edx
	jae	SHORT $LN3@Insert_n
	lea	ecx, DWORD PTR [eax+ebp]
	push	ecx
	push	ebx
	push	eax
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$214836[esp+16]
	sar	ecx, 2
	push	edx
	sub	edi, ecx
	push	edi
	push	eax
	mov	ecx, esi
	call	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	add	DWORD PTR [esi+8], ebp
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	eax, DWORD PTR __Where$[esp+16]
	lea	edx, DWORD PTR __Tmp$214836[esp+16]
	push	edx
	sub	esi, ebp
	push	esi
	push	eax
	call	??$fill@PAHH@std@@YAXPAH0ABH@Z		; std::fill<int *,int>
	add	esp, 12					; 0000000cH
	pop	ebp
	pop	ebx
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN3@Insert_n:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence
; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	push	ebx
	mov	edi, ebx
	push	ebx
	sub	edi, ebp
	push	edi
	mov	ecx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	push	ebx
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Where$[esp+20]
	push	edi
	push	eax
	call	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[esp+28]
	lea	ecx, DWORD PTR __Tmp$214846[esp+28]
	push	ecx
	add	ebp, eax
	push	ebp
	push	eax
	call	??$fill@PAHH@std@@YAXPAH0ABH@Z		; std::fill<int *,int>
	add	esp, 24					; 00000018H
	pop	ebp
	pop	ebx
$LN1@Insert_n:
	pop	edi
	pop	esi

; 1249 : 			}
; 1250 : 		}

	pop	ecx
	ret	12					; 0000000cH
$LN63@Insert_n:
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Insert_n
_TEXT	ENDS
PUBLIC	?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIH@Z ; std::vector<int,std::allocator<int> >::resize
; Function compile flags: /Ogtpy
;	COMDAT ?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIH@Z
_TEXT	SEGMENT
$T220910 = 8						; size = 4
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIH@Z PROC ; std::vector<int,std::allocator<int> >::resize, COMDAT
; _this$ = ecx

; 718  : 		if (size() < _Newsize)

	mov	edx, DWORD PTR __Newsize$[esp-4]
	push	esi
	mov	esi, DWORD PTR [ecx+8]
	push	edi
	mov	edi, DWORD PTR [ecx+4]
	mov	eax, esi
	sub	eax, edi
	sar	eax, 2
	cmp	edx, eax
	jbe	SHORT $LN36@resize

; 719  : 			_Insert_n(end(), _Newsize - size(), _Val);

	lea	edi, DWORD PTR __Val$[esp+4]
	push	edi
	sub	edx, eax
	push	edx
	push	esi
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
	pop	edi
	pop	esi

; 722  : 		}

	ret	8
$LN36@resize:

; 720  : 		else if (_Newsize < size())

	jae	SHORT $LN1@resize

; 721  : 			erase(begin() + _Newsize, end());

	lea	eax, DWORD PTR [edi+edx*4]
	push	esi
	push	eax
	lea	eax, DWORD PTR $T220910[esp+12]
	push	eax
	call	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase
$LN1@resize:
	pop	edi
	pop	esi

; 722  : 		}

	ret	8
?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXIH@Z ENDP ; std::vector<int,std::allocator<int> >::resize
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXPAVCvString@@0@Z ; std::vector<CvString,std::allocator<CvString> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXPAVCvString@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXPAVCvString@@0@Z PROC ; std::vector<CvString,std::allocator<CvString> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	esi

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	esi, DWORD PTR __First$[esp]
	push	edi
	mov	edi, DWORD PTR __Last$[esp+4]
	cmp	esi, edi
	je	SHORT $LN7@Destroy
	npad	2
$LL9@Destroy:
	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $LL9@Destroy
$LN7@Destroy:
	pop	edi
	pop	esi

; 1120 : 		}

	ret	8
?_Destroy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXPAVCvString@@0@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::_Destroy
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@PAV3@IABV3@@Z ; std::vector<CvString,std::allocator<CvString> >::_Ufill
; Function compile flags: /Ogtpy
;	COMDAT ?_Ufill@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@PAV3@IABV3@@Z
_TEXT	SEGMENT
$T221074 = -4						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$221078 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@PAV3@IABV3@@Z PROC ; std::vector<CvString,std::allocator<CvString> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	edx, DWORD PTR __Cat$221078[esp]
	push	esi
	mov	esi, DWORD PTR __Count$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+8]
	mov	BYTE PTR $T221074[esp+12], 0
	mov	eax, DWORD PTR $T221074[esp+12]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+12]
	push	edx
	push	ecx
	push	eax
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAVCvString@@IV1@V?$allocator@VCvString@@@std@@@std@@YAXPAVCvString@@IABV1@AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvString *,unsigned int,CvString,std::allocator<CvString> >
	add	esp, 24					; 00000018H

; 1255 : 		return (_Ptr + _Count);

	lea	ecx, DWORD PTR [esi*8]
	sub	ecx, esi
	lea	eax, DWORD PTR [edi+ecx*4]
	pop	edi
	pop	esi

; 1256 : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Ufill@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@PAV3@IABV3@@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::_Ufill
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@stdext@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<CvString *,CvString *,std::allocator<CvString> >
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@stdext@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@std@@@Z
_TEXT	SEGMENT
$T221111 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$221115 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@stdext@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<CvString *,CvString *,std::allocator<CvString> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$221115[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T221111[esp+4], 0
	mov	eax, DWORD PTR $T221111[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvString *,CvString *,std::allocator<CvString> >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@stdext@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<CvString *,CvString *,std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z ; std::vector<int,std::allocator<int> >::resize
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
;	COMDAT ?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
$T221247 = -4						; size = 4
$T221225 = 8						; size = 4
__Newsize$ = 8						; size = 4
?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z PROC ; std::vector<int,std::allocator<int> >::resize, COMDAT
; _this$ = ecx

; 712  : 		{	// determine new length, padding with _Ty() elements as needed

	push	ecx

; 713  : 		resize(_Newsize, _Ty());

	mov	edx, DWORD PTR __Newsize$[esp]
	push	esi
	mov	esi, DWORD PTR [ecx+8]
	push	edi
	mov	edi, DWORD PTR [ecx+4]
	mov	eax, esi
	sub	eax, edi
	sar	eax, 2
	mov	DWORD PTR $T221247[esp+12], 0
	cmp	edx, eax
	jbe	SHORT $LN38@resize@2
	lea	edi, DWORD PTR $T221247[esp+12]
	push	edi
	sub	edx, eax
	push	edx
	push	esi
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
	pop	edi
	pop	esi

; 714  : 		}

	pop	ecx
	ret	4
$LN38@resize@2:

; 713  : 		resize(_Newsize, _Ty());

	jae	SHORT $LN3@resize@2
	lea	eax, DWORD PTR [edi+edx*4]
	push	esi
	push	eax
	lea	eax, DWORD PTR $T221225[esp+16]
	push	eax
	call	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase
$LN3@resize@2:
	pop	edi
	pop	esi

; 714  : 		}

	pop	ecx
	ret	4
?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z ENDP ; std::vector<int,std::allocator<int> >::resize
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXXZ ; std::vector<CvString,std::allocator<CvString> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXXZ PROC ; std::vector<CvString,std::allocator<CvString> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebx
	mov	ebx, ecx
	push	esi

; 1124 : 		if (_Myfirst != 0)

	mov	esi, DWORD PTR [ebx+4]
	test	esi, esi
	je	SHORT $LN25@Tidy@2
	push	edi

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	edi, DWORD PTR [ebx+8]
	cmp	esi, edi
	je	SHORT $LN10@Tidy@2
$LL12@Tidy@2:
	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $LL12@Tidy@2
$LN10@Tidy@2:

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR [ebx+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	edi
$LN25@Tidy@2:
	pop	esi

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [ebx+4], 0
	mov	DWORD PTR [ebx+8], 0
	mov	DWORD PTR [ebx+12], 0
	pop	ebx

; 1135 : 		}

	ret	0
?_Tidy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvString,std::allocator<CvString> >::_Tidy
_TEXT	ENDS
PUBLIC	?erase@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@0@Z ; std::vector<CvString,std::allocator<CvString> >::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@0@Z PROC ; std::vector<CvString,std::allocator<CvString> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	push	ebp
	push	esi
	mov	esi, DWORD PTR __First_arg$[esp+4]
	push	edi

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edi, DWORD PTR __Last_arg$[esp+8]
	mov	ebp, ecx
	mov	DWORD PTR [eax], esi
	cmp	esi, edi
	je	SHORT $LN1@erase@2
	push	ebx

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	ebx, DWORD PTR [ebp+8]
	cmp	edi, ebx
	je	SHORT $LN26@erase@2
	npad	1
$LL28@erase@2:
	push	edi
	mov	ecx, esi
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	add	edi, 28					; 0000001cH
	add	esi, 28					; 0000001cH
	cmp	edi, ebx
	jne	SHORT $LL28@erase@2
$LN26@erase@2:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	ebx, DWORD PTR [ebp+8]
	mov	edi, esi
	cmp	esi, ebx
	je	SHORT $LN39@erase@2
	npad	4
$LL41@erase@2:
	mov	ecx, edi
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	add	edi, 28					; 0000001cH
	cmp	edi, ebx
	jne	SHORT $LL41@erase@2
$LN39@erase@2:

; 1049 : 			_Mylast = _Ptr;
; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	mov	DWORD PTR [ebp+8], esi
	pop	ebx
$LN1@erase@2:
	pop	edi
	pop	esi
	pop	ebp

; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@0@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::erase
_TEXT	ENDS
PUBLIC	??$_Umove@PAVCvString@@@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@PAV2@00@Z ; std::vector<CvString,std::allocator<CvString> >::_Umove<CvString *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Umove@PAVCvString@@@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@PAV2@00@Z
_TEXT	SEGMENT
$T221596 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$221600 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAVCvString@@@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@PAV2@00@Z PROC ; std::vector<CvString,std::allocator<CvString> >::_Umove<CvString *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$221600[esp]
	mov	BYTE PTR $T221596[esp+4], 0
	mov	eax, DWORD PTR $T221596[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvString *,CvString *,std::allocator<CvString> >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@PAVCvString@@@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@PAV2@00@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::_Umove<CvString *>
_TEXT	ENDS
PUBLIC	??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ; std::vector<CvString,std::allocator<CvString> >::~vector<CvString,std::allocator<CvString> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ PROC ; std::vector<CvString,std::allocator<CvString> >::~vector<CvString,std::allocator<CvString> >, COMDAT
; _this$ = ecx

; 559  : 		_Tidy();

	jmp	?_Tidy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXXZ ; std::vector<CvString,std::allocator<CvString> >::_Tidy
??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvString,std::allocator<CvString> >::~vector<CvString,std::allocator<CvString> >
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z ; std::vector<CvString,std::allocator<CvString> >::_Insert_n
;	COMDAT xdata$x
; File s:\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$11 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$2
__catchsym$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$10 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$0
__ehfuncinfo$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$10
	DD	03H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$11
__unwindtable$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$4
	DD	02H
	DD	00H
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$5
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z
_TEXT	SEGMENT
__Tmp$217757 = -92					; size = 28
__Tmp$217747 = -64					; size = 28
__Whereoff$217733 = -36					; size = 4
_this$ = -32						; size = 4
__Ncopied$217734 = -28					; size = 4
__Newvec$217732 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$221816 = 8					; size = 1
__Cat$221744 = 8					; size = 1
__Where$ = 8						; size = 4
tv525 = 12						; size = 4
__Count$ = 12						; size = 4
$T221812 = 16						; size = 1
$T221740 = 16						; size = 1
__Val$ = 16						; size = 4
?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z PROC ; std::vector<CvString,std::allocator<CvString> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	eax, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], esi
	test	eax, eax
	jne	SHORT $LN31@Insert_n@2
	mov	DWORD PTR __Capacity$[ebp], eax
	jmp	SHORT $LN32@Insert_n@2
$LN31@Insert_n@2:
	mov	ecx, DWORD PTR [esi+12]
	sub	ecx, eax
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR __Capacity$[ebp], eax
$LN32@Insert_n@2:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	edi, DWORD PTR __Count$[ebp]
	test	edi, edi
	je	$LN1@Insert_n@2

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ebx, DWORD PTR [esi+8]
	mov	ecx, ebx
	sub	ecx, DWORD PTR [esi+4]
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	ecx, 153391689				; 09249249H
	sub	ecx, eax
	cmp	ecx, edi
	jae	SHORT $LN12@Insert_n@2

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@KAXXZ ; std::vector<CvString,std::allocator<CvString> >::_Xlen
$LN103@Insert_n@2:
$LN12@Insert_n@2:

; 1167 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR __Capacity$[ebp]
	add	eax, edi
	cmp	ecx, eax
	jae	$LN10@Insert_n@2

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	edx, ecx
	shr	edx, 1
	mov	ebx, 153391689				; 09249249H
	sub	ebx, edx
	cmp	ebx, ecx
	jae	SHORT $LN17@Insert_n@2
	mov	DWORD PTR __Capacity$[ebp], 0
	mov	ecx, DWORD PTR __Capacity$[ebp]
	jmp	SHORT $LN18@Insert_n@2
$LN17@Insert_n@2:
	add	ecx, edx
	mov	DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n@2:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, eax
	jae	SHORT $LN9@Insert_n@2

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[ebp], eax
	mov	ecx, eax
$LN9@Insert_n@2:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@VCvString@@@std@@YAPAVCvString@@IPAV1@@Z ; std::_Allocate<CvString>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	ebx, DWORD PTR __Where$[ebp]
	sub	ebx, DWORD PTR [esi+4]
	mov	ecx, eax
	mov	eax, -1840700269			; 92492493H
	imul	ebx
	add	edx, ebx
	sar	edx, 4
	mov	ebx, edx

; 1175 : 			int _Ncopied = 0;

	xor	eax, eax
	shr	ebx, 31					; 0000001fH
	add	ebx, edx

; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	edx, DWORD PTR __Val$[ebp]
	add	esp, 8
	mov	DWORD PTR __Ncopied$217734[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], eax
	push	edx
	lea	eax, DWORD PTR [ebx*8]
	mov	DWORD PTR __Newvec$217732[ebp], ecx
	sub	eax, ebx
	lea	ecx, DWORD PTR [ecx+eax*4]
	push	edi
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR __Whereoff$217733[ebp], ebx
	call	?_Ufill@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@PAV3@IABV3@@Z ; std::vector<CvString,std::allocator<CvString> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR __Cat$221744[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR $T221740[ebp], 0
	mov	edx, DWORD PTR $T221740[ebp]
	push	edx
	mov	edx, DWORD PTR __Newvec$217732[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Where$[ebp]
	push	esi
	push	edx
	push	ecx
	push	eax
	mov	DWORD PTR __Ncopied$217734[ebp], 1
	call	??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvString *,CvString *,std::allocator<CvString> >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	ecx, DWORD PTR __Newvec$217732[ebp]
	mov	eax, DWORD PTR [esi+8]
	add	ebx, edi
	add	esp, 24					; 00000018H
	lea	edx, DWORD PTR [ebx*8]
	sub	edx, ebx
	lea	ecx, DWORD PTR [ecx+edx*4]
	mov	BYTE PTR $T221812[ebp], 0
	mov	edx, DWORD PTR $T221812[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$221816[ebp]
	push	edx
	push	esi
	push	ecx
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	DWORD PTR __Ncopied$217734[ebp], 2
	call	??$_Uninit_copy@PAVCvString@@PAV1@V?$allocator@VCvString@@@std@@@std@@YAPAVCvString@@PAV1@00AAV?$allocator@VCvString@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvString *,CvString *,std::allocator<CvString> >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	ebx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, ebx
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	add	esp, 24					; 00000018H
	add	edi, ecx
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1195 : 			if (_Myfirst != 0)

	test	ebx, ebx
	je	SHORT $LN83@Insert_n@2

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	edx, DWORD PTR [esi+8]
	push	edx
	push	ebx
	mov	ecx, esi
	call	?_Destroy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXPAVCvString@@0@Z ; std::vector<CvString,std::allocator<CvString> >::_Destroy

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN83@Insert_n@2:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	mov	eax, DWORD PTR __Newvec$217732[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [edi*8]
	sub	ecx, edi
	mov	DWORD PTR [esi+12], edx
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [esi+8], edx

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], eax

; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	mov	ebx, DWORD PTR __Ncopied$217734[ebp]
	cmp	ebx, 1

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	esi, DWORD PTR __Whereoff$217733[ebp]
	mov	edi, DWORD PTR __Newvec$217732[ebp]
	jle	SHORT $LN7@Insert_n@2
	lea	eax, DWORD PTR [esi*8]
	sub	eax, esi
	lea	ecx, DWORD PTR [edi+eax*4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	push	edi
	call	?_Destroy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXPAVCvString@@0@Z ; std::vector<CvString,std::allocator<CvString> >::_Destroy
$LN7@Insert_n@2:

; 1188 : 			if (0 < _Ncopied)

	test	ebx, ebx
	jle	SHORT $LN6@Insert_n@2

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [esi+edx]
	lea	ecx, DWORD PTR [eax*8]
	sub	ecx, eax
	lea	edx, DWORD PTR [edi+ecx*4]
	lea	eax, DWORD PTR [esi*8]
	sub	eax, esi
	lea	ecx, DWORD PTR [edi+eax*4]
	push	edx
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXPAVCvString@@0@Z ; std::vector<CvString,std::allocator<CvString> >::_Destroy
$LN6@Insert_n@2:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN104@Insert_n@2:
$LN10@Insert_n@2:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	sub	ebx, DWORD PTR __Where$[ebp]
	mov	eax, -1840700269			; 92492493H
	imul	ebx
	add	edx, ebx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, edi
	jae	$LN3@Insert_n@2

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Tmp$217747[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR __Where$[ebp]
	mov	ecx, DWORD PTR [esi+8]
	lea	ebx, DWORD PTR [edi*8]
	sub	ebx, edi
	add	ebx, ebx
	add	ebx, ebx
	lea	edx, DWORD PTR [ebx+eax]
	push	edx
	push	ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	??$_Umove@PAVCvString@@@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@PAV2@00@Z ; std::vector<CvString,std::allocator<CvString> >::_Umove<CvString *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR __Tmp$217747[ebp]
	push	edx
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	sub	edi, eax
	mov	eax, DWORD PTR [esi+8]
	push	edi
	push	eax
	mov	ecx, esi
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	call	?_Ufill@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@PAV3@IABV3@@Z ; std::vector<CvString,std::allocator<CvString> >::_Ufill

; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	add	DWORD PTR [esi+8], ebx
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	mov	edx, DWORD PTR __Where$[ebp]
	lea	ecx, DWORD PTR __Tmp$217747[ebp]
	push	ecx
	sub	esi, ebx
	push	esi
	push	edx
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	??$fill@PAVCvString@@V1@@std@@YAXPAVCvString@@0ABV1@@Z ; std::fill<CvString *,CvString>
	add	esp, 12					; 0000000cH

; 1232 : 			}

	lea	ecx, DWORD PTR __Tmp$217747[ebp]

; 1233 : 		else

	jmp	$LN102@Insert_n@2
__catch$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	eax, eax
	add	eax, eax
	add	edx, eax
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	add	eax, edx
	push	eax
	call	?_Destroy@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXPAVCvString@@0@Z ; std::vector<CvString,std::allocator<CvString> >::_Destroy

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN105@Insert_n@2:
$LN3@Insert_n@2:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$217757[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR [esi+8]

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	lea	ebx, DWORD PTR [edi*8]
	sub	ebx, edi
	add	ebx, ebx
	push	eax
	mov	edi, eax
	add	ebx, ebx
	push	eax
	sub	edi, ebx
	push	edi
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 5
	mov	DWORD PTR tv525[ebp], eax
	call	??$_Umove@PAVCvString@@@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEPAVCvString@@PAV2@00@Z ; std::vector<CvString,std::allocator<CvString> >::_Umove<CvString *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	ecx, DWORD PTR tv525[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	push	ecx
	push	edi
	push	edx
	mov	DWORD PTR [esi+8], eax
	call	??$_Unchecked_move_backward@PAVCvString@@PAV1@@stdext@@YAPAVCvString@@PAV1@00@Z ; stdext::_Unchecked_move_backward<CvString *,CvString *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$217757[ebp]
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	add	ebx, eax
	push	ebx
	push	eax
	call	??$fill@PAVCvString@@V1@@std@@YAXPAVCvString@@0ABV1@@Z ; std::fill<CvString *,CvString>
	add	esp, 24					; 00000018H

; 1249 : 			}

	lea	ecx, DWORD PTR __Tmp$217757[ebp]
$LN102@Insert_n@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@Insert_n@2:

; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN101@Insert_n@2:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$4:
	lea	ecx, DWORD PTR __Tmp$217747[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__unwindfunclet$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z$5:
	lea	ecx, DWORD PTR __Tmp$217757[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::_Insert_n
PUBLIC	?resize@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXIVCvString@@@Z ; std::vector<CvString,std::allocator<CvString> >::resize
;	COMDAT xdata$x
; File s:\lekmod_dll\cvgamecoredllutil\include\cvstring.h
xdata$x	SEGMENT
__unwindtable$?resize@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXIVCvString@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?resize@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXIVCvString@@@Z$0
__ehfuncinfo$?resize@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXIVCvString@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?resize@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXIVCvString@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\msvs2008\vc\include\vector
xdata$x	ENDS
;	COMDAT ?resize@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXIVCvString@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
$T221873 = 8						; size = 4
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 28
?resize@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXIVCvString@@@Z PROC ; std::vector<CvString,std::allocator<CvString> >::resize, COMDAT
; _this$ = ecx

; 717  : 		{	// determine new length, padding with _Val elements as needed

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?resize@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXIVCvString@@@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ebx
	push	esi
	push	edi

; 718  : 		if (size() < _Newsize)

	mov	edi, DWORD PTR [ecx+8]
	mov	ebx, DWORD PTR [ecx+4]
	mov	esi, edi
	sub	esi, ebx
	mov	eax, -1840700269			; 92492493H
	imul	esi
	add	edx, esi
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	edx, DWORD PTR __Newsize$[esp+20]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	cmp	edx, eax
	jbe	SHORT $LN41@resize@3

; 719  : 			_Insert_n(end(), _Newsize - size(), _Val);

	lea	esi, DWORD PTR __Val$[esp+20]
	push	esi
	sub	edx, eax
	push	edx
	push	edi
	call	?_Insert_n@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@IAEXV?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@IABVCvString@@@Z ; std::vector<CvString,std::allocator<CvString> >::_Insert_n
	jmp	SHORT $LN1@resize@3
$LN41@resize@3:

; 720  : 		else if (_Newsize < size())

	jae	SHORT $LN1@resize@3

; 721  : 			erase(begin() + _Newsize, end());

	lea	eax, DWORD PTR [edx*8]
	sub	eax, edx
	push	edi
	lea	eax, DWORD PTR [ebx+eax*4]
	push	eax
	lea	edx, DWORD PTR $T221873[esp+28]
	push	edx
	call	?erase@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE?AV?$_Vector_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@V?$_Vector_const_iterator@VCvString@@V?$allocator@VCvString@@@std@@@2@0@Z ; std::vector<CvString,std::allocator<CvString> >::erase
$LN1@resize@3:

; 722  : 		}

	lea	ecx, DWORD PTR __Val$[esp+20]
	mov	DWORD PTR __$EHRec$[esp+32], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	32					; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?resize@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXIVCvString@@@Z$0:
	lea	ecx, DWORD PTR __Val$[ebp-4]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?resize@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXIVCvString@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?resize@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXIVCvString@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?resize@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXIVCvString@@@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::resize
PUBLIC	?resize@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXI@Z ; std::vector<CvString,std::allocator<CvString> >::resize
; Function compile flags: /Ogtpy
;	COMDAT ?resize@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
$T221962 = -4						; size = 4
__Newsize$ = 8						; size = 4
?resize@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXI@Z PROC ; std::vector<CvString,std::allocator<CvString> >::resize, COMDAT
; _this$ = ecx

; 712  : 		{	// determine new length, padding with _Ty() elements as needed

	push	ecx
	push	esi

; 713  : 		resize(_Newsize, _Ty());

	sub	esp, 28					; 0000001cH
	mov	esi, ecx
	mov	ecx, esp
	mov	DWORD PTR $T221962[esp+36], esp
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR __Newsize$[esp+32]
	push	eax
	mov	ecx, esi
	call	?resize@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXIVCvString@@@Z ; std::vector<CvString,std::allocator<CvString> >::resize

; 714  : 		}

	pop	esi
	pop	ecx
	ret	4
?resize@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXI@Z ENDP ; std::vector<CvString,std::allocator<CvString> >::resize
_TEXT	ENDS
PUBLIC	??0PopupReturn@@QAE@ABV0@@Z			; PopupReturn::PopupReturn
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0PopupReturn@@QAE@ABV0@@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$??0PopupReturn@@QAE@ABV0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0PopupReturn@@QAE@ABV0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0PopupReturn@@QAE@ABV0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0PopupReturn@@QAE@ABV0@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0PopupReturn@@QAE@ABV0@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0PopupReturn@@QAE@ABV0@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0PopupReturn@@QAE@ABV0@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0PopupReturn@@QAE@ABV0@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0PopupReturn@@QAE@ABV0@@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$??0PopupReturn@@QAE@ABV0@@Z$7
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvpopupreturn.cpp
xdata$x	ENDS
;	COMDAT ??0PopupReturn@@QAE@ABV0@@Z
_TEXT	SEGMENT
$T223782 = -24						; size = 4
$T223428 = -24						; size = 4
$T223378 = -24						; size = 4
_this$ = -20						; size = 4
$T225841 = -16						; size = 4
$T225831 = -16						; size = 4
$T224637 = -16						; size = 4
$T224628 = -16						; size = 4
$T223894 = -16						; size = 4
__Result$223379 = -16					; size = 4
$T223772 = -16						; size = 4
__$EHRec$ = -12						; size = 12
tv3762 = 8						; size = 4
tv3633 = 8						; size = 4
tv3574 = 8						; size = 4
tv3531 = 8						; size = 4
tv3488 = 8						; size = 4
$T225477 = 8						; size = 4
$T225427 = 8						; size = 4
$T225037 = 8						; size = 4
$T225023 = 8						; size = 4
$T224238 = 8						; size = 4
$T224224 = 8						; size = 4
_popupReturn$ = 8					; size = 4
??0PopupReturn@@QAE@ABV0@@Z PROC			; PopupReturn::PopupReturn, COMDAT
; _this$ = ecx

; 19   : {

	push	-1
	push	__ehhandler$??0PopupReturn@@QAE@ABV0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	mov	ebp, ecx
	xor	eax, eax
	push	esi
	push	edi
	mov	DWORD PTR _this$[esp+40], ebp
	mov	DWORD PTR [ebp+4], eax
	mov	DWORD PTR [ebp+8], eax
	mov	DWORD PTR [ebp+12], eax
	lea	ebx, DWORD PTR [ebp+16]
	mov	DWORD PTR __$EHRec$[esp+48], eax
	mov	DWORD PTR [ebx+4], eax
	mov	DWORD PTR [ebx+8], eax
	mov	DWORD PTR [ebx+12], eax
	mov	DWORD PTR [ebp+36], eax
	mov	DWORD PTR [ebp+40], eax
	mov	DWORD PTR [ebp+44], eax
	mov	DWORD PTR [ebp+52], eax
	mov	DWORD PTR [ebp+56], eax
	mov	DWORD PTR [ebp+60], eax
	mov	DWORD PTR [ebp+68], eax
	mov	DWORD PTR [ebp+72], eax
	mov	DWORD PTR [ebp+76], eax
	mov	DWORD PTR [ebp+84], eax
	mov	DWORD PTR [ebp+88], eax
	mov	DWORD PTR [ebp+92], eax
	mov	DWORD PTR [ebp+100], eax
	mov	DWORD PTR [ebp+104], eax
	mov	DWORD PTR [ebp+108], eax
	mov	DWORD PTR [ebp+116], eax
	mov	DWORD PTR [ebp+120], eax
	mov	DWORD PTR [ebp+124], eax

; 20   : 	int iI;
; 21   : 
; 22   : 	for(iI = 0; iI < popupReturn.getRadioButtonSize(); iI++)

	mov	esi, DWORD PTR _popupReturn$[esp+36]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, DWORD PTR [esi+4]
	mov	BYTE PTR __$EHRec$[esp+48], 7
	test	ecx, -4					; fffffffcH
	jle	$LN30@PopupRetur
	mov	DWORD PTR tv3488[esp+36], eax
	lea	edi, DWORD PTR [eax+1]
$LL32@PopupRetur:

; 23   : 	{
; 24   : 		CvPopup_SetAtGrow(m_aiSelectedRadioButton, iI, popupReturn.getSelectedRadioButton(iI));

	mov	ecx, DWORD PTR [ebp+8]
	mov	edx, DWORD PTR [ebp+4]
	mov	eax, ecx
	sub	eax, edx
	sar	eax, 2
	lea	edx, DWORD PTR [edi-1]
	cmp	eax, edx
	jg	SHORT $LN929@PopupRetur
	mov	DWORD PTR $T223378[esp+40], 0
	cmp	edi, eax
	jbe	SHORT $LN942@PopupRetur
	lea	edx, DWORD PTR $T223378[esp+40]
	push	edx
	mov	edx, edi
	sub	edx, eax
	push	edx
	push	ecx
	mov	ecx, ebp
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
	jmp	SHORT $LN929@PopupRetur
$LN942@PopupRetur:
	jae	SHORT $LN929@PopupRetur
	mov	eax, DWORD PTR [ebp+4]
	mov	edx, DWORD PTR tv3488[esp+36]
	lea	eax, DWORD PTR [eax+edx+4]
	mov	DWORD PTR $T223428[esp+40], eax
	cmp	eax, ecx
	je	SHORT $LN929@PopupRetur
	mov	ebp, DWORD PTR $T223428[esp+40]
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	add	ebp, edx
	mov	DWORD PTR __Result$223379[esp+40], ebp
	test	eax, eax
	jle	SHORT $LN927@PopupRetur
	mov	eax, DWORD PTR $T223428[esp+40]
	push	edx
	push	ecx
	push	edx
	push	eax
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN927@PopupRetur:
	mov	ebp, DWORD PTR _this$[esp+40]
	mov	ecx, DWORD PTR __Result$223379[esp+40]
	mov	DWORD PTR [ebp+8], ecx
$LN929@PopupRetur:
	mov	eax, DWORD PTR tv3488[esp+36]
	mov	edx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [eax+edx]
	mov	ecx, DWORD PTR [ebp+4]
	mov	DWORD PTR [eax+ecx], edx
	add	eax, 4
	mov	DWORD PTR tv3488[esp+36], eax
	mov	eax, DWORD PTR [esi+8]
	sub	eax, DWORD PTR [esi+4]
	inc	edi
	sar	eax, 2
	lea	ecx, DWORD PTR [edi-1]
	cmp	ecx, eax
	jl	$LL32@PopupRetur

; 20   : 	int iI;
; 21   : 
; 22   : 	for(iI = 0; iI < popupReturn.getRadioButtonSize(); iI++)

	xor	eax, eax
$LN30@PopupRetur:

; 25   : 	}
; 26   : 
; 27   : 	for(iI = 0; iI < popupReturn.getCheckboxSize(); iI++)

	mov	edx, DWORD PTR [esi+24]
	sub	edx, DWORD PTR [esi+20]
	test	edx, -4					; fffffffcH
	jle	$LN26@PopupRetur
	mov	DWORD PTR tv3531[esp+36], eax
	mov	edi, 1
	jmp	SHORT $LN28@PopupRetur
$LL930@PopupRetur:
	xor	eax, eax
$LN28@PopupRetur:

; 28   : 	{
; 29   : 		CvPopup_SetAtGrow(m_aiBitField, iI, popupReturn.getCheckboxBitfield(iI));

	mov	ecx, DWORD PTR [ebx+8]
	sub	ecx, DWORD PTR [ebx+4]
	lea	edx, DWORD PTR [edi-1]
	sar	ecx, 2
	cmp	ecx, edx
	jg	SHORT $LN931@PopupRetur
	mov	ecx, DWORD PTR [ebx+8]
	mov	edx, DWORD PTR [ebx+4]
	mov	DWORD PTR $T223772[esp+40], eax
	mov	eax, ecx
	sub	eax, edx
	sar	eax, 2
	cmp	edi, eax
	jbe	SHORT $LN943@PopupRetur
	lea	edx, DWORD PTR $T223772[esp+40]
	push	edx
	mov	edx, edi
	sub	edx, eax
	push	edx
	push	ecx
	mov	ecx, ebx
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
	jmp	SHORT $LN931@PopupRetur
$LN943@PopupRetur:
	jae	SHORT $LN931@PopupRetur
	mov	eax, DWORD PTR tv3531[esp+36]
	lea	eax, DWORD PTR [edx+eax+4]
	mov	DWORD PTR $T223782[esp+40], eax
	cmp	eax, ecx
	je	SHORT $LN931@PopupRetur
	mov	ebp, DWORD PTR $T223782[esp+40]
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	add	ebp, edx
	test	eax, eax
	jle	SHORT $LN928@PopupRetur
	push	edx
	push	ecx
	mov	ecx, DWORD PTR $T223782[esp+48]
	push	edx
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN928@PopupRetur:
	mov	DWORD PTR [ebx+8], ebp
	mov	ebp, DWORD PTR _this$[esp+40]
$LN931@PopupRetur:
	mov	eax, DWORD PTR tv3531[esp+36]
	mov	edx, DWORD PTR [esi+20]
	mov	edx, DWORD PTR [eax+edx]
	mov	ecx, DWORD PTR [ebp+20]
	mov	DWORD PTR [eax+ecx], edx
	add	eax, 4
	mov	DWORD PTR tv3531[esp+36], eax
	mov	eax, DWORD PTR [esi+24]
	sub	eax, DWORD PTR [esi+20]
	inc	edi
	sar	eax, 2
	lea	ecx, DWORD PTR [edi-1]
	cmp	ecx, eax
	jl	$LL930@PopupRetur
$LN26@PopupRetur:

; 30   : 	}
; 31   : 
; 32   : 	for(iI = 0; iI < popupReturn.getEditboxSize(); iI++)

	mov	ecx, DWORD PTR [esi+40]
	sub	ecx, DWORD PTR [esi+36]
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	xor	edi, edi
	test	eax, eax
	jle	$LN932@PopupRetur
	mov	DWORD PTR tv3574[esp+36], edi
$LL24@PopupRetur:

; 33   : 	{
; 34   : 		CvPopup_SetAtGrow(m_aszEditBoxString, iI, popupReturn.getEditBoxString(iI));

	mov	ecx, DWORD PTR [ebp+40]
	sub	ecx, DWORD PTR [ebp+36]
	lea	ebx, DWORD PTR [ebp+32]
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	cmp	ecx, edi
	jg	SHORT $LN492@PopupRetur
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T223894[esp+68], esp
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	edx, DWORD PTR [edi+1]
	push	edx
	mov	ecx, ebx
	call	?resize@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXIVCvString@@@Z ; std::vector<CvString,std::allocator<CvString> >::resize
$LN492@PopupRetur:
	mov	ecx, DWORD PTR [esi+40]
	sub	ecx, DWORD PTR [esi+36]
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	edi, eax
	jae	SHORT $LN498@PopupRetur
	mov	ecx, DWORD PTR [esi+36]
	add	ecx, DWORD PTR tv3574[esp+36]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	jmp	SHORT $LN499@PopupRetur
$LN498@PopupRetur:
	xor	eax, eax
$LN499@PopupRetur:
	mov	ecx, DWORD PTR [ebp+36]
	add	ecx, DWORD PTR tv3574[esp+36]
	test	eax, eax
	je	SHORT $LN510@PopupRetur
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN23@PopupRetur
$LN510@PopupRetur:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN23@PopupRetur:

; 30   : 	}
; 31   : 
; 32   : 	for(iI = 0; iI < popupReturn.getEditboxSize(); iI++)

	mov	ecx, DWORD PTR [esi+40]
	sub	ecx, DWORD PTR [esi+36]
	add	DWORD PTR tv3574[esp+36], 28		; 0000001cH
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	inc	edi
	add	ecx, edx
	cmp	edi, ecx
	jl	$LL24@PopupRetur
$LN932@PopupRetur:

; 35   : 	}
; 36   : 
; 37   : 	for(iI = 0; iI < popupReturn.getSpinnerWidsize(); iI++)

	mov	edx, DWORD PTR [esi+56]
	sub	edx, DWORD PTR [esi+52]
	xor	edi, edi
	test	edx, -4					; fffffffcH
	jle	$LN18@PopupRetur
	npad	2
$LL20@PopupRetur:

; 38   : 	{
; 39   : 		CvPopup_SetAtGrow(m_aiSpinnerWidgetValues, iI, popupReturn.getSpinnerWidgetValue(iI));

	mov	eax, DWORD PTR [ebp+56]
	sub	eax, DWORD PTR [ebp+52]
	sar	eax, 2
	cmp	eax, edi
	jg	SHORT $LN556@PopupRetur
	mov	ecx, DWORD PTR [ebp+56]
	mov	ebx, DWORD PTR [ebp+52]
	mov	eax, ecx
	sub	eax, ebx
	sar	eax, 2
	lea	edx, DWORD PTR [edi+1]
	mov	DWORD PTR $T224224[esp+36], 0
	cmp	edx, eax
	jbe	SHORT $LN944@PopupRetur
	lea	ebx, DWORD PTR $T224224[esp+36]
	push	ebx
	sub	edx, eax
	push	edx
	push	ecx
	lea	ecx, DWORD PTR [ebp+48]
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
	jmp	SHORT $LN556@PopupRetur
$LN944@PopupRetur:
	jae	SHORT $LN556@PopupRetur
	lea	ebx, DWORD PTR [ebx+edi*4+4]
	mov	DWORD PTR $T224238[esp+36], ebx
	cmp	ebx, ecx
	je	SHORT $LN556@PopupRetur
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	add	ebx, edx
	test	eax, eax
	jle	SHORT $LN581@PopupRetur
	push	edx
	push	ecx
	mov	ecx, DWORD PTR $T224238[esp+44]
	push	edx
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN581@PopupRetur:
	mov	DWORD PTR [ebp+56], ebx
$LN556@PopupRetur:
	mov	edx, DWORD PTR [esi+120]
	sub	edx, DWORD PTR [esi+116]
	sar	edx, 2
	cmp	edi, edx
	jae	SHORT $LN586@PopupRetur
	mov	eax, DWORD PTR [esi+116]
	mov	eax, DWORD PTR [eax+edi*4]
	jmp	SHORT $LN587@PopupRetur
$LN586@PopupRetur:
	or	eax, -1
$LN587@PopupRetur:
	mov	ecx, DWORD PTR [ebp+52]
	mov	DWORD PTR [ecx+edi*4], eax
	mov	edx, DWORD PTR [esi+56]
	sub	edx, DWORD PTR [esi+52]
	inc	edi
	sar	edx, 2
	cmp	edi, edx
	jl	$LL20@PopupRetur
$LN18@PopupRetur:

; 40   : 	}
; 41   : 
; 42   : 	for(iI = 0; iI < popupReturn.getPulldownSize(); iI++)

	mov	eax, DWORD PTR [esi+72]
	sub	eax, DWORD PTR [esi+68]
	test	eax, -4					; fffffffcH
	jle	$LN933@PopupRetur
	mov	DWORD PTR tv3633[esp+36], 0
	mov	edi, 1
$LL16@PopupRetur:

; 43   : 	{
; 44   : 		CvPopup_SetAtGrow(m_aiPulldownID, iI, popupReturn.getSelectedPullDownValue(iI));

	mov	ecx, DWORD PTR [ebp+72]
	sub	ecx, DWORD PTR [ebp+68]
	lea	edx, DWORD PTR [ebp+64]
	sar	ecx, 2
	lea	eax, DWORD PTR [edi-1]
	cmp	ecx, eax
	jg	SHORT $LN935@PopupRetur
	mov	ecx, DWORD PTR [edx+8]
	mov	ebx, DWORD PTR [edx+4]
	mov	eax, ecx
	sub	eax, ebx
	sar	eax, 2
	mov	DWORD PTR $T224628[esp+40], 0
	cmp	edi, eax
	jbe	SHORT $LN945@PopupRetur
	lea	ebx, DWORD PTR $T224628[esp+40]
	push	ebx
	mov	ebx, edi
	sub	ebx, eax
	push	ebx
	push	ecx
	mov	ecx, edx
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
	jmp	SHORT $LN935@PopupRetur
$LN945@PopupRetur:
	jae	SHORT $LN935@PopupRetur
	mov	edx, DWORD PTR tv3633[esp+36]
	lea	ebx, DWORD PTR [ebx+edx+4]
	mov	DWORD PTR $T224637[esp+40], ebx
	cmp	ebx, ecx
	je	SHORT $LN935@PopupRetur
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	add	ebx, edx
	test	eax, eax
	jle	SHORT $LN662@PopupRetur
	mov	eax, DWORD PTR $T224637[esp+40]
	push	edx
	push	ecx
	push	edx
	push	eax
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN662@PopupRetur:
	mov	DWORD PTR [ebp+72], ebx
$LN935@PopupRetur:
	mov	eax, DWORD PTR tv3633[esp+36]
	mov	ecx, DWORD PTR [esi+68]
	mov	ecx, DWORD PTR [eax+ecx]
	mov	edx, DWORD PTR [ebp+68]
	mov	DWORD PTR [eax+edx], ecx
	mov	edx, DWORD PTR [esi+72]
	sub	edx, DWORD PTR [esi+68]
	add	eax, 4
	inc	edi
	mov	DWORD PTR tv3633[esp+36], eax
	sar	edx, 2
	lea	eax, DWORD PTR [edi-1]
	cmp	eax, edx
	jl	$LL16@PopupRetur
$LN933@PopupRetur:

; 45   : 	}
; 46   : 
; 47   : 	for(iI = 0; iI < popupReturn.getListBoxSize(); iI++)

	mov	ecx, DWORD PTR [esi+88]
	sub	ecx, DWORD PTR [esi+84]
	xor	edi, edi
	test	ecx, -4					; fffffffcH
	jle	$LN10@PopupRetur
	npad	6
$LL12@PopupRetur:

; 48   : 	{
; 49   : 		CvPopup_SetAtGrow(m_aiListBoxID, iI, popupReturn.getSelectedListBoxValue(iI));

	mov	edx, DWORD PTR [ebp+88]
	sub	edx, DWORD PTR [ebp+84]
	sar	edx, 2
	cmp	edx, edi
	jg	SHORT $LN714@PopupRetur
	mov	ecx, DWORD PTR [ebp+88]
	mov	ebx, DWORD PTR [ebp+84]
	mov	eax, ecx
	sub	eax, ebx
	sar	eax, 2
	lea	edx, DWORD PTR [edi+1]
	mov	DWORD PTR $T225023[esp+36], 0
	cmp	edx, eax
	jbe	SHORT $LN946@PopupRetur
	lea	ebx, DWORD PTR $T225023[esp+36]
	push	ebx
	sub	edx, eax
	push	edx
	push	ecx
	lea	ecx, DWORD PTR [ebp+80]
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
	jmp	SHORT $LN714@PopupRetur
$LN946@PopupRetur:
	jae	SHORT $LN714@PopupRetur
	lea	ebx, DWORD PTR [ebx+edi*4+4]
	mov	DWORD PTR $T225037[esp+36], ebx
	cmp	ebx, ecx
	je	SHORT $LN714@PopupRetur
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	add	ebx, edx
	test	eax, eax
	jle	SHORT $LN739@PopupRetur
	mov	eax, DWORD PTR $T225037[esp+36]
	push	edx
	push	ecx
	push	edx
	push	eax
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN739@PopupRetur:
	mov	DWORD PTR [ebp+88], ebx
$LN714@PopupRetur:
	mov	ecx, DWORD PTR [esi+88]
	sub	ecx, DWORD PTR [esi+84]
	sar	ecx, 2
	cmp	edi, ecx
	jae	SHORT $LN744@PopupRetur
	mov	edx, DWORD PTR [esi+84]
	mov	eax, DWORD PTR [edx+edi*4]
	jmp	SHORT $LN745@PopupRetur
$LN744@PopupRetur:
	or	eax, -1
$LN745@PopupRetur:
	mov	ecx, DWORD PTR [ebp+84]
	mov	DWORD PTR [ecx+edi*4], eax
	mov	edx, DWORD PTR [esi+88]
	sub	edx, DWORD PTR [esi+84]
	inc	edi
	sar	edx, 2
	cmp	edi, edx
	jl	$LL12@PopupRetur
$LN10@PopupRetur:

; 50   : 	}
; 51   : 
; 52   : 	for(iI = 0; iI < popupReturn.getSpinBoxSize(); iI++)

	mov	eax, DWORD PTR [esi+120]
	sub	eax, DWORD PTR [esi+116]
	xor	edi, edi
	test	eax, -4					; fffffffcH
	jle	$LN6@PopupRetur
$LL8@PopupRetur:

; 53   : 	{
; 54   : 		CvPopup_SetAtGrow(m_aiSpinBoxID, iI, popupReturn.getSpinnerWidgetValue(iI));

	mov	ecx, DWORD PTR [ebp+120]
	sub	ecx, DWORD PTR [ebp+116]
	sar	ecx, 2
	cmp	ecx, edi
	jg	SHORT $LN795@PopupRetur
	mov	ecx, DWORD PTR [ebp+120]
	mov	ebx, DWORD PTR [ebp+116]
	mov	eax, ecx
	sub	eax, ebx
	sar	eax, 2
	lea	edx, DWORD PTR [edi+1]
	mov	DWORD PTR $T225427[esp+36], 0
	cmp	edx, eax
	jbe	SHORT $LN947@PopupRetur
	lea	ebx, DWORD PTR $T225427[esp+36]
	push	ebx
	sub	edx, eax
	push	edx
	push	ecx
	lea	ecx, DWORD PTR [ebp+112]
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
	jmp	SHORT $LN795@PopupRetur
$LN947@PopupRetur:
	jae	SHORT $LN795@PopupRetur
	lea	ebx, DWORD PTR [ebx+edi*4+4]
	mov	DWORD PTR $T225477[esp+36], ebx
	cmp	ebx, ecx
	je	SHORT $LN795@PopupRetur
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	add	ebx, edx
	test	eax, eax
	jle	SHORT $LN820@PopupRetur
	push	edx
	push	ecx
	push	edx
	mov	edx, DWORD PTR $T225477[esp+48]
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN820@PopupRetur:
	mov	DWORD PTR [ebp+120], ebx
$LN795@PopupRetur:
	mov	eax, DWORD PTR [esi+120]
	sub	eax, DWORD PTR [esi+116]
	sar	eax, 2
	cmp	edi, eax
	jae	SHORT $LN825@PopupRetur
	mov	ecx, DWORD PTR [esi+116]
	mov	eax, DWORD PTR [ecx+edi*4]
	jmp	SHORT $LN826@PopupRetur
$LN825@PopupRetur:
	or	eax, -1
$LN826@PopupRetur:
	mov	edx, DWORD PTR [ebp+116]
	mov	DWORD PTR [edx+edi*4], eax
	mov	eax, DWORD PTR [esi+120]
	sub	eax, DWORD PTR [esi+116]
	inc	edi
	sar	eax, 2
	cmp	edi, eax
	jl	$LL8@PopupRetur
$LN6@PopupRetur:

; 55   : 	}
; 56   : 
; 57   : 	for(iI = 0; iI < popupReturn.GetButtonSize(); iI++)

	mov	ecx, DWORD PTR [esi+104]
	sub	ecx, DWORD PTR [esi+100]
	test	ecx, -4					; fffffffcH
	jle	$LN926@PopupRetur
	mov	DWORD PTR tv3762[esp+36], 0
	mov	edi, 1
$LL4@PopupRetur:

; 58   : 	{
; 59   : 		CvPopup_SetAtGrow(m_aiButtonID, iI, popupReturn.GetButtonClicked(iI));

	mov	eax, DWORD PTR [ebp+104]
	sub	eax, DWORD PTR [ebp+100]
	lea	edx, DWORD PTR [ebp+96]
	sar	eax, 2
	lea	ecx, DWORD PTR [edi-1]
	cmp	eax, ecx
	jg	SHORT $LN937@PopupRetur
	mov	ecx, DWORD PTR [edx+8]
	mov	ebx, DWORD PTR [edx+4]
	mov	eax, ecx
	sub	eax, ebx
	sar	eax, 2
	mov	DWORD PTR $T225831[esp+40], 0
	cmp	edi, eax
	jbe	SHORT $LN948@PopupRetur
	lea	ebx, DWORD PTR $T225831[esp+40]
	push	ebx
	mov	ebx, edi
	sub	ebx, eax
	push	ebx
	push	ecx
	mov	ecx, edx
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
	jmp	SHORT $LN937@PopupRetur
$LN948@PopupRetur:
	jae	SHORT $LN937@PopupRetur
	mov	edx, DWORD PTR tv3762[esp+36]
	lea	ebx, DWORD PTR [edx+ebx+4]
	mov	DWORD PTR $T225841[esp+40], ebx
	cmp	ebx, ecx
	je	SHORT $LN937@PopupRetur
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	add	ebx, edx
	test	eax, eax
	jle	SHORT $LN901@PopupRetur
	mov	eax, DWORD PTR $T225841[esp+40]
	push	edx
	push	ecx
	push	edx
	push	eax
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN901@PopupRetur:
	mov	DWORD PTR [ebp+104], ebx
$LN937@PopupRetur:
	mov	eax, DWORD PTR tv3762[esp+36]
	mov	ecx, DWORD PTR [esi+100]
	mov	ecx, DWORD PTR [eax+ecx]
	mov	edx, DWORD PTR [ebp+100]
	mov	DWORD PTR [eax+edx], ecx
	mov	edx, DWORD PTR [esi+104]
	sub	edx, DWORD PTR [esi+100]
	add	eax, 4
	inc	edi
	mov	DWORD PTR tv3762[esp+36], eax
	sar	edx, 2
	lea	eax, DWORD PTR [edi-1]
	cmp	eax, edx
	jl	$LL4@PopupRetur
$LN926@PopupRetur:

; 60   : 	}
; 61   : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	pop	edi
	pop	esi
	mov	eax, ebp
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 24					; 00000018H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0PopupReturn@@QAE@ABV0@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??0PopupReturn@@QAE@ABV0@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??0PopupReturn@@QAE@ABV0@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	jmp	??1?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAE@XZ ; std::vector<CvString,std::allocator<CvString> >::~vector<CvString,std::allocator<CvString> >
__unwindfunclet$??0PopupReturn@@QAE@ABV0@@Z$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??0PopupReturn@@QAE@ABV0@@Z$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??0PopupReturn@@QAE@ABV0@@Z$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 80					; 00000050H
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??0PopupReturn@@QAE@ABV0@@Z$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 96					; 00000060H
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??0PopupReturn@@QAE@ABV0@@Z$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	jmp	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__ehhandler$??0PopupReturn@@QAE@ABV0@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0PopupReturn@@QAE@ABV0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0PopupReturn@@QAE@ABV0@@Z ENDP			; PopupReturn::PopupReturn
PUBLIC	??4PopupReturn@@QAEAAV0@ABV0@@Z			; PopupReturn::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4PopupReturn@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Result$228796 = -4					; size = 4
$T228724 = -4						; size = 4
__Result$227550 = -4					; size = 4
$T227521 = -4						; size = 4
__Result$226737 = -4					; size = 4
$T226665 = -4						; size = 4
$T226271 = -4						; size = 4
tv2848 = 8						; size = 4
tv2719 = 8						; size = 4
tv2617 = 8						; size = 4
tv2574 = 8						; size = 4
__Result$228402 = 8					; size = 4
__Result$227998 = 8					; size = 4
$T228320 = 8						; size = 4
$T227916 = 8						; size = 4
__Result$227199 = 8					; size = 4
$T227117 = 8						; size = 4
$T226787 = 8						; size = 4
_source$ = 8						; size = 4
??4PopupReturn@@QAEAAV0@ABV0@@Z PROC			; PopupReturn::operator=, COMDAT
; _this$ = ecx

; 65   : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi

; 66   : 	int iI;
; 67   : 
; 68   : 	for(iI = 0; iI < source.getRadioButtonSize(); iI++)

	mov	esi, DWORD PTR _source$[esp+16]
	mov	eax, DWORD PTR [esi+8]
	sub	eax, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR _this$[esp+24], ecx
	test	eax, -4					; fffffffcH
	jle	$LN30@operator@2
	xor	ebx, ebx
	mov	DWORD PTR tv2574[esp+20], ebx
	lea	edi, DWORD PTR [ebx+1]
	npad	7
$LL32@operator@2:

; 69   : 	{
; 70   : 		CvPopup_SetAtGrow(m_aiSelectedRadioButton, iI, source.getSelectedRadioButton(iI));

	mov	eax, DWORD PTR _this$[esp+24]
	mov	ecx, DWORD PTR [eax+8]
	mov	ebp, DWORD PTR [eax+4]
	mov	eax, ecx
	sub	eax, ebp
	sar	eax, 2
	lea	edx, DWORD PTR [edi-1]
	cmp	eax, edx
	jg	SHORT $LN78@operator@2
	mov	DWORD PTR $T226271[esp+24], 0
	cmp	edi, eax
	jbe	SHORT $LN630@operator@2
	lea	edx, DWORD PTR $T226271[esp+24]
	push	edx
	mov	edx, edi
	sub	edx, eax
	push	edx
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+36]
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
	jmp	SHORT $LN78@operator@2
$LN630@operator@2:
	jae	SHORT $LN78@operator@2
	lea	ebp, DWORD PTR [ebx+ebp+4]
	cmp	ebp, ecx
	je	SHORT $LN78@operator@2
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	ebx, DWORD PTR [edx+ebp]
	test	eax, eax
	jle	SHORT $LN103@operator@2
	push	edx
	push	ecx
	push	edx
	push	ebp
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN103@operator@2:
	mov	eax, DWORD PTR _this$[esp+24]
	mov	DWORD PTR [eax+8], ebx
	mov	ebx, DWORD PTR tv2574[esp+20]
$LN78@operator@2:
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR _this$[esp+24]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [ebx+ecx]
	mov	DWORD PTR [ebx+eax], ecx
	mov	edx, DWORD PTR [esi+8]
	sub	edx, DWORD PTR [esi+4]
	inc	edi
	add	ebx, 4
	sar	edx, 2
	lea	eax, DWORD PTR [edi-1]
	cmp	eax, edx
	mov	DWORD PTR tv2574[esp+20], ebx
	jl	$LL32@operator@2
$LN30@operator@2:

; 71   : 	}
; 72   : 
; 73   : 	for(iI = 0; iI < source.getCheckboxSize(); iI++)

	mov	ecx, DWORD PTR [esi+24]
	sub	ecx, DWORD PTR [esi+20]
	test	ecx, -4					; fffffffcH
	jle	$LN26@operator@2
	mov	ebp, DWORD PTR _this$[esp+24]
	add	ebp, 16					; 00000010H
	mov	DWORD PTR tv2617[esp+20], 0
	mov	edi, 1
$LL28@operator@2:

; 74   : 	{
; 75   : 		CvPopup_SetAtGrow(m_aiBitField, iI, source.getCheckboxBitfield(iI));

	mov	edx, DWORD PTR [ebp+8]
	sub	edx, DWORD PTR [ebp+4]
	lea	eax, DWORD PTR [edi-1]
	sar	edx, 2
	cmp	edx, eax
	jg	SHORT $LN155@operator@2
	mov	ecx, DWORD PTR [ebp+8]
	mov	ebx, DWORD PTR [ebp+4]
	mov	eax, ecx
	sub	eax, ebx
	sar	eax, 2
	mov	DWORD PTR $T226665[esp+24], 0
	cmp	edi, eax
	jbe	SHORT $LN631@operator@2
	lea	edx, DWORD PTR $T226665[esp+24]
	push	edx
	mov	edx, edi
	sub	edx, eax
	push	edx
	push	ecx
	mov	ecx, ebp
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
	jmp	SHORT $LN155@operator@2
$LN631@operator@2:
	jae	SHORT $LN155@operator@2
	mov	eax, DWORD PTR tv2617[esp+20]
	lea	ebx, DWORD PTR [ebx+eax+4]
	cmp	ebx, ecx
	je	SHORT $LN155@operator@2
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	ebp, DWORD PTR [edx+ebx]
	mov	DWORD PTR __Result$226737[esp+24], ebp
	test	eax, eax
	jle	SHORT $LN180@operator@2
	push	edx
	push	ecx
	push	edx
	push	ebx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN180@operator@2:
	mov	ebp, DWORD PTR _this$[esp+24]
	mov	ecx, DWORD PTR __Result$226737[esp+24]
	add	ebp, 16					; 00000010H
	mov	DWORD PTR [ebp+8], ecx
$LN155@operator@2:
	mov	eax, DWORD PTR _this$[esp+24]
	mov	ecx, DWORD PTR [eax+20]
	mov	eax, DWORD PTR tv2617[esp+20]
	mov	edx, DWORD PTR [esi+20]
	mov	edx, DWORD PTR [eax+edx]
	mov	DWORD PTR [eax+ecx], edx
	add	eax, 4
	mov	DWORD PTR tv2617[esp+20], eax
	mov	eax, DWORD PTR [esi+24]
	sub	eax, DWORD PTR [esi+20]
	inc	edi
	sar	eax, 2
	lea	ecx, DWORD PTR [edi-1]
	cmp	ecx, eax
	jl	$LL28@operator@2
$LN26@operator@2:

; 76   : 	}
; 77   : 
; 78   : 	for(iI = 0; iI < source.getEditboxSize(); iI++)

	mov	ecx, DWORD PTR [esi+40]
	sub	ecx, DWORD PTR [esi+36]
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	xor	edi, edi
	test	eax, eax
	jle	$LN22@operator@2

; 81   : 	}
; 82   : 
; 83   : 	for(iI = 0; iI < source.getSpinnerWidsize(); iI++)

	mov	ebp, DWORD PTR _this$[esp+24]
	add	ebp, 32					; 00000020H
	xor	ebx, ebx
	npad	2
$LL24@operator@2:
	mov	ecx, DWORD PTR [ebp+8]
	sub	ecx, DWORD PTR [ebp+4]
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	cmp	ecx, edi
	jg	SHORT $LN195@operator@2
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T226787[esp+48], esp
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	edx, DWORD PTR [edi+1]
	push	edx
	mov	ecx, ebp
	call	?resize@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXIVCvString@@@Z ; std::vector<CvString,std::allocator<CvString> >::resize
$LN195@operator@2:
	mov	ecx, DWORD PTR [esi+40]
	sub	ecx, DWORD PTR [esi+36]
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	edi, eax
	jae	SHORT $LN201@operator@2
	mov	ecx, DWORD PTR [esi+36]
	add	ecx, ebx
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	jmp	SHORT $LN202@operator@2

; 79   : 	{
; 80   : 		CvPopup_SetAtGrow(m_aszEditBoxString, iI, source.getEditBoxString(iI));

$LN201@operator@2:
	xor	eax, eax
$LN202@operator@2:
	mov	ecx, DWORD PTR _this$[esp+24]
	mov	ecx, DWORD PTR [ecx+36]
	add	ecx, ebx
	test	eax, eax
	je	SHORT $LN213@operator@2
	push	eax
	call	DWORD PTR __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
	jmp	SHORT $LN23@operator@2
$LN213@operator@2:
	call	DWORD PTR __imp_?clear@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
$LN23@operator@2:

; 76   : 	}
; 77   : 
; 78   : 	for(iI = 0; iI < source.getEditboxSize(); iI++)

	mov	ecx, DWORD PTR [esi+40]
	sub	ecx, DWORD PTR [esi+36]
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	inc	edi
	add	eax, edx
	add	ebx, 28					; 0000001cH
	cmp	edi, eax
	jl	$LL24@operator@2
$LN22@operator@2:

; 81   : 	}
; 82   : 
; 83   : 	for(iI = 0; iI < source.getSpinnerWidsize(); iI++)

	mov	ecx, DWORD PTR [esi+56]
	sub	ecx, DWORD PTR [esi+52]
	xor	edi, edi
	test	ecx, -4					; fffffffcH
	jle	$LN18@operator@2
	mov	ebp, DWORD PTR _this$[esp+24]
	add	ebp, 48					; 00000030H
	npad	1
$LL20@operator@2:

; 84   : 	{
; 85   : 		CvPopup_SetAtGrow(m_aiSpinnerWidgetValues, iI, source.getSpinnerWidgetValue(iI));

	mov	edx, DWORD PTR [ebp+8]
	sub	edx, DWORD PTR [ebp+4]
	sar	edx, 2
	cmp	edx, edi
	jg	SHORT $LN259@operator@2
	mov	ecx, DWORD PTR [ebp+8]
	mov	ebx, DWORD PTR [ebp+4]
	mov	eax, ecx
	sub	eax, ebx
	sar	eax, 2
	lea	edx, DWORD PTR [edi+1]
	mov	DWORD PTR $T227117[esp+20], 0
	cmp	edx, eax
	jbe	SHORT $LN632@operator@2
	lea	ebx, DWORD PTR $T227117[esp+20]
	push	ebx
	sub	edx, eax
	push	edx
	push	ecx
	mov	ecx, ebp
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
	jmp	SHORT $LN259@operator@2
$LN632@operator@2:
	jae	SHORT $LN259@operator@2
	lea	ebx, DWORD PTR [ebx+edi*4+4]
	cmp	ebx, ecx
	je	SHORT $LN259@operator@2
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	ebp, DWORD PTR [edx+ebx]
	mov	DWORD PTR __Result$227199[esp+20], ebp
	test	eax, eax
	jle	SHORT $LN284@operator@2
	push	edx
	push	ecx
	push	edx
	push	ebx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN284@operator@2:
	mov	ebp, DWORD PTR _this$[esp+24]
	mov	eax, DWORD PTR __Result$227199[esp+20]
	add	ebp, 48					; 00000030H
	mov	DWORD PTR [ebp+8], eax
$LN259@operator@2:
	mov	ecx, DWORD PTR [esi+120]
	sub	ecx, DWORD PTR [esi+116]
	sar	ecx, 2
	cmp	edi, ecx
	jae	SHORT $LN289@operator@2
	mov	edx, DWORD PTR [esi+116]
	mov	eax, DWORD PTR [edx+edi*4]
	jmp	SHORT $LN290@operator@2
$LN289@operator@2:
	or	eax, -1
$LN290@operator@2:
	mov	ecx, DWORD PTR _this$[esp+24]
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR [edx+edi*4], eax
	mov	eax, DWORD PTR [esi+56]
	sub	eax, DWORD PTR [esi+52]
	inc	edi
	sar	eax, 2
	cmp	edi, eax
	jl	$LL20@operator@2
$LN18@operator@2:

; 86   : 	}
; 87   : 
; 88   : 	for(iI = 0; iI < source.getPulldownSize(); iI++)

	mov	ecx, DWORD PTR [esi+72]
	sub	ecx, DWORD PTR [esi+68]
	test	ecx, -4					; fffffffcH
	jle	$LN14@operator@2
	mov	ebp, DWORD PTR _this$[esp+24]
	add	ebp, 64					; 00000040H
	mov	DWORD PTR tv2719[esp+20], 0
	mov	edi, 1
$LL16@operator@2:

; 89   : 	{
; 90   : 		CvPopup_SetAtGrow(m_aiPulldownID, iI, source.getSelectedPullDownValue(iI));

	mov	edx, DWORD PTR [ebp+8]
	sub	edx, DWORD PTR [ebp+4]
	lea	eax, DWORD PTR [edi-1]
	sar	edx, 2
	cmp	edx, eax
	jg	SHORT $LN340@operator@2
	mov	ecx, DWORD PTR [ebp+8]
	mov	ebx, DWORD PTR [ebp+4]
	mov	eax, ecx
	sub	eax, ebx
	sar	eax, 2
	mov	DWORD PTR $T227521[esp+24], 0
	cmp	edi, eax
	jbe	SHORT $LN633@operator@2
	lea	edx, DWORD PTR $T227521[esp+24]
	push	edx
	mov	edx, edi
	sub	edx, eax
	push	edx
	push	ecx
	mov	ecx, ebp
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
	jmp	SHORT $LN340@operator@2
$LN633@operator@2:
	jae	SHORT $LN340@operator@2
	mov	eax, DWORD PTR tv2719[esp+20]
	lea	ebx, DWORD PTR [ebx+eax+4]
	cmp	ebx, ecx
	je	SHORT $LN340@operator@2
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	ebp, DWORD PTR [ebx+edx]
	mov	DWORD PTR __Result$227550[esp+24], ebp
	test	eax, eax
	jle	SHORT $LN365@operator@2
	push	edx
	push	ecx
	push	edx
	push	ebx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN365@operator@2:
	mov	ebp, DWORD PTR _this$[esp+24]
	mov	ecx, DWORD PTR __Result$227550[esp+24]
	add	ebp, 64					; 00000040H
	mov	DWORD PTR [ebp+8], ecx
$LN340@operator@2:
	mov	eax, DWORD PTR _this$[esp+24]
	mov	ecx, DWORD PTR [eax+68]
	mov	eax, DWORD PTR tv2719[esp+20]
	mov	edx, DWORD PTR [esi+68]
	mov	edx, DWORD PTR [eax+edx]
	mov	DWORD PTR [eax+ecx], edx
	add	eax, 4
	mov	DWORD PTR tv2719[esp+20], eax
	mov	eax, DWORD PTR [esi+72]
	sub	eax, DWORD PTR [esi+68]
	inc	edi
	sar	eax, 2
	lea	ecx, DWORD PTR [edi-1]
	cmp	ecx, eax
	jl	$LL16@operator@2
$LN14@operator@2:

; 91   : 	}
; 92   : 
; 93   : 	for(iI = 0; iI < source.getListBoxSize(); iI++)

	mov	edx, DWORD PTR [esi+88]
	sub	edx, DWORD PTR [esi+84]
	xor	edi, edi
	test	edx, -4					; fffffffcH
	jle	$LN10@operator@2
	mov	ebp, DWORD PTR _this$[esp+24]
	add	ebp, 80					; 00000050H
	npad	3
$LL12@operator@2:

; 94   : 	{
; 95   : 		CvPopup_SetAtGrow(m_aiListBoxID, iI, source.getSelectedListBoxValue(iI));

	mov	eax, DWORD PTR [ebp+8]
	sub	eax, DWORD PTR [ebp+4]
	sar	eax, 2
	cmp	eax, edi
	jg	SHORT $LN417@operator@2
	mov	ecx, DWORD PTR [ebp+8]
	mov	ebx, DWORD PTR [ebp+4]
	mov	eax, ecx
	sub	eax, ebx
	sar	eax, 2
	lea	edx, DWORD PTR [edi+1]
	mov	DWORD PTR $T227916[esp+20], 0
	cmp	edx, eax
	jbe	SHORT $LN634@operator@2
	lea	ebx, DWORD PTR $T227916[esp+20]
	push	ebx
	sub	edx, eax
	push	edx
	push	ecx
	mov	ecx, ebp
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
	jmp	SHORT $LN417@operator@2
$LN634@operator@2:
	jae	SHORT $LN417@operator@2
	lea	ebx, DWORD PTR [ebx+edi*4+4]
	cmp	ebx, ecx
	je	SHORT $LN417@operator@2
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	ebp, DWORD PTR [ebx+edx]
	mov	DWORD PTR __Result$227998[esp+20], ebp
	test	eax, eax
	jle	SHORT $LN442@operator@2
	push	edx
	push	ecx
	push	edx
	push	ebx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN442@operator@2:
	mov	ebp, DWORD PTR _this$[esp+24]
	mov	ecx, DWORD PTR __Result$227998[esp+20]
	add	ebp, 80					; 00000050H
	mov	DWORD PTR [ebp+8], ecx
$LN417@operator@2:
	mov	edx, DWORD PTR [esi+88]
	sub	edx, DWORD PTR [esi+84]
	sar	edx, 2
	cmp	edi, edx
	jae	SHORT $LN447@operator@2
	mov	eax, DWORD PTR [esi+84]
	mov	eax, DWORD PTR [eax+edi*4]
	jmp	SHORT $LN448@operator@2
$LN447@operator@2:
	or	eax, -1
$LN448@operator@2:
	mov	ecx, DWORD PTR _this$[esp+24]
	mov	edx, DWORD PTR [ecx+84]
	mov	DWORD PTR [edx+edi*4], eax
	mov	eax, DWORD PTR [esi+88]
	sub	eax, DWORD PTR [esi+84]
	inc	edi
	sar	eax, 2
	cmp	edi, eax
	jl	$LL12@operator@2
$LN10@operator@2:

; 96   : 	}
; 97   : 
; 98   : 	for(iI = 0; iI < source.getSpinBoxSize(); iI++)

	mov	ecx, DWORD PTR [esi+120]
	sub	ecx, DWORD PTR [esi+116]
	xor	edi, edi
	test	ecx, -4					; fffffffcH
	jle	$LN6@operator@2
	mov	ebx, DWORD PTR _this$[esp+24]
	add	ebx, 112				; 00000070H
	npad	8
$LL8@operator@2:

; 99   : 	{
; 100  : 		CvPopup_SetAtGrow(m_aiSpinBoxID, iI, source.getSpinnerWidgetValue(iI));

	mov	edx, DWORD PTR [ebx+8]
	sub	edx, DWORD PTR [ebx+4]
	sar	edx, 2
	cmp	edx, edi
	jg	SHORT $LN498@operator@2
	mov	ecx, DWORD PTR [ebx+8]
	mov	ebp, DWORD PTR [ebx+4]
	mov	eax, ecx
	sub	eax, ebp
	sar	eax, 2
	lea	edx, DWORD PTR [edi+1]
	mov	DWORD PTR $T228320[esp+20], 0
	cmp	edx, eax
	jbe	SHORT $LN635@operator@2
	lea	ebp, DWORD PTR $T228320[esp+20]
	push	ebp
	sub	edx, eax
	push	edx
	push	ecx
	mov	ecx, ebx
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
	jmp	SHORT $LN498@operator@2
$LN635@operator@2:
	jae	SHORT $LN498@operator@2
	lea	ebp, DWORD PTR [ebp+edi*4+4]
	cmp	ebp, ecx
	je	SHORT $LN498@operator@2
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	ebx, DWORD PTR [edx+ebp]
	mov	DWORD PTR __Result$228402[esp+20], ebx
	test	eax, eax
	jle	SHORT $LN523@operator@2
	push	edx
	push	ecx
	push	edx
	push	ebp
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN523@operator@2:
	mov	ebx, DWORD PTR _this$[esp+24]
	mov	eax, DWORD PTR __Result$228402[esp+20]
	add	ebx, 112				; 00000070H
	mov	DWORD PTR [ebx+8], eax
$LN498@operator@2:
	mov	ecx, DWORD PTR [esi+120]
	sub	ecx, DWORD PTR [esi+116]
	sar	ecx, 2
	cmp	edi, ecx
	jae	SHORT $LN528@operator@2
	mov	edx, DWORD PTR [esi+116]
	mov	eax, DWORD PTR [edx+edi*4]
	jmp	SHORT $LN529@operator@2
$LN528@operator@2:
	or	eax, -1
$LN529@operator@2:
	mov	ecx, DWORD PTR _this$[esp+24]
	mov	edx, DWORD PTR [ecx+116]
	mov	DWORD PTR [edx+edi*4], eax
	mov	eax, DWORD PTR [esi+120]
	sub	eax, DWORD PTR [esi+116]
	inc	edi
	sar	eax, 2
	cmp	edi, eax
	jl	$LL8@operator@2
$LN6@operator@2:

; 101  : 	}
; 102  : 
; 103  : 	for(iI = 0; iI < source.GetButtonSize(); iI++)

	mov	ecx, DWORD PTR [esi+104]
	sub	ecx, DWORD PTR [esi+100]
	test	ecx, -4					; fffffffcH
	jle	$LN629@operator@2
	mov	ebp, DWORD PTR _this$[esp+24]
	add	ebp, 96					; 00000060H
	mov	DWORD PTR tv2848[esp+20], 0
	mov	edi, 1
$LL4@operator@2:

; 104  : 	{
; 105  : 		CvPopup_SetAtGrow(m_aiButtonID, iI, source.GetButtonClicked(iI));

	mov	edx, DWORD PTR [ebp+8]
	sub	edx, DWORD PTR [ebp+4]
	lea	eax, DWORD PTR [edi-1]
	sar	edx, 2
	cmp	edx, eax
	jg	SHORT $LN579@operator@2
	mov	ecx, DWORD PTR [ebp+8]
	mov	edx, DWORD PTR [ebp+4]
	mov	eax, ecx
	sub	eax, edx
	sar	eax, 2
	mov	DWORD PTR $T228724[esp+24], 0
	cmp	edi, eax
	jbe	SHORT $LN636@operator@2
	lea	edx, DWORD PTR $T228724[esp+24]
	push	edx
	mov	edx, edi
	sub	edx, eax
	push	edx
	push	ecx
	mov	ecx, ebp
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
	jmp	SHORT $LN579@operator@2
$LN636@operator@2:
	jae	SHORT $LN579@operator@2
	mov	eax, DWORD PTR tv2848[esp+20]
	lea	ebx, DWORD PTR [eax+edx+4]
	cmp	ebx, ecx
	je	SHORT $LN579@operator@2
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	ebp, DWORD PTR [ebx+edx]
	mov	DWORD PTR __Result$228796[esp+24], ebp
	test	eax, eax
	jle	SHORT $LN604@operator@2
	push	edx
	push	ecx
	push	edx
	push	ebx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN604@operator@2:
	mov	ebp, DWORD PTR _this$[esp+24]
	mov	ecx, DWORD PTR __Result$228796[esp+24]
	add	ebp, 96					; 00000060H
	mov	DWORD PTR [ebp+8], ecx
$LN579@operator@2:
	mov	eax, DWORD PTR _this$[esp+24]
	mov	ecx, DWORD PTR [eax+100]
	mov	eax, DWORD PTR tv2848[esp+20]
	mov	edx, DWORD PTR [esi+100]
	mov	edx, DWORD PTR [eax+edx]
	mov	DWORD PTR [eax+ecx], edx
	add	eax, 4
	mov	DWORD PTR tv2848[esp+20], eax
	mov	eax, DWORD PTR [esi+104]
	sub	eax, DWORD PTR [esi+100]
	inc	edi
	sar	eax, 2
	lea	ecx, DWORD PTR [edi-1]
	cmp	ecx, eax
	jl	$LL4@operator@2
$LN629@operator@2:

; 106  : 	}
; 107  : 
; 108  : 	return (*this);

	mov	eax, DWORD PTR _this$[esp+24]

; 109  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	4
??4PopupReturn@@QAEAAV0@ABV0@@Z ENDP			; PopupReturn::operator=
_TEXT	ENDS
PUBLIC	?read@PopupReturn@@QAEXAAVFDataStream@@@Z	; PopupReturn::read
;	COMDAT xdata$x
; File s:\msvs2008\vc\include\vector
xdata$x	SEGMENT
__unwindtable$?read@PopupReturn@@QAEXAAVFDataStream@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?read@PopupReturn@@QAEXAAVFDataStream@@@Z$0
__ehfuncinfo$?read@PopupReturn@@QAEXAAVFDataStream@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?read@PopupReturn@@QAEXAAVFDataStream@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File s:\lekmod_dll\cvgamecoredll_expansion2\cvpopupreturn.cpp
xdata$x	ENDS
;	COMDAT ?read@PopupReturn@@QAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_iSize$ = -64						; size = 4
_iValue$ = -60						; size = 4
_this$ = -56						; size = 4
tv2423 = -52						; size = 4
tv2385 = -52						; size = 4
tv2347 = -52						; size = 4
tv2309 = -52						; size = 4
tv2271 = -52						; size = 4
tv2221 = -52						; size = 4
tv2183 = -52						; size = 4
$T231481 = -48						; size = 4
$T231098 = -48						; size = 4
$T230715 = -48						; size = 4
$T230332 = -48						; size = 4
$T229949 = -48						; size = 4
$T229641 = -48						; size = 4
$T229528 = -48						; size = 4
$T229146 = -48						; size = 4
_uiVersion$ = -44					; size = 4
_strValue$217405 = -40					; size = 28
__$EHRec$ = -12						; size = 12
_kStream$ = 8						; size = 4
?read@PopupReturn@@QAEXAAVFDataStream@@@Z PROC		; PopupReturn::read, COMDAT
; _this$ = ecx

; 115  : {

	push	-1
	push	__ehhandler$?read@PopupReturn@@QAEXAAVFDataStream@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 52					; 00000034H
	push	ebx
	push	ebp
	push	esi

; 116  : 	// Version number to maintain backwards compatibility
; 117  : 	uint uiVersion;
; 118  : 	kStream >> uiVersion;

	mov	esi, DWORD PTR _kStream$[esp+72]
	push	edi
	mov	ebp, ecx
	lea	eax, DWORD PTR _uiVersion$[esp+80]
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _this$[esp+84], ebp
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 119  : 
; 120  : 	int iSize;
; 121  : 	int iValue;
; 122  : 	int i;
; 123  : 
; 124  : 	kStream >>  iSize ;

	lea	ecx, DWORD PTR _iSize$[esp+80]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 125  : 	for(i = 0; i < iSize; i++)

	cmp	DWORD PTR _iSize$[esp+80], 0
	jle	$LN30@read
	xor	ebx, ebx
	mov	DWORD PTR tv2183[esp+80], ebx
	lea	esi, DWORD PTR [ebx+1]
$LL32@read:

; 126  : 	{
; 127  : 		kStream >>  iValue ;

	mov	ecx, DWORD PTR _kStream$[esp+76]
	lea	edx, DWORD PTR _iValue$[esp+80]
	push	edx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 128  : 		CvPopup_SetAtGrow(m_aiSelectedRadioButton, i, iValue);

	mov	ecx, DWORD PTR [ebp+8]
	mov	edx, DWORD PTR [ebp+4]
	mov	eax, ecx
	sub	eax, edx
	sar	eax, 2
	lea	edi, DWORD PTR [esi-1]
	cmp	eax, edi
	jg	SHORT $LN81@read
	mov	DWORD PTR $T229146[esp+80], 0
	cmp	esi, eax
	jbe	SHORT $LN594@read
	lea	edx, DWORD PTR $T229146[esp+80]
	push	edx
	mov	edx, esi
	sub	edx, eax
	push	edx
	push	ecx
	mov	ecx, ebp
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
	jmp	SHORT $LN81@read
$LN594@read:
	jae	SHORT $LN81@read
	lea	edi, DWORD PTR [ebx+edx+4]
	cmp	edi, ecx
	je	SHORT $LN81@read
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	ebx, DWORD PTR [edx+edi]
	test	eax, eax
	jle	SHORT $LN106@read
	push	edx
	push	ecx
	push	edx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN106@read:
	mov	DWORD PTR [ebp+8], ebx
	mov	ebx, DWORD PTR tv2183[esp+80]
$LN81@read:
	mov	eax, DWORD PTR [ebp+4]
	mov	ecx, DWORD PTR _iValue$[esp+80]
	inc	esi
	mov	DWORD PTR [ebx+eax], ecx
	add	ebx, 4
	lea	edx, DWORD PTR [esi-1]
	cmp	edx, DWORD PTR _iSize$[esp+80]
	mov	DWORD PTR tv2183[esp+80], ebx
	jl	$LL32@read

; 125  : 	for(i = 0; i < iSize; i++)

	mov	esi, DWORD PTR _kStream$[esp+76]
$LN30@read:

; 129  : 	}
; 130  : 
; 131  : 	kStream >>  iSize ;

	lea	eax, DWORD PTR _iSize$[esp+80]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 132  : 	for(i = 0; i < iSize; i++)

	cmp	DWORD PTR _iSize$[esp+80], 0
	jle	$LN592@read
	lea	ebx, DWORD PTR [ebp+16]
	mov	DWORD PTR tv2221[esp+80], 0
	mov	esi, 1
$LL28@read:

; 133  : 	{
; 134  : 		kStream >>  iValue ;

	lea	ecx, DWORD PTR _iValue$[esp+80]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[esp+80]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 135  : 		CvPopup_SetAtGrow(m_aiBitField, i, iValue);

	mov	edx, DWORD PTR [ebx+8]
	sub	edx, DWORD PTR [ebx+4]
	lea	eax, DWORD PTR [esi-1]
	sar	edx, 2
	cmp	edx, eax
	jg	SHORT $LN587@read
	mov	ecx, DWORD PTR [ebx+8]
	mov	edi, DWORD PTR [ebx+4]
	mov	eax, ecx
	sub	eax, edi
	sar	eax, 2
	mov	DWORD PTR $T229528[esp+80], 0
	cmp	esi, eax
	jbe	SHORT $LN595@read
	lea	edx, DWORD PTR $T229528[esp+80]
	push	edx
	mov	edx, esi
	sub	edx, eax
	push	edx
	push	ecx
	mov	ecx, ebx
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
	jmp	SHORT $LN587@read
$LN595@read:
	jae	SHORT $LN587@read
	mov	eax, DWORD PTR tv2221[esp+80]
	lea	edi, DWORD PTR [edi+eax+4]
	cmp	edi, ecx
	je	SHORT $LN587@read
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	ebp, DWORD PTR [edx+edi]
	test	eax, eax
	jle	SHORT $LN179@read
	push	edx
	push	ecx
	push	edx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN179@read:
	mov	DWORD PTR [ebx+8], ebp
	mov	ebp, DWORD PTR _this$[esp+80]
$LN587@read:
	mov	eax, DWORD PTR tv2221[esp+80]
	mov	ecx, DWORD PTR [ebp+20]
	mov	edx, DWORD PTR _iValue$[esp+80]
	mov	DWORD PTR [eax+ecx], edx
	add	eax, 4
	inc	esi
	mov	DWORD PTR tv2221[esp+80], eax
	lea	eax, DWORD PTR [esi-1]
	cmp	eax, DWORD PTR _iSize$[esp+80]
	jl	$LL28@read
$LN592@read:

; 136  : 	}
; 137  : 
; 138  : 	kStream >>  iSize ;

	lea	ecx, DWORD PTR _iSize$[esp+80]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[esp+80]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 139  : 	for(i = 0; i < iSize; i++)

	xor	esi, esi
	cmp	DWORD PTR _iSize$[esp+80], esi
	jle	$LN22@read
	lea	edi, DWORD PTR [ebp+32]
	xor	ebx, ebx
$LL24@read:

; 140  : 	{
; 141  : 		CvString strValue;

	lea	ecx, DWORD PTR _strValue$217405[esp+80]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 142  : 		kStream >>  strValue ;

	mov	ecx, DWORD PTR _kStream$[esp+76]
	lea	edx, DWORD PTR _strValue$217405[esp+80]
	push	edx
	mov	DWORD PTR __$EHRec$[esp+92], 0
	call	?Read@FDataStream@@IAEXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; FDataStream::Read

; 143  : 		CvPopup_SetAtGrow(m_aszEditBoxString, i, strValue);

	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, DWORD PTR [edi+4]
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, esi
	jg	SHORT $LN193@read
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T229641[esp+108], esp
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	lea	ecx, DWORD PTR [esi+1]
	push	ecx
	mov	ecx, edi
	call	?resize@?$vector@VCvString@@V?$allocator@VCvString@@@std@@@std@@QAEXIVCvString@@@Z ; std::vector<CvString,std::allocator<CvString> >::resize
$LN193@read:
	mov	ecx, DWORD PTR [ebp+36]
	lea	edx, DWORD PTR _strValue$217405[esp+80]
	add	ecx, ebx
	push	edx
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 144  : 	}

	lea	ecx, DWORD PTR _strValue$217405[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], -1
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	inc	esi
	add	ebx, 28					; 0000001cH
	cmp	esi, DWORD PTR _iSize$[esp+80]
	jl	$LL24@read
$LN22@read:

; 145  : 
; 146  : 	kStream >>  iSize ;

	mov	ecx, DWORD PTR _kStream$[esp+76]
	lea	eax, DWORD PTR _iSize$[esp+80]
	push	eax
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 147  : 	for(i = 0; i < iSize; i++)

	cmp	DWORD PTR _iSize$[esp+80], 0
	jle	$LN18@read
	lea	ebx, DWORD PTR [ebp+48]
	mov	DWORD PTR tv2271[esp+80], 0
	mov	esi, 1
$LL20@read:

; 148  : 	{
; 149  : 		kStream >>  iValue ;

	lea	ecx, DWORD PTR _iValue$[esp+80]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[esp+80]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 150  : 		CvPopup_SetAtGrow(m_aiSpinnerWidgetValues, i, iValue);

	mov	edx, DWORD PTR [ebx+8]
	sub	edx, DWORD PTR [ebx+4]
	lea	eax, DWORD PTR [esi-1]
	sar	edx, 2
	cmp	edx, eax
	jg	SHORT $LN588@read
	mov	ecx, DWORD PTR [ebx+8]
	mov	edi, DWORD PTR [ebx+4]
	mov	eax, ecx
	sub	eax, edi
	sar	eax, 2
	mov	DWORD PTR $T229949[esp+80], 0
	cmp	esi, eax
	jbe	SHORT $LN596@read
	lea	edx, DWORD PTR $T229949[esp+80]
	push	edx
	mov	edx, esi
	sub	edx, eax
	push	edx
	push	ecx
	mov	ecx, ebx
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
	jmp	SHORT $LN588@read
$LN596@read:
	jae	SHORT $LN588@read
	mov	eax, DWORD PTR tv2271[esp+80]
	lea	edi, DWORD PTR [edi+eax+4]
	cmp	edi, ecx
	je	SHORT $LN588@read
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	ebp, DWORD PTR [edx+edi]
	test	eax, eax
	jle	SHORT $LN274@read
	push	edx
	push	ecx
	push	edx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN274@read:
	mov	DWORD PTR [ebx+8], ebp
	mov	ebp, DWORD PTR _this$[esp+80]
$LN588@read:
	mov	eax, DWORD PTR tv2271[esp+80]
	mov	ecx, DWORD PTR [ebp+52]
	mov	edx, DWORD PTR _iValue$[esp+80]
	mov	DWORD PTR [eax+ecx], edx
	add	eax, 4
	inc	esi
	mov	DWORD PTR tv2271[esp+80], eax
	lea	eax, DWORD PTR [esi-1]
	cmp	eax, DWORD PTR _iSize$[esp+80]
	jl	$LL20@read
$LN18@read:

; 151  : 	}
; 152  : 
; 153  : 	kStream >>  iSize ;

	lea	ecx, DWORD PTR _iSize$[esp+80]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[esp+80]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 154  : 	for(i = 0; i < iSize; i++)

	cmp	DWORD PTR _iSize$[esp+80], 0
	jle	$LN14@read
	lea	ebx, DWORD PTR [ebp+64]
	mov	DWORD PTR tv2309[esp+80], 0
	mov	esi, 1
$LL16@read:

; 155  : 	{
; 156  : 		kStream >>  iValue ;

	mov	ecx, DWORD PTR _kStream$[esp+76]
	lea	edx, DWORD PTR _iValue$[esp+80]
	push	edx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 157  : 		CvPopup_SetAtGrow(m_aiPulldownID, i, iValue);

	mov	eax, DWORD PTR [ebx+8]
	sub	eax, DWORD PTR [ebx+4]
	lea	ecx, DWORD PTR [esi-1]
	sar	eax, 2
	cmp	eax, ecx
	jg	SHORT $LN589@read
	mov	ecx, DWORD PTR [ebx+8]
	mov	edi, DWORD PTR [ebx+4]
	mov	eax, ecx
	sub	eax, edi
	sar	eax, 2
	mov	DWORD PTR $T230332[esp+80], 0
	cmp	esi, eax
	jbe	SHORT $LN597@read
	lea	edx, DWORD PTR $T230332[esp+80]
	push	edx
	mov	edx, esi
	sub	edx, eax
	push	edx
	push	ecx
	mov	ecx, ebx
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
	jmp	SHORT $LN589@read
$LN597@read:
	jae	SHORT $LN589@read
	mov	eax, DWORD PTR tv2309[esp+80]
	lea	edi, DWORD PTR [edi+eax+4]
	cmp	edi, ecx
	je	SHORT $LN589@read
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	ebp, DWORD PTR [edx+edi]
	test	eax, eax
	jle	SHORT $LN347@read
	push	edx
	push	ecx
	push	edx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN347@read:
	mov	DWORD PTR [ebx+8], ebp
	mov	ebp, DWORD PTR _this$[esp+80]
$LN589@read:
	mov	eax, DWORD PTR tv2309[esp+80]
	mov	ecx, DWORD PTR [ebp+68]
	mov	edx, DWORD PTR _iValue$[esp+80]
	mov	DWORD PTR [eax+ecx], edx
	add	eax, 4
	inc	esi
	mov	DWORD PTR tv2309[esp+80], eax
	lea	eax, DWORD PTR [esi-1]
	cmp	eax, DWORD PTR _iSize$[esp+80]
	jl	$LL16@read
$LN14@read:

; 158  : 	}
; 159  : 
; 160  : 	kStream >>  iSize ;

	lea	ecx, DWORD PTR _iSize$[esp+80]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[esp+80]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 161  : 	for(i = 0; i < iSize; i++)

	cmp	DWORD PTR _iSize$[esp+80], 0
	jle	$LN10@read
	lea	ebx, DWORD PTR [ebp+80]
	mov	DWORD PTR tv2347[esp+80], 0
	mov	esi, 1
$LL12@read:

; 162  : 	{
; 163  : 		kStream >>  iValue ;

	mov	ecx, DWORD PTR _kStream$[esp+76]
	lea	edx, DWORD PTR _iValue$[esp+80]
	push	edx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 164  : 		CvPopup_SetAtGrow(m_aiListBoxID, i, iValue);

	mov	eax, DWORD PTR [ebx+8]
	sub	eax, DWORD PTR [ebx+4]
	lea	ecx, DWORD PTR [esi-1]
	sar	eax, 2
	cmp	eax, ecx
	jg	SHORT $LN590@read
	mov	ecx, DWORD PTR [ebx+8]
	mov	edi, DWORD PTR [ebx+4]
	mov	eax, ecx
	sub	eax, edi
	sar	eax, 2
	mov	DWORD PTR $T230715[esp+80], 0
	cmp	esi, eax
	jbe	SHORT $LN598@read
	lea	edx, DWORD PTR $T230715[esp+80]
	push	edx
	mov	edx, esi
	sub	edx, eax
	push	edx
	push	ecx
	mov	ecx, ebx
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
	jmp	SHORT $LN590@read
$LN598@read:
	jae	SHORT $LN590@read
	mov	eax, DWORD PTR tv2347[esp+80]
	lea	edi, DWORD PTR [edi+eax+4]
	cmp	edi, ecx
	je	SHORT $LN590@read
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	ebp, DWORD PTR [edx+edi]
	test	eax, eax
	jle	SHORT $LN420@read
	push	edx
	push	ecx
	push	edx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN420@read:
	mov	DWORD PTR [ebx+8], ebp
	mov	ebp, DWORD PTR _this$[esp+80]
$LN590@read:
	mov	eax, DWORD PTR tv2347[esp+80]
	mov	ecx, DWORD PTR [ebp+84]
	mov	edx, DWORD PTR _iValue$[esp+80]
	mov	DWORD PTR [eax+ecx], edx
	add	eax, 4
	inc	esi
	mov	DWORD PTR tv2347[esp+80], eax
	lea	eax, DWORD PTR [esi-1]
	cmp	eax, DWORD PTR _iSize$[esp+80]
	jl	$LL12@read
$LN10@read:

; 165  : 	}
; 166  : 
; 167  : 	kStream >>  iSize ;

	lea	ecx, DWORD PTR _iSize$[esp+80]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[esp+80]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 168  : 	for(i = 0; i < iSize; i++)

	cmp	DWORD PTR _iSize$[esp+80], 0
	jle	$LN591@read
	mov	ebx, DWORD PTR _this$[esp+80]
	add	ebx, 112				; 00000070H
	xor	ebp, ebp
	mov	DWORD PTR tv2385[esp+80], ebp
	lea	esi, DWORD PTR [ebp+1]
	npad	1
$LL8@read:

; 169  : 	{
; 170  : 		kStream >>  iValue ;

	mov	ecx, DWORD PTR _kStream$[esp+76]
	lea	edx, DWORD PTR _iValue$[esp+80]
	push	edx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 171  : 		CvPopup_SetAtGrow(m_aiSpinBoxID, i, iValue);

	mov	eax, DWORD PTR [ebx+8]
	sub	eax, DWORD PTR [ebx+4]
	lea	ecx, DWORD PTR [esi-1]
	sar	eax, 2
	cmp	eax, ecx
	jg	SHORT $LN468@read
	mov	ecx, DWORD PTR [ebx+8]
	mov	edi, DWORD PTR [ebx+4]
	mov	eax, ecx
	sub	eax, edi
	sar	eax, 2
	mov	DWORD PTR $T231098[esp+80], 0
	cmp	esi, eax
	jbe	SHORT $LN599@read
	lea	edx, DWORD PTR $T231098[esp+80]
	push	edx
	mov	edx, esi
	sub	edx, eax
	push	edx
	push	ecx
	mov	ecx, ebx
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
	jmp	SHORT $LN468@read
$LN599@read:
	jae	SHORT $LN468@read
	lea	edi, DWORD PTR [edi+ebp+4]
	cmp	edi, ecx
	je	SHORT $LN468@read
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	ebp, DWORD PTR [edx+edi]
	test	eax, eax
	jle	SHORT $LN493@read
	push	edx
	push	ecx
	push	edx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN493@read:
	mov	DWORD PTR [ebx+8], ebp
	mov	ebp, DWORD PTR tv2385[esp+80]
$LN468@read:
	mov	eax, DWORD PTR _this$[esp+80]
	mov	ecx, DWORD PTR [eax+116]
	mov	edx, DWORD PTR _iValue$[esp+80]
	inc	esi
	mov	DWORD PTR [ecx+ebp], edx
	add	ebp, 4
	lea	eax, DWORD PTR [esi-1]
	cmp	eax, DWORD PTR _iSize$[esp+80]
	mov	DWORD PTR tv2385[esp+80], ebp
	jl	$LL8@read
$LN591@read:

; 172  : 	}
; 173  : 
; 174  : 	kStream >>  iSize ;

	lea	ecx, DWORD PTR _iSize$[esp+80]
	push	ecx
	mov	ecx, DWORD PTR _kStream$[esp+80]
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 175  : 	for(i = 0; i < iSize; i++)

	cmp	DWORD PTR _iSize$[esp+80], 0
	jle	$LN2@read
	mov	ebx, DWORD PTR _this$[esp+80]
	add	ebx, 96					; 00000060H
	xor	ebp, ebp
	mov	DWORD PTR tv2423[esp+80], ebp
	lea	esi, DWORD PTR [ebp+1]
	npad	6
$LL4@read:

; 176  : 	{
; 177  : 		kStream >>  iValue ;

	mov	ecx, DWORD PTR _kStream$[esp+76]
	lea	edx, DWORD PTR _iValue$[esp+80]
	push	edx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 178  : 		CvPopup_SetAtGrow(m_aiButtonID, i, iValue);

	mov	eax, DWORD PTR [ebx+8]
	sub	eax, DWORD PTR [ebx+4]
	lea	ecx, DWORD PTR [esi-1]
	sar	eax, 2
	cmp	eax, ecx
	jg	SHORT $LN541@read
	mov	ecx, DWORD PTR [ebx+8]
	mov	edi, DWORD PTR [ebx+4]
	mov	eax, ecx
	sub	eax, edi
	sar	eax, 2
	mov	DWORD PTR $T231481[esp+80], 0
	cmp	esi, eax
	jbe	SHORT $LN600@read
	lea	edx, DWORD PTR $T231481[esp+80]
	push	edx
	mov	edx, esi
	sub	edx, eax
	push	edx
	push	ecx
	mov	ecx, ebx
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
	jmp	SHORT $LN541@read
$LN600@read:
	jae	SHORT $LN541@read
	lea	edi, DWORD PTR [edi+ebp+4]
	cmp	edi, ecx
	je	SHORT $LN541@read
	mov	eax, ecx
	sub	eax, ecx
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	lea	ebp, DWORD PTR [edx+edi]
	test	eax, eax
	jle	SHORT $LN566@read
	push	edx
	push	ecx
	push	edx
	push	edi
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN566@read:
	mov	DWORD PTR [ebx+8], ebp
	mov	ebp, DWORD PTR tv2423[esp+80]
$LN541@read:
	mov	eax, DWORD PTR _this$[esp+80]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR _iValue$[esp+80]
	inc	esi
	mov	DWORD PTR [ecx+ebp], edx
	add	ebp, 4
	lea	eax, DWORD PTR [esi-1]
	cmp	eax, DWORD PTR _iSize$[esp+80]
	mov	DWORD PTR tv2423[esp+80], ebp
	jl	$LL4@read
$LN2@read:

; 179  : 	}
; 180  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+80]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 64					; 00000040H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?read@PopupReturn@@QAEXAAVFDataStream@@@Z$0:
	lea	ecx, DWORD PTR _strValue$217405[ebp]
	jmp	??1CvString@@QAE@XZ			; CvString::~CvString
__ehhandler$?read@PopupReturn@@QAEXAAVFDataStream@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?read@PopupReturn@@QAEXAAVFDataStream@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?read@PopupReturn@@QAEXAAVFDataStream@@@Z ENDP		; PopupReturn::read
END
