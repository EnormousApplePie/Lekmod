; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Documents\GitHub\Lekmod\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvFractal.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG217756 DB	'Fractal Gen', 00H
$SG217764 DB	'Fractal Gen 2', 00H
	ORG $+2
$SG217766 DB	'Fractal Gen 3', 00H
	ORG $+2
$SG217769 DB	'Fractal Gen 4', 00H
	ORG $+2
$SG218026 DB	'Ridge Gen 1', 00H
$SG218027 DB	'Ridge Gen 2', 00H
$SG218030 DB	'Ridge Gen 3', 00H
$SG218031 DB	'Ridge Gen 4', 00H
$SG218034 DB	'Ridge Gen 5', 00H
$SG218045 DB	'Ridge Gen 6', 00H
$SG218046 DB	'Ridge Gen 7', 00H
$SG218065 DB	'Ridge Gen 8', 00H
CONST	ENDS
PUBLIC	?range@@YAHHHH@Z				; range
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvgamecoreutils.h
;	COMDAT ?range@@YAHHHH@Z
_TEXT	SEGMENT
_iNum$ = 8						; size = 4
_iLow$ = 12						; size = 4
_iHigh$ = 16						; size = 4
?range@@YAHHHH@Z PROC					; range, COMDAT

; 21   : 	CvAssertMsg(iHigh >= iLow, "High should be higher than low");
; 22   : 
; 23   : 	if(iNum < iLow)

	mov	ecx, DWORD PTR _iNum$[esp-4]
	mov	eax, DWORD PTR _iLow$[esp-4]
	cmp	ecx, eax

; 24   : 	{
; 25   : 		return iLow;

	jl	SHORT $LN1@range

; 26   : 	}
; 27   : 	else if(iNum > iHigh)

	mov	eax, DWORD PTR _iHigh$[esp-4]
	cmp	ecx, eax

; 28   : 	{
; 29   : 		return iHigh;

	jg	SHORT $LN1@range

; 30   : 	}
; 31   : 	else
; 32   : 	{
; 33   : 		return iNum;

	mov	eax, ecx
$LN1@range:

; 34   : 	}
; 35   : }

	ret	0
?range@@YAHHHH@Z ENDP					; range
_TEXT	ENDS
PUBLIC	?xToHexspaceX@@YAHHH@Z				; xToHexspaceX
; Function compile flags: /Ogtpy
;	COMDAT ?xToHexspaceX@@YAHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?xToHexspaceX@@YAHHH@Z PROC				; xToHexspaceX, COMDAT

; 86   : 	return iX - ((iY >= 0) ? (iY>>1) : ((iY - 1)/2));

	mov	ecx, DWORD PTR _iY$[esp-4]
	test	ecx, ecx
	jge	SHORT $LN5@xToHexspac
	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
	mov	ecx, eax
$LN5@xToHexspac:
	mov	eax, DWORD PTR _iX$[esp-4]
	sar	ecx, 1
	sub	eax, ecx

; 87   : }

	ret	0
?xToHexspaceX@@YAHHH@Z ENDP				; xToHexspaceX
_TEXT	ENDS
PUBLIC	?hexDistance@@YAHHH@Z				; hexDistance
; Function compile flags: /Ogtpy
;	COMDAT ?hexDistance@@YAHHH@Z
_TEXT	SEGMENT
_iDX$ = 8						; size = 4
_iDY$ = 12						; size = 4
?hexDistance@@YAHHH@Z PROC				; hexDistance, COMDAT

; 96   : 	// I'm assuming iDX and iDY are in hex-space
; 97   : #ifdef NQM_GAME_CORE_UTILS_OPTIMIZATIONS
; 98   : 	// Delnar: Using abs() because I trust the compiler to generate more efficient code than if I'd write an abs(int) function myself, especially if the CPU has an abs(int) operation
; 99   : 	if ((iDX ^ iDY) >= 0)  // the signs match
; 100  : 	{
; 101  : 		return abs(iDX) + abs(iDY);
; 102  : 	}
; 103  : 	else
; 104  : 	{
; 105  : 		return MAX(abs(iDX), abs(iDY));
; 106  : 	}
; 107  : #else
; 108  : 	if((iDX >= 0) == (iDY >= 0))  // the signs match

	mov	eax, DWORD PTR _iDX$[esp-4]
	xor	ecx, ecx
	test	eax, eax
	setge	cl
	push	esi
	mov	esi, DWORD PTR _iDY$[esp]
	xor	edx, edx
	test	esi, esi
	setge	dl
	cmp	ecx, edx
	jne	SHORT $LN2@hexDistanc

; 109  : 	{
; 110  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	test	eax, eax
	jge	SHORT $LN6@hexDistanc
	neg	eax
$LN6@hexDistanc:

; 111  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	test	esi, esi
	jge	SHORT $LN8@hexDistanc
	neg	esi
$LN8@hexDistanc:

; 112  : 		return iAbsDX + iAbsDY;

	add	eax, esi
	pop	esi

; 119  : 	}
; 120  : #endif
; 121  : }

	ret	0
$LN2@hexDistanc:

; 113  : 	}
; 114  : 	else
; 115  : 	{
; 116  : 		int iAbsDX = iDX >= 0 ? iDX : -iDX;

	test	eax, eax
	jge	SHORT $LN10@hexDistanc
	neg	eax
$LN10@hexDistanc:

; 117  : 		int iAbsDY = iDY >= 0 ? iDY : -iDY;

	test	esi, esi
	jge	SHORT $LN12@hexDistanc
	neg	esi
$LN12@hexDistanc:

; 118  : 		return iAbsDX >= iAbsDY ? iAbsDX : iAbsDY;

	cmp	eax, esi
	jge	SHORT $LN1@hexDistanc
	mov	eax, esi
$LN1@hexDistanc:
	pop	esi

; 119  : 	}
; 120  : #endif
; 121  : }

	ret	0
?hexDistance@@YAHHH@Z ENDP				; hexDistance
_TEXT	ENDS
PUBLIC	??_7CvFractal@@6B@				; CvFractal::`vftable'
PUBLIC	??0CvFractal@@QAE@XZ				; CvFractal::CvFractal
PUBLIC	??_R4CvFractal@@6B@				; CvFractal::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvFractal@@@8				; CvFractal `RTTI Type Descriptor'
PUBLIC	??_R3CvFractal@@8				; CvFractal::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvFractal@@8				; CvFractal::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvFractal@@8			; CvFractal::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ECvFractal@@UAEPAXI@Z:PROC			; CvFractal::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CvFractal@@8
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvfractal.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@CvFractal@@8 DD FLAT:??_R0?AVCvFractal@@@8 ; CvFractal::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvFractal@@8
rdata$r	ENDS
;	COMDAT ??_R2CvFractal@@8
rdata$r	SEGMENT
??_R2CvFractal@@8 DD FLAT:??_R1A@?0A@EA@CvFractal@@8	; CvFractal::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CvFractal@@8
rdata$r	SEGMENT
??_R3CvFractal@@8 DD 00H				; CvFractal::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CvFractal@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvFractal@@@8
_DATA	SEGMENT
??_R0?AVCvFractal@@@8 DD FLAT:??_7type_info@@6B@	; CvFractal `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvFractal@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvFractal@@6B@
rdata$r	SEGMENT
??_R4CvFractal@@6B@ DD 00H				; CvFractal::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvFractal@@@8
	DD	FLAT:??_R3CvFractal@@8
rdata$r	ENDS
;	COMDAT ??_7CvFractal@@6B@
CONST	SEGMENT
??_7CvFractal@@6B@ DD FLAT:??_R4CvFractal@@6B@		; CvFractal::`vftable'
	DD	FLAT:??_ECvFractal@@UAEPAXI@Z
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0CvFractal@@QAE@XZ
_TEXT	SEGMENT
??0CvFractal@@QAE@XZ PROC				; CvFractal::CvFractal, COMDAT
; _this$ = ecx

; 29   : {

	mov	eax, ecx

; 30   : 	m_iFracXExp = -1;

	or	ecx, -1
	mov	DWORD PTR [eax], OFFSET ??_7CvFractal@@6B@
	mov	DWORD PTR [eax+24], ecx

; 31   : 	m_iFracYExp = -1;

	mov	DWORD PTR [eax+28], ecx

; 32   : 	m_iXs = -1;

	mov	DWORD PTR [eax+4], ecx

; 33   : 	m_iYs = -1;

	mov	DWORD PTR [eax+8], ecx

; 34   : 	m_iFlags = 0;

	mov	DWORD PTR [eax+12], 0

; 35   : 	m_iFracX = -1;

	mov	DWORD PTR [eax+16], ecx

; 36   : 	m_iFracY = -1;

	mov	DWORD PTR [eax+20], ecx

; 37   : }

	ret	0
??0CvFractal@@QAE@XZ ENDP				; CvFractal::CvFractal
_TEXT	ENDS
PUBLIC	?uninit@CvFractal@@QAEXXZ			; CvFractal::uninit
; Function compile flags: /Ogtpy
;	COMDAT ?uninit@CvFractal@@QAEXXZ
_TEXT	SEGMENT
?uninit@CvFractal@@QAEXXZ PROC				; CvFractal::uninit, COMDAT
; _this$ = ecx

; 46   : }

	ret	0
?uninit@CvFractal@@QAEXXZ ENDP				; CvFractal::uninit
_TEXT	ENDS
PUBLIC	?reset@CvFractal@@QAEXXZ			; CvFractal::reset
; Function compile flags: /Ogtpy
;	COMDAT ?reset@CvFractal@@QAEXXZ
_TEXT	SEGMENT
?reset@CvFractal@@QAEXXZ PROC				; CvFractal::reset, COMDAT
; _this$ = ecx

; 50   : 	uninit();
; 51   : 	m_iFracXExp = -1;

	or	eax, -1
	mov	DWORD PTR [ecx+24], eax

; 52   : 	m_iFracYExp = -1;

	mov	DWORD PTR [ecx+28], eax

; 53   : 	m_iXs = -1;

	mov	DWORD PTR [ecx+4], eax

; 54   : 	m_iYs = -1;

	mov	DWORD PTR [ecx+8], eax

; 55   : 	m_iFlags = 0;

	mov	DWORD PTR [ecx+12], 0

; 56   : 	m_iFracX = -1;

	mov	DWORD PTR [ecx+16], eax

; 57   : 	m_iFracY = -1;

	mov	DWORD PTR [ecx+20], eax

; 58   : #ifdef AUI_WARNING_FIXES
; 59   : 	m_iXInc = 0;
; 60   : 	m_iYInc = 0;
; 61   : #endif
; 62   : }

	ret	0
?reset@CvFractal@@QAEXXZ ENDP				; CvFractal::reset
_TEXT	ENDS
PUBLIC	?getHeight@CvFractal@@QAEHHH@Z			; CvFractal::getHeight
; Function compile flags: /Ogtpy
;	COMDAT ?getHeight@CvFractal@@QAEHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?getHeight@CvFractal@@QAEHHH@Z PROC			; CvFractal::getHeight, COMDAT
; _this$ = ecx

; 309  : 	int iErrX = 0;
; 310  : 	int iErrY = 0;
; 311  : 	int iSum = 0;
; 312  : 	int iHeight = 0;
; 313  : 	int iLowX = 0;
; 314  : 	int iLowY = 0;
; 315  : 
; 316  : 	CvAssertMsg(0 <= iX && iX < m_iXs, "iX out of range");
; 317  : 	if(!(0 <= iX && iX < m_iXs)) return 0;

	mov	eax, DWORD PTR _iX$[esp-4]
	test	eax, eax
	jl	$LN11@getHeight
	cmp	eax, DWORD PTR [ecx+4]
	jge	$LN11@getHeight
	push	ebp

; 318  : 
; 319  : 	CvAssertMsg(0 <= iY && iY < m_iYs, "iY out of range");
; 320  : 	if(!(0 <= iY && iY < m_iYs)) return 0;

	mov	ebp, DWORD PTR _iY$[esp]
	test	ebp, ebp
	jl	$LN9@getHeight
	cmp	ebp, DWORD PTR [ecx+8]
	jge	$LN9@getHeight
	push	ebx

; 321  : 
; 322  : 	iLowX = ((m_iXInc * iX) / FLOAT_PRECISION);

	mov	ebx, DWORD PTR [ecx+32]
	imul	ebx, eax
	mov	eax, 274877907				; 10624dd3H
	imul	ebx

; 323  : 	if(iLowX > m_iFracX - 1)

	mov	eax, DWORD PTR [ecx+16]
	sar	edx, 6
	push	esi
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	dec	eax
	cmp	esi, eax
	jle	SHORT $LN8@getHeight

; 324  : 	{
; 325  : 		iLowX = m_iFracX - 1;	// clamp so that iLowX+1 doesn't overrun array

	mov	esi, eax
$LN8@getHeight:
	push	edi

; 326  : 	}
; 327  : 
; 328  : 	iLowY = ((m_iYInc * iY) / FLOAT_PRECISION);

	mov	edi, DWORD PTR [ecx+36]
	imul	edi, ebp
	mov	eax, 274877907				; 10624dd3H
	imul	edi
	sar	edx, 6
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 329  : 	if(iLowY > m_iFracY - 1)

	mov	edx, DWORD PTR [ecx+20]
	dec	edx
	cmp	eax, edx
	jle	SHORT $LN7@getHeight

; 330  : 	{
; 331  : 		iLowY = m_iFracY - 1;	// clamp so that iLowY+1 doesn't overrun array

	mov	eax, edx
$LN7@getHeight:

; 332  : 	}
; 333  : 	iErrX = ((m_iXInc * iX) - (iLowX * FLOAT_PRECISION));

	mov	edx, esi
	imul	edx, 1000				; 000003e8H
	sub	ebx, edx

; 334  : 	iErrY = ((m_iYInc * iY) - (iLowY * FLOAT_PRECISION));

	mov	edx, eax
	imul	edx, 1000				; 000003e8H
	sub	edi, edx

; 335  : 
; 336  : 	if(iLowX < 0 || iLowX > FRACTAL_MAX_DIMS) return 0; // array is defined as FRACTAL_MAX_DIMS+1

	cmp	esi, 255				; 000000ffH
	ja	SHORT $LN5@getHeight

; 337  : 	if(iLowY < 0 || iLowY > FRACTAL_MAX_DIMS) return 0; // array is defined as FRACTAL_MAX_DIMS+1

	cmp	eax, 255				; 000000ffH
	ja	SHORT $LN5@getHeight
	shl	esi, 8
	add	eax, esi

; 338  : 
; 339  : 	iSum = 0;
; 340  : 	iSum += ((FLOAT_PRECISION - iErrX) * (FLOAT_PRECISION - iErrY) * m_aaiFrac[iLowX    ][iLowY    ]);

	mov	edx, DWORD PTR [ecx+eax*4+40]

; 341  : 	iSum += ((iErrX) * (FLOAT_PRECISION - iErrY) * m_aaiFrac[iLowX + 1][iLowY    ]);

	mov	ebp, DWORD PTR [ecx+eax*4+1064]
	imul	ebp, ebx
	mov	esi, 1000				; 000003e8H
	sub	esi, ebx
	imul	edx, esi
	add	edx, ebp
	mov	ebp, 1000				; 000003e8H
	sub	ebp, edi
	imul	edx, ebp

; 342  : 	iSum += ((FLOAT_PRECISION - iErrX) * (iErrY) * m_aaiFrac[iLowX    ][iLowY + 1]);

	mov	ebp, DWORD PTR [ecx+eax*4+44]

; 343  : 	iSum += ((iErrX) * (iErrY) * m_aaiFrac[iLowX + 1][iLowY + 1]);

	mov	eax, DWORD PTR [ecx+eax*4+1068]
	imul	ebp, esi
	imul	eax, ebx
	add	ebp, eax
	imul	ebp, edi
	add	edx, ebp

; 344  : 
; 345  : 	iSum /= (FLOAT_PRECISION * FLOAT_PRECISION);

	mov	eax, 1125899907				; 431bde83H
	imul	edx
	sar	edx, 18					; 00000012H
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 346  : 
; 347  : 	iHeight = range(iSum, 0, 255);

	jns	SHORT $LN18@getHeight
	xor	eax, eax
	jmp	SHORT $LN16@getHeight
$LN18@getHeight:
	cmp	eax, 255				; 000000ffH
	jle	SHORT $LN16@getHeight
	mov	eax, 255				; 000000ffH
$LN16@getHeight:

; 348  : 
; 349  : 	if(m_iFlags & FRAC_PERCENT)

	test	BYTE PTR [ecx+12], 4
	je	SHORT $LN24@getHeight

; 350  : 	{
; 351  : 		return ((iHeight * 100) >> 8);

	imul	eax, 100				; 00000064H
	sar	eax, 8
$LN24@getHeight:
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp

; 352  : 	}
; 353  : 	else
; 354  : 	{
; 355  : 		return iHeight;
; 356  : 	}
; 357  : }

	ret	8
$LN5@getHeight:
	pop	edi
	pop	esi
	pop	ebx

; 335  : 
; 336  : 	if(iLowX < 0 || iLowX > FRACTAL_MAX_DIMS) return 0; // array is defined as FRACTAL_MAX_DIMS+1

	xor	eax, eax
	pop	ebp

; 352  : 	}
; 353  : 	else
; 354  : 	{
; 355  : 		return iHeight;
; 356  : 	}
; 357  : }

	ret	8
$LN9@getHeight:

; 318  : 
; 319  : 	CvAssertMsg(0 <= iY && iY < m_iYs, "iY out of range");
; 320  : 	if(!(0 <= iY && iY < m_iYs)) return 0;

	xor	eax, eax
	pop	ebp

; 352  : 	}
; 353  : 	else
; 354  : 	{
; 355  : 		return iHeight;
; 356  : 	}
; 357  : }

	ret	8
$LN11@getHeight:

; 309  : 	int iErrX = 0;
; 310  : 	int iErrY = 0;
; 311  : 	int iSum = 0;
; 312  : 	int iHeight = 0;
; 313  : 	int iLowX = 0;
; 314  : 	int iLowY = 0;
; 315  : 
; 316  : 	CvAssertMsg(0 <= iX && iX < m_iXs, "iX out of range");
; 317  : 	if(!(0 <= iX && iX < m_iXs)) return 0;

	xor	eax, eax

; 352  : 	}
; 353  : 	else
; 354  : 	{
; 355  : 		return iHeight;
; 356  : 	}
; 357  : }

	ret	8
?getHeight@CvFractal@@QAEHHH@Z ENDP			; CvFractal::getHeight
_TEXT	ENDS
PUBLIC	?getHeightFromPercent@CvFractal@@QAEHH@Z	; CvFractal::getHeightFromPercent
; Function compile flags: /Ogtpy
;	COMDAT ?getHeightFromPercent@CvFractal@@QAEHH@Z
_TEXT	SEGMENT
_iLowerBound$ = -20					; size = 4
_iUpperBound$ = -16					; size = 4
tv167 = -12						; size = 4
_this$ = -8						; size = 4
tv186 = -4						; size = 4
_iPercent$ = 8						; size = 4
?getHeightFromPercent@CvFractal@@QAEHH@Z PROC		; CvFractal::getHeightFromPercent, COMDAT
; _this$ = ecx

; 361  : {

	sub	esp, 20					; 00000014H

; 362  : 	int iEstimate;
; 363  : 	int iLowerBound;
; 364  : 	int iUpperBound;
; 365  : 	int iSum;
; 366  : 	int iX, iY;
; 367  : 
; 368  : 	iLowerBound = 0;
; 369  : 	iUpperBound = 255;
; 370  : 
; 371  : 	iPercent = range(iPercent, 0, 100);

	mov	eax, DWORD PTR _iPercent$[esp+16]
	push	ebx
	mov	ebx, ecx
	xor	ecx, ecx
	cmp	eax, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], ebx
	mov	DWORD PTR _iLowerBound$[esp+28], ecx
	mov	DWORD PTR _iUpperBound$[esp+28], 255	; 000000ffH
	jge	SHORT $LN17@getHeightF
	mov	DWORD PTR _iPercent$[esp+24], ecx
	jmp	SHORT $LN15@getHeightF
$LN17@getHeightF:
	cmp	eax, 100				; 00000064H
	jle	SHORT $LN15@getHeightF
	mov	DWORD PTR _iPercent$[esp+24], 100	; 00000064H
$LN15@getHeightF:

; 372  : 	iEstimate = 255 * iPercent / 100;

	mov	edx, DWORD PTR _iPercent$[esp+24]
	imul	edx, 255				; 000000ffH
	mov	eax, 1374389535				; 51eb851fH
	imul	edx
	sar	edx, 5
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	add	edi, edx

; 373  : 
; 374  : 	while(iEstimate != iLowerBound)

	je	$LN25@getHeightF
	mov	ecx, DWORD PTR [ebx+20]
	push	ebp
	push	esi
	mov	esi, DWORD PTR [ebx+16]
	mov	eax, ecx
	imul	eax, esi
	mov	DWORD PTR tv167[esp+36], esi
	mov	DWORD PTR tv186[esp+36], eax
	npad	6
$LL11@getHeightF:

; 375  : 	{
; 376  : 		iSum = 0;

	xor	eax, eax

; 377  : 
; 378  : 		for(iX = 0; iX < m_iFracX; iX++)

	test	esi, esi
	jle	SHORT $LN7@getHeightF
	add	ebx, 40					; 00000028H
	mov	ebp, esi
	npad	5
$LL9@getHeightF:

; 379  : 		{
; 380  : 			for(iY = 0; iY < m_iFracY; iY++)

	test	ecx, ecx
	jle	SHORT $LN8@getHeightF
	mov	edx, ebx
	mov	esi, ecx
$LL6@getHeightF:

; 381  : 			{
; 382  : 				if(m_aaiFrac[iX][iY] < iEstimate)

	cmp	DWORD PTR [edx], edi
	jge	SHORT $LN5@getHeightF

; 383  : 				{
; 384  : 					iSum++;

	inc	eax
$LN5@getHeightF:

; 379  : 		{
; 380  : 			for(iY = 0; iY < m_iFracY; iY++)

	add	edx, 4
	sub	esi, 1
	jne	SHORT $LL6@getHeightF
	mov	esi, DWORD PTR tv167[esp+36]
$LN8@getHeightF:

; 377  : 
; 378  : 		for(iX = 0; iX < m_iFracX; iX++)

	add	ebx, 1024				; 00000400H
	sub	ebp, 1
	jne	SHORT $LL9@getHeightF
	mov	ebx, DWORD PTR _this$[esp+36]
$LN7@getHeightF:

; 385  : 				}
; 386  : 			}
; 387  : 		}
; 388  : 		if(((100 * iSum) / (m_iFracX * m_iFracY)) > iPercent)

	imul	eax, 100				; 00000064H
	cdq
	idiv	DWORD PTR tv186[esp+36]
	cmp	eax, DWORD PTR _iPercent$[esp+32]
	jle	SHORT $LN2@getHeightF

; 389  : 		{
; 390  : 			iUpperBound = iEstimate;
; 391  : 			iEstimate = (iUpperBound + iLowerBound) / 2;

	mov	eax, DWORD PTR _iLowerBound$[esp+36]
	mov	DWORD PTR _iUpperBound$[esp+36], edi
	add	eax, edi

; 392  : 		}
; 393  : 		else

	jmp	SHORT $LN27@getHeightF
$LN2@getHeightF:

; 394  : 		{
; 395  : 			iLowerBound = iEstimate;
; 396  : 			iEstimate = (iUpperBound + iLowerBound) / 2;

	mov	edx, DWORD PTR _iUpperBound$[esp+36]
	mov	DWORD PTR _iLowerBound$[esp+36], edi
	lea	eax, DWORD PTR [edi+edx]
$LN27@getHeightF:
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edi, eax
	cmp	edi, DWORD PTR _iLowerBound$[esp+36]
	jne	SHORT $LL11@getHeightF
	pop	esi
	pop	ebp
$LN25@getHeightF:

; 397  : 		}
; 398  : 	}
; 399  : 
; 400  : 	return iEstimate;

	mov	eax, edi
	pop	edi
	pop	ebx

; 401  : }

	add	esp, 20					; 00000014H
	ret	4
?getHeightFromPercent@CvFractal@@QAEHH@Z ENDP		; CvFractal::getHeightFromPercent
_TEXT	ENDS
PUBLIC	?yieldX@CvFractal@@IAEHH@Z			; CvFractal::yieldX
; Function compile flags: /Ogtpy
;	COMDAT ?yieldX@CvFractal@@IAEHH@Z
_TEXT	SEGMENT
_iBadX$ = 8						; size = 4
?yieldX@CvFractal@@IAEHH@Z PROC				; CvFractal::yieldX, COMDAT
; _this$ = ecx

; 433  : 	if(iBadX < 0)

	mov	edx, DWORD PTR _iBadX$[esp-4]
	test	edx, edx
	jge	SHORT $LN2@yieldX

; 434  : 	{
; 435  : 		return (iBadX + m_iFracX);

	mov	eax, DWORD PTR [ecx+16]
	add	eax, edx

; 441  : 	}
; 442  : 
; 443  : 	return iBadX;
; 444  : }

	ret	4
$LN2@yieldX:

; 436  : 	}
; 437  : 
; 438  : 	if(iBadX >= m_iFracX)

	mov	ecx, DWORD PTR [ecx+16]
	cmp	edx, ecx

; 439  : 	{
; 440  : 		return (iBadX - m_iFracX);

	mov	eax, edx
	jl	SHORT $LN3@yieldX
	sub	eax, ecx
$LN3@yieldX:

; 441  : 	}
; 442  : 
; 443  : 	return iBadX;
; 444  : }

	ret	4
?yieldX@CvFractal@@IAEHH@Z ENDP				; CvFractal::yieldX
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[esp-4]

; 60   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??A?$BaseVector@UVoronoiSeed@@$00@@QAEAAUVoronoiSeed@@I@Z ; BaseVector<VoronoiSeed,1>::operator[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??A?$BaseVector@UVoronoiSeed@@$00@@QAEAAUVoronoiSeed@@I@Z
_TEXT	SEGMENT
_ui$ = 8						; size = 4
??A?$BaseVector@UVoronoiSeed@@$00@@QAEAAUVoronoiSeed@@I@Z PROC ; BaseVector<VoronoiSeed,1>::operator[], COMDAT
; _this$ = ecx

; 129  : 		FAssert(ui < m_uiCurrSize);
; 130  : 		return m_pData[ui];

	mov	eax, DWORD PTR _ui$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [ecx+eax*4]

; 131  : 	};

	ret	4
??A?$BaseVector@UVoronoiSeed@@$00@@QAEAAUVoronoiSeed@@I@Z ENDP ; BaseVector<VoronoiSeed,1>::operator[]
_TEXT	ENDS
PUBLIC	??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@ ; `string'
PUBLIC	?Alloc@?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@IAEPAUVoronoiSeed@@I@Z ; FStaticVector<VoronoiSeed,256,1,297,0>::Alloc
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
CONST	SEGMENT
??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@ DB 'c:\users\eno'
	DB	'rmousapplepie\documents\github\lekmod\lekmod_dll\fireplace\in'
	DB	'clude\fireworks\FFastVector.h', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?Alloc@?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@IAEPAUVoronoiSeed@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@IAEPAUVoronoiSeed@@I@Z PROC ; FStaticVector<VoronoiSeed,256,1,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 256				; 00000100H
	jbe	SHORT $LN2@Alloc

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	lea	eax, DWORD PTR [edi+edi*4]
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	add	eax, eax
	add	eax, eax
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 256			; 00000100H
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@IAEPAUVoronoiSeed@@I@Z ENDP ; FStaticVector<VoronoiSeed,256,1,297,0>::Alloc
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UVoronoiSeed@@$00@@QAE@XZ	; BaseVector<VoronoiSeed,1>::~BaseVector<VoronoiSeed,1>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$BaseVector@UVoronoiSeed@@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@UVoronoiSeed@@$00@@QAE@XZ PROC		; BaseVector<VoronoiSeed,1>::~BaseVector<VoronoiSeed,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@UVoronoiSeed@@$00@@QAE@XZ ENDP		; BaseVector<VoronoiSeed,1>::~BaseVector<VoronoiSeed,1>
_TEXT	ENDS
PUBLIC	??0?$BaseVector@UVoronoiSeed@@$00@@IAE@XZ	; BaseVector<VoronoiSeed,1>::BaseVector<VoronoiSeed,1>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$BaseVector@UVoronoiSeed@@$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@UVoronoiSeed@@$00@@IAE@XZ PROC		; BaseVector<VoronoiSeed,1>::BaseVector<VoronoiSeed,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@UVoronoiSeed@@$00@@IAE@XZ ENDP		; BaseVector<VoronoiSeed,1>::BaseVector<VoronoiSeed,1>
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@UVoronoiSeed@@$00@@IAEXPAUVoronoiSeed@@I@Z ; BaseVector<VoronoiSeed,1>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@UVoronoiSeed@@$00@@IAEXPAUVoronoiSeed@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@UVoronoiSeed@@$00@@IAEXPAUVoronoiSeed@@I@Z PROC ; BaseVector<VoronoiSeed,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@UVoronoiSeed@@$00@@IAEXPAUVoronoiSeed@@I@Z ENDP ; BaseVector<VoronoiSeed,1>::Destroy
_TEXT	ENDS
PUBLIC	??$max@H@std@@YAABHABH0@Z			; std::max<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$max@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@H@std@@YAABHABH0@Z PROC				; std::max<int>, COMDAT

; 3384 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN4@max
	mov	eax, ecx
$LN4@max:

; 3385 : 	}

	ret	0
??$max@H@std@@YAABHABH0@Z ENDP				; std::max<int>
_TEXT	ENDS
PUBLIC	??$min@H@std@@YAABHABH0@Z			; std::min<int>
; Function compile flags: /Ogtpy
;	COMDAT ??$min@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@H@std@@YAABHABH0@Z PROC				; std::min<int>, COMDAT

; 3399 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Left$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jl	SHORT $LN4@min
	mov	eax, ecx
$LN4@min:

; 3400 : 	}

	ret	0
??$min@H@std@@YAABHABH0@Z ENDP				; std::min<int>
_TEXT	ENDS
PUBLIC	??1CvFractal@@UAE@XZ				; CvFractal::~CvFractal
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvfractal.cpp
;	COMDAT ??1CvFractal@@UAE@XZ
_TEXT	SEGMENT
??1CvFractal@@UAE@XZ PROC				; CvFractal::~CvFractal, COMDAT
; _this$ = ecx

; 40   : {

	mov	DWORD PTR [ecx], OFFSET ??_7CvFractal@@6B@

; 41   : 	uninit();
; 42   : }

	ret	0
??1CvFractal@@UAE@XZ ENDP				; CvFractal::~CvFractal
_TEXT	ENDS
PUBLIC	?tectonicAction@CvFractal@@IAEXPAV1@@Z		; CvFractal::tectonicAction
; Function compile flags: /Ogtpy
;	COMDAT ?tectonicAction@CvFractal@@IAEXPAV1@@Z
_TEXT	SEGMENT
tv676 = -4						; size = 4
tv928 = 8						; size = 4
_pRifts$ = 8						; size = 4
?tectonicAction@CvFractal@@IAEXPAV1@@Z PROC		; CvFractal::tectonicAction, COMDAT
; _this$ = ecx

; 406  : {

	push	ecx

; 407  : 	//int iRift1x = (m_iFracX / 4);
; 408  : 	const int iRift2x = ((m_iFracX / 4) * 3);

	mov	eax, DWORD PTR [ecx+16]
	cdq
	and	edx, 3
	add	eax, edx

; 409  : 	const int iWidth = 16;
; 410  : 
; 411  : 	for(int iY = 0; iY < m_iFracY + 1; iY++)

	mov	edx, DWORD PTR [ecx+20]
	push	ebx
	sar	eax, 2
	inc	edx
	push	esi
	xor	ebx, ebx
	push	edi
	lea	eax, DWORD PTR [eax+eax*2]
	test	edx, edx
	jle	$LN7@tectonicAc
	mov	edx, DWORD PTR _pRifts$[esp+12]
	shl	eax, 10					; 0000000aH
	lea	eax, DWORD PTR [eax+edx+40]
	mov	DWORD PTR tv928[esp+12], eax
	push	ebp
$LL45@tectonicAc:

; 412  : 	{
; 413  : 		for(int iX = 0; iX < iWidth; iX++)

	xor	esi, esi
$LL46@tectonicAc:

; 414  : 		{
; 415  : 			//  Rift along edge of map.
; 416  : 			int iDeep = 0;
; 417  : 			int iRx = yieldX(((((pRifts->m_aaiFrac[iRift2x][iY] - 128) * m_iFracX) / 128) / 8) + iX);

	mov	edx, DWORD PTR tv928[esp+16]
	mov	eax, DWORD PTR [edx]
	mov	edi, DWORD PTR [ecx+16]
	add	eax, -128				; ffffff80H
	imul	eax, edi
	cdq
	and	edx, 127				; 0000007fH
	add	eax, edx
	sar	eax, 7
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	lea	edx, DWORD PTR [eax+esi]
	test	edx, edx
	jge	SHORT $LN13@tectonicAc
	add	edx, edi
	jmp	SHORT $LN12@tectonicAc
$LN13@tectonicAc:
	cmp	edx, edi
	jl	SHORT $LN12@tectonicAc
	sub	edx, edi
$LN12@tectonicAc:

; 418  : 			int iLx = yieldX(((((pRifts->m_aaiFrac[iRift2x][iY] - 128) * m_iFracX) / 128) / 8) - iX);

	sub	eax, esi
	jns	SHORT $LN17@tectonicAc
	add	edi, eax
	jmp	SHORT $LN18@tectonicAc
$LN17@tectonicAc:
	cmp	eax, edi
	jl	SHORT $LN16@tectonicAc
	sub	eax, edi
$LN16@tectonicAc:
	mov	edi, eax
$LN18@tectonicAc:

; 419  : 			m_aaiFrac[iRx][iY] = (((m_aaiFrac[iRx][iY] * iX) + iDeep * (iWidth - iX)) / iWidth);

	shl	edx, 8
	add	edx, ebx
	mov	eax, DWORD PTR [ecx+edx*4+40]
	imul	eax, esi
	lea	ebp, DWORD PTR [ecx+edx*4+40]
	cdq
	and	edx, 15					; 0000000fH
	add	eax, edx
	sar	eax, 4
	mov	DWORD PTR [ebp], eax

; 420  : 			m_aaiFrac[iLx][iY] = (((m_aaiFrac[iLx][iY] * iX) + iDeep * (iWidth - iX)) / iWidth);

	shl	edi, 8
	add	edi, ebx
	mov	eax, DWORD PTR [ecx+edi*4+40]
	imul	eax, esi
	lea	edi, DWORD PTR [ecx+edi*4+40]
	cdq
	and	edx, 15					; 0000000fH
	add	eax, edx
	sar	eax, 4
	mov	DWORD PTR [edi], eax
	mov	eax, DWORD PTR tv928[esp+16]
	mov	eax, DWORD PTR [eax]
	mov	ebp, DWORD PTR [ecx+16]
	add	eax, -128				; ffffff80H
	imul	eax, ebp
	cdq
	and	edx, 127				; 0000007fH
	add	eax, edx
	sar	eax, 7
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	lea	edx, DWORD PTR [eax+esi+1]
	test	edx, edx
	jge	SHORT $LN27@tectonicAc

; 414  : 		{
; 415  : 			//  Rift along edge of map.
; 416  : 			int iDeep = 0;
; 417  : 			int iRx = yieldX(((((pRifts->m_aaiFrac[iRift2x][iY] - 128) * m_iFracX) / 128) / 8) + iX);

	add	edx, ebp
	jmp	SHORT $LN28@tectonicAc
$LN27@tectonicAc:
	cmp	edx, ebp
	jl	SHORT $LN28@tectonicAc
	sub	edx, ebp
$LN28@tectonicAc:

; 418  : 			int iLx = yieldX(((((pRifts->m_aaiFrac[iRift2x][iY] - 128) * m_iFracX) / 128) / 8) - iX);

	sub	eax, esi
	sub	eax, 1
	jns	SHORT $LN30@tectonicAc
	lea	edi, DWORD PTR [eax+ebp]
	jmp	SHORT $LN32@tectonicAc
$LN30@tectonicAc:
	cmp	eax, ebp
	jl	SHORT $LN31@tectonicAc
	sub	eax, ebp
$LN31@tectonicAc:
	mov	edi, eax
$LN32@tectonicAc:

; 419  : 			m_aaiFrac[iRx][iY] = (((m_aaiFrac[iRx][iY] * iX) + iDeep * (iWidth - iX)) / iWidth);

	shl	edx, 8
	add	edx, ebx
	lea	eax, DWORD PTR [ecx+edx*4+40]
	mov	DWORD PTR tv676[esp+20], eax
	mov	eax, DWORD PTR [eax]
	lea	ebp, DWORD PTR [esi+2]
	lea	edx, DWORD PTR [ebp-1]
	imul	eax, edx
	cdq
	and	edx, 15					; 0000000fH
	add	eax, edx
	mov	edx, DWORD PTR tv676[esp+20]
	sar	eax, 4
	mov	DWORD PTR [edx], eax

; 420  : 			m_aaiFrac[iLx][iY] = (((m_aaiFrac[iLx][iY] * iX) + iDeep * (iWidth - iX)) / iWidth);

	shl	edi, 8
	add	edi, ebx
	mov	eax, DWORD PTR [ecx+edi*4+40]
	lea	edi, DWORD PTR [ecx+edi*4+40]
	lea	edx, DWORD PTR [ebp-1]
	imul	eax, edx
	cdq
	and	edx, 15					; 0000000fH
	add	eax, edx
	sar	eax, 4
	mov	DWORD PTR [edi], eax
	mov	eax, DWORD PTR tv928[esp+16]
	mov	eax, DWORD PTR [eax]
	mov	edi, DWORD PTR [ecx+16]
	add	eax, -128				; ffffff80H
	imul	eax, edi
	cdq
	and	edx, 127				; 0000007fH
	add	eax, edx
	sar	eax, 7
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	lea	edx, DWORD PTR [eax+esi+2]
	test	edx, edx
	jge	SHORT $LN33@tectonicAc

; 414  : 		{
; 415  : 			//  Rift along edge of map.
; 416  : 			int iDeep = 0;
; 417  : 			int iRx = yieldX(((((pRifts->m_aaiFrac[iRift2x][iY] - 128) * m_iFracX) / 128) / 8) + iX);

	add	edx, edi
	jmp	SHORT $LN34@tectonicAc
$LN33@tectonicAc:
	cmp	edx, edi
	jl	SHORT $LN34@tectonicAc
	sub	edx, edi
$LN34@tectonicAc:

; 418  : 			int iLx = yieldX(((((pRifts->m_aaiFrac[iRift2x][iY] - 128) * m_iFracX) / 128) / 8) - iX);

	sub	eax, esi
	sub	eax, 2
	jns	SHORT $LN36@tectonicAc
	add	edi, eax
	jmp	SHORT $LN38@tectonicAc
$LN36@tectonicAc:
	cmp	eax, edi
	jl	SHORT $LN37@tectonicAc
	sub	eax, edi
$LN37@tectonicAc:
	mov	edi, eax
$LN38@tectonicAc:

; 419  : 			m_aaiFrac[iRx][iY] = (((m_aaiFrac[iRx][iY] * iX) + iDeep * (iWidth - iX)) / iWidth);

	shl	edx, 8
	add	edx, ebx
	mov	eax, DWORD PTR [ecx+edx*4+40]
	imul	eax, ebp
	lea	edx, DWORD PTR [ecx+edx*4+40]
	mov	DWORD PTR tv676[esp+20], edx
	cdq
	and	edx, 15					; 0000000fH
	add	eax, edx
	mov	edx, DWORD PTR tv676[esp+20]
	sar	eax, 4
	mov	DWORD PTR [edx], eax

; 420  : 			m_aaiFrac[iLx][iY] = (((m_aaiFrac[iLx][iY] * iX) + iDeep * (iWidth - iX)) / iWidth);

	shl	edi, 8
	add	edi, ebx
	mov	eax, DWORD PTR [ecx+edi*4+40]
	imul	eax, ebp
	lea	edi, DWORD PTR [ecx+edi*4+40]
	cdq
	and	edx, 15					; 0000000fH
	add	eax, edx
	sar	eax, 4
	mov	DWORD PTR [edi], eax
	mov	eax, DWORD PTR tv928[esp+16]
	mov	eax, DWORD PTR [eax]
	mov	edi, DWORD PTR [ecx+16]
	add	eax, -128				; ffffff80H
	imul	eax, edi
	cdq
	and	edx, 127				; 0000007fH
	add	eax, edx
	sar	eax, 7
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	lea	edx, DWORD PTR [eax+esi+3]
	test	edx, edx
	jge	SHORT $LN39@tectonicAc

; 414  : 		{
; 415  : 			//  Rift along edge of map.
; 416  : 			int iDeep = 0;
; 417  : 			int iRx = yieldX(((((pRifts->m_aaiFrac[iRift2x][iY] - 128) * m_iFracX) / 128) / 8) + iX);

	add	edx, edi
	jmp	SHORT $LN40@tectonicAc
$LN39@tectonicAc:
	cmp	edx, edi
	jl	SHORT $LN40@tectonicAc
	sub	edx, edi
$LN40@tectonicAc:

; 418  : 			int iLx = yieldX(((((pRifts->m_aaiFrac[iRift2x][iY] - 128) * m_iFracX) / 128) / 8) - iX);

	sub	eax, esi
	sub	eax, 3
	jns	SHORT $LN42@tectonicAc
	add	edi, eax
	jmp	SHORT $LN44@tectonicAc
$LN42@tectonicAc:
	cmp	eax, edi
	jl	SHORT $LN43@tectonicAc
	sub	eax, edi
$LN43@tectonicAc:
	mov	edi, eax
$LN44@tectonicAc:

; 419  : 			m_aaiFrac[iRx][iY] = (((m_aaiFrac[iRx][iY] * iX) + iDeep * (iWidth - iX)) / iWidth);

	shl	edx, 8
	add	edx, ebx
	lea	eax, DWORD PTR [ecx+edx*4+40]
	mov	DWORD PTR tv676[esp+20], eax
	mov	eax, DWORD PTR [eax]
	inc	ebp
	imul	eax, ebp
	cdq
	and	edx, 15					; 0000000fH
	add	eax, edx
	mov	edx, DWORD PTR tv676[esp+20]
	sar	eax, 4

; 420  : 			m_aaiFrac[iLx][iY] = (((m_aaiFrac[iLx][iY] * iX) + iDeep * (iWidth - iX)) / iWidth);

	shl	edi, 8
	mov	DWORD PTR [edx], eax
	add	edi, ebx
	mov	eax, DWORD PTR [ecx+edi*4+40]
	lea	edi, DWORD PTR [ecx+edi*4+40]
	imul	eax, ebp
	cdq
	and	edx, 15					; 0000000fH
	add	eax, edx
	sar	eax, 4
	add	esi, 4
	cmp	esi, 16					; 00000010H
	mov	DWORD PTR [edi], eax
	jl	$LL46@tectonicAc
	mov	eax, DWORD PTR [ecx+20]
	add	DWORD PTR tv928[esp+16], 4
	inc	ebx
	inc	eax
	cmp	ebx, eax
	jl	$LL45@tectonicAc
	pop	ebp
$LN7@tectonicAc:

; 421  : 		}
; 422  : 	}
; 423  : 
; 424  : 	for(int iY = 0; iY < m_iFracY + 1; iY++)

	mov	edx, DWORD PTR [ecx+20]
	inc	edx
	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN1@tectonicAc
	lea	edx, DWORD PTR [ecx+40]
	npad	5
$LL3@tectonicAc:

; 425  : 	{
; 426  : 		m_aaiFrac[m_iFracX][iY] = m_aaiFrac[0][iY];

	mov	esi, DWORD PTR [ecx+16]
	mov	edi, DWORD PTR [edx]
	shl	esi, 8
	add	esi, eax
	mov	DWORD PTR [ecx+esi*4+40], edi
	mov	esi, DWORD PTR [ecx+20]
	inc	eax
	inc	esi
	add	edx, 4
	cmp	eax, esi
	jl	SHORT $LL3@tectonicAc
$LN1@tectonicAc:
	pop	edi
	pop	esi
	pop	ebx

; 427  : 	}
; 428  : }

	pop	ecx
	ret	4
?tectonicAction@CvFractal@@IAEXPAV1@@Z ENDP		; CvFractal::tectonicAction
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<VoronoiSeed,256,1,297,0>::FStaticVector<VoronoiSeed,256,1,297,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<VoronoiSeed,256,1,297,0>::FStaticVector<VoronoiSeed,256,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 256			; 00000100H
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<VoronoiSeed,256,1,297,0>::FStaticVector<VoronoiSeed,256,1,297,0>
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@IAEXPAUVoronoiSeed@@I@Z ; FStaticVector<VoronoiSeed,256,1,297,0>::Free
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
; Function compile flags: /Ogtpy
;	COMDAT ?Free@?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@IAEXPAUVoronoiSeed@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@IAEXPAUVoronoiSeed@@I@Z PROC ; FStaticVector<VoronoiSeed,256,1,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@IAEXPAUVoronoiSeed@@I@Z ENDP ; FStaticVector<VoronoiSeed,256,1,297,0>::Free
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvFractal@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvFractal@@UAEPAXI@Z PROC				; CvFractal::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvFractal@@6B@
	je	SHORT $LN8@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvFractal@@UAEPAXI@Z ENDP				; CvFractal::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?fracInitInternal@CvFractal@@IAEXHHHAAVCvRandom@@PAEHHPAV1@HH@Z ; CvFractal::fracInitInternal
EXTRN	?get@CvRandom@@QAEGGPBD@Z:PROC			; CvRandom::get
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvfractal.cpp
;	COMDAT ?fracInitInternal@CvFractal@@IAEXHHHAAVCvRandom@@PAEHHPAV1@HH@Z
_TEXT	SEGMENT
_iScreen$ = -16						; size = 4
_iHintsWidth$ = -12					; size = 4
_iHintsHeight$ = -8					; size = 4
tv1935 = -4						; size = 4
tv1615 = -4						; size = 4
tv1705 = 8						; size = 4
tv1031 = 8						; size = 4
tv995 = 8						; size = 4
_iNewXs$ = 8						; size = 4
_iSmooth$ = 12						; size = 4
_iNewYs$ = 12						; size = 4
tv1033 = 16						; size = 4
tv888 = 16						; size = 4
_iGrain$ = 16						; size = 4
_random$ = 20						; size = 4
_pbyHints$ = 24						; size = 4
___formal$ = 28						; size = 4
tv1934 = 32						; size = 4
_iFlags$ = 32						; size = 4
_pRifts$ = 36						; size = 4
tv1016 = 40						; size = 4
_iX$ = 40						; size = 4
_iFracXExp$ = 40					; size = 4
tv1613 = 44						; size = 4
_iY$ = 44						; size = 4
_iFracYExp$ = 44					; size = 4
?fracInitInternal@CvFractal@@IAEXHHHAAVCvRandom@@PAEHHPAV1@HH@Z PROC ; CvFractal::fracInitInternal, COMDAT
; _this$ = ecx

; 86   : {

	sub	esp, 16					; 00000010H
	push	ebx

; 87   : 	FAssert(iNewXs < FRACTAL_MAX_DIMS);
; 88   : 	FAssert(iNewYs < FRACTAL_MAX_DIMS);
; 89   : 
; 90   : 	int iSmooth;
; 91   : 	int iScreen;  // This screens out already marked spots in m_aaiFrac[][];
; 92   : 	int iPass;
; 93   : 	int iSum;
; 94   : 	int iX, iY;
; 95   : 	int iI;
; 96   : 
; 97   : 	reset();

	or	eax, -1
	push	esi
	mov	esi, ecx

; 98   : 
; 99   : 	if(iFracXExp < 0)

	mov	ecx, DWORD PTR _iFracXExp$[esp+20]
	lea	ebx, DWORD PTR [esi+24]
	push	edi
	mov	DWORD PTR [ebx], eax
	mov	DWORD PTR [esi+28], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], eax
	test	ecx, ecx
	jge	SHORT $LN71@fracInitIn

; 100  : 	{
; 101  : 		iFracXExp = DEFAULT_FRAC_X_EXP;

	lea	ecx, DWORD PTR [eax+8]
$LN71@fracInitIn:

; 102  : 	}
; 103  : 	if(iFracYExp < 0)

	mov	edx, DWORD PTR _iFracYExp$[esp+24]
	test	edx, edx
	jge	SHORT $LN70@fracInitIn

; 104  : 	{
; 105  : 		iFracYExp = DEFAULT_FRAC_Y_EXP;

	mov	edx, 6
$LN70@fracInitIn:

; 109  : 	m_iFracYExp = iFracYExp;
; 110  : 	m_iFracX = 1 << iFracXExp;

	mov	eax, 1
	shl	eax, cl
	mov	DWORD PTR [ebx], ecx

; 111  : 	m_iFracY = 1 << iFracYExp;

	mov	ecx, edx
	mov	edi, 1
	shl	edi, cl
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+28], edx

; 112  : 
; 113  : 	// Init m_aaiFrac to all zeroes:
; 114  : 	for(iX = 0; iX < m_iFracX + 1; iX++)

	inc	eax
	xor	edx, edx
	push	ebp
	mov	DWORD PTR [esi+20], edi
	test	eax, eax
	jle	SHORT $LN67@fracInitIn

; 106  : 	}
; 107  : 
; 108  : 	m_iFracXExp = iFracXExp;

	lea	edi, DWORD PTR [esi+40]
$LL143@fracInitIn:

; 115  : 	{
; 116  : 		for(iY = 0; iY < m_iFracY + 1; iY++)

	mov	ecx, DWORD PTR [esi+20]
	inc	ecx
	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN68@fracInitIn
	mov	ecx, edi
$LL142@fracInitIn:

; 117  : 		{
; 118  : 			m_aaiFrac[iX][iY] = 0;

	mov	DWORD PTR [ecx], 0
	mov	ebp, DWORD PTR [esi+20]
	inc	eax
	inc	ebp
	add	ecx, 4
	cmp	eax, ebp
	jl	SHORT $LL142@fracInitIn
$LN68@fracInitIn:

; 112  : 
; 113  : 	// Init m_aaiFrac to all zeroes:
; 114  : 	for(iX = 0; iX < m_iFracX + 1; iX++)

	mov	eax, DWORD PTR [esi+16]
	inc	edx
	inc	eax
	add	edi, 1024				; 00000400H
	cmp	edx, eax
	jl	SHORT $LL143@fracInitIn
$LN67@fracInitIn:

; 119  : 		}
; 120  : 	}
; 121  : 
; 122  : 	m_iXs = iNewXs;
; 123  : 	m_iYs = iNewYs;
; 124  : 	m_iFlags = iFlags;
; 125  : 	m_iXInc = ((m_iFracX * FLOAT_PRECISION) / m_iXs);

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR _iNewXs$[esp+28]
	imul	eax, 1000				; 000003e8H
	cdq
	idiv	ecx
	mov	ebp, DWORD PTR _iNewYs$[esp+28]
	mov	edi, DWORD PTR _iFlags$[esp+28]
	mov	DWORD PTR [esi+4], ecx
	mov	DWORD PTR [esi+8], ebp
	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [esi+32], eax

; 126  : 	m_iYInc = ((m_iFracY * FLOAT_PRECISION) / m_iYs);

	mov	eax, DWORD PTR [esi+20]
	imul	eax, 1000				; 000003e8H
	cdq
	idiv	ebp
	mov	DWORD PTR [esi+36], eax

; 127  : 
; 128  : #ifdef NQM_FAST_COMP
; 129  : 	int iMinExp = MIN(m_iFracXExp, m_iFracYExp);
; 130  : #else
; 131  : 	int iMinExp = std::min(m_iFracXExp, m_iFracYExp);

	mov	ecx, DWORD PTR [esi+28]
	cmp	ecx, DWORD PTR [ebx]
	lea	eax, DWORD PTR [esi+28]
	jl	SHORT $LN81@fracInitIn
	mov	eax, ebx
$LN81@fracInitIn:
	mov	ebp, DWORD PTR [eax]

; 132  : #endif
; 133  : 	iSmooth = range(iMinExp - iGrain, 0, iMinExp);

	mov	eax, ebp
	sub	eax, DWORD PTR _iGrain$[esp+28]
	jns	SHORT $LN85@fracInitIn
	xor	ebp, ebp
	mov	DWORD PTR _iSmooth$[esp+28], ebp
	jmp	SHORT $LN82@fracInitIn
$LN85@fracInitIn:
	cmp	eax, ebp
	jle	SHORT $LN83@fracInitIn
	mov	DWORD PTR _iSmooth$[esp+28], ebp
	jmp	SHORT $LN82@fracInitIn
$LN83@fracInitIn:
	mov	ebp, eax
	mov	DWORD PTR _iSmooth$[esp+28], eax
$LN82@fracInitIn:

; 134  : 
; 135  : 	int iHintsWidth = (1 << (m_iFracXExp - iSmooth)) + ((m_iFlags & FRAC_WRAP_X) ? 0 : 1);

	mov	ecx, DWORD PTR [ebx]
	sub	ecx, ebp
	mov	edx, edi
	mov	eax, 1
	shl	eax, cl

; 136  : 	int iHintsHeight = (1 << (m_iFracYExp - iSmooth)) + ((m_iFlags & FRAC_WRAP_Y) ? 0 : 1);

	mov	ecx, DWORD PTR [esi+28]
	not	edx
	and	edx, 1
	add	eax, edx
	mov	DWORD PTR _iHintsWidth$[esp+32], eax
	sub	ecx, ebp
	shr	edi, 1
	mov	eax, 1
	shl	eax, cl
	not	edi
	and	edi, 1
	add	eax, edi
	mov	DWORD PTR _iHintsHeight$[esp+32], eax

; 137  : #ifdef CVASSERT_ENABLE
; 138  : 	if(pbyHints != NULL)
; 139  : 	{
; 140  : 		CvAssertMsg(iHintsLength == iHintsWidth*iHintsHeight, "pbyHints is the wrong size!")
; 141  : 	}
; 142  : #endif
; 143  : 
; 144  : 	for(iPass = iSmooth; iPass >= 0; iPass--)

	test	ebp, ebp
	jl	$LN61@fracInitIn
	mov	eax, 7
	sub	eax, DWORD PTR _iSmooth$[esp+28]
	mov	DWORD PTR tv1934[esp+28], eax
$LL63@fracInitIn:

; 145  : 	{
; 146  : 		iScreen = 0;

	xor	edi, edi
	xor	edx, edx

; 147  : 
; 148  : 		for(iI = 0; iI <= iPass; iI++)

	cmp	ebp, edi
	mov	DWORD PTR _iScreen$[esp+32], edx
	lea	eax, DWORD PTR [edi+1]
	jl	SHORT $LN58@fracInitIn
	mov	ecx, DWORD PTR tv1934[esp+28]
	mov	ebx, DWORD PTR _iSmooth$[esp+28]
	lea	ecx, DWORD PTR [ecx+ebx-6]
	add	ecx, ebp
$LL60@fracInitIn:

; 149  : 		{
; 150  : 			iScreen |= (1 << iI);

	or	edx, eax
	rol	eax, 1
	sub	ecx, 1
	jne	SHORT $LL60@fracInitIn
	mov	DWORD PTR _iScreen$[esp+32], edx
$LN58@fracInitIn:

; 151  : 		}
; 152  : 
; 153  : 		if(m_iFlags & FRAC_WRAP_Y)

	mov	eax, DWORD PTR [esi+12]
	test	al, 2
	je	SHORT $LN57@fracInitIn

; 154  : 		{
; 155  : 			for(iX = 0; iX < m_iFracX + 1; iX++)

	mov	eax, DWORD PTR [esi+16]
	inc	eax
	xor	edx, edx
	test	eax, eax
	jle	SHORT $LN49@fracInitIn
	xor	ecx, ecx
	lea	eax, DWORD PTR [esi+40]
$LL56@fracInitIn:

; 156  : 			{
; 157  : 				m_aaiFrac[iX][m_iFracY] = m_aaiFrac[iX][0];

	mov	edi, DWORD PTR [esi+20]
	mov	ebx, DWORD PTR [eax]
	add	edi, ecx
	mov	DWORD PTR [esi+edi*4+40], ebx
	mov	edi, DWORD PTR [esi+16]
	inc	edx
	inc	edi
	add	eax, 1024				; 00000400H
	add	ecx, 256				; 00000100H
	cmp	edx, edi
	jl	SHORT $LL56@fracInitIn

; 158  : 			}
; 159  : 		}
; 160  : 		else if(m_iFlags & FRAC_POLAR)

	xor	edi, edi
	jmp	SHORT $LN49@fracInitIn
$LN57@fracInitIn:
	test	al, 8
	je	SHORT $LN49@fracInitIn

; 161  : 		{
; 162  : 			for(iX = 0; iX < m_iFracX + 1; iX++)

	mov	ecx, DWORD PTR [esi+16]
	inc	ecx
	xor	edx, edx
	test	ecx, ecx
	jle	SHORT $LN49@fracInitIn
	xor	ecx, ecx
	lea	eax, DWORD PTR [esi+40]
	npad	2
$LL51@fracInitIn:

; 163  : 			{
; 164  : 				m_aaiFrac[iX][   0    ] = 0;

	mov	DWORD PTR [eax], edi

; 165  : 				m_aaiFrac[iX][m_iFracY] = 0;

	mov	ebx, DWORD PTR [esi+20]
	add	ebx, ecx
	mov	DWORD PTR [esi+ebx*4+40], edi
	mov	ebx, DWORD PTR [esi+16]
	inc	edx
	inc	ebx
	add	eax, 1024				; 00000400H
	add	ecx, 256				; 00000100H
	cmp	edx, ebx
	jl	SHORT $LL51@fracInitIn
$LN49@fracInitIn:

; 166  : 			}
; 167  : 		}
; 168  : 
; 169  : 		if(m_iFlags & FRAC_WRAP_X)

	mov	eax, DWORD PTR [esi+12]
	test	al, 1
	je	SHORT $LN48@fracInitIn

; 170  : 		{
; 171  : 			for(iY = 0; iY < m_iFracY + 1; iY++)

	mov	edx, DWORD PTR [esi+20]
	inc	edx
	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN40@fracInitIn
	lea	ecx, DWORD PTR [esi+40]
$LL47@fracInitIn:

; 172  : 			{
; 173  : 				m_aaiFrac[m_iFracX][iY] = m_aaiFrac[0][iY];

	mov	edx, DWORD PTR [esi+16]
	mov	edi, DWORD PTR [ecx]
	shl	edx, 8
	add	edx, eax
	mov	DWORD PTR [esi+edx*4+40], edi
	mov	edx, DWORD PTR [esi+20]
	inc	eax
	inc	edx
	add	ecx, 4
	cmp	eax, edx
	jl	SHORT $LL47@fracInitIn

; 174  : 			}
; 175  : 		}
; 176  : 		else if(m_iFlags & FRAC_POLAR)

	jmp	SHORT $LN40@fracInitIn
$LN48@fracInitIn:
	test	al, 8
	je	SHORT $LN40@fracInitIn

; 177  : 		{
; 178  : 			for(iY = 0; iY < m_iFracY + 1; iY++)

	mov	ecx, DWORD PTR [esi+20]
	inc	ecx
	xor	eax, eax
	test	ecx, ecx
	jle	SHORT $LN40@fracInitIn
	lea	ecx, DWORD PTR [esi+40]
$LL42@fracInitIn:

; 179  : 			{
; 180  : 				m_aaiFrac[   0    ][iY] = 0;

	mov	DWORD PTR [ecx], edi

; 181  : 				m_aaiFrac[m_iFracX][iY] = 0;

	mov	edx, DWORD PTR [esi+16]
	shl	edx, 8
	add	edx, eax
	mov	DWORD PTR [esi+edx*4+40], edi
	mov	edx, DWORD PTR [esi+20]
	inc	eax
	inc	edx
	add	ecx, 4
	cmp	eax, edx
	jl	SHORT $LL42@fracInitIn
$LN40@fracInitIn:

; 182  : 			}
; 183  : 		}
; 184  : 
; 185  : 		if(m_iFlags & FRAC_CENTER_RIFT)

	mov	eax, DWORD PTR [esi+12]
	test	al, 16					; 00000010H
	je	$LN28@fracInitIn

; 186  : 		{
; 187  : 			if(m_iFlags & FRAC_WRAP_Y)

	test	al, 2
	je	$LN35@fracInitIn

; 188  : 			{
; 189  : 				for(iX = 0; iX < m_iFracX + 1; iX++)

	mov	eax, DWORD PTR [esi+16]
	xor	edi, edi
	inc	eax
	mov	DWORD PTR _iX$[esp+28], edi
	test	eax, eax
	jle	$LN35@fracInitIn
	lea	ecx, DWORD PTR [esi+40]
	mov	DWORD PTR tv1613[esp+28], ecx
$LL37@fracInitIn:

; 190  : 				{
; 191  : 					for(iY = 0; iY < (m_iFracY / 6); iY++)

	mov	edx, DWORD PTR [esi+20]
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	xor	ecx, ecx
	test	eax, eax
	jle	$LN36@fracInitIn
	shl	edi, 8
	mov	DWORD PTR tv888[esp+28], edi
	mov	edi, DWORD PTR tv1613[esp+28]
	npad	4
$LL34@fracInitIn:

; 192  : 					{
; 193  : 						m_aaiFrac[iX][        iY         ] /= (abs((m_iFracY / 12) - iY) + 1);

	mov	edx, DWORD PTR [esi+20]
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	sub	eax, ecx
	cdq
	mov	ebx, eax
	mov	eax, DWORD PTR [edi]
	xor	ebx, edx
	sub	ebx, edx
	cdq
	inc	ebx
	idiv	ebx
	add	edi, 4
	mov	DWORD PTR [edi-4], eax

; 194  : 						m_aaiFrac[iX][(m_iFracY / 2) + iY] /= (abs((m_iFracY / 12) - iY) + 1);

	mov	ebx, DWORD PTR [esi+20]
	mov	eax, ebx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, DWORD PTR tv888[esp+28]
	add	eax, ecx
	lea	edx, DWORD PTR [esi+eax*4+40]
	mov	DWORD PTR tv995[esp+28], edx
	mov	eax, 715827883				; 2aaaaaabH
	imul	ebx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	sub	eax, ecx
	cdq
	mov	ebx, eax
	mov	eax, DWORD PTR tv995[esp+28]
	mov	eax, DWORD PTR [eax]
	xor	ebx, edx
	sub	ebx, edx
	cdq
	inc	ebx
	idiv	ebx
	mov	edx, DWORD PTR tv995[esp+28]
	inc	ecx
	mov	DWORD PTR [edx], eax
	mov	edx, DWORD PTR [esi+20]
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	ecx, eax
	jl	SHORT $LL34@fracInitIn

; 190  : 				{
; 191  : 					for(iY = 0; iY < (m_iFracY / 6); iY++)

	mov	edi, DWORD PTR _iX$[esp+28]
$LN36@fracInitIn:

; 188  : 			{
; 189  : 				for(iX = 0; iX < m_iFracX + 1; iX++)

	mov	ecx, DWORD PTR [esi+16]
	add	DWORD PTR tv1613[esp+28], 1024		; 00000400H
	inc	edi
	inc	ecx
	cmp	edi, ecx
	mov	DWORD PTR _iX$[esp+28], edi
	jl	$LL37@fracInitIn
$LN35@fracInitIn:

; 195  : 					}
; 196  : 				}
; 197  : 			}
; 198  : 
; 199  : 			if(m_iFlags & FRAC_WRAP_X)

	test	BYTE PTR [esi+12], 1
	je	$LN28@fracInitIn

; 200  : 			{
; 201  : 				for(iY = 0; iY < m_iFracY + 1; iY++)

	mov	edx, DWORD PTR [esi+20]
	inc	edx
	mov	DWORD PTR _iY$[esp+28], 0
	test	edx, edx
	jle	$LN28@fracInitIn
	lea	edi, DWORD PTR [esi+40]
	mov	DWORD PTR tv1705[esp+28], edi
$LL30@fracInitIn:

; 202  : 				{
; 203  : 					for(iX = 0; iX < (m_iFracX / 6); iX++)

	mov	edx, DWORD PTR [esi+16]
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	xor	ecx, ecx
	test	eax, eax
	jle	$LN29@fracInitIn
	npad	4
$LL27@fracInitIn:

; 204  : 					{
; 205  : 						m_aaiFrac[        iX         ][iY] /= (abs((m_iFracX / 12) - iX) + 1);

	mov	edx, DWORD PTR [esi+16]
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	sub	eax, ecx
	cdq
	mov	ebx, eax
	mov	eax, DWORD PTR [edi]
	xor	ebx, edx
	sub	ebx, edx
	cdq
	inc	ebx
	idiv	ebx
	add	edi, 1024				; 00000400H
	mov	DWORD PTR [edi-1024], eax

; 206  : 						m_aaiFrac[(m_iFracX / 2) + iX][iY] /= (abs((m_iFracX / 12) - iX) + 1);

	mov	ebx, DWORD PTR [esi+16]
	mov	eax, ebx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	shl	eax, 8
	add	eax, DWORD PTR _iY$[esp+28]
	lea	edx, DWORD PTR [esi+eax*4+40]
	mov	DWORD PTR tv1016[esp+28], edx
	mov	eax, 715827883				; 2aaaaaabH
	imul	ebx
	sar	edx, 1
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	sub	eax, ecx
	cdq
	mov	ebx, eax
	mov	eax, DWORD PTR tv1016[esp+28]
	mov	eax, DWORD PTR [eax]
	xor	ebx, edx
	sub	ebx, edx
	cdq
	inc	ebx
	idiv	ebx
	mov	edx, DWORD PTR tv1016[esp+28]
	inc	ecx
	mov	DWORD PTR [edx], eax
	mov	edx, DWORD PTR [esi+16]
	mov	eax, 715827883				; 2aaaaaabH
	imul	edx
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	ecx, eax
	jl	$LL27@fracInitIn
$LN29@fracInitIn:

; 200  : 			{
; 201  : 				for(iY = 0; iY < m_iFracY + 1; iY++)

	mov	eax, DWORD PTR _iY$[esp+28]
	mov	edi, DWORD PTR tv1705[esp+28]
	mov	ecx, DWORD PTR [esi+20]
	inc	eax
	add	edi, 4
	inc	ecx
	cmp	eax, ecx
	mov	DWORD PTR _iY$[esp+28], eax
	mov	DWORD PTR tv1705[esp+28], edi
	jl	$LL30@fracInitIn
$LN28@fracInitIn:

; 207  : 					}
; 208  : 				}
; 209  : 			}
; 210  : 		}
; 211  : 
; 212  : 		for(iX = 0; iX < (m_iFracX >> iPass) + ((m_iFlags & FRAC_WRAP_X) ? 0 : 1); iX++)

	mov	edx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR [esi+12]
	mov	ecx, ebp
	sar	edx, cl
	not	eax
	and	eax, 1
	mov	DWORD PTR _iX$[esp+28], 0
	add	edx, eax
	test	edx, edx
	jle	$LN62@fracInitIn
	mov	edx, DWORD PTR _iScreen$[esp+32]
$LL140@fracInitIn:

; 213  : 		{
; 214  : 			for(iY = 0; iY < (m_iFracY >> iPass) + ((m_iFlags & FRAC_WRAP_Y) ? 0 : 1); iY++)

	mov	eax, DWORD PTR [esi+12]
	mov	edi, DWORD PTR [esi+20]
	shr	eax, 1
	mov	ecx, ebp
	sar	edi, cl
	not	eax
	and	eax, 1
	xor	ebx, ebx
	add	eax, edi
	mov	DWORD PTR _iY$[esp+28], ebx
	test	eax, eax
	jle	$LN23@fracInitIn
	mov	edi, DWORD PTR _iX$[esp+28]
	shl	edi, cl
	mov	DWORD PTR tv1031[esp+28], edi
	npad	4
$LL21@fracInitIn:

; 215  : 			{
; 216  : 				if((iPass == iSmooth)) // If this is the first, pass, set the initial random spots

	cmp	ebp, DWORD PTR _iSmooth$[esp+28]
	jne	SHORT $LN18@fracInitIn

; 217  : 				{
; 218  : 					if(pbyHints == NULL)

	cmp	DWORD PTR _pbyHints$[esp+28], 0
	jne	SHORT $LN17@fracInitIn

; 219  : 					{
; 220  : 						m_aaiFrac[iX << iPass][iY << iPass] = random.get(256, "Fractal Gen");

	mov	ecx, DWORD PTR _random$[esp+28]
	push	OFFSET $SG217756
	push	256					; 00000100H
	call	?get@CvRandom@@QAEGGPBD@Z		; CvRandom::get
	movzx	edx, ax

; 221  : 					}
; 222  : 					else

	jmp	SHORT $LN147@fracInitIn
$LN17@fracInitIn:

; 223  : 					{
; 224  : 						int iXX = iX % iHintsWidth;  // wrap
; 225  : 						int iYY = iY % iHintsHeight; // wrap

	mov	eax, ebx
	cdq
	idiv	DWORD PTR _iHintsHeight$[esp+32]
	mov	eax, DWORD PTR _iX$[esp+28]
	mov	ecx, edx
	cdq

; 226  : 						int iHintsI = iYY*iHintsWidth + iXX;

	imul	ecx, DWORD PTR _iHintsWidth$[esp+32]
	idiv	DWORD PTR _iHintsWidth$[esp+32]
	add	ecx, DWORD PTR _pbyHints$[esp+28]

; 227  : 
; 228  : #ifdef CVASSERT_ENABLE
; 229  : 						DEBUG_VARIABLE(iHintsLength);
; 230  : 						CvAssertMsg(iHintsI < iHintsLength, "iHintsI out of range");
; 231  : #endif
; 232  : 						m_aaiFrac[iX << iPass][iY << iPass] = pbyHints[iHintsI];

	movzx	edx, BYTE PTR [edx+ecx]
$LN147@fracInitIn:
	mov	ecx, ebp
	mov	eax, ebx
	shl	eax, cl
	mov	ecx, edi
	shl	ecx, 8
	add	eax, ecx
	mov	DWORD PTR [esi+eax*4+40], edx

; 233  : 					}
; 234  : 				}
; 235  : 				else  // Interpolate

	jmp	$LN20@fracInitIn
$LN18@fracInitIn:

; 236  : 				{
; 237  : 					iSum = 0;
; 238  : 					if((iX << iPass) & iScreen)
; 239  : 					{
; 240  : 						if((iY << iPass) & iScreen)   // (center)

	mov	eax, ebx
	mov	ecx, ebp
	shl	eax, cl
	mov	DWORD PTR tv1033[esp+28], eax
	test	edx, edi
	je	$LN14@fracInitIn
	test	edx, eax

; 241  : 						{
; 242  : 							iSum += m_aaiFrac[(iX-1) << iPass][(iY-1) << iPass];

	mov	eax, DWORD PTR _iX$[esp+28]
	je	$LN13@fracInitIn

; 243  : 							iSum += m_aaiFrac[(iX+1) << iPass][(iY-1) << iPass];

	mov	edx, DWORD PTR _iX$[esp+28]
	inc	edx
	shl	edx, cl
	inc	ebx
	dec	eax
	shl	eax, cl
	lea	edi, DWORD PTR [ebx-2]
	shl	edi, cl

; 244  : 							iSum += m_aaiFrac[(iX-1) << iPass][(iY+1) << iPass];

	shl	ebx, cl
	shl	edx, 8
	shl	eax, 8

; 245  : 							iSum += m_aaiFrac[(iX+1) << iPass][(iY+1) << iPass];
; 246  : 							iSum >>= 2;

	lea	ecx, DWORD PTR [edi+edx]
	add	edi, eax
	mov	DWORD PTR tv1615[esp+32], edi
	mov	edi, DWORD PTR [esi+ecx*4+40]
	mov	ecx, DWORD PTR tv1615[esp+32]
	add	edi, DWORD PTR [esi+ecx*4+40]
	add	edx, ebx
	add	edi, DWORD PTR [esi+edx*4+40]
	add	ebx, eax
	add	edi, DWORD PTR [esi+ebx*4+40]

; 247  : 							iSum += random.get(1 << (8 - iSmooth + iPass), "Fractal Gen 2");

	mov	eax, DWORD PTR tv1934[esp+28]
	lea	ebx, DWORD PTR [eax+ebp]
	lea	ecx, DWORD PTR [ebx+1]
	mov	edx, 1
	shl	edx, cl
	mov	ecx, DWORD PTR _random$[esp+28]
	push	OFFSET $SG217764
	sar	edi, 2
	push	edx
	call	?get@CvRandom@@QAEGGPBD@Z		; CvRandom::get

; 248  : 							iSum -= 1 << (7 - iSmooth + iPass);

	mov	edx, 1
	mov	ecx, ebx
	shl	edx, cl
	movzx	eax, ax
	sub	eax, edx
	add	edi, eax

; 249  : 							iSum = range(iSum, 0, 255);

	jns	SHORT $LN91@fracInitIn

; 250  : 							m_aaiFrac[iX << iPass][iY << iPass] = iSum;

	mov	eax, DWORD PTR tv1031[esp+28]
	xor	edi, edi
	shl	eax, 8
	add	eax, DWORD PTR tv1033[esp+28]
	mov	DWORD PTR [esi+eax*4+40], edi

; 251  : 						}
; 252  : 						else  // (horizontal)

	jmp	$LN145@fracInitIn

; 249  : 							iSum = range(iSum, 0, 255);

$LN91@fracInitIn:
	cmp	edi, 255				; 000000ffH
	jle	SHORT $LN138@fracInitIn
	mov	edi, 255				; 000000ffH
$LN138@fracInitIn:

; 250  : 							m_aaiFrac[iX << iPass][iY << iPass] = iSum;

	mov	eax, DWORD PTR tv1031[esp+28]
	shl	eax, 8
	add	eax, DWORD PTR tv1033[esp+28]
	mov	DWORD PTR [esi+eax*4+40], edi

; 251  : 						}
; 252  : 						else  // (horizontal)

	jmp	$LN145@fracInitIn
$LN13@fracInitIn:

; 253  : 						{
; 254  : 							iSum += m_aaiFrac[(iX-1) << iPass][iY << iPass];
; 255  : 							iSum += m_aaiFrac[(iX+1) << iPass][iY << iPass];
; 256  : 							iSum >>= 1;

	mov	edx, DWORD PTR tv1033[esp+28]
	lea	edi, DWORD PTR [eax-1]
	shl	edi, cl
	inc	eax
	mov	ecx, ebp
	shl	eax, cl

; 257  : 							iSum += random.get(1 << (8 - iSmooth + iPass), "Fractal Gen 3");

	mov	ecx, DWORD PTR tv1934[esp+28]
	shl	edi, 8
	add	edi, edx
	mov	edi, DWORD PTR [esi+edi*4+40]
	shl	eax, 8
	add	eax, edx
	add	edi, DWORD PTR [esi+eax*4+40]
	lea	eax, DWORD PTR [ecx+ebp]
	lea	ecx, DWORD PTR [eax+1]
	mov	edx, 1
	shl	edx, cl
	mov	ecx, DWORD PTR _random$[esp+28]
	push	OFFSET $SG217766
	sar	edi, 1
	push	edx
	call	?get@CvRandom@@QAEGGPBD@Z		; CvRandom::get

; 258  : 							iSum -= 1 << (7 - iSmooth + iPass);

	mov	ecx, DWORD PTR tv1934[esp+28]
	add	ecx, ebp
	mov	edx, 1
	shl	edx, cl
	movzx	eax, ax
	sub	eax, edx
	add	edi, eax

; 259  : 							iSum = range(iSum, 0, 255);

	jns	SHORT $LN97@fracInitIn

; 260  : 							m_aaiFrac[iX << iPass][iY << iPass] = iSum;

	mov	edx, DWORD PTR tv1031[esp+28]
	xor	edi, edi
	shl	edx, 8
	add	edx, DWORD PTR tv1033[esp+28]
	mov	DWORD PTR [esi+edx*4+40], edi

; 261  : 						}
; 262  : 					}
; 263  : 					else

	jmp	$LN146@fracInitIn

; 259  : 							iSum = range(iSum, 0, 255);

$LN97@fracInitIn:
	cmp	edi, 255				; 000000ffH
	jle	SHORT $LN95@fracInitIn
	mov	edi, 255				; 000000ffH
$LN95@fracInitIn:

; 260  : 							m_aaiFrac[iX << iPass][iY << iPass] = iSum;

	mov	edx, DWORD PTR tv1031[esp+28]
	shl	edx, 8
	add	edx, DWORD PTR tv1033[esp+28]
	mov	DWORD PTR [esi+edx*4+40], edi

; 261  : 						}
; 262  : 					}
; 263  : 					else

	jmp	$LN146@fracInitIn
$LN14@fracInitIn:

; 264  : 					{
; 265  : 						if((iY << iPass) & iScreen)   // (vertical)

	test	edx, eax
	je	$LN20@fracInitIn

; 266  : 						{
; 267  : 							iSum += m_aaiFrac[iX << iPass][(iY-1) << iPass];

	mov	eax, DWORD PTR _iY$[esp+28]
	mov	edi, DWORD PTR tv1031[esp+28]
	inc	eax
	lea	edx, DWORD PTR [eax-2]
	mov	ecx, ebp
	shl	edx, cl

; 268  : 							iSum += m_aaiFrac[iX << iPass][(iY+1) << iPass];

	shl	eax, cl
	shl	edi, 8

; 269  : 							iSum >>= 1;
; 270  : 							iSum += random.get(1 << (8 - iSmooth + iPass), "Fractal Gen 4");

	push	OFFSET $SG217769
	add	edx, edi
	mov	ebx, DWORD PTR [esi+edx*4+40]
	add	eax, edi
	add	ebx, DWORD PTR [esi+eax*4+40]
	mov	eax, DWORD PTR tv1934[esp+32]
	add	eax, ebp
	lea	ecx, DWORD PTR [eax+1]
	mov	edx, 1
	shl	edx, cl
	mov	ecx, DWORD PTR _random$[esp+32]
	sar	ebx, 1
	mov	DWORD PTR tv1935[esp+36], eax
	push	edx
	call	?get@CvRandom@@QAEGGPBD@Z		; CvRandom::get

; 271  : 							iSum -= 1 << (7 - iSmooth + iPass);

	mov	ecx, DWORD PTR tv1935[esp+32]
	mov	edx, 1
	shl	edx, cl
	movzx	eax, ax
	sub	eax, edx
	add	ebx, eax

; 272  : 							iSum = range(iSum, 0, 255);

	jns	SHORT $LN103@fracInitIn
	xor	ebx, ebx
	jmp	SHORT $LN101@fracInitIn
$LN103@fracInitIn:
	cmp	ebx, 255				; 000000ffH
	jle	SHORT $LN101@fracInitIn
	mov	ebx, 255				; 000000ffH
$LN101@fracInitIn:

; 273  : #ifdef AUI_WARNING_FIXES
; 274  : 							m_aaiFrac[iX << iPass][iY << iPass] = iSum;
; 275  : #else
; 276  : 							m_aaiFrac[iX << iPass][iY << iPass] = (BYTE) iSum;

	mov	ecx, DWORD PTR tv1033[esp+28]
	movzx	eax, bl
	add	ecx, edi
	mov	DWORD PTR [esi+ecx*4+40], eax
$LN145@fracInitIn:
	mov	ebx, DWORD PTR _iY$[esp+28]
$LN146@fracInitIn:
	mov	edi, DWORD PTR tv1031[esp+28]
$LN20@fracInitIn:

; 213  : 		{
; 214  : 			for(iY = 0; iY < (m_iFracY >> iPass) + ((m_iFlags & FRAC_WRAP_Y) ? 0 : 1); iY++)

	mov	edx, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [esi+20]
	shr	edx, 1
	mov	ecx, ebp
	not	edx
	sar	eax, cl
	and	edx, 1
	inc	ebx
	mov	DWORD PTR _iY$[esp+28], ebx
	add	edx, eax
	cmp	ebx, edx
	mov	edx, DWORD PTR _iScreen$[esp+32]
	jl	$LL21@fracInitIn
$LN23@fracInitIn:

; 207  : 					}
; 208  : 				}
; 209  : 			}
; 210  : 		}
; 211  : 
; 212  : 		for(iX = 0; iX < (m_iFracX >> iPass) + ((m_iFlags & FRAC_WRAP_X) ? 0 : 1); iX++)

	mov	edi, DWORD PTR [esi+16]
	mov	eax, DWORD PTR _iX$[esp+28]
	mov	ecx, ebp
	sar	edi, cl
	mov	ecx, DWORD PTR [esi+12]
	not	ecx
	and	ecx, 1
	inc	eax
	add	edi, ecx
	cmp	eax, edi
	mov	DWORD PTR _iX$[esp+28], eax
	jl	$LL140@fracInitIn
$LN62@fracInitIn:

; 137  : #ifdef CVASSERT_ENABLE
; 138  : 	if(pbyHints != NULL)
; 139  : 	{
; 140  : 		CvAssertMsg(iHintsLength == iHintsWidth*iHintsHeight, "pbyHints is the wrong size!")
; 141  : 	}
; 142  : #endif
; 143  : 
; 144  : 	for(iPass = iSmooth; iPass >= 0; iPass--)

	sub	ebp, 1
	jns	$LL63@fracInitIn
$LN61@fracInitIn:

; 277  : #endif
; 278  : 						}
; 279  : 						else
; 280  : 						{
; 281  : 							continue;  // (corner) This was already set in an earlier iPass.
; 282  : 						}
; 283  : 					}
; 284  : 				}
; 285  : 			}
; 286  : 		}
; 287  : 	}
; 288  : 
; 289  : 	if(pRifts)

	mov	eax, DWORD PTR _pRifts$[esp+28]
	pop	ebp
	test	eax, eax
	je	SHORT $LN8@fracInitIn

; 290  : 	{
; 291  : 		tectonicAction(pRifts);  //  Assumes FRAC_WRAP_X is on.

	push	eax
	mov	ecx, esi
	call	?tectonicAction@CvFractal@@IAEXPAV1@@Z	; CvFractal::tectonicAction
$LN8@fracInitIn:

; 292  : 	}
; 293  : 
; 294  : 	if(m_iFlags & FRAC_INVERT_HEIGHTS)

	test	BYTE PTR [esi+12], 32			; 00000020H
	je	SHORT $LN4@fracInitIn

; 295  : 	{
; 296  : 		for(iX = 0; iX < m_iFracX; iX++)

	xor	edx, edx
	cmp	DWORD PTR [esi+16], edx
	jle	SHORT $LN4@fracInitIn
	lea	edi, DWORD PTR [esi+40]
$LL6@fracInitIn:

; 297  : 		{
; 298  : 			for(iY = 0; iY < m_iFracY; iY++)

	xor	ecx, ecx
	cmp	DWORD PTR [esi+20], ecx
	jle	SHORT $LN5@fracInitIn
	mov	eax, edi
	npad	3
$LL3@fracInitIn:

; 299  : 			{
; 300  : 				m_aaiFrac[iX][iY] = (255 - m_aaiFrac[iX][iY]);

	mov	ebx, 255				; 000000ffH
	sub	ebx, DWORD PTR [eax]
	inc	ecx
	mov	DWORD PTR [eax], ebx
	add	eax, 4
	cmp	ecx, DWORD PTR [esi+20]
	jl	SHORT $LL3@fracInitIn
$LN5@fracInitIn:

; 295  : 	{
; 296  : 		for(iX = 0; iX < m_iFracX; iX++)

	inc	edx
	add	edi, 1024				; 00000400H
	cmp	edx, DWORD PTR [esi+16]
	jl	SHORT $LL6@fracInitIn
$LN4@fracInitIn:
	pop	edi
	pop	esi
	pop	ebx

; 301  : 			}
; 302  : 		}
; 303  : 	}
; 304  : }

	add	esp, 16					; 00000010H
	ret	40					; 00000028H
?fracInitInternal@CvFractal@@IAEXHHHAAVCvRandom@@PAEHHPAV1@HH@Z ENDP ; CvFractal::fracInitInternal
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<VoronoiSeed,256,1,297,0>::~FStaticVector<VoronoiSeed,256,1,297,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<VoronoiSeed,256,1,297,0>::~FStaticVector<VoronoiSeed,256,1,297,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec:

; 619  : 	};

	ret	0
??1?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<VoronoiSeed,256,1,297,0>::~FStaticVector<VoronoiSeed,256,1,297,0>
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<VoronoiSeed,256,1,297,0>::GrowSize
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSize@?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<VoronoiSeed,256,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN30@GrowSize
	mov	DWORD PTR [esi+8], 1
$LN30@GrowSize:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize
	npad	6
$LL8@GrowSize:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN31@GrowSize

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize
$LN31@GrowSize:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 256				; 00000100H
	jbe	SHORT $LN15@GrowSize
	push	798					; 0000031eH
	lea	eax, DWORD PTR [ebp+ebp*4]
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	add	eax, eax
	add	eax, eax
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN14@GrowSize
$LN15@GrowSize:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 256			; 00000100H
$LN14@GrowSize:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	lea	ecx, DWORD PTR [eax+eax*4]
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN33@GrowSize
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN33@GrowSize:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+5132], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<VoronoiSeed,256,1,297,0>::GrowSize
_TEXT	ENDS
PUBLIC	?GrowSizeToFit@?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<VoronoiSeed,256,1,297,0>::GrowSizeToFit
; Function compile flags: /Ogtpy
;	COMDAT ?GrowSizeToFit@?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSizeToFit@?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<VoronoiSeed,256,1,297,0>::GrowSizeToFit, COMDAT
; _this$ = ecx

; 776  : 	{

	push	esi
	push	edi

; 777  : 		if( uiFit <= m_uiCurrMaxSize )

	mov	edi, DWORD PTR _uiFit$[esp+4]
	mov	esi, ecx
	cmp	edi, DWORD PTR [esi+8]
	jbe	SHORT $LN7@GrowSizeTo
	push	ebx

; 778  : 			return;
; 779  : 
; 780  : 		m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edi

; 781  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	cmp	edi, 256				; 00000100H
	jbe	SHORT $LN12@GrowSizeTo
	push	798					; 0000031eH
	lea	eax, DWORD PTR [edi+edi*4]
	push	OFFSET ??_C@_0GH@ECFAPJEJ@c?3?2users?2enormousapplepie?2docume@
	add	eax, eax
	add	eax, eax
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	ebx, eax
	mov	DWORD PTR [esi+8], edi
	jmp	SHORT $LN11@GrowSizeTo
$LN12@GrowSizeTo:
	lea	ebx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 256			; 00000100H
$LN11@GrowSizeTo:

; 782  : 		if( bPODType ){
; 783  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	eax, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	lea	ecx, DWORD PTR [eax+eax*4]
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	ebx
	call	_memcpy

; 784  : 		}else{
; 785  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 786  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 787  : 		}
; 788  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [esi+12]
	add	esp, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN17@GrowSizeTo
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN17@GrowSizeTo:

; 789  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], ebx

; 790  : 
; 791  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+5132], 1
	pop	ebx
$LN7@GrowSizeTo:
	pop	edi
	pop	esi

; 792  : 	};

	ret	4
?GrowSizeToFit@?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<VoronoiSeed,256,1,297,0>::GrowSizeToFit
_TEXT	ENDS
PUBLIC	?fracInit@CvFractal@@QAEXHHHAAVCvRandom@@HPAV1@HH@Z ; CvFractal::fracInit
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvfractal.cpp
;	COMDAT ?fracInit@CvFractal@@QAEXHHHAAVCvRandom@@HPAV1@HH@Z
_TEXT	SEGMENT
_iNewXs$ = 8						; size = 4
_iNewYs$ = 12						; size = 4
_iGrain$ = 16						; size = 4
_random$ = 20						; size = 4
_iFlags$ = 24						; size = 4
_pRifts$ = 28						; size = 4
_iFracXExp$ = 32					; size = 4
_iFracYExp$ = 36					; size = 4
?fracInit@CvFractal@@QAEXHHHAAVCvRandom@@HPAV1@HH@Z PROC ; CvFractal::fracInit, COMDAT
; _this$ = ecx

; 66   : 	fracInitInternal(iNewXs, iNewYs, iGrain, random, NULL, -1, iFlags, pRifts, iFracXExp, iFracYExp);

	mov	eax, DWORD PTR _iFracYExp$[esp-4]
	mov	edx, DWORD PTR _iFracXExp$[esp-4]
	push	eax
	mov	eax, DWORD PTR _pRifts$[esp]
	push	edx
	mov	edx, DWORD PTR _iFlags$[esp+4]
	push	eax
	mov	eax, DWORD PTR _random$[esp+8]
	push	edx
	mov	edx, DWORD PTR _iGrain$[esp+12]
	push	-1
	push	0
	push	eax
	mov	eax, DWORD PTR _iNewYs$[esp+24]
	push	edx
	mov	edx, DWORD PTR _iNewXs$[esp+28]
	push	eax
	push	edx
	call	?fracInitInternal@CvFractal@@IAEXHHHAAVCvRandom@@PAEHHPAV1@HH@Z ; CvFractal::fracInitInternal

; 67   : }

	ret	32					; 00000020H
?fracInit@CvFractal@@QAEXHHHAAVCvRandom@@HPAV1@HH@Z ENDP ; CvFractal::fracInit
_TEXT	ENDS
PUBLIC	?fracInitHinted@CvFractal@@QAEXHHHAAVCvRandom@@PAEHHPAV1@HH@Z ; CvFractal::fracInitHinted
; Function compile flags: /Ogtpy
;	COMDAT ?fracInitHinted@CvFractal@@QAEXHHHAAVCvRandom@@PAEHHPAV1@HH@Z
_TEXT	SEGMENT
_iNewXs$ = 8						; size = 4
_iNewYs$ = 12						; size = 4
_iGrain$ = 16						; size = 4
_random$ = 20						; size = 4
_pbyHints$ = 24						; size = 4
_iHintsLength$ = 28					; size = 4
_iFlags$ = 32						; size = 4
_pRifts$ = 36						; size = 4
_iFracXExp$ = 40					; size = 4
_iFracYExp$ = 44					; size = 4
?fracInitHinted@CvFractal@@QAEXHHHAAVCvRandom@@PAEHHPAV1@HH@Z PROC ; CvFractal::fracInitHinted, COMDAT
; _this$ = ecx

; 77   : 	int iFlagsNonPolar = iFlags & (~FRAC_POLAR);

	mov	edx, DWORD PTR _iFlags$[esp-4]
	and	edx, -9					; fffffff7H

; 78   : 	fracInitInternal(iNewXs, iNewYs, iGrain, random, pbyHints, iHintsLength, iFlagsNonPolar, pRifts, iFracXExp, iFracYExp);

	mov	DWORD PTR _iFlags$[esp-4], edx
	jmp	?fracInitInternal@CvFractal@@IAEXHHHAAVCvRandom@@PAEHHPAV1@HH@Z ; CvFractal::fracInitInternal
?fracInitHinted@CvFractal@@QAEXHHHAAVCvRandom@@PAEHHPAV1@HH@Z ENDP ; CvFractal::fracInitHinted
_TEXT	ENDS
PUBLIC	?reserve@?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAEXI@Z ; FStaticVector<VoronoiSeed,256,1,297,0>::reserve
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?reserve@?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAEXI@Z
_TEXT	SEGMENT
_uiResSize$ = 8						; size = 4
?reserve@?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAEXI@Z PROC ; FStaticVector<VoronoiSeed,256,1,297,0>::reserve, COMDAT
; _this$ = ecx

; 658  : 		GrowSizeToFit(uiResSize);

	jmp	?GrowSizeToFit@?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<VoronoiSeed,256,1,297,0>::GrowSizeToFit
?reserve@?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAEXI@Z ENDP ; FStaticVector<VoronoiSeed,256,1,297,0>::reserve
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAEIABUVoronoiSeed@@@Z ; FStaticVector<VoronoiSeed,256,1,297,0>::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAEIABUVoronoiSeed@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAEIABUVoronoiSeed@@@Z PROC ; FStaticVector<VoronoiSeed,256,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+5132], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<VoronoiSeed,256,1,297,0>::GrowSize
$LN1@push_back:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $LN4@push_back
	mov	ecx, DWORD PTR _element$[esp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], ecx
$LN4@push_back:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAEIABUVoronoiSeed@@@Z ENDP ; FStaticVector<VoronoiSeed,256,1,297,0>::push_back
_TEXT	ENDS
PUBLIC	?ridgeBuilder@CvFractal@@QAEXAAVCvRandom@@HHHH@Z ; CvFractal::ridgeBuilder
EXTRN	?estimateDirection@@YA?AW4DirectionTypes@@HH@Z:PROC ; estimateDirection
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__chkstk:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ridgeBuilder@CvFractal@@QAEXAAVCvRandom@@HHHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ridgeBuilder@CvFractal@@QAEXAAVCvRandom@@HHHH@Z$0
__ehfuncinfo$?ridgeBuilder@CvFractal@@QAEXAAVCvRandom@@HHHH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ridgeBuilder@CvFractal@@QAEXAAVCvRandom@@HHHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvfractal.cpp
xdata$x	ENDS
;	COMDAT ?ridgeBuilder@CvFractal@@QAEXAAVCvRandom@@HHHH@Z
_TEXT	SEGMENT
_iY$218051 = -5216					; size = 4
_iThisVoronoiSeedIndex$218021 = -5216			; size = 4
tv1184 = -5212						; size = 4
$T218734 = -5212					; size = 4
$T218732 = -5212					; size = 4
$T218731 = -5212					; size = 4
_this$ = -5208						; size = 4
_iNextClosestSeed$218058 = -5204			; size = 4
tv567 = -5200						; size = 4
$T218735 = -5200					; size = 4
$T218738 = -5196					; size = 4
$T218733 = -5196					; size = 4
tv1217 = -5192						; size = 4
_iX$218047 = -5188					; size = 4
_iClosestSeed$218057 = -5184				; size = 4
_iModifiedHexspaceDistance$218063 = -5180		; size = 4
$T218736 = -5176					; size = 4
_thisVoronoiSeed$218025 = -5172				; size = 20
$T218737 = -5152					; size = 4
_vVoronoiSeeds$ = -5148					; size = 5136
__$EHRec$ = -12						; size = 12
_random$ = 8						; size = 4
_iNumVoronoiSeeds$ = 12					; size = 4
_iRidgeFlags$ = 16					; size = 4
_iBlendRidge$ = 20					; size = 4
_iBlendFract$ = 24					; size = 4
?ridgeBuilder@CvFractal@@QAEXAAVCvRandom@@HHHH@Z PROC	; CvFractal::ridgeBuilder, COMDAT
; _this$ = ecx

; 458  : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?ridgeBuilder@CvFractal@@QAEXAAVCvRandom@@HHHH@Z
	push	eax
	mov	eax, 5204				; 00001454H
	mov	DWORD PTR fs:0, esp
	call	__chkstk

; 459  : 	// this will use a modified Voronoi system to give the appearance of mountain ranges
; 460  : 
; 461  : #ifdef NQM_FAST_COMP
; 462  : 	iNumVoronoiSeeds = MAX(iNumVoronoiSeeds, 3); // make sure that we have at least 3
; 463  : #else
; 464  : 	iNumVoronoiSeeds = std::max(iNumVoronoiSeeds,3); // make sure that we have at least 3

	mov	eax, 3
	cmp	DWORD PTR _iNumVoronoiSeeds$[esp+5212], eax
	mov	DWORD PTR $T218731[esp+5216], eax
	mov	DWORD PTR _this$[esp+5216], ecx
	lea	eax, DWORD PTR $T218731[esp+5216]
	jl	SHORT $LN33@ridgeBuild
	lea	eax, DWORD PTR _iNumVoronoiSeeds$[esp+5212]
$LN33@ridgeBuild:
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR [eax]
	push	edi

; 465  : #endif
; 466  : 
; 467  : 	// randomly place the seed points of each region ??? do we want a way for an advanced script to pass this in ???
; 468  : 	FStaticVector<VoronoiSeed,256, true, c_eCiv5GameplayDLL, 0> vVoronoiSeeds;

	xor	edi, edi
	lea	eax, DWORD PTR _vVoronoiSeeds$[esp+5244]
	mov	DWORD PTR _iNumVoronoiSeeds$[esp+5228], esi
	mov	DWORD PTR _vVoronoiSeeds$[esp+5236], edi
	mov	DWORD PTR _vVoronoiSeeds$[esp+5240], 256 ; 00000100H
	mov	DWORD PTR _vVoronoiSeeds$[esp+5232], eax

; 469  : 	vVoronoiSeeds.reserve(iNumVoronoiSeeds);

	push	esi
	lea	ecx, DWORD PTR _vVoronoiSeeds$[esp+5236]
	mov	DWORD PTR __$EHRec$[esp+5244], edi
	call	?GrowSizeToFit@?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<VoronoiSeed,256,1,297,0>::GrowSizeToFit

; 470  : 
; 471  : 	for(int iThisVoronoiSeedIndex = 0; iThisVoronoiSeedIndex < iNumVoronoiSeeds; iThisVoronoiSeedIndex++)

	cmp	esi, edi
	mov	DWORD PTR _iThisVoronoiSeedIndex$218021[esp+5232], edi
	jle	$LN153@ridgeBuild

; 476  : #ifdef AUI_FRACTAL_RIDGE_USE_BINOM_RNG
; 477  : 		thisVoronoiSeed.m_iWeakness = MAX(0, int(random.getBinom(7, "Ridge Gen 3")) - 3); // ??? do we want to parameterize this???
; 478  : #elif defined(AUI_USE_SFMT_RNG) || defined(AUI_WARNING_FIXES)
; 479  : 		thisVoronoiSeed.m_iWeakness = MAX(0, int(random.get(7, "Ridge Gen 3")) - 3); // ??? do we want to parameterize this???
; 480  : #elif defined(NQM_FAST_COMP)
; 481  : 		thisVoronoiSeed.m_iWeakness = MAX(0, random.get(7, "Ridge Gen 3") - 3); // ??? do we want to parameterize this???
; 482  : #else
; 483  : 		thisVoronoiSeed.m_iWeakness = std::max(0,random.get(7, "Ridge Gen 3")-3); // ??? do we want to parameterize this???

	mov	DWORD PTR $T218733[esp+5232], edi

; 486  : #ifdef AUI_FRACTAL_RIDGE_USE_BINOM_RNG
; 487  : 		thisVoronoiSeed.m_iDirectionalBiasStrength = MAX(0, int(random.getBinom(8, "Ridge Gen 5")) - 4); // ??? do we want to parameterize this???
; 488  : #elif defined(AUI_USE_SFMT_RNG) || defined(AUI_WARNING_FIXES)
; 489  : 		thisVoronoiSeed.m_iDirectionalBiasStrength = MAX(0, int(random.get(8, "Ridge Gen 5")) - 4); // ??? do we want to parameterize this???
; 490  : #elif defined(NQM_FAST_COMP)
; 491  : 		thisVoronoiSeed.m_iDirectionalBiasStrength = MAX(0, random.get(8, "Ridge Gen 5") - 4); // ??? do we want to parameterize this???
; 492  : #else
; 493  : 		thisVoronoiSeed.m_iDirectionalBiasStrength = std::max(0,random.get(8, "Ridge Gen 5") - 4); // ??? do we want to parameterize this???

	mov	DWORD PTR $T218735[esp+5232], edi
	npad	8
$LL26@ridgeBuild:
	mov	edi, DWORD PTR _this$[esp+5232]
	movzx	ecx, WORD PTR [edi+20]
	mov	esi, DWORD PTR _random$[esp+5228]
	push	OFFSET $SG218026
	push	ecx
	mov	ecx, esi
	call	?get@CvRandom@@QAEGGPBD@Z		; CvRandom::get
	movzx	edx, WORD PTR [edi+16]
	push	OFFSET $SG218027
	push	edx
	mov	ecx, esi
	movzx	ebx, ax
	call	?get@CvRandom@@QAEGGPBD@Z		; CvRandom::get
	movzx	ecx, ax
	test	ebx, ebx
	jl	SHORT $LN46@ridgeBuild

; 472  : 	{
; 473  : 		VoronoiSeed thisVoronoiSeed;
; 474  : 		thisVoronoiSeed.m_iHexspaceY = random.get(m_iFracY, "Ridge Gen 1");
; 475  : 		thisVoronoiSeed.m_iHexspaceX =  xToHexspaceX(random.get(m_iFracX, "Ridge Gen 2"), thisVoronoiSeed.m_iHexspaceY);

	mov	eax, ebx
	jmp	SHORT $LN157@ridgeBuild
$LN46@ridgeBuild:
	lea	eax, DWORD PTR [ebx-1]
	cdq
	sub	eax, edx
$LN157@ridgeBuild:
	sar	eax, 1
	sub	ecx, eax

; 476  : #ifdef AUI_FRACTAL_RIDGE_USE_BINOM_RNG
; 477  : 		thisVoronoiSeed.m_iWeakness = MAX(0, int(random.getBinom(7, "Ridge Gen 3")) - 3); // ??? do we want to parameterize this???
; 478  : #elif defined(AUI_USE_SFMT_RNG) || defined(AUI_WARNING_FIXES)
; 479  : 		thisVoronoiSeed.m_iWeakness = MAX(0, int(random.get(7, "Ridge Gen 3")) - 3); // ??? do we want to parameterize this???
; 480  : #elif defined(NQM_FAST_COMP)
; 481  : 		thisVoronoiSeed.m_iWeakness = MAX(0, random.get(7, "Ridge Gen 3") - 3); // ??? do we want to parameterize this???
; 482  : #else
; 483  : 		thisVoronoiSeed.m_iWeakness = std::max(0,random.get(7, "Ridge Gen 3")-3); // ??? do we want to parameterize this???

	push	OFFSET $SG218030
	mov	DWORD PTR _thisVoronoiSeed$218025[esp+5236], ecx
	push	7
	mov	ecx, esi
	call	?get@CvRandom@@QAEGGPBD@Z		; CvRandom::get
	movzx	eax, ax
	sub	eax, 3
	mov	DWORD PTR $T218732[esp+5232], eax
	test	eax, eax
	lea	eax, DWORD PTR $T218732[esp+5232]
	jg	SHORT $LN51@ridgeBuild
	lea	eax, DWORD PTR $T218733[esp+5232]
$LN51@ridgeBuild:
	mov	eax, DWORD PTR [eax]

; 484  : #endif
; 485  : 		thisVoronoiSeed.m_eBiasDirection = random.get(NUM_DIRECTION_TYPES, "Ridge Gen 4");

	push	OFFSET $SG218031
	push	6
	mov	ecx, esi
	mov	DWORD PTR _thisVoronoiSeed$218025[esp+5248], eax
	call	?get@CvRandom@@QAEGGPBD@Z		; CvRandom::get
	movzx	ecx, ax

; 486  : #ifdef AUI_FRACTAL_RIDGE_USE_BINOM_RNG
; 487  : 		thisVoronoiSeed.m_iDirectionalBiasStrength = MAX(0, int(random.getBinom(8, "Ridge Gen 5")) - 4); // ??? do we want to parameterize this???
; 488  : #elif defined(AUI_USE_SFMT_RNG) || defined(AUI_WARNING_FIXES)
; 489  : 		thisVoronoiSeed.m_iDirectionalBiasStrength = MAX(0, int(random.get(8, "Ridge Gen 5")) - 4); // ??? do we want to parameterize this???
; 490  : #elif defined(NQM_FAST_COMP)
; 491  : 		thisVoronoiSeed.m_iDirectionalBiasStrength = MAX(0, random.get(8, "Ridge Gen 5") - 4); // ??? do we want to parameterize this???
; 492  : #else
; 493  : 		thisVoronoiSeed.m_iDirectionalBiasStrength = std::max(0,random.get(8, "Ridge Gen 5") - 4); // ??? do we want to parameterize this???

	push	OFFSET $SG218034
	mov	DWORD PTR _thisVoronoiSeed$218025[esp+5248], ecx
	push	8
	mov	ecx, esi
	call	?get@CvRandom@@QAEGGPBD@Z		; CvRandom::get
	movzx	eax, ax
	sub	eax, 4
	mov	DWORD PTR $T218734[esp+5232], eax
	test	eax, eax
	lea	eax, DWORD PTR $T218734[esp+5232]
	jg	SHORT $LN55@ridgeBuild
	lea	eax, DWORD PTR $T218735[esp+5232]
$LN55@ridgeBuild:
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _thisVoronoiSeed$218025[esp+5248], edx
$LL23@ridgeBuild:

; 494  : #endif
; 495  : 
; 496  : 		// check to see if we are too close to an existing seed
; 497  : 		bool bNeedToRecheck;
; 498  : 		do
; 499  : 		{
; 500  : 			bNeedToRecheck = false;
; 501  : 			for(int iThatVoronoiSeedIndex = 0; iThatVoronoiSeedIndex < iThisVoronoiSeedIndex; iThatVoronoiSeedIndex++)

	xor	ebp, ebp
	cmp	DWORD PTR _iThisVoronoiSeedIndex$218021[esp+5232], ebp
	jle	SHORT $LN155@ridgeBuild
	mov	edi, DWORD PTR _vVoronoiSeeds$[esp+5232]
	npad	2
$LL20@ridgeBuild:

; 502  : 			{
; 503  : 				int iDistanceBetweenVoronoiSeeds = hexDistance(thisVoronoiSeed.m_iHexspaceX-vVoronoiSeeds[iThatVoronoiSeedIndex].m_iHexspaceX,thisVoronoiSeed.m_iHexspaceY-vVoronoiSeeds[iThatVoronoiSeedIndex].m_iHexspaceY);

	mov	esi, DWORD PTR _thisVoronoiSeed$218025[esp+5232]
	mov	eax, ebx
	sub	eax, DWORD PTR [edi+4]
	sub	esi, DWORD PTR [edi]
	mov	ecx, 0
	setns	cl
	xor	edx, edx
	test	eax, eax
	setge	dl
	cmp	ecx, edx
	jne	SHORT $LN61@ridgeBuild
	test	esi, esi
	jge	SHORT $LN65@ridgeBuild
	neg	esi
$LN65@ridgeBuild:
	test	eax, eax
	jge	SHORT $LN67@ridgeBuild
	neg	eax
$LN67@ridgeBuild:
	add	eax, esi
	jmp	SHORT $LN72@ridgeBuild
$LN61@ridgeBuild:
	test	esi, esi
	jge	SHORT $LN69@ridgeBuild
	neg	esi
$LN69@ridgeBuild:
	test	eax, eax
	jge	SHORT $LN71@ridgeBuild
	neg	eax
$LN71@ridgeBuild:
	cmp	esi, eax
	jl	SHORT $LN72@ridgeBuild
	mov	eax, esi
$LN72@ridgeBuild:

; 504  : 
; 505  : 				if(iDistanceBetweenVoronoiSeeds < 7)  // ??? parameterize ???

	cmp	eax, 7
	jl	$LN145@ridgeBuild
	inc	ebp
	add	edi, 20					; 00000014H
	cmp	ebp, DWORD PTR _iThisVoronoiSeedIndex$218021[esp+5232]
	jl	SHORT $LL20@ridgeBuild
$LN155@ridgeBuild:

; 516  : 
; 517  : 		vVoronoiSeeds.push_back(thisVoronoiSeed);

	mov	eax, DWORD PTR _vVoronoiSeeds$[esp+5240]
	mov	BYTE PTR _vVoronoiSeeds$[esp+10364], 0
	cmp	DWORD PTR _vVoronoiSeeds$[esp+5236], eax
	jne	SHORT $LN74@ridgeBuild
	push	eax
	lea	ecx, DWORD PTR _vVoronoiSeeds$[esp+5236]
	call	?GrowSize@?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<VoronoiSeed,256,1,297,0>::GrowSize
$LN74@ridgeBuild:
	mov	eax, DWORD PTR _vVoronoiSeeds$[esp+5236]
	mov	ecx, DWORD PTR _vVoronoiSeeds$[esp+5232]
	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [ecx+eax*4]
	test	eax, eax
	je	SHORT $LN77@ridgeBuild
	mov	edx, DWORD PTR _thisVoronoiSeed$218025[esp+5232]
	mov	ecx, DWORD PTR _thisVoronoiSeed$218025[esp+5240]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR _thisVoronoiSeed$218025[esp+5244]
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR _thisVoronoiSeed$218025[esp+5248]
	mov	DWORD PTR [eax+12], edx
	mov	DWORD PTR [eax+16], ecx
$LN77@ridgeBuild:
	mov	eax, DWORD PTR _iThisVoronoiSeedIndex$218021[esp+5232]
	inc	DWORD PTR _vVoronoiSeeds$[esp+5236]
	inc	eax
	cmp	eax, DWORD PTR _iNumVoronoiSeeds$[esp+5228]
	mov	DWORD PTR _iThisVoronoiSeedIndex$218021[esp+5232], eax
	jl	$LL26@ridgeBuild

; 470  : 
; 471  : 	for(int iThisVoronoiSeedIndex = 0; iThisVoronoiSeedIndex < iNumVoronoiSeeds; iThisVoronoiSeedIndex++)

	xor	edi, edi
$LN153@ridgeBuild:

; 518  : 	}
; 519  : 
; 520  : 	//std::vector<int> vDistances;
; 521  : 	//vDistances.reserve(iNumVoronoiSeeds);
; 522  : 
; 523  : 	for(int iX = 0; iX < m_iFracX; iX++)

	mov	edx, DWORD PTR _this$[esp+5232]
	cmp	DWORD PTR [edx+16], edi
	mov	DWORD PTR _iX$218047[esp+5232], edi
	jle	$LN14@ridgeBuild
	mov	eax, edx
	add	eax, 40					; 00000028H
	mov	DWORD PTR tv1217[esp+5232], eax
	npad	11
$LL16@ridgeBuild:

; 524  : 	{
; 525  : 		for(int iY = 0; iY < m_iFracY; iY++)

	mov	ecx, DWORD PTR _this$[esp+5232]
	cmp	DWORD PTR [ecx+20], 0
	mov	DWORD PTR _iY$218051[esp+5232], 0
	jle	$LN15@ridgeBuild

; 578  : 
; 579  : 			// blend the new ridge height with the previous fractal height
; 580  : #ifdef AUI_FAST_COMP
; 581  : 			m_aaiFrac[iX][iY] = (iRidgeHeight * iBlendRidge + m_aaiFrac[iX][iY] * iBlendFract) / MAX(iBlendRidge + iBlendFract, 1);
; 582  : #else
; 583  : 			m_aaiFrac[iX][iY] = (iRidgeHeight * iBlendRidge + m_aaiFrac[iX][iY] * iBlendFract) / std::max(iBlendRidge + iBlendFract, 1);

	mov	edx, DWORD PTR _iBlendRidge$[esp+5228]
	mov	eax, DWORD PTR _iBlendFract$[esp+5228]
	mov	ecx, DWORD PTR tv1217[esp+5232]

; 584  : #endif
; 585  : 		}
; 586  : 	}
; 587  : }

	add	edx, eax
	mov	DWORD PTR $T218737[esp+5232], 1
	mov	DWORD PTR $T218738[esp+5232], edx
	mov	DWORD PTR tv1184[esp+5232], ecx
	npad	6
$LL13@ridgeBuild:
	mov	eax, DWORD PTR _iY$218051[esp+5232]
	test	eax, eax
	jge	SHORT $LN158@ridgeBuild
	dec	eax
	cdq
	sub	eax, edx
$LN158@ridgeBuild:
	mov	ebx, DWORD PTR _iX$218047[esp+5232]
	sar	eax, 1
	sub	ebx, eax
	cmp	DWORD PTR _iNumVoronoiSeeds$[esp+5228], 0
	mov	eax, 2147483647				; 7fffffffH
	mov	DWORD PTR _iClosestSeed$218057[esp+5232], eax
	mov	DWORD PTR _iNextClosestSeed$218058[esp+5232], eax
	jle	$LN8@ridgeBuild
	mov	edx, DWORD PTR _iNumVoronoiSeeds$[esp+5228]
	xor	edi, edi
	mov	DWORD PTR tv567[esp+5232], edx
	npad	4
$LL10@ridgeBuild:
	mov	ecx, DWORD PTR _vVoronoiSeeds$[esp+5232]
	mov	ebp, DWORD PTR _iY$218051[esp+5232]
	sub	ebp, DWORD PTR [ecx+edi+4]
	mov	eax, ebx
	sub	eax, DWORD PTR [ecx+edi]
	xor	ecx, ecx
	test	ebp, ebp
	setge	cl
	xor	edx, edx
	test	eax, eax
	setge	dl
	cmp	edx, ecx
	jne	SHORT $LN90@ridgeBuild

; 536  : 			{
; 537  : 				int iModifiedHexspaceDistance = hexDistance(iThisHexX-vVoronoiSeeds[iThisVoronoiSeedIndex].m_iHexspaceX,iThisHexY-vVoronoiSeeds[iThisVoronoiSeedIndex].m_iHexspaceY);

	test	eax, eax
	jge	SHORT $LN94@ridgeBuild
	neg	eax
$LN94@ridgeBuild:
	test	ebp, ebp
	jge	SHORT $LN96@ridgeBuild
	neg	ebp
$LN96@ridgeBuild:
	lea	esi, DWORD PTR [eax+ebp]
	jmp	SHORT $LN102@ridgeBuild
$LN145@ridgeBuild:

; 506  : 				{
; 507  : 					thisVoronoiSeed.m_iHexspaceX = random.get(m_iFracX, "Ridge Gen 6");

	mov	edi, DWORD PTR _this$[esp+5232]
	movzx	eax, WORD PTR [edi+16]
	mov	esi, DWORD PTR _random$[esp+5228]
	push	OFFSET $SG218045
	push	eax
	mov	ecx, esi
	call	?get@CvRandom@@QAEGGPBD@Z		; CvRandom::get

; 508  : 					thisVoronoiSeed.m_iHexspaceY = random.get(m_iFracY, "Ridge Gen 7");

	movzx	edx, WORD PTR [edi+20]
	movzx	ecx, ax
	push	OFFSET $SG218046
	mov	DWORD PTR _thisVoronoiSeed$218025[esp+5236], ecx
	push	edx
	mov	ecx, esi
	call	?get@CvRandom@@QAEGGPBD@Z		; CvRandom::get
	movzx	ebx, ax

; 509  : 					bNeedToRecheck = true;
; 510  : 					break;
; 511  : 				}
; 512  : 			}
; 513  : 
; 514  : 		}
; 515  : 		while(bNeedToRecheck);

	jmp	$LL23@ridgeBuild

; 536  : 			{
; 537  : 				int iModifiedHexspaceDistance = hexDistance(iThisHexX-vVoronoiSeeds[iThisVoronoiSeedIndex].m_iHexspaceX,iThisHexY-vVoronoiSeeds[iThisVoronoiSeedIndex].m_iHexspaceY);

$LN90@ridgeBuild:
	test	eax, eax
	jge	SHORT $LN98@ridgeBuild
	neg	eax
$LN98@ridgeBuild:
	test	ebp, ebp
	jge	SHORT $LN100@ridgeBuild
	neg	ebp
$LN100@ridgeBuild:
	cmp	eax, ebp
	mov	esi, eax
	jge	SHORT $LN102@ridgeBuild
	mov	esi, ebp
$LN102@ridgeBuild:

; 538  : 				if(iRidgeFlags)  // we may decide to add more control later

	cmp	DWORD PTR _iRidgeFlags$[esp+5228], 0
	je	$LN154@ridgeBuild

; 539  : 				{
; 540  : 					iModifiedHexspaceDistance += vVoronoiSeeds[iThisVoronoiSeedIndex].m_iWeakness;

	mov	eax, DWORD PTR _vVoronoiSeeds$[esp+5232]

; 541  : #ifdef AUI_FRACTAL_RIDGE_USE_BINOM_RNG
; 542  : 					iModifiedHexspaceDistance += random.getBinom(3, "Ridge Gen 8");
; 543  : #else
; 544  : 					iModifiedHexspaceDistance += random.get(3, "Ridge Gen 8");

	mov	ecx, DWORD PTR _random$[esp+5228]
	add	esi, DWORD PTR [eax+edi+8]
	push	OFFSET $SG218065
	push	3
	call	?get@CvRandom@@QAEGGPBD@Z		; CvRandom::get
	movzx	ecx, ax

; 545  : #endif
; 546  : 					DirectionTypes eRelativeDirection = estimateDirection(vVoronoiSeeds[iThisVoronoiSeedIndex].m_iHexspaceX-iThisHexX,vVoronoiSeeds[iThisVoronoiSeedIndex].m_iHexspaceY-iThisHexY);

	mov	eax, DWORD PTR _vVoronoiSeeds$[esp+5232]
	mov	edx, DWORD PTR [eax+edi+4]
	sub	edx, DWORD PTR _iY$218051[esp+5232]
	mov	eax, DWORD PTR [eax+edi]
	push	edx
	sub	eax, ebx
	add	esi, ecx
	push	eax
	mov	DWORD PTR _iModifiedHexspaceDistance$218063[esp+5240], esi
	call	?estimateDirection@@YA?AW4DirectionTypes@@HH@Z ; estimateDirection

; 547  : 					if(eRelativeDirection == vVoronoiSeeds[iThisVoronoiSeedIndex].m_eBiasDirection)

	mov	edx, DWORD PTR _vVoronoiSeeds$[esp+5240]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+edi+12]
	add	esp, 8
	cmp	ecx, eax
	jne	SHORT $LN6@ridgeBuild

; 548  : 					{
; 549  : 						iModifiedHexspaceDistance -= vVoronoiSeeds[iThisVoronoiSeedIndex].m_iDirectionalBiasStrength;

	sub	esi, DWORD PTR [edx+edi+16]
	jmp	SHORT $LN159@ridgeBuild
$LN6@ridgeBuild:

; 550  : 					}
; 551  : 					else if(eRelativeDirection == (vVoronoiSeeds[iThisVoronoiSeedIndex].m_eBiasDirection + 3) % NUM_DIRECTION_TYPES)

	add	eax, 3
	cdq
	mov	ebp, 6
	idiv	ebp
	cmp	ecx, edx
	jne	SHORT $LN4@ridgeBuild

; 552  : 					{
; 553  : 						iModifiedHexspaceDistance += vVoronoiSeeds[iThisVoronoiSeedIndex].m_iDirectionalBiasStrength;

	mov	ecx, DWORD PTR _vVoronoiSeeds$[esp+5232]
	add	esi, DWORD PTR [ecx+edi+16]
$LN159@ridgeBuild:
	mov	DWORD PTR _iModifiedHexspaceDistance$218063[esp+5232], esi
$LN4@ridgeBuild:

; 554  : 					}
; 555  : #ifdef AUI_FAST_COMP
; 556  : 					iModifiedHexspaceDistance = MAX(1, iModifiedHexspaceDistance);
; 557  : #else
; 558  : 					iModifiedHexspaceDistance = std::max(1,iModifiedHexspaceDistance);

	cmp	esi, 1
	mov	DWORD PTR $T218736[esp+5232], 1
	lea	eax, DWORD PTR _iModifiedHexspaceDistance$218063[esp+5232]
	jg	SHORT $LN120@ridgeBuild
	lea	eax, DWORD PTR $T218736[esp+5232]
$LN120@ridgeBuild:
	mov	esi, DWORD PTR [eax]
$LN154@ridgeBuild:

; 559  : #endif
; 560  : 				}
; 561  : 				//vDistances.push_back(iModifiedHexspaceDistance);
; 562  : 				if(iModifiedHexspaceDistance < iClosestSeed)

	mov	eax, DWORD PTR _iClosestSeed$218057[esp+5232]
	cmp	esi, eax
	jge	SHORT $LN3@ridgeBuild

; 563  : 				{
; 564  : 					iNextClosestSeed = iClosestSeed;

	mov	DWORD PTR _iNextClosestSeed$218058[esp+5232], eax

; 565  : 					iClosestSeed = iModifiedHexspaceDistance;

	mov	DWORD PTR _iClosestSeed$218057[esp+5232], esi
	jmp	SHORT $LN9@ridgeBuild
$LN3@ridgeBuild:

; 566  : 				}
; 567  : 				else if(iModifiedHexspaceDistance < iNextClosestSeed)

	cmp	esi, DWORD PTR _iNextClosestSeed$218058[esp+5232]
	jge	SHORT $LN9@ridgeBuild

; 568  : 				{
; 569  : 					iNextClosestSeed = iModifiedHexspaceDistance;

	mov	DWORD PTR _iNextClosestSeed$218058[esp+5232], esi
$LN9@ridgeBuild:

; 526  : 		{
; 527  : 			// get the hexspace coordinate for this position
; 528  : 			int iThisHexX = xToHexspaceX(iX,iY);
; 529  : 			int iThisHexY = iY; // not really needed except for clarity
; 530  : 
; 531  : 			// find the distance to each of the seeds (with modifiers for strength of the seed, directional bias, and random factors)
; 532  : 			//vDistances.clear();
; 533  : 			int iClosestSeed = INT_MAX;
; 534  : 			int iNextClosestSeed = INT_MAX;
; 535  : 			for(int iThisVoronoiSeedIndex= 0; iThisVoronoiSeedIndex < iNumVoronoiSeeds; iThisVoronoiSeedIndex++)

	add	edi, 20					; 00000014H
	sub	DWORD PTR tv567[esp+5232], 1
	jne	$LL10@ridgeBuild
$LN8@ridgeBuild:

; 570  : 				}
; 571  : 			}
; 572  : 
; 573  : 			// use the modified distance between the two closest seeds to determine the ridge height
; 574  : 			// ??? are there any other fudge factors I want to add in here???
; 575  : 			//std::sort(vDistances.begin(),vDistances.end());
; 576  : 
; 577  : 			int iRidgeHeight = (255 * iClosestSeed) / iNextClosestSeed;

	mov	eax, DWORD PTR _iClosestSeed$218057[esp+5232]
	imul	eax, 255				; 000000ffH
	cdq
	idiv	DWORD PTR _iNextClosestSeed$218058[esp+5232]

; 578  : 
; 579  : 			// blend the new ridge height with the previous fractal height
; 580  : #ifdef AUI_FAST_COMP
; 581  : 			m_aaiFrac[iX][iY] = (iRidgeHeight * iBlendRidge + m_aaiFrac[iX][iY] * iBlendFract) / MAX(iBlendRidge + iBlendFract, 1);
; 582  : #else
; 583  : 			m_aaiFrac[iX][iY] = (iRidgeHeight * iBlendRidge + m_aaiFrac[iX][iY] * iBlendFract) / std::max(iBlendRidge + iBlendFract, 1);

	cmp	DWORD PTR $T218738[esp+5232], 1
	lea	ecx, DWORD PTR $T218737[esp+5232]
	jl	SHORT $LN124@ridgeBuild
	lea	ecx, DWORD PTR $T218738[esp+5232]
$LN124@ridgeBuild:
	mov	esi, DWORD PTR tv1184[esp+5232]
	imul	eax, DWORD PTR _iBlendRidge$[esp+5228]
	mov	edx, DWORD PTR [esi]
	imul	edx, DWORD PTR _iBlendFract$[esp+5228]
	add	eax, edx
	cdq
	idiv	DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[esp+5232]
	add	esi, 4
	mov	DWORD PTR tv1184[esp+5232], esi
	mov	DWORD PTR [esi-4], eax
	mov	eax, DWORD PTR _iY$218051[esp+5232]
	inc	eax
	cmp	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR _iY$218051[esp+5232], eax
	jl	$LL13@ridgeBuild
$LN15@ridgeBuild:

; 518  : 	}
; 519  : 
; 520  : 	//std::vector<int> vDistances;
; 521  : 	//vDistances.reserve(iNumVoronoiSeeds);
; 522  : 
; 523  : 	for(int iX = 0; iX < m_iFracX; iX++)

	mov	eax, DWORD PTR _iX$218047[esp+5232]
	mov	edx, DWORD PTR _this$[esp+5232]
	add	DWORD PTR tv1217[esp+5232], 1024	; 00000400H
	inc	eax
	cmp	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _iX$218047[esp+5232], eax
	jl	$LL16@ridgeBuild
$LN14@ridgeBuild:

; 584  : #endif
; 585  : 		}
; 586  : 	}
; 587  : }

	mov	eax, DWORD PTR _vVoronoiSeeds$[esp+5232]
	pop	edi
	pop	esi
	lea	ecx, DWORD PTR _vVoronoiSeeds$[esp+5236]
	pop	ebp
	mov	DWORD PTR __$EHRec$[esp+5228], -1
	pop	ebx
	cmp	eax, ecx
	je	SHORT $LN127@ridgeBuild
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN127@ridgeBuild:
	mov	ecx, DWORD PTR __$EHRec$[esp+5216]
	mov	DWORD PTR fs:0, ecx
	add	esp, 5216				; 00001460H
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ridgeBuilder@CvFractal@@QAEXAAVCvRandom@@HHHH@Z$0:
	lea	ecx, DWORD PTR _vVoronoiSeeds$[ebp]
	jmp	??1?$FStaticVector@UVoronoiSeed@@$0BAA@$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<VoronoiSeed,256,1,297,0>::~FStaticVector<VoronoiSeed,256,1,297,0>
__ehhandler$?ridgeBuilder@CvFractal@@QAEXAAVCvRandom@@HHHH@Z:
	mov	eax, OFFSET __ehfuncinfo$?ridgeBuilder@CvFractal@@QAEXAAVCvRandom@@HHHH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ridgeBuilder@CvFractal@@QAEXAAVCvRandom@@HHHH@Z ENDP	; CvFractal::ridgeBuilder
END
