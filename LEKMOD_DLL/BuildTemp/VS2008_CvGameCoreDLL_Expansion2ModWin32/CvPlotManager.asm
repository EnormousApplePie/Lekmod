; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Desktop\Lekmod Files\Lekmod DLL versions\v29\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvPlotManager.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??0CvSparseIDInfoGrid@@QAE@IIPAV?$FObjectPool@VCvIDInfoFixedVector@@@@@Z ; CvSparseIDInfoGrid::CvSparseIDInfoGrid
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	_memset:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvplotmanager.cpp
;	COMDAT ??0CvSparseIDInfoGrid@@QAE@IIPAV?$FObjectPool@VCvIDInfoFixedVector@@@@@Z
_TEXT	SEGMENT
_uiWidth$ = 8						; size = 4
_uiHeight$ = 12						; size = 4
_pkAllocator$ = 16					; size = 4
??0CvSparseIDInfoGrid@@QAE@IIPAV?$FObjectPool@VCvIDInfoFixedVector@@@@@Z PROC ; CvSparseIDInfoGrid::CvSparseIDInfoGrid, COMDAT
; _this$ = ecx

; 19   : 	m_uiWidth = uiWidth;

	mov	eax, DWORD PTR _uiWidth$[esp-4]
	push	esi
	mov	esi, ecx

; 20   : 	m_uiHeight = uiHeight;

	mov	ecx, DWORD PTR _uiHeight$[esp]
	mov	DWORD PTR [esi], eax

; 21   : 	m_uiMaxIndex = uiWidth * uiHeight;

	imul	eax, ecx
	mov	DWORD PTR [esi+4], ecx

; 22   : 	m_uiNumAllocated = 0;
; 23   : 
; 24   : 	m_paEntries = FNEW(CvIDInfoFixedVector*[m_uiMaxIndex], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	mov	DWORD PTR [esi+8], eax
	mov	edx, 4
	mul	edx
	seto	cl
	mov	DWORD PTR [esi+12], 0
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 25   : 	memset( &m_paEntries[0], 0, sizeof(CvIDInfoFixedVector*) * m_uiMaxIndex);

	mov	ecx, DWORD PTR [esi+8]
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	0
	push	eax
	mov	DWORD PTR [esi+16], eax
	call	_memset

; 26   : 
; 27   : 	m_pkAllocator = pkAllocator;

	mov	edx, DWORD PTR _pkAllocator$[esp+16]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+20], edx

; 28   : }

	mov	eax, esi
	pop	esi
	ret	12					; 0000000cH
??0CvSparseIDInfoGrid@@QAE@IIPAV?$FObjectPool@VCvIDInfoFixedVector@@@@@Z ENDP ; CvSparseIDInfoGrid::CvSparseIDInfoGrid
_TEXT	ENDS
PUBLIC	?Get@CvSparseIDInfoGrid@@QBEPBVCvIDInfoFixedVector@@HH@Z ; CvSparseIDInfoGrid::Get
; Function compile flags: /Ogtpy
;	COMDAT ?Get@CvSparseIDInfoGrid@@QBEPBVCvIDInfoFixedVector@@HH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
?Get@CvSparseIDInfoGrid@@QBEPBVCvIDInfoFixedVector@@HH@Z PROC ; CvSparseIDInfoGrid::Get, COMDAT
; _this$ = ecx

; 49   : 	uint uiIndex = ((uint) iY * m_uiWidth) + (uint) iX;

	mov	eax, DWORD PTR [ecx]
	imul	eax, DWORD PTR _iY$[esp-4]
	add	eax, DWORD PTR _iX$[esp-4]

; 50   : 	if (uiIndex < m_uiMaxIndex)

	cmp	eax, DWORD PTR [ecx+8]
	jae	SHORT $LN1@Get

; 51   : 	{
; 52   : 		CvIDInfoFixedVector* pkEntry = m_paEntries[uiIndex];

	mov	ecx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [ecx+eax*4]

; 53   : 		if (pkEntry)

	test	eax, eax

; 54   : 			return pkEntry;

	jne	SHORT $LN3@Get
$LN1@Get:

; 55   : 	}
; 56   : 
; 57   : 	return NULL;

	xor	eax, eax
$LN3@Get:

; 58   : }

	ret	8
?Get@CvSparseIDInfoGrid@@QBEPBVCvIDInfoFixedVector@@HH@Z ENDP ; CvSparseIDInfoGrid::Get
_TEXT	ENDS
PUBLIC	?Init@CvPlotManager@@QAEXII@Z			; CvPlotManager::Init
; Function compile flags: /Ogtpy
;	COMDAT ?Init@CvPlotManager@@QAEXII@Z
_TEXT	SEGMENT
_uiWidth$ = 8						; size = 4
_uiHeight$ = 12						; size = 4
?Init@CvPlotManager@@QAEXII@Z PROC			; CvPlotManager::Init, COMDAT
; _this$ = ecx

; 125  : 	m_uiWidth = uiWidth;

	mov	eax, DWORD PTR _uiWidth$[esp-4]

; 126  : 	m_uiHeight = uiHeight;

	mov	edx, DWORD PTR _uiHeight$[esp-4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], edx

; 127  : }

	ret	8
?Init@CvPlotManager@@QAEXII@Z ENDP			; CvPlotManager::Init
_TEXT	ENDS
PUBLIC	?size@?$BaseVector@UIDInfo@@$00@@QBEIXZ		; BaseVector<IDInfo,1>::size
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?size@?$BaseVector@UIDInfo@@$00@@QBEIXZ
_TEXT	SEGMENT
?size@?$BaseVector@UIDInfo@@$00@@QBEIXZ PROC		; BaseVector<IDInfo,1>::size, COMDAT
; _this$ = ecx

; 169  : 		return m_uiCurrSize;

	mov	eax, DWORD PTR [ecx+4]

; 170  : 	};

	ret	0
?size@?$BaseVector@UIDInfo@@$00@@QBEIXZ ENDP		; BaseVector<IDInfo,1>::size
_TEXT	ENDS
PUBLIC	?size@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QBEIXZ ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?size@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 3

; 727  : 		}

	ret	0
?size@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QBEABUCvSparseIDInfoGridEntry@@I@Z ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QBEABUCvSparseIDInfoGridEntry@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QBEABUCvSparseIDInfoGridEntry@@I@Z PROC ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*8]

; 771  : 		}

	ret	4
??A?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QBEABUCvSparseIDInfoGridEntry@@I@Z ENDP ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::operator[]
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QBEABUCvSparseIDInfoGridEntry@@XZ ; std::_Vector_const_iterator<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QBEABUCvSparseIDInfoGridEntry@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QBEABUCvSparseIDInfoGridEntry@@XZ PROC ; std::_Vector_const_iterator<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::operator*, COMDAT
; _this$ = ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());
; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [ecx]

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QBEABUCvSparseIDInfoGridEntry@@XZ ENDP ; std::_Vector_const_iterator<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::operator++
; Function compile flags: /Ogtpy
;	COMDAT ??E?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	mov	eax, ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);
; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [eax], 8

; 126  : 		return (*this);
; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::operator++
_TEXT	ENDS
PUBLIC	??0?$BaseVector@UIDInfo@@$00@@IAE@XZ		; BaseVector<IDInfo,1>::BaseVector<IDInfo,1>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$BaseVector@UIDInfo@@$00@@IAE@XZ
_TEXT	SEGMENT
??0?$BaseVector@UIDInfo@@$00@@IAE@XZ PROC		; BaseVector<IDInfo,1>::BaseVector<IDInfo,1>, COMDAT
; _this$ = ecx

; 216  : 	BaseVector() : m_uiCurrSize(0), m_uiCurrMaxSize(0), m_pData(NULL) {};

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	ret	0
??0?$BaseVector@UIDInfo@@$00@@IAE@XZ ENDP		; BaseVector<IDInfo,1>::BaseVector<IDInfo,1>
_TEXT	ENDS
PUBLIC	?capacity@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QBEIXZ ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 3

; 636  : 		}

	ret	0
?capacity@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::capacity
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<CvSparseIDInfoGridEntry> >::~_Container_base_aux_alloc_empty<std::allocator<CvSparseIDInfoGridEntry> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvSparseIDInfoGridEntry> >::~_Container_base_aux_alloc_empty<std::allocator<CvSparseIDInfoGridEntry> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvSparseIDInfoGridEntry> >::~_Container_base_aux_alloc_empty<std::allocator<CvSparseIDInfoGridEntry> >
_TEXT	ENDS
PUBLIC	??0?$allocator@UCvSparseIDInfoGridEntry@@@std@@QAE@XZ ; std::allocator<CvSparseIDInfoGridEntry>::allocator<CvSparseIDInfoGridEntry>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UCvSparseIDInfoGridEntry@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@UCvSparseIDInfoGridEntry@@@std@@QAE@XZ PROC ; std::allocator<CvSparseIDInfoGridEntry>::allocator<CvSparseIDInfoGridEntry>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@UCvSparseIDInfoGridEntry@@@std@@QAE@XZ ENDP ; std::allocator<CvSparseIDInfoGridEntry>::allocator<CvSparseIDInfoGridEntry>
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE@PAUCvSparseIDInfoGridEntry@@@Z ; std::_Vector_const_iterator<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Vector_const_iterator<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE@PAUCvSparseIDInfoGridEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE@PAUCvSparseIDInfoGridEntry@@@Z PROC ; std::_Vector_const_iterator<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Vector_const_iterator<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE@PAUCvSparseIDInfoGridEntry@@@Z ENDP ; std::_Vector_const_iterator<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Vector_const_iterator<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::operator==, COMDAT
; _this$ = ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	4
??8?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::operator==
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE@PAUCvSparseIDInfoGridEntry@@@Z ; std::_Vector_iterator<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Vector_iterator<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE@PAUCvSparseIDInfoGridEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE@PAUCvSparseIDInfoGridEntry@@@Z PROC ; std::_Vector_iterator<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Vector_iterator<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE@PAUCvSparseIDInfoGridEntry@@@Z ENDP ; std::_Vector_iterator<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Vector_iterator<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@V?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@@Z ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Make_iter
; Function compile flags: /Ogtpy
;	COMDAT ?_Make_iter@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@V?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@V?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@@Z PROC ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Make_iter, COMDAT
; _this$ = ecx

; 687  : 		return (iterator(_Where._Myptr));

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR __Where$[esp-4]
	mov	DWORD PTR [eax], ecx

; 688  : 		}

	ret	8
?_Make_iter@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QBE?AV?$_Vector_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@V?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@@Z ENDP ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Make_iter
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAE@V?$allocator@UCvSparseIDInfoGridEntry@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<CvSparseIDInfoGridEntry> >::_Container_base_aux_alloc_empty<std::allocator<CvSparseIDInfoGridEntry> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAE@V?$allocator@UCvSparseIDInfoGridEntry@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAE@V?$allocator@UCvSparseIDInfoGridEntry@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<CvSparseIDInfoGridEntry> >::_Container_base_aux_alloc_empty<std::allocator<CvSparseIDInfoGridEntry> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAE@V?$allocator@UCvSparseIDInfoGridEntry@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<CvSparseIDInfoGridEntry> >::_Container_base_aux_alloc_empty<std::allocator<CvSparseIDInfoGridEntry> >
_TEXT	ENDS
PUBLIC	??0?$allocator@UCvSparseIDInfoGridEntry@@@std@@QAE@ABV01@@Z ; std::allocator<CvSparseIDInfoGridEntry>::allocator<CvSparseIDInfoGridEntry>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UCvSparseIDInfoGridEntry@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@UCvSparseIDInfoGridEntry@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CvSparseIDInfoGridEntry>::allocator<CvSparseIDInfoGridEntry>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@UCvSparseIDInfoGridEntry@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CvSparseIDInfoGridEntry>::allocator<CvSparseIDInfoGridEntry>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UCvSparseIDInfoGridEntry@@@std@@QAEXPAUCvSparseIDInfoGridEntry@@I@Z ; std::allocator<CvSparseIDInfoGridEntry>::deallocate
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
;	COMDAT ?deallocate@?$allocator@UCvSparseIDInfoGridEntry@@@std@@QAEXPAUCvSparseIDInfoGridEntry@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UCvSparseIDInfoGridEntry@@@std@@QAEXPAUCvSparseIDInfoGridEntry@@I@Z PROC ; std::allocator<CvSparseIDInfoGridEntry>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@UCvSparseIDInfoGridEntry@@@std@@QAEXPAUCvSparseIDInfoGridEntry@@I@Z ENDP ; std::allocator<CvSparseIDInfoGridEntry>::deallocate
_TEXT	ENDS
PUBLIC	??G?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::operator-
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??G?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::operator-, COMDAT
; _this$ = ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[esp-4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 3

; 195  : 		}

	ret	4
??G?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::operator-
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UCvSparseIDInfoGridEntry@@@std@@QBEIXZ ; std::allocator<CvSparseIDInfoGridEntry>::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@UCvSparseIDInfoGridEntry@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UCvSparseIDInfoGridEntry@@@std@@QBEIXZ PROC ; std::allocator<CvSparseIDInfoGridEntry>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 536870911				; 1fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@UCvSparseIDInfoGridEntry@@@std@@QBEIXZ ENDP ; std::allocator<CvSparseIDInfoGridEntry>::max_size
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::operator+=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	mov	eax, ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());
; 161  : 		_SCL_SECURE_VALIDATE_RANGE(
; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);
; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*8]
	add	DWORD PTR [eax], edx

; 165  : 		return (*this);
; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::operator+=
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	esi
	lea	eax, DWORD PTR __Message$[esp]
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[esp-4]

; 60   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@UCvSparseIDInfoGridEntry@@@std@@YAPAUCvSparseIDInfoGridEntry@@IPAU1@@Z ; std::_Allocate<CvSparseIDInfoGridEntry>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@UCvSparseIDInfoGridEntry@@@std@@YAPAUCvSparseIDInfoGridEntry@@IPAU1@@Z
_TEXT	SEGMENT
$T218473 = -12						; size = 12
$T218478 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UCvSparseIDInfoGridEntry@@@std@@YAPAUCvSparseIDInfoGridEntry@@IPAU1@@Z PROC ; std::_Allocate<CvSparseIDInfoGridEntry>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*8]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 8
	jae	SHORT $LN1@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T218478[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T218473[esp+16]
	mov	DWORD PTR $T218478[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T218473[esp+16]
	push	ecx
	mov	DWORD PTR $T218473[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate:
$LN8@Allocate:
	int	3
??$_Allocate@UCvSparseIDInfoGridEntry@@@std@@YAPAUCvSparseIDInfoGridEntry@@IPAU1@@Z ENDP ; std::_Allocate<CvSparseIDInfoGridEntry>
_TEXT	ENDS
PUBLIC	?GetNextFreeIndex@?$FObjectPool@VCvIDInfoFixedVector@@@@IAEIXZ ; FObjectPool<CvIDInfoFixedVector>::GetNextFreeIndex
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjectpool.h
;	COMDAT ?GetNextFreeIndex@?$FObjectPool@VCvIDInfoFixedVector@@@@IAEIXZ
_TEXT	SEGMENT
?GetNextFreeIndex@?$FObjectPool@VCvIDInfoFixedVector@@@@IAEIXZ PROC ; FObjectPool<CvIDInfoFixedVector>::GetNextFreeIndex, COMDAT
; _this$ = ecx

; 323  : 	// Find the next free index
; 324  : 	m_bFull = true;
; 325  : 	for (; m_uiFirstFreeIndex < m_uiSize; ++m_uiFirstFreeIndex)

	mov	eax, DWORD PTR [ecx+40]
	mov	BYTE PTR [ecx+37], 1
	cmp	eax, DWORD PTR [ecx+32]
	jae	SHORT $LN2@GetNextFre
	mov	edx, DWORD PTR [ecx+4]
	npad	1
$LL4@GetNextFre:

; 326  : 	{
; 327  : 		if (m_pStorage[m_uiFirstFreeIndex].bFree)

	mov	eax, DWORD PTR [ecx+40]
	cmp	BYTE PTR [edx+eax*8+4], 0
	jne	SHORT $LN8@GetNextFre
	inc	eax
	mov	DWORD PTR [ecx+40], eax
	cmp	eax, DWORD PTR [ecx+32]
	jb	SHORT $LL4@GetNextFre

; 330  : 			break;
; 331  : 		}
; 332  : 	}
; 333  : 
; 334  : 	return m_uiFirstFreeIndex;
; 335  : }

	ret	0
$LN8@GetNextFre:

; 328  : 		{
; 329  : 			m_bFull = false;

	mov	BYTE PTR [ecx+37], 0
$LN2@GetNextFre:

; 330  : 			break;
; 331  : 		}
; 332  : 	}
; 333  : 
; 334  : 	return m_uiFirstFreeIndex;
; 335  : }

	ret	0
?GetNextFreeIndex@?$FObjectPool@VCvIDInfoFixedVector@@@@IAEIXZ ENDP ; FObjectPool<CvIDInfoFixedVector>::GetNextFreeIndex
_TEXT	ENDS
PUBLIC	??$_Iter_random@PAUCvSparseIDInfoGridEntry@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUCvSparseIDInfoGridEntry@@0@Z ; std::_Iter_random<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_random@PAUCvSparseIDInfoGridEntry@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUCvSparseIDInfoGridEntry@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUCvSparseIDInfoGridEntry@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUCvSparseIDInfoGridEntry@@0@Z PROC ; std::_Iter_random<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *>, COMDAT

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 998  : 	}

	ret	0
??$_Iter_random@PAUCvSparseIDInfoGridEntry@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUCvSparseIDInfoGridEntry@@0@Z ENDP ; std::_Iter_random<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAUCvSparseIDInfoGridEntry@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUCvSparseIDInfoGridEntry@@0@Z ; std::_Ptr_cat<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAUCvSparseIDInfoGridEntry@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUCvSparseIDInfoGridEntry@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUCvSparseIDInfoGridEntry@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUCvSparseIDInfoGridEntry@@0@Z PROC ; std::_Ptr_cat<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAUCvSparseIDInfoGridEntry@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUCvSparseIDInfoGridEntry@@0@Z ENDP ; std::_Ptr_cat<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUCvSparseIDInfoGridEntry@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Copy_opt@PAUCvSparseIDInfoGridEntry@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUCvSparseIDInfoGridEntry@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *,std::random_access_iterator_tag>, COMDAT

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN1@Copy_opt
	push	esi
$LL3@Copy_opt:

; 2472 : 		*_Dest = *_First;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	add	ecx, 8
	add	eax, 8
	cmp	ecx, edx
	jne	SHORT $LL3@Copy_opt
	pop	esi
$LN1@Copy_opt:

; 2473 : 	return (_Dest);
; 2474 : 	}

	ret	0
??$_Copy_opt@PAUCvSparseIDInfoGridEntry@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Fill@PAUCvSparseIDInfoGridEntry@@U1@@std@@YAXPAUCvSparseIDInfoGridEntry@@0ABU1@@Z ; std::_Fill<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Fill@PAUCvSparseIDInfoGridEntry@@U1@@std@@YAXPAUCvSparseIDInfoGridEntry@@0ABU1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAUCvSparseIDInfoGridEntry@@U1@@std@@YAXPAUCvSparseIDInfoGridEntry@@0ABU1@@Z PROC ; std::_Fill<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry>, COMDAT

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN1@Fill
	mov	ecx, DWORD PTR __Val$[esp-4]
	push	esi
$LL3@Fill:

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	add	eax, 8
	cmp	eax, edx
	jne	SHORT $LL3@Fill
	pop	esi
$LN1@Fill:

; 3160 : 	}

	ret	0
??$_Fill@PAUCvSparseIDInfoGridEntry@@U1@@std@@YAXPAUCvSparseIDInfoGridEntry@@0ABU1@@Z ENDP ; std::_Fill<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry>
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAUCvSparseIDInfoGridEntry@@@std@@YA?AU_Undefined_move_tag@0@ABQAUCvSparseIDInfoGridEntry@@@Z ; std::_Move_cat<CvSparseIDInfoGridEntry *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_cat@PAUCvSparseIDInfoGridEntry@@@std@@YA?AU_Undefined_move_tag@0@ABQAUCvSparseIDInfoGridEntry@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAUCvSparseIDInfoGridEntry@@@std@@YA?AU_Undefined_move_tag@0@ABQAUCvSparseIDInfoGridEntry@@@Z PROC ; std::_Move_cat<CvSparseIDInfoGridEntry *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAUCvSparseIDInfoGridEntry@@@std@@YA?AU_Undefined_move_tag@0@ABQAUCvSparseIDInfoGridEntry@@@Z ENDP ; std::_Move_cat<CvSparseIDInfoGridEntry *>
_TEXT	ENDS
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	eax, DWORD PTR __Message$[esp+16]
	push	eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 31   : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
_TEXT	ENDS
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 35   : 		return (_Str.c_str());

	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUCvSparseIDInfoGridEntry@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_backward_opt@PAUCvSparseIDInfoGridEntry@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUCvSparseIDInfoGridEntry@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *,std::random_access_iterator_tag>, COMDAT

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	edx, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw
	push	esi
$LL2@Copy_backw:

; 2676 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw
	pop	esi
$LN1@Copy_backw:

; 2677 : 	return (_Dest);
; 2678 : 	}

	ret	0
??$_Copy_backward_opt@PAUCvSparseIDInfoGridEntry@@PAU1@Urandom_access_iterator_tag@std@@@std@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??$_Construct@UCvSparseIDInfoGridEntry@@U1@@std@@YAXPAUCvSparseIDInfoGridEntry@@ABU1@@Z ; std::_Construct<CvSparseIDInfoGridEntry,CvSparseIDInfoGridEntry>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Construct@UCvSparseIDInfoGridEntry@@U1@@std@@YAXPAUCvSparseIDInfoGridEntry@@ABU1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UCvSparseIDInfoGridEntry@@U1@@std@@YAXPAUCvSparseIDInfoGridEntry@@ABU1@@Z PROC ; std::_Construct<CvSparseIDInfoGridEntry,CvSparseIDInfoGridEntry>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN3@Construct:

; 53   : 	}

	ret	0
??$_Construct@UCvSparseIDInfoGridEntry@@U1@@std@@YAXPAUCvSparseIDInfoGridEntry@@ABU1@@Z ENDP ; std::_Construct<CvSparseIDInfoGridEntry,CvSparseIDInfoGridEntry>
_TEXT	ENDS
PUBLIC	??$_Destroy@UCvSparseIDInfoGridEntry@@@std@@YAXPAUCvSparseIDInfoGridEntry@@@Z ; std::_Destroy<CvSparseIDInfoGridEntry>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@UCvSparseIDInfoGridEntry@@@std@@YAXPAUCvSparseIDInfoGridEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UCvSparseIDInfoGridEntry@@@std@@YAXPAUCvSparseIDInfoGridEntry@@@Z PROC ; std::_Destroy<CvSparseIDInfoGridEntry>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@UCvSparseIDInfoGridEntry@@@std@@YAXPAUCvSparseIDInfoGridEntry@@@Z ENDP ; std::_Destroy<CvSparseIDInfoGridEntry>
_TEXT	ENDS
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
; Function compile flags: /Ogtpy
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 110  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@3:
	mov	eax, esi
	pop	esi
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??8IDInfo@@QBE_NABU0@@Z				; IDInfo::operator==
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvstructs.h
;	COMDAT ??8IDInfo@@QBE_NABU0@@Z
_TEXT	SEGMENT
_info$ = 8						; size = 4
??8IDInfo@@QBE_NABU0@@Z PROC				; IDInfo::operator==, COMDAT
; _this$ = ecx

; 183  : 		return (eOwner == info.eOwner && iID == info.iID);

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _info$[esp-4]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN3@operator
	mov	ecx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN3@operator
	mov	eax, 1

; 184  : 	}

	ret	4
$LN3@operator:

; 183  : 		return (eOwner == info.eOwner && iID == info.iID);

	xor	eax, eax

; 184  : 	}

	ret	4
??8IDInfo@@QBE_NABU0@@Z ENDP				; IDInfo::operator==
_TEXT	ENDS
PUBLIC	??0CvSparseIDInfoGridEntry@@QAE@IPAVCvSparseIDInfoGrid@@@Z ; CvSparseIDInfoGridEntry::CvSparseIDInfoGridEntry
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvplotmanager.h
;	COMDAT ??0CvSparseIDInfoGridEntry@@QAE@IPAVCvSparseIDInfoGrid@@@Z
_TEXT	SEGMENT
_uiID$ = 8						; size = 4
_pkGrid$ = 12						; size = 4
??0CvSparseIDInfoGridEntry@@QAE@IPAVCvSparseIDInfoGrid@@@Z PROC ; CvSparseIDInfoGridEntry::CvSparseIDInfoGridEntry, COMDAT
; _this$ = ecx

; 84   : 	CvSparseIDInfoGridEntry(uint uiID, CvSparseIDInfoGrid* pkGrid) : m_uiID(uiID), m_pkGrid(pkGrid) {}

	mov	edx, DWORD PTR _pkGrid$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _uiID$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	ret	8
??0CvSparseIDInfoGridEntry@@QAE@IPAVCvSparseIDInfoGrid@@@Z ENDP ; CvSparseIDInfoGridEntry::CvSparseIDInfoGridEntry
_TEXT	ENDS
PUBLIC	?GetID@CvSparseIDInfoGridEntry@@QBEIXZ		; CvSparseIDInfoGridEntry::GetID
; Function compile flags: /Ogtpy
;	COMDAT ?GetID@CvSparseIDInfoGridEntry@@QBEIXZ
_TEXT	SEGMENT
?GetID@CvSparseIDInfoGridEntry@@QBEIXZ PROC		; CvSparseIDInfoGridEntry::GetID, COMDAT
; _this$ = ecx

; 86   : 	uint GetID() const { return m_uiID; };

	mov	eax, DWORD PTR [ecx]
	ret	0
?GetID@CvSparseIDInfoGridEntry@@QBEIXZ ENDP		; CvSparseIDInfoGridEntry::GetID
_TEXT	ENDS
PUBLIC	?GetGrid@CvSparseIDInfoGridEntry@@QBEPAVCvSparseIDInfoGrid@@XZ ; CvSparseIDInfoGridEntry::GetGrid
; Function compile flags: /Ogtpy
;	COMDAT ?GetGrid@CvSparseIDInfoGridEntry@@QBEPAVCvSparseIDInfoGrid@@XZ
_TEXT	SEGMENT
?GetGrid@CvSparseIDInfoGridEntry@@QBEPAVCvSparseIDInfoGrid@@XZ PROC ; CvSparseIDInfoGridEntry::GetGrid, COMDAT
; _this$ = ecx

; 87   : 	CvSparseIDInfoGrid*	GetGrid() const { return m_pkGrid; };

	mov	eax, DWORD PTR [ecx+4]
	ret	0
?GetGrid@CvSparseIDInfoGridEntry@@QBEPAVCvSparseIDInfoGrid@@XZ ENDP ; CvSparseIDInfoGridEntry::GetGrid
_TEXT	ENDS
PUBLIC	?begin@?$BaseVector@UIDInfo@@$00@@QAEPAUIDInfo@@XZ ; BaseVector<IDInfo,1>::begin
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?begin@?$BaseVector@UIDInfo@@$00@@QAEPAUIDInfo@@XZ
_TEXT	SEGMENT
?begin@?$BaseVector@UIDInfo@@$00@@QAEPAUIDInfo@@XZ PROC	; BaseVector<IDInfo,1>::begin, COMDAT
; _this$ = ecx

; 194  :         return m_pData; 

	mov	eax, DWORD PTR [ecx]

; 195  :     };

	ret	0
?begin@?$BaseVector@UIDInfo@@$00@@QAEPAUIDInfo@@XZ ENDP	; BaseVector<IDInfo,1>::begin
_TEXT	ENDS
PUBLIC	?end@?$BaseVector@UIDInfo@@$00@@QAEPAUIDInfo@@XZ ; BaseVector<IDInfo,1>::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$BaseVector@UIDInfo@@$00@@QAEPAUIDInfo@@XZ
_TEXT	SEGMENT
?end@?$BaseVector@UIDInfo@@$00@@QAEPAUIDInfo@@XZ PROC	; BaseVector<IDInfo,1>::end, COMDAT
; _this$ = ecx

; 197  :         return m_pData+m_uiCurrSize; 

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [ecx+eax*8]

; 198  :     };

	ret	0
?end@?$BaseVector@UIDInfo@@$00@@QAEPAUIDInfo@@XZ ENDP	; BaseVector<IDInfo,1>::end
_TEXT	ENDS
PUBLIC	?erase@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAEXPAUIDInfo@@@Z ; FStaticVector<IDInfo,8,1,297,0>::erase
; Function compile flags: /Ogtpy
;	COMDAT ?erase@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAEXPAUIDInfo@@@Z
_TEXT	SEGMENT
_it$ = 8						; size = 4
?erase@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAEXPAUIDInfo@@@Z PROC ; FStaticVector<IDInfo,8,1,297,0>::erase, COMDAT
; _this$ = ecx

; 703  : 		m_bIsResized = false;
; 704  : 
; 705  : 		unsigned int uIndex = it - m_pData;

	mov	eax, DWORD PTR _it$[esp-4]
	sub	eax, DWORD PTR [ecx]
	push	esi
	sar	eax, 3

; 706  : 
; 707  :         for(unsigned int i = uIndex; i + 1< m_uiCurrSize; ++i)

	lea	esi, DWORD PTR [eax+1]
	mov	BYTE PTR [ecx+76], 0
	cmp	esi, DWORD PTR [ecx+4]
	jae	SHORT $LN8@erase
	lea	edx, DWORD PTR [eax*8]
	push	edi
	npad	2
$LL3@erase:

; 708  :         {
; 709  :             m_pData[i] = m_pData[i+1];

	mov	eax, DWORD PTR [ecx]
	mov	edi, DWORD PTR [eax+edx+8]
	add	eax, edx
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [eax+12]
	inc	esi
	mov	DWORD PTR [eax+4], edi
	add	edx, 8
	cmp	esi, DWORD PTR [ecx+4]
	jb	SHORT $LL3@erase
	pop	edi
$LN8@erase:

; 710  :         }
; 711  : 		
; 712  : 		--m_uiCurrSize;

	dec	DWORD PTR [ecx+4]
	pop	esi

; 713  : 	}

	ret	4
?erase@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAEXPAUIDInfo@@@Z ENDP ; FStaticVector<IDInfo,8,1,297,0>::erase
_TEXT	ENDS
PUBLIC	??_C@_0HM@IMGGMCHG@c?3?2users?2enormousapplepie?2deskto@ ; `string'
PUBLIC	?Alloc@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEPAUIDInfo@@I@Z ; FStaticVector<IDInfo,8,1,297,0>::Alloc
EXTRN	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z:PROC ; FireMallocAlignedNoTracking
;	COMDAT ??_C@_0HM@IMGGMCHG@c?3?2users?2enormousapplepie?2deskto@
CONST	SEGMENT
??_C@_0HM@IMGGMCHG@c?3?2users?2enormousapplepie?2deskto@ DB 'c:\users\eno'
	DB	'rmousapplepie\desktop\lekmod files\lekmod dll versions\v29\le'
	DB	'kmod_dll\fireplace\include\fireworks\FFastVector.h', 00H ; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?Alloc@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEPAUIDInfo@@I@Z
_TEXT	SEGMENT
_uiSize$ = 8						; size = 4
?Alloc@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEPAUIDInfo@@I@Z PROC ; FStaticVector<IDInfo,8,1,297,0>::Alloc, COMDAT
; _this$ = ecx

; 795  : 	T* Alloc(unsigned int uiSize){

	push	esi
	push	edi

; 796  : 		T* pRet;
; 797  : 		if( uiSize > L ){

	mov	edi, DWORD PTR _uiSize$[esp+4]
	mov	esi, ecx
	cmp	edi, 8
	jbe	SHORT $LN2@Alloc

; 798  : 			pRet = (T*)FMALLOCALIGNED( uiSize*sizeof(T), __alignof(T), AllocPool, nSubID );

	push	798					; 0000031eH
	push	OFFSET ??_C@_0HM@IMGGMCHG@c?3?2users?2enormousapplepie?2deskto@
	lea	eax, DWORD PTR [edi*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H

; 799  : 			m_uiCurrMaxSize = uiSize;

	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
$LN2@Alloc:
	pop	edi

; 800  : 		}else{
; 801  : 			pRet = (T*)m_aData;

	lea	eax, DWORD PTR [esi+12]

; 802  : 			m_uiCurrMaxSize = L;

	mov	DWORD PTR [esi+8], 8
	pop	esi

; 803  : 		}
; 804  : 		return pRet;
; 805  : 	};

	ret	4
?Alloc@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEPAUIDInfo@@I@Z ENDP ; FStaticVector<IDInfo,8,1,297,0>::Alloc
_TEXT	ENDS
PUBLIC	?Destroy@?$BaseVector@UIDInfo@@$00@@IAEXPAUIDInfo@@I@Z ; BaseVector<IDInfo,1>::Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?Destroy@?$BaseVector@UIDInfo@@$00@@IAEXPAUIDInfo@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Destroy@?$BaseVector@UIDInfo@@$00@@IAEXPAUIDInfo@@I@Z PROC ; BaseVector<IDInfo,1>::Destroy, COMDAT
; _this$ = ecx

; 221  : 		if( !bPODType){
; 222  : 			for(unsigned int i = 0; i < uiNumElements; ++i){
; 223  : 				pVal[i].~T();
; 224  : 			}
; 225  : 		}
; 226  : 	};

	ret	8
?Destroy@?$BaseVector@UIDInfo@@$00@@IAEXPAUIDInfo@@I@Z ENDP ; BaseVector<IDInfo,1>::Destroy
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	?Lock@?$FObjectPool@VCvIDInfoFixedVector@@@@IAEXXZ ; FObjectPool<CvIDInfoFixedVector>::Lock
EXTRN	?Enter@FCriticalSection@@QAEXXZ:PROC		; FCriticalSection::Enter
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjectpool.h
;	COMDAT ?Lock@?$FObjectPool@VCvIDInfoFixedVector@@@@IAEXXZ
_TEXT	SEGMENT
?Lock@?$FObjectPool@VCvIDInfoFixedVector@@@@IAEXXZ PROC	; FObjectPool<CvIDInfoFixedVector>::Lock, COMDAT
; _this$ = ecx

; 60   : 		{ m_Locker.Enter(); }

	add	ecx, 8
	jmp	?Enter@FCriticalSection@@QAEXXZ		; FCriticalSection::Enter
?Lock@?$FObjectPool@VCvIDInfoFixedVector@@@@IAEXXZ ENDP	; FObjectPool<CvIDInfoFixedVector>::Lock
_TEXT	ENDS
PUBLIC	?Unlock@?$FObjectPool@VCvIDInfoFixedVector@@@@IAEXXZ ; FObjectPool<CvIDInfoFixedVector>::Unlock
EXTRN	?Leave@FCriticalSection@@QAEXXZ:PROC		; FCriticalSection::Leave
; Function compile flags: /Ogtpy
;	COMDAT ?Unlock@?$FObjectPool@VCvIDInfoFixedVector@@@@IAEXXZ
_TEXT	SEGMENT
?Unlock@?$FObjectPool@VCvIDInfoFixedVector@@@@IAEXXZ PROC ; FObjectPool<CvIDInfoFixedVector>::Unlock, COMDAT
; _this$ = ecx

; 62   : 		{ m_Locker.Leave(); }

	add	ecx, 8
	jmp	?Leave@FCriticalSection@@QAEXXZ		; FCriticalSection::Leave
?Unlock@?$FObjectPool@VCvIDInfoFixedVector@@@@IAEXXZ ENDP ; FObjectPool<CvIDInfoFixedVector>::Unlock
_TEXT	ENDS
PUBLIC	??1?$BaseVector@UIDInfo@@$00@@QAE@XZ		; BaseVector<IDInfo,1>::~BaseVector<IDInfo,1>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??1?$BaseVector@UIDInfo@@$00@@QAE@XZ
_TEXT	SEGMENT
??1?$BaseVector@UIDInfo@@$00@@QAE@XZ PROC		; BaseVector<IDInfo,1>::~BaseVector<IDInfo,1>, COMDAT
; _this$ = ecx

; 111  : 	~BaseVector(){};

	ret	0
??1?$BaseVector@UIDInfo@@$00@@QAE@XZ ENDP		; BaseVector<IDInfo,1>::~BaseVector<IDInfo,1>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@UFPoolNode@?$FObjectPool@VCvIDInfoFixedVector@@@@@@YAXAAPAUFPoolNode@?$FObjectPool@VCvIDInfoFixedVector@@@@@Z ; SAFE_DELETE_ARRAY<FObjectPool<CvIDInfoFixedVector>::FPoolNode>
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE_ARRAY@UFPoolNode@?$FObjectPool@VCvIDInfoFixedVector@@@@@@YAXAAPAUFPoolNode@?$FObjectPool@VCvIDInfoFixedVector@@@@@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@UFPoolNode@?$FObjectPool@VCvIDInfoFixedVector@@@@@@YAXAAPAUFPoolNode@?$FObjectPool@VCvIDInfoFixedVector@@@@@Z PROC ; SAFE_DELETE_ARRAY<FObjectPool<CvIDInfoFixedVector>::FPoolNode>, COMDAT

; 311  : {

	push	esi

; 312  : 	delete[] pkInstanceArray;

	mov	esi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@UFPoolNode@?$FObjectPool@VCvIDInfoFixedVector@@@@@@YAXAAPAUFPoolNode@?$FObjectPool@VCvIDInfoFixedVector@@@@@Z ENDP ; SAFE_DELETE_ARRAY<FObjectPool<CvIDInfoFixedVector>::FPoolNode>
_TEXT	ENDS
PUBLIC	?GetNumLayers@CvPlotManager@@QBEHXZ		; CvPlotManager::GetNumLayers
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvplotmanager.cpp
;	COMDAT ?GetNumLayers@CvPlotManager@@QBEHXZ
_TEXT	SEGMENT
?GetNumLayers@CvPlotManager@@QBEHXZ PROC		; CvPlotManager::GetNumLayers, COMDAT
; _this$ = ecx

; 138  : 	return (int)m_aLayers.size();

	mov	eax, DWORD PTR [ecx+96]
	sub	eax, DWORD PTR [ecx+92]
	sar	eax, 3

; 139  : }

	ret	0
?GetNumLayers@CvPlotManager@@QBEHXZ ENDP		; CvPlotManager::GetNumLayers
_TEXT	ENDS
PUBLIC	?GetLayerIndexID@CvPlotManager@@QBEIH@Z		; CvPlotManager::GetLayerIndexID
; Function compile flags: /Ogtpy
;	COMDAT ?GetLayerIndexID@CvPlotManager@@QBEIH@Z
_TEXT	SEGMENT
_iLayerIndex$ = 8					; size = 4
?GetLayerIndexID@CvPlotManager@@QBEIH@Z PROC		; CvPlotManager::GetLayerIndexID, COMDAT
; _this$ = ecx

; 160  : 	if (iLayerIndex >= 0 && iLayerIndex < (int)m_aLayers.size())

	mov	eax, DWORD PTR _iLayerIndex$[esp-4]
	test	eax, eax
	jl	SHORT $LN1@GetLayerIn
	mov	edx, DWORD PTR [ecx+96]
	sub	edx, DWORD PTR [ecx+92]
	sar	edx, 3
	cmp	eax, edx
	jge	SHORT $LN1@GetLayerIn

; 161  : 		return m_aLayers[iLayerIndex].GetID();

	mov	ecx, DWORD PTR [ecx+92]
	mov	eax, DWORD PTR [ecx+eax*8]

; 164  : }

	ret	4
$LN1@GetLayerIn:

; 162  : 
; 163  : 	return (uint)-1;

	or	eax, -1

; 164  : }

	ret	4
?GetLayerIndexID@CvPlotManager@@QBEIH@Z ENDP		; CvPlotManager::GetLayerIndexID
_TEXT	ENDS
PUBLIC	?GetUnitsByIndex@CvPlotManager@@QBEABVCvIDInfoFixedVector@@HHH@Z ; CvPlotManager::GetUnitsByIndex
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnitsByIndex@CvPlotManager@@QBEABVCvIDInfoFixedVector@@HHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iLayerIndex$ = 16					; size = 4
?GetUnitsByIndex@CvPlotManager@@QBEABVCvIDInfoFixedVector@@HHH@Z PROC ; CvPlotManager::GetUnitsByIndex, COMDAT
; _this$ = ecx

; 233  : 	if (iLayerIndex >= 0 && iLayerIndex < (int)m_aLayers.size())

	mov	eax, DWORD PTR _iLayerIndex$[esp-4]
	test	eax, eax
	jl	SHORT $LN1@GetUnitsBy
	mov	edx, DWORD PTR [ecx+96]
	sub	edx, DWORD PTR [ecx+92]
	sar	edx, 3
	cmp	eax, edx
	jge	SHORT $LN1@GetUnitsBy

; 234  : 	{
; 235  : 		const CvIDInfoFixedVector* pkEntry = m_aLayers[iLayerIndex].GetGrid()->Get(iX, iY);

	mov	edx, DWORD PTR [ecx+92]
	mov	edx, DWORD PTR [edx+eax*8+4]
	mov	eax, DWORD PTR [edx]
	imul	eax, DWORD PTR _iY$[esp-4]
	add	eax, DWORD PTR _iX$[esp-4]
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $LN1@GetUnitsBy
	mov	edx, DWORD PTR [edx+16]
	mov	eax, DWORD PTR [edx+eax*4]
	test	eax, eax

; 236  : 		if (pkEntry)
; 237  : 			return *pkEntry;

	jne	SHORT $LN3@GetUnitsBy
$LN1@GetUnitsBy:

; 238  : 	}
; 239  : 
; 240  : 	return m_kEmpty;

	lea	eax, DWORD PTR [ecx+8]
$LN3@GetUnitsBy:

; 241  : }

	ret	12					; 0000000cH
?GetUnitsByIndex@CvPlotManager@@QBEABVCvIDInfoFixedVector@@HHH@Z ENDP ; CvPlotManager::GetUnitsByIndex
_TEXT	ENDS
PUBLIC	?GetNumUnitsByIndex@CvPlotManager@@QBEHHHH@Z	; CvPlotManager::GetNumUnitsByIndex
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumUnitsByIndex@CvPlotManager@@QBEHHHH@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_iLayerIndex$ = 16					; size = 4
?GetNumUnitsByIndex@CvPlotManager@@QBEHHHH@Z PROC	; CvPlotManager::GetNumUnitsByIndex, COMDAT
; _this$ = ecx

; 297  : 	if (iLayerIndex >= 0 && iLayerIndex < (int)m_aLayers.size())

	mov	eax, DWORD PTR _iLayerIndex$[esp-4]
	test	eax, eax
	jl	SHORT $LN1@GetNumUnit
	mov	edx, DWORD PTR [ecx+96]
	sub	edx, DWORD PTR [ecx+92]
	sar	edx, 3
	cmp	eax, edx
	jge	SHORT $LN1@GetNumUnit

; 298  : 	{
; 299  : 		const CvIDInfoFixedVector* pkEntry = m_aLayers[iLayerIndex].GetGrid()->Get(iX, iY);

	mov	ecx, DWORD PTR [ecx+92]
	mov	ecx, DWORD PTR [ecx+eax*8+4]
	mov	eax, DWORD PTR [ecx]
	imul	eax, DWORD PTR _iY$[esp-4]
	add	eax, DWORD PTR _iX$[esp-4]
	cmp	eax, DWORD PTR [ecx+8]
	jae	SHORT $LN1@GetNumUnit
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx+eax*4]
	test	eax, eax

; 300  : 		if (pkEntry)

	je	SHORT $LN1@GetNumUnit

; 301  : 			return (int)pkEntry->size();

	mov	eax, DWORD PTR [eax+4]

; 305  : }

	ret	12					; 0000000cH
$LN1@GetNumUnit:

; 302  : 	}
; 303  : 
; 304  : 	return 0;

	xor	eax, eax

; 305  : }

	ret	12					; 0000000cH
?GetNumUnitsByIndex@CvPlotManager@@QBEHHHH@Z ENDP	; CvPlotManager::GetNumUnitsByIndex
_TEXT	ENDS
PUBLIC	??0?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<IDInfo,8,1,297,0>::FStaticVector<IDInfo,8,1,297,0>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ??0?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??0?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<IDInfo,8,1,297,0>::FStaticVector<IDInfo,8,1,297,0>, COMDAT
; _this$ = ecx

; 601  : 	FStaticVector()

	mov	eax, ecx

; 602  :     {
; 603  : 		m_uiCurrMaxSize = L;
; 604  : 		m_pData = Alloc(m_uiCurrMaxSize);

	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 8
	mov	DWORD PTR [eax], ecx

; 605  : #ifdef BREAK_ON_STATIC_RESIZE
; 606  : 		m_iNumResized = 0;
; 607  : #endif
; 608  :     };

	ret	0
??0?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<IDInfo,8,1,297,0>::FStaticVector<IDInfo,8,1,297,0>
_TEXT	ENDS
PUBLIC	?begin@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@XZ ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@XZ PROC ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@XZ ENDP ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::begin
_TEXT	ENDS
PUBLIC	?begin@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@XZ ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@XZ PROC ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::begin, COMDAT
; _this$ = ecx

; 672  : 		return (const_iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 673  : 		}

	ret	4
?begin@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@XZ ENDP ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@XZ ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@XZ PROC ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::end, COMDAT
; _this$ = ecx

; 677  : 		return (iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 678  : 		}

	ret	4
?end@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@XZ ENDP ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::end
_TEXT	ENDS
PUBLIC	?end@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@XZ ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@XZ PROC ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::end, COMDAT
; _this$ = ecx

; 682  : 		return (const_iterator(_Mylast));

	mov	ecx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 683  : 		}

	ret	4
?end@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@XZ ENDP ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::end
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::operator!=, COMDAT
; _this$ = ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	4
??9?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::operator!=
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE@XZ ; std::_Vector_val<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::~_Vector_val<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::~_Vector_val<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::~_Vector_val<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAE@V?$allocator@UCvSparseIDInfoGridEntry@@@1@@Z ; std::_Vector_val<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Vector_val<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_val@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAE@V?$allocator@UCvSparseIDInfoGridEntry@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAE@V?$allocator@UCvSparseIDInfoGridEntry@@@1@@Z PROC ; std::_Vector_val<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Vector_val<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAE@V?$allocator@UCvSparseIDInfoGridEntry@@@1@@Z ENDP ; std::_Vector_val<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Vector_val<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >
_TEXT	ENDS
PUBLIC	?max_size@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QBEIXZ ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::max_size
; Function compile flags: /Ogtpy
;	COMDAT ?max_size@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QBEIXZ PROC ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 536870911				; 1fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QBEIXZ ENDP ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::max_size
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@KAXXZ ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Xlen
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T218789 = -80						; size = 28
$T218788 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@KAXXZ PROC ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T218789[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T218788[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T218789[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T218788[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T218788[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T218788[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T218788[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen:
$LN12@Xlen:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T218789[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T218788[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@KAXXZ ENDP ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Xlen
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+20]
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	add	edi, 12					; 0000000cH
	push	edi
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
; Function compile flags: /Ogtpy
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UCvSparseIDInfoGridEntry@@@std@@QAEPAUCvSparseIDInfoGridEntry@@I@Z ; std::allocator<CvSparseIDInfoGridEntry>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@UCvSparseIDInfoGridEntry@@@std@@QAEPAUCvSparseIDInfoGridEntry@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@UCvSparseIDInfoGridEntry@@@std@@QAEPAUCvSparseIDInfoGridEntry@@I@Z PROC ; std::allocator<CvSparseIDInfoGridEntry>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@UCvSparseIDInfoGridEntry@@@std@@YAPAUCvSparseIDInfoGridEntry@@IPAU1@@Z ; std::_Allocate<CvSparseIDInfoGridEntry>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@UCvSparseIDInfoGridEntry@@@std@@QAEPAUCvSparseIDInfoGridEntry@@I@Z ENDP ; std::allocator<CvSparseIDInfoGridEntry>::allocate
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::operator+=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	mov	eax, ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [ecx*8]
	add	DWORD PTR [eax], edx

; 376  : 		return (*this);
; 377  : 		}

	ret	4
??Y?$_Vector_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::operator+=
_TEXT	ENDS
PUBLIC	?Release@?$FObjectPool@VCvIDInfoFixedVector@@@@QAEXPAVCvIDInfoFixedVector@@@Z ; FObjectPool<CvIDInfoFixedVector>::Release
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjectpool.h
;	COMDAT ?Release@?$FObjectPool@VCvIDInfoFixedVector@@@@QAEXPAVCvIDInfoFixedVector@@@Z
_TEXT	SEGMENT
_pObject$ = 8						; size = 4
?Release@?$FObjectPool@VCvIDInfoFixedVector@@@@QAEXPAVCvIDInfoFixedVector@@@Z PROC ; FObjectPool<CvIDInfoFixedVector>::Release, COMDAT
; _this$ = ecx

; 289  : {

	push	ebx
	push	esi
	mov	esi, ecx

; 290  : 	// Thread-safety
; 291  : 	Lock();

	lea	ebx, DWORD PTR [esi+8]
	mov	ecx, ebx
	call	?Enter@FCriticalSection@@QAEXXZ		; FCriticalSection::Enter

; 292  : 
; 293  : 	// Find this pointer -> can we do better than linear search here?
; 294  : 	for (uint i = 0; i < m_uiSize; ++i)

	xor	eax, eax
	cmp	DWORD PTR [esi+32], eax
	jbe	SHORT $LN1@Release
	mov	edx, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR _pObject$[esp+8]
	mov	ecx, edx
	npad	1
$LL5@Release:

; 295  : 	{
; 296  : 		if (m_pStorage[i].pObject == pObject)

	cmp	DWORD PTR [ecx], edi
	je	SHORT $LN13@Release
	inc	eax
	add	ecx, 8
	cmp	eax, DWORD PTR [esi+32]
	jb	SHORT $LL5@Release
	pop	edi

; 305  : 
; 306  : 			break;
; 307  : 		}
; 308  : 	}
; 309  : 
; 310  : 	Unlock();

	mov	ecx, ebx
	call	?Leave@FCriticalSection@@QAEXXZ		; FCriticalSection::Leave
	pop	esi
	pop	ebx

; 311  : }

	ret	4
$LN13@Release:

; 297  : 		{
; 298  : 			// We found it
; 299  : 			m_pStorage[i].bFree = true;

	mov	BYTE PTR [edx+eax*8+4], 1

; 300  : 			m_bFull = false;

	mov	BYTE PTR [esi+37], 0

; 301  : 
; 302  : 			// See if we can move the first available index
; 303  : 			if (i < m_uiFirstFreeIndex)

	cmp	eax, DWORD PTR [esi+40]
	jae	SHORT $LN15@Release

; 304  : 				m_uiFirstFreeIndex = i;

	mov	DWORD PTR [esi+40], eax
$LN15@Release:
	pop	edi
$LN1@Release:

; 305  : 
; 306  : 			break;
; 307  : 		}
; 308  : 	}
; 309  : 
; 310  : 	Unlock();

	mov	ecx, ebx
	call	?Leave@FCriticalSection@@QAEXXZ		; FCriticalSection::Leave
	pop	esi
	pop	ebx

; 311  : }

	ret	4
?Release@?$FObjectPool@VCvIDInfoFixedVector@@@@QAEXPAVCvIDInfoFixedVector@@@Z ENDP ; FObjectPool<CvIDInfoFixedVector>::Release
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAUCvSparseIDInfoGridEntry@@PAU1@@stdext@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00@Z ; stdext::unchecked_copy<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAUCvSparseIDInfoGridEntry@@PAU1@@stdext@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAUCvSparseIDInfoGridEntry@@PAU1@@stdext@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00@Z PROC ; stdext::unchecked_copy<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *>, COMDAT

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN7@unchecked_
	push	esi
$LL9@unchecked_:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	add	ecx, 8
	add	eax, 8
	cmp	ecx, edx
	jne	SHORT $LL9@unchecked_
	pop	esi
$LN7@unchecked_:

; 3607 : 	}

	ret	0
??$unchecked_copy@PAUCvSparseIDInfoGridEntry@@PAU1@@stdext@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00@Z ENDP ; stdext::unchecked_copy<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *>
_TEXT	ENDS
PUBLIC	??$fill@PAUCvSparseIDInfoGridEntry@@U1@@std@@YAXPAUCvSparseIDInfoGridEntry@@0ABU1@@Z ; std::fill<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry>
; Function compile flags: /Ogtpy
;	COMDAT ??$fill@PAUCvSparseIDInfoGridEntry@@U1@@std@@YAXPAUCvSparseIDInfoGridEntry@@0ABU1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAUCvSparseIDInfoGridEntry@@U1@@std@@YAXPAUCvSparseIDInfoGridEntry@@0ABU1@@Z PROC ; std::fill<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry>, COMDAT

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN3@fill
	mov	ecx, DWORD PTR __Val$[esp-4]
	push	esi
$LL5@fill:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	add	eax, 8
	cmp	eax, edx
	jne	SHORT $LL5@fill
	pop	esi
$LN3@fill:

; 3188 : 	}

	ret	0
??$fill@PAUCvSparseIDInfoGridEntry@@U1@@std@@YAXPAUCvSparseIDInfoGridEntry@@0ABU1@@Z ENDP ; std::fill<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAUCvSparseIDInfoGridEntry@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Move_backward_opt@PAUCvSparseIDInfoGridEntry@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAUCvSparseIDInfoGridEntry@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN5@Move_backw
	push	esi
$LL6@Move_backw:
	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL6@Move_backw
	pop	esi
$LN5@Move_backw:

; 2755 : 	}

	ret	0
??$_Move_backward_opt@PAUCvSparseIDInfoGridEntry@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UCvSparseIDInfoGridEntry@@@std@@QAEXPAUCvSparseIDInfoGridEntry@@ABU3@@Z ; std::allocator<CvSparseIDInfoGridEntry>::construct
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?construct@?$allocator@UCvSparseIDInfoGridEntry@@@std@@QAEXPAUCvSparseIDInfoGridEntry@@ABU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UCvSparseIDInfoGridEntry@@@std@@QAEXPAUCvSparseIDInfoGridEntry@@ABU3@@Z PROC ; std::allocator<CvSparseIDInfoGridEntry>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN5@construct:

; 156  : 		}

	ret	8
?construct@?$allocator@UCvSparseIDInfoGridEntry@@@std@@QAEXPAUCvSparseIDInfoGridEntry@@ABU3@@Z ENDP ; std::allocator<CvSparseIDInfoGridEntry>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UCvSparseIDInfoGridEntry@@@std@@QAEXPAUCvSparseIDInfoGridEntry@@@Z ; std::allocator<CvSparseIDInfoGridEntry>::destroy
; Function compile flags: /Ogtpy
;	COMDAT ?destroy@?$allocator@UCvSparseIDInfoGridEntry@@@std@@QAEXPAUCvSparseIDInfoGridEntry@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UCvSparseIDInfoGridEntry@@@std@@QAEXPAUCvSparseIDInfoGridEntry@@@Z PROC ; std::allocator<CvSparseIDInfoGridEntry>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@UCvSparseIDInfoGridEntry@@@std@@QAEXPAUCvSparseIDInfoGridEntry@@@Z ENDP ; std::allocator<CvSparseIDInfoGridEntry>::destroy
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *,std::allocator<CvSparseIDInfoGridEntry> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *,std::allocator<CvSparseIDInfoGridEntry> >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop
	push	esi
$LL6@Uninit_cop:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
$LN5@Uninit_cop:
	add	ecx, 8
	add	eax, 8
	cmp	ecx, edx
	jne	SHORT $LL6@Uninit_cop
	pop	esi
$LN4@Uninit_cop:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *,std::allocator<CvSparseIDInfoGridEntry> >
_TEXT	ENDS
PUBLIC	?Find@CvIDInfoFixedVector@@QAEPAUIDInfo@@ABU2@@Z ; CvIDInfoFixedVector::Find
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvplotmanager.h
;	COMDAT ?Find@CvIDInfoFixedVector@@QAEPAUIDInfo@@ABU2@@Z
_TEXT	SEGMENT
_kInfo$ = 8						; size = 4
?Find@CvIDInfoFixedVector@@QAEPAUIDInfo@@ABU2@@Z PROC	; CvIDInfoFixedVector::Find, COMDAT
; _this$ = ecx

; 16   : 		for (iterator itr = begin(); itr != end(); ++itr)

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	lea	ecx, DWORD PTR [eax+ecx*8]
	push	esi
	push	edi
	cmp	eax, ecx
	je	SHORT $LN2@Find
	mov	edx, DWORD PTR _kInfo$[esp+4]
	mov	esi, DWORD PTR [edx]
$LL4@Find:

; 17   : 		{
; 18   : 			if ((*itr) == kInfo)

	cmp	DWORD PTR [eax], esi
	jne	SHORT $LN13@Find
	mov	edi, DWORD PTR [eax+4]
	cmp	edi, DWORD PTR [edx+4]
	je	SHORT $LN5@Find
$LN13@Find:
	add	eax, 8
	cmp	eax, ecx
	jne	SHORT $LL4@Find
$LN2@Find:

; 19   : 				return &(*itr);
; 20   : 		}
; 21   : 		return NULL;

	xor	eax, eax
$LN5@Find:
	pop	edi
	pop	esi

; 22   : 	}

	ret	4
?Find@CvIDInfoFixedVector@@QAEPAUIDInfo@@ABU2@@Z ENDP	; CvIDInfoFixedVector::Find
_TEXT	ENDS
PUBLIC	?Remove@CvIDInfoFixedVector@@QAE_NABUIDInfo@@@Z	; CvIDInfoFixedVector::Remove
; Function compile flags: /Ogtpy
;	COMDAT ?Remove@CvIDInfoFixedVector@@QAE_NABUIDInfo@@@Z
_TEXT	SEGMENT
_kInfo$ = 8						; size = 4
?Remove@CvIDInfoFixedVector@@QAE_NABUIDInfo@@@Z PROC	; CvIDInfoFixedVector::Remove, COMDAT
; _this$ = ecx

; 43   : 		for (iterator itr = begin(); itr != end(); ++itr)

	mov	edx, DWORD PTR [ecx]
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR [ecx+4]
	mov	eax, edx
	lea	esi, DWORD PTR [edx+edi*8]
	cmp	eax, esi
	je	SHORT $LN2@Remove
	mov	esi, DWORD PTR _kInfo$[esp+12]
$LL4@Remove:

; 44   : 		{
; 45   : 			if ((*itr) == kInfo)

	mov	ebx, DWORD PTR [esi]
	cmp	DWORD PTR [eax], ebx
	jne	SHORT $LN13@Remove
	mov	ebx, DWORD PTR [eax+4]
	cmp	ebx, DWORD PTR [esi+4]
	je	SHORT $LN22@Remove
$LN13@Remove:
	mov	ebx, edi
	mov	ebp, edx
	add	eax, 8
	lea	ebx, DWORD PTR [ebp+ebx*8]
	cmp	eax, ebx
	jne	SHORT $LL4@Remove
$LN2@Remove:
	pop	edi
	pop	esi
	pop	ebp

; 49   : 			}
; 50   : 		}
; 51   : 		return false;

	xor	al, al
	pop	ebx

; 52   : 	}

	ret	4
$LN22@Remove:

; 46   : 			{
; 47   : 				erase(itr);

	sub	eax, edx
	sar	eax, 3
	lea	esi, DWORD PTR [eax+1]
	mov	BYTE PTR [ecx+76], 0
	cmp	esi, edi
	jae	SHORT $LN15@Remove
	lea	edx, DWORD PTR [eax*8]
$LL17@Remove:
	mov	eax, DWORD PTR [ecx]
	mov	edi, DWORD PTR [eax+edx+8]
	add	eax, edx
	mov	DWORD PTR [eax], edi
	mov	edi, DWORD PTR [eax+12]
	inc	esi
	mov	DWORD PTR [eax+4], edi
	add	edx, 8
	cmp	esi, DWORD PTR [ecx+4]
	jb	SHORT $LL17@Remove
$LN15@Remove:
	dec	DWORD PTR [ecx+4]
	pop	edi
	pop	esi
	pop	ebp

; 48   : 				return true;

	mov	al, 1
	pop	ebx

; 52   : 	}

	ret	4
?Remove@CvIDInfoFixedVector@@QAE_NABUIDInfo@@@Z ENDP	; CvIDInfoFixedVector::Remove
_TEXT	ENDS
PUBLIC	?Free@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEXPAUIDInfo@@I@Z ; FStaticVector<IDInfo,8,1,297,0>::Free
EXTRN	?FireFreeAlignedNoTracking@@YAXPAX@Z:PROC	; FireFreeAlignedNoTracking
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?Free@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEXPAUIDInfo@@I@Z
_TEXT	SEGMENT
_pVal$ = 8						; size = 4
_uiNumElements$ = 12					; size = 4
?Free@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEXPAUIDInfo@@I@Z PROC ; FStaticVector<IDInfo,8,1,297,0>::Free, COMDAT
; _this$ = ecx

; 810  : 		if( !bPODType) Destroy(pVal, uiNumElements);
; 811  : 		if( pVal != (T*)m_aData )

	mov	eax, DWORD PTR _pVal$[esp-4]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN1@Free

; 812  : 			FFREEALIGNED( (unsigned char*)pVal );

	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN1@Free:

; 813  : 	};

	ret	8
?Free@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEXPAUIDInfo@@I@Z ENDP ; FStaticVector<IDInfo,8,1,297,0>::Free
_TEXT	ENDS
PUBLIC	??1?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ ; FStaticVector<IDInfo,8,1,297,0>::~FStaticVector<IDInfo,8,1,297,0>
; Function compile flags: /Ogtpy
;	COMDAT ??1?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ
_TEXT	SEGMENT
??1?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ PROC ; FStaticVector<IDInfo,8,1,297,0>::~FStaticVector<IDInfo,8,1,297,0>, COMDAT
; _this$ = ecx

; 618  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN3@FStaticVec@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN3@FStaticVec@2:

; 619  : 	};

	ret	0
??1?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAE@XZ ENDP ; FStaticVector<IDInfo,8,1,297,0>::~FStaticVector<IDInfo,8,1,297,0>
_TEXT	ENDS
PUBLIC	??1CvSparseIDInfoGrid@@QAE@XZ			; CvSparseIDInfoGrid::~CvSparseIDInfoGrid
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvplotmanager.cpp
;	COMDAT ??1CvSparseIDInfoGrid@@QAE@XZ
_TEXT	SEGMENT
??1CvSparseIDInfoGrid@@QAE@XZ PROC			; CvSparseIDInfoGrid::~CvSparseIDInfoGrid, COMDAT
; _this$ = ecx

; 32   : {

	push	ebx
	mov	ebx, ecx
	push	edi

; 33   : 	if (m_paEntries)

	mov	edi, DWORD PTR [ebx+16]
	test	edi, edi
	je	SHORT $LN4@CvSparseID
	push	esi

; 34   : 	{
; 35   : 		CvIDInfoFixedVector** pkEntry = m_paEntries;
; 36   : 		for (uint uiIndex = m_uiMaxIndex; --uiIndex;)

	mov	esi, DWORD PTR [ebx+8]
	sub	esi, 1
	je	SHORT $LN2@CvSparseID
$LL3@CvSparseID:

; 37   : 		{
; 38   : 			if (*pkEntry)

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN1@CvSparseID

; 39   : 				m_pkAllocator->Release(*pkEntry);

	mov	ecx, DWORD PTR [ebx+20]
	push	eax
	call	?Release@?$FObjectPool@VCvIDInfoFixedVector@@@@QAEXPAVCvIDInfoFixedVector@@@Z ; FObjectPool<CvIDInfoFixedVector>::Release
$LN1@CvSparseID:

; 40   : 
; 41   : 			pkEntry++;

	add	edi, 4
	sub	esi, 1
	jne	SHORT $LL3@CvSparseID
$LN2@CvSparseID:

; 42   : 		}
; 43   : 		delete []m_paEntries;

	mov	eax, DWORD PTR [ebx+16]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	pop	esi
$LN4@CvSparseID:
	pop	edi
	pop	ebx

; 44   : 	}
; 45   : }

	ret	0
??1CvSparseIDInfoGrid@@QAE@XZ ENDP			; CvSparseIDInfoGrid::~CvSparseIDInfoGrid
_TEXT	ENDS
PUBLIC	?Remove@CvSparseIDInfoGrid@@QAEXABUIDInfo@@HH@Z	; CvSparseIDInfoGrid::Remove
; Function compile flags: /Ogtpy
;	COMDAT ?Remove@CvSparseIDInfoGrid@@QAEXABUIDInfo@@HH@Z
_TEXT	SEGMENT
_kInfo$ = 8						; size = 4
_iX$ = 12						; size = 4
_iY$ = 16						; size = 4
?Remove@CvSparseIDInfoGrid@@QAEXABUIDInfo@@HH@Z PROC	; CvSparseIDInfoGrid::Remove, COMDAT
; _this$ = ecx

; 85   : {

	push	esi
	push	edi
	mov	edi, ecx

; 86   : 	uint uiIndex = ((uint) iY * m_uiWidth) + (uint) iX;

	mov	esi, DWORD PTR [edi]
	imul	esi, DWORD PTR _iY$[esp+4]
	add	esi, DWORD PTR _iX$[esp+4]

; 87   : 	if (uiIndex < m_uiMaxIndex)

	cmp	esi, DWORD PTR [edi+8]
	jae	SHORT $LN1@Remove@2

; 88   : 	{
; 89   : 		CvIDInfoFixedVector* pkEntry = m_paEntries[uiIndex];

	mov	eax, DWORD PTR [edi+16]
	push	ebx
	mov	ebx, DWORD PTR [eax+esi*4]

; 90   : 		if (pkEntry)

	test	ebx, ebx
	je	SHORT $LN9@Remove@2

; 91   : 		{
; 92   : 			if (pkEntry->Remove(kInfo))

	mov	ecx, DWORD PTR _kInfo$[esp+8]
	push	ecx
	mov	ecx, ebx
	call	?Remove@CvIDInfoFixedVector@@QAE_NABUIDInfo@@@Z ; CvIDInfoFixedVector::Remove
	test	al, al
	je	SHORT $LN9@Remove@2

; 93   : 			{
; 94   : 				if (pkEntry->size() == 0)

	cmp	DWORD PTR [ebx+4], 0
	jne	SHORT $LN9@Remove@2

; 95   : 				{
; 96   : 					// Nothing there, release the array
; 97   : 					m_pkAllocator->Release(pkEntry);

	mov	ecx, DWORD PTR [edi+20]
	push	ebx
	call	?Release@?$FObjectPool@VCvIDInfoFixedVector@@@@QAEXPAVCvIDInfoFixedVector@@@Z ; FObjectPool<CvIDInfoFixedVector>::Release

; 98   : 					m_paEntries[uiIndex] = NULL;

	mov	edx, DWORD PTR [edi+16]
	mov	DWORD PTR [edx+esi*4], 0
$LN9@Remove@2:
	pop	ebx
$LN1@Remove@2:
	pop	edi
	pop	esi

; 99   : 				}
; 100  : 			}
; 101  : 		}
; 102  : 	}
; 103  : }

	ret	12					; 0000000cH
?Remove@CvSparseIDInfoGrid@@QAEXABUIDInfo@@HH@Z ENDP	; CvSparseIDInfoGrid::Remove
_TEXT	ENDS
PUBLIC	??0CvIDInfoFixedVector@@QAE@XZ			; CvIDInfoFixedVector::CvIDInfoFixedVector
; Function compile flags: /Ogtpy
;	COMDAT ??0CvIDInfoFixedVector@@QAE@XZ
_TEXT	SEGMENT
??0CvIDInfoFixedVector@@QAE@XZ PROC			; CvIDInfoFixedVector::CvIDInfoFixedVector, COMDAT
; _this$ = ecx
	mov	eax, ecx
	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 8
	mov	DWORD PTR [eax], ecx
	ret	0
??0CvIDInfoFixedVector@@QAE@XZ ENDP			; CvIDInfoFixedVector::CvIDInfoFixedVector
_TEXT	ENDS
PUBLIC	?GetLayerIDIndex@CvPlotManager@@QBEHI@Z		; CvPlotManager::GetLayerIDIndex
; Function compile flags: /Ogtpy
;	COMDAT ?GetLayerIDIndex@CvPlotManager@@QBEHI@Z
_TEXT	SEGMENT
_uiLayerID$ = 8						; size = 4
?GetLayerIDIndex@CvPlotManager@@QBEHI@Z PROC		; CvPlotManager::GetLayerIDIndex, COMDAT
; _this$ = ecx

; 144  : 	int iIndex = 0;
; 145  : 	for (CvSparseIDInfoGridVector::const_iterator itr = m_aLayers.begin(); itr != m_aLayers.end(); ++itr)

	mov	edx, DWORD PTR [ecx+92]
	mov	ecx, DWORD PTR [ecx+96]
	xor	eax, eax
	push	esi
	cmp	edx, ecx
	je	SHORT $LN2@GetLayerID
	mov	esi, DWORD PTR _uiLayerID$[esp]
$LL11@GetLayerID:

; 146  : 	{
; 147  : 		if ((*itr).m_uiID == uiLayerID)

	cmp	DWORD PTR [edx], esi
	je	SHORT $LN5@GetLayerID
	add	edx, 8

; 148  : 		{
; 149  : 			return iIndex;
; 150  : 		}
; 151  : 		++iIndex;

	inc	eax
	cmp	edx, ecx
	jne	SHORT $LL11@GetLayerID
$LN2@GetLayerID:

; 152  : 	}
; 153  : 
; 154  : 	return -1;

	or	eax, -1
$LN5@GetLayerID:
	pop	esi

; 155  : }

	ret	4
?GetLayerIDIndex@CvPlotManager@@QBEHI@Z ENDP		; CvPlotManager::GetLayerIDIndex
_TEXT	ENDS
PUBLIC	?FindLayer@CvPlotManager@@IAEPAVCvSparseIDInfoGrid@@I@Z ; CvPlotManager::FindLayer
; Function compile flags: /Ogtpy
;	COMDAT ?FindLayer@CvPlotManager@@IAEPAVCvSparseIDInfoGrid@@I@Z
_TEXT	SEGMENT
_uiLayerID$ = 8						; size = 4
?FindLayer@CvPlotManager@@IAEPAVCvSparseIDInfoGrid@@I@Z PROC ; CvPlotManager::FindLayer, COMDAT
; _this$ = ecx

; 186  : 	for (CvSparseIDInfoGridVector::const_iterator itr = m_aLayers.begin(); itr != m_aLayers.end(); ++itr)

	mov	eax, DWORD PTR [ecx+92]
	mov	ecx, DWORD PTR [ecx+96]
	cmp	eax, ecx
	je	SHORT $LN2@FindLayer
	mov	edx, DWORD PTR _uiLayerID$[esp-4]
	npad	2
$LL13@FindLayer:

; 187  : 	{
; 188  : 		if ((*itr).m_uiID == uiLayerID)

	cmp	DWORD PTR [eax], edx
	je	SHORT $LN30@FindLayer
	add	eax, 8
	cmp	eax, ecx
	jne	SHORT $LL13@FindLayer
$LN2@FindLayer:

; 191  : 		}
; 192  : 	}
; 193  : 
; 194  : 	return NULL;

	xor	eax, eax

; 195  : }

	ret	4
$LN30@FindLayer:

; 189  : 		{
; 190  : 			return (*itr).m_pkGrid;

	mov	eax, DWORD PTR [eax+4]

; 195  : }

	ret	4
?FindLayer@CvPlotManager@@IAEPAVCvSparseIDInfoGrid@@I@Z ENDP ; CvPlotManager::FindLayer
_TEXT	ENDS
PUBLIC	?FindLayer@CvPlotManager@@QBEPBVCvSparseIDInfoGrid@@I@Z ; CvPlotManager::FindLayer
; Function compile flags: /Ogtpy
;	COMDAT ?FindLayer@CvPlotManager@@QBEPBVCvSparseIDInfoGrid@@I@Z
_TEXT	SEGMENT
_uiLayerID$ = 8						; size = 4
?FindLayer@CvPlotManager@@QBEPBVCvSparseIDInfoGrid@@I@Z PROC ; CvPlotManager::FindLayer, COMDAT
; _this$ = ecx

; 200  : 	for (CvSparseIDInfoGridVector::const_iterator itr = m_aLayers.begin(); itr != m_aLayers.end(); ++itr)

	mov	eax, DWORD PTR [ecx+92]
	mov	ecx, DWORD PTR [ecx+96]
	cmp	eax, ecx
	je	SHORT $LN2@FindLayer@2
	mov	edx, DWORD PTR _uiLayerID$[esp-4]
	npad	2
$LL11@FindLayer@2:

; 201  : 	{
; 202  : 		if ((*itr).m_uiID == uiLayerID)

	cmp	DWORD PTR [eax], edx
	je	SHORT $LN26@FindLayer@2
	add	eax, 8
	cmp	eax, ecx
	jne	SHORT $LL11@FindLayer@2
$LN2@FindLayer@2:

; 205  : 		}
; 206  : 	}
; 207  : 
; 208  : 	return NULL;

	xor	eax, eax

; 209  : }

	ret	4
$LN26@FindLayer@2:

; 203  : 		{
; 204  : 			return (*itr).m_pkGrid;

	mov	eax, DWORD PTR [eax+4]

; 209  : }

	ret	4
?FindLayer@CvPlotManager@@QBEPBVCvSparseIDInfoGrid@@I@Z ENDP ; CvPlotManager::FindLayer
_TEXT	ENDS
PUBLIC	?GetUnits@CvPlotManager@@QBEABVCvIDInfoFixedVector@@HHI@Z ; CvPlotManager::GetUnits
; Function compile flags: /Ogtpy
;	COMDAT ?GetUnits@CvPlotManager@@QBEABVCvIDInfoFixedVector@@HHI@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_uiLayerID$ = 16					; size = 4
?GetUnits@CvPlotManager@@QBEABVCvIDInfoFixedVector@@HHI@Z PROC ; CvPlotManager::GetUnits, COMDAT
; _this$ = ecx

; 214  : 	if (uiLayerID != (uint)-1)

	cmp	DWORD PTR _uiLayerID$[esp-4], -1
	push	ebx
	push	ebp
	push	esi
	push	edi
	je	SHORT $LN3@GetUnits

; 215  : 	{
; 216  : 		for (CvSparseIDInfoGridVector::const_iterator itr = m_aLayers.begin(); itr != m_aLayers.end(); ++itr)

	mov	esi, DWORD PTR [ecx+92]
	mov	ebp, DWORD PTR [ecx+96]
	cmp	esi, ebp
	je	SHORT $LN3@GetUnits
	mov	edi, DWORD PTR _iY$[esp+12]
	mov	ebx, DWORD PTR _iX$[esp+12]
	npad	3
$LL13@GetUnits:

; 217  : 		{
; 218  : 			if ((*itr).m_uiID == uiLayerID)

	mov	eax, DWORD PTR _uiLayerID$[esp+12]
	cmp	DWORD PTR [esi], eax
	jne	SHORT $LN4@GetUnits

; 219  : 			{
; 220  : 				const CvIDInfoFixedVector* pkEntry = (*itr).m_pkGrid->Get(iX, iY);

	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [edx]
	imul	eax, edi
	add	eax, ebx
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $LN4@GetUnits
	mov	edx, DWORD PTR [edx+16]
	mov	eax, DWORD PTR [edx+eax*4]
	test	eax, eax
	jne	SHORT $LN7@GetUnits
$LN4@GetUnits:

; 215  : 	{
; 216  : 		for (CvSparseIDInfoGridVector::const_iterator itr = m_aLayers.begin(); itr != m_aLayers.end(); ++itr)

	add	esi, 8
	cmp	esi, ebp
	jne	SHORT $LL13@GetUnits
$LN3@GetUnits:

; 221  : 				if (pkEntry)
; 222  : 					return *pkEntry;
; 223  : 			}
; 224  : 		}
; 225  : 	}
; 226  : 
; 227  : 	return m_kEmpty;

	lea	eax, DWORD PTR [ecx+8]
$LN7@GetUnits:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 228  : }

	ret	12					; 0000000cH
?GetUnits@CvPlotManager@@QBEABVCvIDInfoFixedVector@@HHI@Z ENDP ; CvPlotManager::GetUnits
_TEXT	ENDS
PUBLIC	?RemoveUnit@CvPlotManager@@QAEXABUIDInfo@@HHI@Z	; CvPlotManager::RemoveUnit
; Function compile flags: /Ogtpy
;	COMDAT ?RemoveUnit@CvPlotManager@@QAEXABUIDInfo@@HHI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_kInfo$ = 8						; size = 4
_iX$ = 12						; size = 4
_iY$ = 16						; size = 4
_uiLayerID$ = 20					; size = 4
?RemoveUnit@CvPlotManager@@QAEXABUIDInfo@@HHI@Z PROC	; CvPlotManager::RemoveUnit, COMDAT
; _this$ = ecx

; 255  : {

	push	ecx

; 256  : #ifdef AUI_WARNING_FIXES
; 257  : 	if (uiLayerID != MAX_UNSIGNED_INT)
; 258  : #else
; 259  : 	if (uiLayerID != -1)

	mov	edx, DWORD PTR _uiLayerID$[esp]
	mov	DWORD PTR _this$[esp+4], ecx
	cmp	edx, -1
	je	SHORT $LN6@RemoveUnit

; 260  : #endif
; 261  : 	{
; 262  : 		CvSparseIDInfoGrid* pkLayer = FindLayer(uiLayerID);

	mov	eax, DWORD PTR [ecx+92]
	mov	ecx, DWORD PTR [ecx+96]
	cmp	eax, ecx
	je	$LN1@RemoveUnit
	npad	5
$LL21@RemoveUnit:
	cmp	DWORD PTR [eax], edx
	je	SHORT $LN69@RemoveUnit
	add	eax, 8
	cmp	eax, ecx
	jne	SHORT $LL21@RemoveUnit

; 276  : 		}
; 277  : 	}
; 278  : }

	pop	ecx
	ret	16					; 00000010H
$LN69@RemoveUnit:

; 260  : #endif
; 261  : 	{
; 262  : 		CvSparseIDInfoGrid* pkLayer = FindLayer(uiLayerID);

	mov	eax, DWORD PTR [eax+4]

; 263  : 		if (pkLayer)

	test	eax, eax
	je	$LN1@RemoveUnit

; 264  : 		{
; 265  : 			pkLayer->Remove(kInfo, iX, iY);

	mov	ecx, DWORD PTR _iY$[esp]
	mov	edx, DWORD PTR _iX$[esp]
	push	ecx
	mov	ecx, DWORD PTR _kInfo$[esp+4]
	push	edx
	push	ecx
	mov	ecx, eax
	call	?Remove@CvSparseIDInfoGrid@@QAEXABUIDInfo@@HH@Z ; CvSparseIDInfoGrid::Remove

; 276  : 		}
; 277  : 	}
; 278  : }

	pop	ecx
	ret	16					; 00000010H
$LN6@RemoveUnit:
	push	ebp

; 266  : 		}
; 267  : 	}
; 268  : 	else
; 269  : 	{
; 270  : #ifndef AUI_WARNING_FIXES
; 271  : 		int iIndex = 0;
; 272  : #endif
; 273  : 		for (CvSparseIDInfoGridVector::const_iterator itr = m_aLayers.begin(); itr != m_aLayers.end(); ++itr)

	mov	ebp, DWORD PTR [ecx+92]
	cmp	ebp, DWORD PTR [ecx+96]
	je	SHORT $LN73@RemoveUnit
	push	ebx
	push	esi
	push	edi
$LL43@RemoveUnit:

; 274  : 		{
; 275  : 			(*itr).GetGrid()->Remove(kInfo, iX, iY);

	mov	edi, DWORD PTR [ebp+4]
	mov	esi, DWORD PTR [edi]
	imul	esi, DWORD PTR _iY$[esp+16]
	add	esi, DWORD PTR _iX$[esp+16]
	cmp	esi, DWORD PTR [edi+8]
	jae	SHORT $LN2@RemoveUnit
	mov	edx, DWORD PTR [edi+16]
	mov	ebx, DWORD PTR [edx+esi*4]
	test	ebx, ebx
	je	SHORT $LN2@RemoveUnit
	mov	eax, DWORD PTR _kInfo$[esp+16]
	push	eax
	mov	ecx, ebx
	call	?Remove@CvIDInfoFixedVector@@QAE_NABUIDInfo@@@Z ; CvIDInfoFixedVector::Remove
	test	al, al
	je	SHORT $LN72@RemoveUnit
	cmp	DWORD PTR [ebx+4], 0
	jne	SHORT $LN72@RemoveUnit
	mov	ecx, DWORD PTR [edi+20]
	push	ebx
	call	?Release@?$FObjectPool@VCvIDInfoFixedVector@@@@QAEXPAVCvIDInfoFixedVector@@@Z ; FObjectPool<CvIDInfoFixedVector>::Release
	mov	ecx, DWORD PTR [edi+16]
	mov	DWORD PTR [ecx+esi*4], 0
$LN72@RemoveUnit:
	mov	ecx, DWORD PTR _this$[esp+20]
$LN2@RemoveUnit:

; 266  : 		}
; 267  : 	}
; 268  : 	else
; 269  : 	{
; 270  : #ifndef AUI_WARNING_FIXES
; 271  : 		int iIndex = 0;
; 272  : #endif
; 273  : 		for (CvSparseIDInfoGridVector::const_iterator itr = m_aLayers.begin(); itr != m_aLayers.end(); ++itr)

	add	ebp, 8
	cmp	ebp, DWORD PTR [ecx+96]
	jne	SHORT $LL43@RemoveUnit
	pop	edi
	pop	esi
	pop	ebx
$LN73@RemoveUnit:
	pop	ebp
$LN1@RemoveUnit:

; 276  : 		}
; 277  : 	}
; 278  : }

	pop	ecx
	ret	16					; 00000010H
?RemoveUnit@CvPlotManager@@QAEXABUIDInfo@@HHI@Z ENDP	; CvPlotManager::RemoveUnit
_TEXT	ENDS
PUBLIC	?GetNumUnits@CvPlotManager@@QBEHHHI@Z		; CvPlotManager::GetNumUnits
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumUnits@CvPlotManager@@QBEHHHI@Z
_TEXT	SEGMENT
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_uiLayerID$ = 16					; size = 4
?GetNumUnits@CvPlotManager@@QBEHHHI@Z PROC		; CvPlotManager::GetNumUnits, COMDAT
; _this$ = ecx

; 283  : 	const CvSparseIDInfoGrid* pkLayer = FindLayer(uiLayerID);

	mov	eax, DWORD PTR [ecx+92]
	mov	ecx, DWORD PTR [ecx+96]
	cmp	eax, ecx
	je	SHORT $LN1@GetNumUnit@2
	mov	edx, DWORD PTR _uiLayerID$[esp-4]
	npad	2
$LL15@GetNumUnit@2:
	cmp	DWORD PTR [eax], edx
	je	SHORT $LN36@GetNumUnit@2
	add	eax, 8
	cmp	eax, ecx
	jne	SHORT $LL15@GetNumUnit@2
$LN1@GetNumUnit@2:

; 289  : 	}
; 290  : 
; 291  : 	return 0;

	xor	eax, eax

; 292  : }

	ret	12					; 0000000cH
$LN36@GetNumUnit@2:

; 283  : 	const CvSparseIDInfoGrid* pkLayer = FindLayer(uiLayerID);

	mov	eax, DWORD PTR [eax+4]

; 284  : 	if (pkLayer)

	test	eax, eax
	je	SHORT $LN1@GetNumUnit@2

; 285  : 	{
; 286  : 		const CvIDInfoFixedVector* pkUnits = pkLayer->Get(iX, iY);

	mov	ecx, DWORD PTR [eax]
	imul	ecx, DWORD PTR _iY$[esp-4]
	add	ecx, DWORD PTR _iX$[esp-4]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN1@GetNumUnit@2
	mov	eax, DWORD PTR [eax+16]
	mov	ecx, DWORD PTR [eax+ecx*4]
	test	ecx, ecx

; 287  : 		if (pkUnits)

	je	SHORT $LN1@GetNumUnit@2

; 288  : 			return pkUnits->size();

	mov	eax, DWORD PTR [ecx+4]

; 292  : }

	ret	12					; 0000000cH
?GetNumUnits@CvPlotManager@@QBEHHHI@Z ENDP		; CvPlotManager::GetNumUnits
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAE_NI@Z ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Buy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAE_NI@Z PROC ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax
	push	edi

; 1104 : 		if (_Capacity == 0)

	mov	edi, DWORD PTR __Capacity$[esp+4]
	mov	esi, ecx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	cmp	edi, eax
	jne	SHORT $LN4@Buy
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	edi, 536870911				; 1fffffffH
	jbe	SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@KAXXZ ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Xlen
$LN16@Buy:
$LN2@Buy:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	edi
	call	??$_Allocate@UCvSparseIDInfoGridEntry@@@std@@YAPAUCvSparseIDInfoGridEntry@@IPAU1@@Z ; std::_Allocate<CvSparseIDInfoGridEntry>
	mov	DWORD PTR [esi+4], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+8], eax
	add	esp, 8

; 1112 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*8]
	mov	DWORD PTR [esi+12], eax
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy:
?_Buy@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Buy
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::operator+
; Function compile flags: /Ogtpy
;	COMDAT ??H?$_Vector_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::operator+, COMDAT
; _this$ = ecx

; 381  : 		_Myt _Tmp = *this;
; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], edx

; 383  : 		}

	ret	8
??H?$_Vector_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::operator+
_TEXT	ENDS
PUBLIC	__TI1H
PUBLIC	??_7?$FObjectPool@VCvIDInfoFixedVector@@@@6B@	; FObjectPool<CvIDInfoFixedVector>::`vftable'
PUBLIC	??0?$FObjectPool@VCvIDInfoFixedVector@@@@QAE@I_N@Z ; FObjectPool<CvIDInfoFixedVector>::FObjectPool<CvIDInfoFixedVector>
PUBLIC	??_R4?$FObjectPool@VCvIDInfoFixedVector@@@@6B@	; FObjectPool<CvIDInfoFixedVector>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$FObjectPool@VCvIDInfoFixedVector@@@@@8 ; FObjectPool<CvIDInfoFixedVector> `RTTI Type Descriptor'
PUBLIC	??_R3?$FObjectPool@VCvIDInfoFixedVector@@@@8	; FObjectPool<CvIDInfoFixedVector>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$FObjectPool@VCvIDInfoFixedVector@@@@8	; FObjectPool<CvIDInfoFixedVector>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$FObjectPool@VCvIDInfoFixedVector@@@@8 ; FObjectPool<CvIDInfoFixedVector>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__CTA1H
PUBLIC	__CT??_R0H@84
PUBLIC	??_R0H@8					; int `RTTI Type Descriptor'
EXTRN	??1FCriticalSection@@QAE@XZ:PROC		; FCriticalSection::~FCriticalSection
EXTRN	??0FCriticalSection@@QAE@XZ:PROC		; FCriticalSection::FCriticalSection
EXTRN	??_E?$FObjectPool@VCvIDInfoFixedVector@@@@UAEPAXI@Z:PROC ; FObjectPool<CvIDInfoFixedVector>::`vector deleting destructor'
;	COMDAT ??_R0H@8
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
_DATA	SEGMENT
??_R0H@8 DD	FLAT:??_7type_info@@6B@			; int `RTTI Type Descriptor'
	DD	00H
	DB	'.H', 00H
_DATA	ENDS
;	COMDAT __CT??_R0H@84
xdata$x	SEGMENT
__CT??_R0H@84 DD 01H
	DD	FLAT:??_R0H@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT __CTA1H
xdata$x	SEGMENT
__CTA1H	DD	01H
	DD	FLAT:__CT??_R0H@84
xdata$x	ENDS
;	COMDAT ??_R1A@?0A@EA@?$FObjectPool@VCvIDInfoFixedVector@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$FObjectPool@VCvIDInfoFixedVector@@@@8 DD FLAT:??_R0?AV?$FObjectPool@VCvIDInfoFixedVector@@@@@8 ; FObjectPool<CvIDInfoFixedVector>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$FObjectPool@VCvIDInfoFixedVector@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$FObjectPool@VCvIDInfoFixedVector@@@@8
rdata$r	SEGMENT
??_R2?$FObjectPool@VCvIDInfoFixedVector@@@@8 DD FLAT:??_R1A@?0A@EA@?$FObjectPool@VCvIDInfoFixedVector@@@@8 ; FObjectPool<CvIDInfoFixedVector>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$FObjectPool@VCvIDInfoFixedVector@@@@8
rdata$r	SEGMENT
??_R3?$FObjectPool@VCvIDInfoFixedVector@@@@8 DD 00H	; FObjectPool<CvIDInfoFixedVector>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$FObjectPool@VCvIDInfoFixedVector@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$FObjectPool@VCvIDInfoFixedVector@@@@@8
_DATA	SEGMENT
??_R0?AV?$FObjectPool@VCvIDInfoFixedVector@@@@@8 DD FLAT:??_7type_info@@6B@ ; FObjectPool<CvIDInfoFixedVector> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$FObjectPool@VCvIDInfoFixedVector@@@@', 00H
_DATA	ENDS
;	COMDAT ??_R4?$FObjectPool@VCvIDInfoFixedVector@@@@6B@
rdata$r	SEGMENT
??_R4?$FObjectPool@VCvIDInfoFixedVector@@@@6B@ DD 00H	; FObjectPool<CvIDInfoFixedVector>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$FObjectPool@VCvIDInfoFixedVector@@@@@8
	DD	FLAT:??_R3?$FObjectPool@VCvIDInfoFixedVector@@@@8
rdata$r	ENDS
;	COMDAT __TI1H
xdata$x	SEGMENT
__TI1H	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA1H
xdata$x	ENDS
;	COMDAT ??_7?$FObjectPool@VCvIDInfoFixedVector@@@@6B@
CONST	SEGMENT
??_7?$FObjectPool@VCvIDInfoFixedVector@@@@6B@ DD FLAT:??_R4?$FObjectPool@VCvIDInfoFixedVector@@@@6B@ ; FObjectPool<CvIDInfoFixedVector>::`vftable'
	DD	FLAT:??_E?$FObjectPool@VCvIDInfoFixedVector@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$FObjectPool@VCvIDInfoFixedVector@@@@QAE@I_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$FObjectPool@VCvIDInfoFixedVector@@@@QAE@I_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$FObjectPool@VCvIDInfoFixedVector@@@@QAE@I_N@Z$1
__ehfuncinfo$??0?$FObjectPool@VCvIDInfoFixedVector@@@@QAE@I_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$FObjectPool@VCvIDInfoFixedVector@@@@QAE@I_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjectpool.h
xdata$x	ENDS
;	COMDAT ??0?$FObjectPool@VCvIDInfoFixedVector@@@@QAE@I_N@Z
_TEXT	SEGMENT
$T219581 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_uiSize$ = 8						; size = 4
$T219579 = 12						; size = 4
_bGrow$ = 12						; size = 1
??0?$FObjectPool@VCvIDInfoFixedVector@@@@QAE@I_N@Z PROC	; FObjectPool<CvIDInfoFixedVector>::FObjectPool<CvIDInfoFixedVector>, COMDAT
; _this$ = ecx

; 95   : {

	push	-1
	push	__ehhandler$??0?$FObjectPool@VCvIDInfoFixedVector@@@@QAE@I_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR _this$[esp+32], esi
	mov	DWORD PTR [esi], OFFSET ??_7?$FObjectPool@VCvIDInfoFixedVector@@@@6B@
	call	??0FCriticalSection@@QAE@XZ		; FCriticalSection::FCriticalSection

; 96   : 	// Allocate the array memory
; 97   : 	m_pStorage = FNEW( FPoolNode[uiSize], c_eMPoolTypeContainer, 0 );

	mov	ebp, DWORD PTR _uiSize$[esp+28]
	xor	ecx, ecx
	xor	ebx, ebx
	mov	eax, ebp
	mov	edx, 8
	mul	edx
	seto	cl
	mov	DWORD PTR __$EHRec$[esp+40], ebx
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR [esi+4], eax

; 98   : 
; 99   : 	#ifndef		_NDS
; 100  : 	if (!m_pStorage)

	cmp	eax, ebx
	jne	SHORT $LN4@FObjectPoo

; 101  : 		throw(-1);

	push	OFFSET __TI1H
	lea	eax, DWORD PTR $T219579[esp+32]
	push	eax
	mov	DWORD PTR $T219579[esp+36], -1
	call	__CxxThrowException@8
$LN26@FObjectPoo:
$LN4@FObjectPoo:
	push	edi

; 102  : 	#endif	//	!_NDS
; 103  : 
; 104  : 	// Now pre-allocated each object in that array
; 105  : 	for (uint i = 0; i < uiSize; ++i)

	xor	edi, edi
	cmp	ebp, ebx
	jbe	SHORT $LN1@FObjectPoo
	npad	7
$LL3@FObjectPoo:

; 106  : 	{
; 107  : 		m_pStorage[i].pObject = FNEW( T, c_eMPoolTypeContainer, 0 );

	push	80					; 00000050H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	cmp	eax, ebx
	je	SHORT $LN7@FObjectPoo
	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], 8
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN8@FObjectPoo
$LN7@FObjectPoo:
	xor	eax, eax
$LN8@FObjectPoo:
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+edi*8], eax

; 108  : 		m_pStorage[i].bFree = true;

	mov	edx, DWORD PTR [esi+4]
	mov	BYTE PTR [edx+edi*8+4], 1
	inc	edi
	mov	BYTE PTR __$EHRec$[esp+44], bl
	cmp	edi, ebp
	jb	SHORT $LL3@FObjectPoo
$LN1@FObjectPoo:

; 109  : 	}
; 110  : 
; 111  : 	m_uiSize = uiSize;
; 112  : 	m_bGrow = bGrow;

	mov	al, BYTE PTR _bGrow$[esp+32]

; 113  : 	m_bFull = false;
; 114  : 	m_uiFirstFreeIndex = 0;
; 115  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	mov	BYTE PTR [esi+36], al
	pop	edi
	mov	DWORD PTR [esi+32], ebp
	mov	BYTE PTR [esi+37], bl
	mov	DWORD PTR [esi+40], ebx
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	8
$LN25@FObjectPoo:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$FObjectPool@VCvIDInfoFixedVector@@@@QAE@I_N@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1FCriticalSection@@QAE@XZ		; FCriticalSection::~FCriticalSection
__unwindfunclet$??0?$FObjectPool@VCvIDInfoFixedVector@@@@QAE@I_N@Z$1:
	mov	eax, DWORD PTR $T219581[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$??0?$FObjectPool@VCvIDInfoFixedVector@@@@QAE@I_N@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$FObjectPool@VCvIDInfoFixedVector@@@@QAE@I_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$FObjectPool@VCvIDInfoFixedVector@@@@QAE@I_N@Z ENDP	; FObjectPool<CvIDInfoFixedVector>::FObjectPool<CvIDInfoFixedVector>
PUBLIC	?GetFreeObject@?$FObjectPool@VCvIDInfoFixedVector@@@@QAEPAVCvIDInfoFixedVector@@XZ ; FObjectPool<CvIDInfoFixedVector>::GetFreeObject
EXTRN	__imp__memmove:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetFreeObject@?$FObjectPool@VCvIDInfoFixedVector@@@@QAEPAVCvIDInfoFixedVector@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetFreeObject@?$FObjectPool@VCvIDInfoFixedVector@@@@QAEPAVCvIDInfoFixedVector@@XZ$0
__ehfuncinfo$?GetFreeObject@?$FObjectPool@VCvIDInfoFixedVector@@@@QAEPAVCvIDInfoFixedVector@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetFreeObject@?$FObjectPool@VCvIDInfoFixedVector@@@@QAEPAVCvIDInfoFixedVector@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?GetFreeObject@?$FObjectPool@VCvIDInfoFixedVector@@@@QAEPAVCvIDInfoFixedVector@@XZ
_TEXT	SEGMENT
$T219635 = -24						; size = 4
$T219633 = -20						; size = 4
_pReturnObj$ = -20					; size = 4
tv288 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?GetFreeObject@?$FObjectPool@VCvIDInfoFixedVector@@@@QAEPAVCvIDInfoFixedVector@@XZ PROC ; FObjectPool<CvIDInfoFixedVector>::GetFreeObject, COMDAT
; _this$ = ecx

; 228  : {

	push	-1
	push	__ehhandler$?GetFreeObject@?$FObjectPool@VCvIDInfoFixedVector@@@@QAEPAVCvIDInfoFixedVector@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 229  : 	Lock();

	lea	ebp, DWORD PTR [esi+8]
	push	edi
	mov	ecx, ebp
	mov	DWORD PTR tv288[esp+40], ebp
	call	?Enter@FCriticalSection@@QAEXXZ		; FCriticalSection::Enter

; 230  : 
; 231  : 	T* pReturnObj = NULL;

	xor	ebx, ebx
	mov	DWORD PTR _pReturnObj$[esp+40], ebx

; 232  : 
; 233  : 	// Do we have any allocated objects not being used?
; 234  : 	if (m_bFull)

	cmp	BYTE PTR [esi+37], bl
	je	$LN45@GetFreeObj

; 235  : 	{
; 236  : 		// If we have no available objects, see if we should grow
; 237  : 		if (m_bGrow)

	cmp	BYTE PTR [esi+36], bl
	je	$LN6@GetFreeObj

; 238  : 		{
; 239  : 			// We want to grow - double the size of the storage and pre-allocate all the objects
; 240  : 			// (This is where we eat it to save time later)
; 241  : 			FPoolNode *pOldStorage = m_pStorage;
; 242  : 			m_pStorage = FNEW( FPoolNode[ m_uiSize * 2 ], c_eMPoolTypeFireWorks, 0);

	mov	eax, DWORD PTR [esi+32]
	mov	edi, DWORD PTR [esi+4]
	xor	ecx, ecx
	add	eax, eax
	mov	edx, 8
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 243  : 			memmove( m_pStorage, pOldStorage, sizeof( FPoolNode ) * m_uiSize );

	mov	ecx, DWORD PTR [esi+32]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edi
	push	eax
	mov	DWORD PTR [esi+4], eax
	call	DWORD PTR __imp__memmove

; 244  : 			SAFE_DELETE_ARRAY( pOldStorage );

	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 20					; 00000014H

; 245  : 
; 246  : 			// If we get a memory error, bad bad things will happen.  Just bail
; 247  : 			#ifndef		_NDS
; 248  : 			if (!m_pStorage)

	cmp	DWORD PTR [esi+4], ebx
	jne	SHORT $LN5@GetFreeObj

; 249  : 				throw(-1);

	push	OFFSET __TI1H
	lea	edx, DWORD PTR $T219633[esp+44]
	push	edx
	mov	DWORD PTR $T219633[esp+48], -1
	call	__CxxThrowException@8
$LN46@GetFreeObj:
$LN5@GetFreeObj:

; 250  : 			#endif	//	!_NDS
; 251  : 
; 252  : 			// Pre-allocate and set each object in the array
; 253  : 			for (uint i = m_uiSize; i < (2*m_uiSize); ++i)

	mov	edi, DWORD PTR [esi+32]
	lea	eax, DWORD PTR [edi+edi]
	cmp	edi, eax
	jae	SHORT $LN2@GetFreeObj
	or	ebp, -1
	npad	7
$LL4@GetFreeObj:

; 254  : 			{
; 255  : 				m_pStorage[i].pObject = FNEW( T, c_eMPoolTypeContainer, 0 );

	push	80					; 00000050H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	cmp	eax, ebx
	je	SHORT $LN10@GetFreeObj
	lea	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+4], ebx
	mov	DWORD PTR [eax+8], 8
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN11@GetFreeObj
$LN10@GetFreeObj:
	xor	eax, eax
$LN11@GetFreeObj:
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+edi*8], eax

; 256  : 				m_pStorage[i].bFree = true;

	mov	edx, DWORD PTR [esi+4]
	mov	BYTE PTR [edx+edi*8+4], 1
	mov	eax, DWORD PTR [esi+32]
	inc	edi
	add	eax, eax
	mov	DWORD PTR __$EHRec$[esp+48], ebp
	cmp	edi, eax
	jb	SHORT $LL4@GetFreeObj

; 250  : 			#endif	//	!_NDS
; 251  : 
; 252  : 			// Pre-allocate and set each object in the array
; 253  : 			for (uint i = m_uiSize; i < (2*m_uiSize); ++i)

	mov	ebp, DWORD PTR tv288[esp+40]
$LN2@GetFreeObj:

; 257  : 			}
; 258  : 
; 259  : 			m_uiFirstFreeIndex = m_uiSize;

	mov	eax, DWORD PTR [esi+32]

; 260  : 			m_uiSize *= 2;

	lea	ecx, DWORD PTR [eax+eax]
	mov	DWORD PTR [esi+40], eax
	mov	DWORD PTR [esi+32], ecx

; 261  : 			m_bFull = false;

	mov	BYTE PTR [esi+37], bl
$LN6@GetFreeObj:

; 262  : 		}
; 263  : 	}
; 264  : 
; 265  : 	// If we have free objects, give one to the caller
; 266  : 	if (!m_bFull)

	cmp	BYTE PTR [esi+37], bl
	jne	SHORT $LN41@GetFreeObj
$LN45@GetFreeObj:

; 267  : 	{
; 268  : 		// Set the free pointer
; 269  : 		pReturnObj = m_pStorage[m_uiFirstFreeIndex].pObject;

	mov	edx, DWORD PTR [esi+40]
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+edx*8]
	lea	eax, DWORD PTR [eax+edx*8]

; 270  : 		m_pStorage[m_uiFirstFreeIndex].bFree = false;

	mov	BYTE PTR [eax+4], bl

; 271  : 
; 272  : 		m_uiFirstFreeIndex = GetNextFreeIndex();

	mov	edx, DWORD PTR [esi+40]
	mov	DWORD PTR _pReturnObj$[esp+40], ecx
	mov	BYTE PTR [esi+37], 1
	cmp	edx, DWORD PTR [esi+32]
	jae	SHORT $LN41@GetFreeObj
	mov	ecx, DWORD PTR [esi+4]
$LL31@GetFreeObj:
	mov	eax, DWORD PTR [esi+40]
	cmp	BYTE PTR [ecx+eax*8+4], bl
	jne	SHORT $LN38@GetFreeObj
	inc	eax
	mov	DWORD PTR [esi+40], eax
	cmp	eax, DWORD PTR [esi+32]
	jb	SHORT $LL31@GetFreeObj
	jmp	SHORT $LN41@GetFreeObj
$LN38@GetFreeObj:
	mov	BYTE PTR [esi+37], bl
$LN41@GetFreeObj:

; 273  : 	}
; 274  : 
; 275  : 	Unlock();

	mov	ecx, ebp
	call	?Leave@FCriticalSection@@QAEXXZ		; FCriticalSection::Leave

; 276  : 
; 277  : 	return pReturnObj;
; 278  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	eax, DWORD PTR _pReturnObj$[esp+40]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 24					; 00000018H
	ret	0
$LN43@GetFreeObj:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetFreeObject@?$FObjectPool@VCvIDInfoFixedVector@@@@QAEPAVCvIDInfoFixedVector@@XZ$0:
	mov	eax, DWORD PTR $T219635[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?GetFreeObject@?$FObjectPool@VCvIDInfoFixedVector@@@@QAEPAVCvIDInfoFixedVector@@XZ:
	mov	eax, OFFSET __ehfuncinfo$?GetFreeObject@?$FObjectPool@VCvIDInfoFixedVector@@@@QAEPAVCvIDInfoFixedVector@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetFreeObject@?$FObjectPool@VCvIDInfoFixedVector@@@@QAEPAVCvIDInfoFixedVector@@XZ ENDP ; FObjectPool<CvIDInfoFixedVector>::GetFreeObject
PUBLIC	??$_Unchecked_move_backward@PAUCvSparseIDInfoGridEntry@@PAU1@@stdext@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00@Z ; stdext::_Unchecked_move_backward<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Unchecked_move_backward@PAUCvSparseIDInfoGridEntry@@PAU1@@stdext@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAUCvSparseIDInfoGridEntry@@PAU1@@stdext@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00@Z PROC ; stdext::_Unchecked_move_backward<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *>, COMDAT

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Last$[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	edx, ecx
	je	SHORT $LN11@Unchecked_
	push	esi
$LL12@Unchecked_:
	mov	esi, DWORD PTR [ecx-8]
	sub	ecx, 8
	sub	eax, 8
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	cmp	ecx, edx
	jne	SHORT $LL12@Unchecked_
	pop	esi
$LN11@Unchecked_:

; 3697 : 	}

	ret	0
??$_Unchecked_move_backward@PAUCvSparseIDInfoGridEntry@@PAU1@@stdext@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00@Z ENDP ; stdext::_Unchecked_move_backward<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *>
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAUCvSparseIDInfoGridEntry@@IU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAXPAUCvSparseIDInfoGridEntry@@IABU1@AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvSparseIDInfoGridEntry *,unsigned int,CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAUCvSparseIDInfoGridEntry@@IU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAXPAUCvSparseIDInfoGridEntry@@IABU1@AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAUCvSparseIDInfoGridEntry@@IU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAXPAUCvSparseIDInfoGridEntry@@IABU1@AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<CvSparseIDInfoGridEntry *,unsigned int,CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >, COMDAT

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;
; 401  : 
; 402  : 	_TRY_BEGIN
; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	mov	ecx, DWORD PTR __Count$[esp-4]
	test	ecx, ecx
	jbe	SHORT $LN4@Uninit_fil
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	eax, DWORD PTR __First$[esp-4]
	push	esi
$LL6@Uninit_fil:

; 404  : 		_Al.construct(_First, _Val);

	test	eax, eax
	je	SHORT $LN5@Uninit_fil
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi
$LN5@Uninit_fil:
	dec	ecx
	add	eax, 8
	test	ecx, ecx
	ja	SHORT $LL6@Uninit_fil
	pop	esi
$LN4@Uninit_fil:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)
; 407  : 		_Al.destroy(_Next);
; 408  : 	_RERAISE;
; 409  : 	_CATCH_END
; 410  : 	}

	ret	0
??$_Uninit_fill_n@PAUCvSparseIDInfoGridEntry@@IU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAXPAUCvSparseIDInfoGridEntry@@IABU1@AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<CvSparseIDInfoGridEntry *,unsigned int,CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAXPAUCvSparseIDInfoGridEntry@@0AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CvSparseIDInfoGridEntry> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAXPAUCvSparseIDInfoGridEntry@@0AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAXPAUCvSparseIDInfoGridEntry@@0AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CvSparseIDInfoGridEntry> >, COMDAT

; 233  : 	for (; _First != _Last; ++_First)
; 234  : 		_Al.destroy(_First);
; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAXPAUCvSparseIDInfoGridEntry@@0AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvSparseIDInfoGridEntry> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@stdext@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@std@@@Z ; stdext::unchecked_uninitialized_copy<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *,std::allocator<CvSparseIDInfoGridEntry> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@stdext@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@std@@@Z
_TEXT	SEGMENT
$T219801 = -4						; size = 1
__Cat$219806 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@stdext@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *,std::allocator<CvSparseIDInfoGridEntry> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T219801[esp+4], 0
	mov	eax, DWORD PTR $T219801[esp+4]
	mov	ecx, DWORD PTR __Cat$219806[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *,std::allocator<CvSparseIDInfoGridEntry> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@stdext@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *,std::allocator<CvSparseIDInfoGridEntry> >
_TEXT	ENDS
PUBLIC	?GrowSize@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<IDInfo,8,1,297,0>::GrowSize
EXTRN	_memcpy:PROC
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?GrowSize@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEXI@Z
_TEXT	SEGMENT
_uiFit$ = 8						; size = 4
?GrowSize@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEXI@Z PROC ; FStaticVector<IDInfo,8,1,297,0>::GrowSize, COMDAT
; _this$ = ecx

; 744  : 	{

	push	esi
	mov	esi, ecx

; 745  : 		if( m_uiCurrMaxSize == 0 ) m_uiCurrMaxSize = 1;

	cmp	DWORD PTR [esi+8], 0
	push	edi
	jne	SHORT $LN30@GrowSize
	mov	DWORD PTR [esi+8], 1
$LN30@GrowSize:

; 746  : 		while( uiFit >= m_uiCurrMaxSize ){

	mov	edx, DWORD PTR _uiFit$[esp+4]
	cmp	edx, DWORD PTR [esi+8]
	jb	SHORT $LN7@GrowSize
	npad	6
$LL8@GrowSize:

; 747  : 
; 748  : 			//Try to double size...
; 749  : 			UINT uiNewSize = m_uiCurrMaxSize<<1;

	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR [eax+eax]

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	cmp	ecx, eax
	jb	SHORT $LN31@GrowSize

; 754  : 				break;
; 755  : 			}
; 756  : 
; 757  : 			//...otherwise use the doubled size
; 758  : 			m_uiCurrMaxSize = uiNewSize;

	mov	DWORD PTR [esi+8], ecx
	cmp	edx, ecx
	jae	SHORT $LL8@GrowSize

; 750  : 
; 751  : 			//...on overflow bail and set to exact size
; 752  : 			if( uiNewSize < m_uiCurrMaxSize ){

	jmp	SHORT $LN7@GrowSize
$LN31@GrowSize:

; 753  : 				m_uiCurrMaxSize = uiFit;

	mov	DWORD PTR [esi+8], edx
$LN7@GrowSize:
	push	ebp

; 759  : 		}
; 760  : 
; 761  : 		T* pTemp = Alloc(m_uiCurrMaxSize);

	mov	ebp, DWORD PTR [esi+8]
	cmp	ebp, 8
	jbe	SHORT $LN15@GrowSize
	push	798					; 0000031eH
	push	OFFSET ??_C@_0HM@IMGGMCHG@c?3?2users?2enormousapplepie?2deskto@
	lea	eax, DWORD PTR [ebp*8]
	push	4
	push	eax
	call	?FireMallocAlignedNoTracking@@YAPAXIIPBDH@Z ; FireMallocAlignedNoTracking
	add	esp, 16					; 00000010H
	mov	edi, eax
	mov	DWORD PTR [esi+8], ebp
	jmp	SHORT $LN14@GrowSize
$LN15@GrowSize:
	lea	edi, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+8], 8
$LN14@GrowSize:

; 762  : 		if( bPODType ){
; 763  : 			memcpy( (void*)pTemp, (void*)m_pData, sizeof(T)*m_uiCurrSize);

	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [esi]
	add	ecx, ecx
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	edi
	call	_memcpy

; 764  : 		}else{
; 765  : 			for(unsigned int i = 0; i < m_uiCurrSize; ++i)
; 766  : 				new( (void*)&(pTemp[i]) )T( m_pData[i]);
; 767  : 		}
; 768  : 		Free(m_pData, m_uiCurrSize);

	mov	eax, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR [esi+12]
	pop	ebp
	cmp	eax, ecx
	je	SHORT $LN33@GrowSize
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN33@GrowSize:

; 769  : 		m_pData = pTemp;

	mov	DWORD PTR [esi], edi
	pop	edi

; 770  : 
; 771  : 		m_bIsResized = true;

	mov	BYTE PTR [esi+76], 1
	pop	esi

; 772  : 	};

	ret	4
?GrowSize@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEXI@Z ENDP ; FStaticVector<IDInfo,8,1,297,0>::GrowSize
_TEXT	ENDS
PUBLIC	??1CvIDInfoFixedVector@@QAE@XZ			; CvIDInfoFixedVector::~CvIDInfoFixedVector
; Function compile flags: /Ogtpy
;	COMDAT ??1CvIDInfoFixedVector@@QAE@XZ
_TEXT	SEGMENT
??1CvIDInfoFixedVector@@QAE@XZ PROC			; CvIDInfoFixedVector::~CvIDInfoFixedVector, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR [ecx]
	add	ecx, 12					; 0000000cH
	cmp	eax, ecx
	je	SHORT $LN6@CvIDInfoFi
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	pop	ecx
$LN6@CvIDInfoFi:
	ret	0
??1CvIDInfoFixedVector@@QAE@XZ ENDP			; CvIDInfoFixedVector::~CvIDInfoFixedVector
_TEXT	ENDS
PUBLIC	??0?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE@XZ ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	mov	eax, ecx

; 471  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 472  : 		}

	ret	0
??0?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAUCvSparseIDInfoGridEntry@@IU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@stdext@@YAXPAUCvSparseIDInfoGridEntry@@IABU1@AAV?$allocator@UCvSparseIDInfoGridEntry@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<CvSparseIDInfoGridEntry *,unsigned int,CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAUCvSparseIDInfoGridEntry@@IU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@stdext@@YAXPAUCvSparseIDInfoGridEntry@@IABU1@AAV?$allocator@UCvSparseIDInfoGridEntry@@@std@@@Z
_TEXT	SEGMENT
$T220000 = -4						; size = 1
__Cat$220005 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAUCvSparseIDInfoGridEntry@@IU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@stdext@@YAXPAUCvSparseIDInfoGridEntry@@IABU1@AAV?$allocator@UCvSparseIDInfoGridEntry@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<CvSparseIDInfoGridEntry *,unsigned int,CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T220000[esp+4], 0
	mov	eax, DWORD PTR $T220000[esp+4]
	mov	ecx, DWORD PTR __Cat$220005[esp+4]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_fill_n@PAUCvSparseIDInfoGridEntry@@IU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAXPAUCvSparseIDInfoGridEntry@@IABU1@AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvSparseIDInfoGridEntry *,unsigned int,CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >

; 943  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_fill_n@PAUCvSparseIDInfoGridEntry@@IU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@stdext@@YAXPAUCvSparseIDInfoGridEntry@@IABU1@AAV?$allocator@UCvSparseIDInfoGridEntry@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<CvSparseIDInfoGridEntry *,unsigned int,CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAXPAUCvSparseIDInfoGridEntry@@0AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@@Z ; std::_Destroy_range<std::allocator<CvSparseIDInfoGridEntry> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAXPAUCvSparseIDInfoGridEntry@@0AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAXPAUCvSparseIDInfoGridEntry@@0AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CvSparseIDInfoGridEntry> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAXPAUCvSparseIDInfoGridEntry@@0AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CvSparseIDInfoGridEntry> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@U_Undefined_move_tag@3@@std@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *,std::allocator<CvSparseIDInfoGridEntry>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@U_Undefined_move_tag@3@@std@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T220025 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$220029 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@U_Undefined_move_tag@3@@std@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *,std::allocator<CvSparseIDInfoGridEntry>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$220029[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T220025[esp+4], 0
	mov	eax, DWORD PTR $T220025[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *,std::allocator<CvSparseIDInfoGridEntry> >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@U_Undefined_move_tag@3@@std@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *,std::allocator<CvSparseIDInfoGridEntry>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	?push_back@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAEIABUIDInfo@@@Z ; FStaticVector<IDInfo,8,1,297,0>::push_back
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
;	COMDAT ?push_back@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAEIABUIDInfo@@@Z
_TEXT	SEGMENT
_element$ = 8						; size = 4
?push_back@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAEIABUIDInfo@@@Z PROC ; FStaticVector<IDInfo,8,1,297,0>::push_back, COMDAT
; _this$ = ecx

; 676  : 	unsigned int push_back(const T& element){

	push	esi
	mov	esi, ecx

; 677  : 		m_bIsResized = false;
; 678  : 		if( m_uiCurrSize == m_uiCurrMaxSize )

	mov	eax, DWORD PTR [esi+8]
	mov	BYTE PTR [esi+76], 0
	cmp	DWORD PTR [esi+4], eax
	jne	SHORT $LN1@push_back

; 679  : 			GrowSize(m_uiCurrMaxSize);

	push	eax
	call	?GrowSize@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@IAEXI@Z ; FStaticVector<IDInfo,8,1,297,0>::GrowSize
$LN1@push_back:

; 680  : 		new( (void*)&m_pData[m_uiCurrSize] )T(element);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN4@push_back
	mov	ecx, DWORD PTR _element$[esp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ecx
$LN4@push_back:

; 681  : 		return m_uiCurrSize++;

	mov	eax, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [esi+4], edx
	pop	esi

; 682  : 	};

	ret	4
?push_back@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAEIABUIDInfo@@@Z ENDP ; FStaticVector<IDInfo,8,1,297,0>::push_back
_TEXT	ENDS
PUBLIC	??_GCvIDInfoFixedVector@@QAEPAXI@Z		; CvIDInfoFixedVector::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvIDInfoFixedVector@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvIDInfoFixedVector@@QAEPAXI@Z PROC			; CvIDInfoFixedVector::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [esi+12]
	cmp	eax, ecx
	je	SHORT $LN9@scalar@4
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN9@scalar@4:
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN21@scalar@4
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN21@scalar@4:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvIDInfoFixedVector@@QAEPAXI@Z ENDP			; CvIDInfoFixedVector::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?Add@CvSparseIDInfoGrid@@QAE_NABUIDInfo@@HH@Z	; CvSparseIDInfoGrid::Add
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvplotmanager.cpp
;	COMDAT ?Add@CvSparseIDInfoGrid@@QAE_NABUIDInfo@@HH@Z
_TEXT	SEGMENT
_kInfo$ = 8						; size = 4
_iX$ = 12						; size = 4
_iY$ = 16						; size = 4
?Add@CvSparseIDInfoGrid@@QAE_NABUIDInfo@@HH@Z PROC	; CvSparseIDInfoGrid::Add, COMDAT
; _this$ = ecx

; 62   : {

	push	esi
	push	edi
	mov	edi, ecx

; 63   : 	uint uiIndex = ((uint) iY * m_uiWidth) + (uint) iX;

	mov	esi, DWORD PTR [edi]
	imul	esi, DWORD PTR _iY$[esp+4]
	add	esi, DWORD PTR _iX$[esp+4]

; 64   : 	if (uiIndex < m_uiMaxIndex)

	cmp	esi, DWORD PTR [edi+8]
	jae	SHORT $LN3@Add

; 65   : 	{
; 66   : 		CvIDInfoFixedVector* pkEntry = m_paEntries[uiIndex];

	mov	eax, DWORD PTR [edi+16]
	mov	eax, DWORD PTR [eax+esi*4]

; 67   : 		if (!pkEntry)

	test	eax, eax
	jne	SHORT $LN2@Add

; 68   : 		{
; 69   : 			pkEntry = m_pkAllocator->GetFreeObject();

	mov	ecx, DWORD PTR [edi+20]
	call	?GetFreeObject@?$FObjectPool@VCvIDInfoFixedVector@@@@QAEPAVCvIDInfoFixedVector@@XZ ; FObjectPool<CvIDInfoFixedVector>::GetFreeObject

; 70   : 			m_paEntries[uiIndex] = pkEntry;

	mov	ecx, DWORD PTR [edi+16]
	mov	DWORD PTR [ecx+esi*4], eax
$LN2@Add:

; 71   : 		}
; 72   : 
; 73   : 		if (pkEntry->Find(kInfo) == NULL)

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+4]
	mov	esi, DWORD PTR _kInfo$[esp+4]
	lea	ecx, DWORD PTR [edx+ecx*8]
	push	ebx
	cmp	edx, ecx
	je	SHORT $LN24@Add
	mov	edi, DWORD PTR [esi]
	npad	1
$LL9@Add:
	cmp	DWORD PTR [edx], edi
	jne	SHORT $LN18@Add
	mov	ebx, DWORD PTR [edx+4]
	cmp	ebx, DWORD PTR [esi+4]
	je	SHORT $LN1@Add
$LN18@Add:
	add	edx, 8
	cmp	edx, ecx
	jne	SHORT $LL9@Add
$LN24@Add:

; 74   : 		{
; 75   : 			pkEntry->push_back(kInfo);

	push	esi
	mov	ecx, eax
	call	?push_back@?$FStaticVector@UIDInfo@@$07$00$0BCJ@$0A@@@QAEIABUIDInfo@@@Z ; FStaticVector<IDInfo,8,1,297,0>::push_back
$LN1@Add:
	pop	ebx
	pop	edi

; 76   : 		}
; 77   : 		return true;

	mov	al, 1
	pop	esi

; 81   : }

	ret	12					; 0000000cH
$LN3@Add:
	pop	edi

; 78   : 	}
; 79   : 
; 80   : 	return false;

	xor	al, al
	pop	esi

; 81   : }

	ret	12					; 0000000cH
?Add@CvSparseIDInfoGrid@@QAE_NABUIDInfo@@HH@Z ENDP	; CvSparseIDInfoGrid::Add
_TEXT	ENDS
PUBLIC	?_Ufill@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEPAUCvSparseIDInfoGridEntry@@PAU3@IABU3@@Z ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Ufill
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Ufill@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEPAUCvSparseIDInfoGridEntry@@PAU3@IABU3@@Z
_TEXT	SEGMENT
$T220159 = -4						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Cat$220162 = 16					; size = 1
__Val$ = 16						; size = 4
?_Ufill@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEPAUCvSparseIDInfoGridEntry@@PAU3@IABU3@@Z PROC ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	edx, DWORD PTR __Cat$220162[esp]
	push	esi
	mov	esi, DWORD PTR __Count$[esp+4]
	push	edi
	mov	edi, DWORD PTR __Ptr$[esp+8]
	mov	BYTE PTR $T220159[esp+12], 0
	mov	eax, DWORD PTR $T220159[esp+12]
	push	eax
	mov	eax, DWORD PTR __Val$[esp+12]
	push	edx
	push	ecx
	push	eax
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAUCvSparseIDInfoGridEntry@@IU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAXPAUCvSparseIDInfoGridEntry@@IABU1@AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvSparseIDInfoGridEntry *,unsigned int,CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >
	add	esp, 24					; 00000018H

; 1255 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*8]
	pop	edi
	pop	esi

; 1256 : 		}

	pop	ecx
	ret	12					; 0000000cH
?_Ufill@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEPAUCvSparseIDInfoGridEntry@@PAU3@IABU3@@Z ENDP ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Ufill
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXPAUCvSparseIDInfoGridEntry@@0@Z ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Destroy
; Function compile flags: /Ogtpy
;	COMDAT ?_Destroy@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXPAUCvSparseIDInfoGridEntry@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXPAUCvSparseIDInfoGridEntry@@0@Z PROC ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXPAUCvSparseIDInfoGridEntry@@0@Z ENDP ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@stdext@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *,std::allocator<CvSparseIDInfoGridEntry> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@stdext@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@std@@@Z
_TEXT	SEGMENT
$T220196 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$220200 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@stdext@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *,std::allocator<CvSparseIDInfoGridEntry> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$220200[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T220196[esp+4], 0
	mov	eax, DWORD PTR $T220196[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *,std::allocator<CvSparseIDInfoGridEntry> >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@stdext@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *,std::allocator<CvSparseIDInfoGridEntry> >
_TEXT	ENDS
PUBLIC	??1?$FObjectPool@VCvIDInfoFixedVector@@@@UAE@XZ	; FObjectPool<CvIDInfoFixedVector>::~FObjectPool<CvIDInfoFixedVector>
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fobjectpool.h
xdata$x	SEGMENT
__unwindtable$??1?$FObjectPool@VCvIDInfoFixedVector@@@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$FObjectPool@VCvIDInfoFixedVector@@@@UAE@XZ$0
__ehfuncinfo$??1?$FObjectPool@VCvIDInfoFixedVector@@@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FObjectPool@VCvIDInfoFixedVector@@@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1?$FObjectPool@VCvIDInfoFixedVector@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FObjectPool@VCvIDInfoFixedVector@@@@UAE@XZ PROC	; FObjectPool<CvIDInfoFixedVector>::~FObjectPool<CvIDInfoFixedVector>, COMDAT
; _this$ = ecx

; 204  : {

	push	-1
	push	__ehhandler$??1?$FObjectPool@VCvIDInfoFixedVector@@@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+28], esi
	mov	DWORD PTR [esi], OFFSET ??_7?$FObjectPool@VCvIDInfoFixedVector@@@@6B@

; 205  : 	Lock(); 

	lea	ebp, DWORD PTR [esi+8]
	xor	ebx, ebx
	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+36], ebx
	call	?Enter@FCriticalSection@@QAEXXZ		; FCriticalSection::Enter

; 206  : 
; 207  : 	// Get rid of each allocated object
; 208  : 	for (uint i = 0; i < m_uiSize; ++i)

	cmp	DWORD PTR [esi+32], ebx
	jbe	SHORT $LN2@FObjectPoo@2
	push	edi
	npad	5
$LL4@FObjectPoo@2:

; 209  : 	{
; 210  : 		if (m_pStorage[i].pObject)

	mov	eax, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [eax+ebx*8]
	test	edi, edi
	je	SHORT $LN3@FObjectPoo@2

; 211  : 			delete m_pStorage[i].pObject;

	mov	eax, DWORD PTR [edi]
	lea	ecx, DWORD PTR [edi+12]
	cmp	eax, ecx
	je	SHORT $LN20@FObjectPoo@2
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN20@FObjectPoo@2:
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN3@FObjectPoo@2:
	inc	ebx
	cmp	ebx, DWORD PTR [esi+32]
	jb	SHORT $LL4@FObjectPoo@2
	pop	edi
$LN2@FObjectPoo@2:

; 212  : 	}
; 213  : 
; 214  : 	// Get rid of the array
; 215  : 	SAFE_DELETE_ARRAY(m_pStorage);

	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 216  : 	Unlock();

	mov	ecx, ebp
	mov	DWORD PTR [esi+4], 0
	call	?Leave@FCriticalSection@@QAEXXZ		; FCriticalSection::Leave

; 217  : }

	mov	ecx, ebp
	mov	DWORD PTR __$EHRec$[esp+36], -1
	call	??1FCriticalSection@@QAE@XZ		; FCriticalSection::~FCriticalSection
	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$FObjectPool@VCvIDInfoFixedVector@@@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1FCriticalSection@@QAE@XZ		; FCriticalSection::~FCriticalSection
__ehhandler$??1?$FObjectPool@VCvIDInfoFixedVector@@@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$FObjectPool@VCvIDInfoFixedVector@@@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$FObjectPool@VCvIDInfoFixedVector@@@@UAE@XZ ENDP	; FObjectPool<CvIDInfoFixedVector>::~FObjectPool<CvIDInfoFixedVector>
; Function compile flags: /Ogtpy
;	COMDAT ??_G?$FObjectPool@VCvIDInfoFixedVector@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$FObjectPool@VCvIDInfoFixedVector@@@@UAEPAXI@Z PROC ; FObjectPool<CvIDInfoFixedVector>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1?$FObjectPool@VCvIDInfoFixedVector@@@@UAE@XZ ; FObjectPool<CvIDInfoFixedVector>::~FObjectPool<CvIDInfoFixedVector>
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@5
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@5:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$FObjectPool@VCvIDInfoFixedVector@@@@UAEPAXI@Z ENDP ; FObjectPool<CvIDInfoFixedVector>::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?erase@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@V?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@0@Z ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::erase
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?erase@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@V?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@V?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@0@Z PROC ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::erase, COMDAT
; _this$ = ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);
; 1030 : 		iterator _Last = _Make_iter(_Last_arg);
; 1031 : 
; 1032 : 		if (_First != _Last)

	mov	edx, DWORD PTR __Last_arg$[esp-4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First_arg$[esp]
	mov	DWORD PTR [eax], esi
	cmp	esi, edx
	je	SHORT $LN1@erase@2
	push	edi

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edi, DWORD PTR [ecx+8]
	cmp	edx, edi
	je	SHORT $LN26@erase@2
	push	ebx
	npad	4
$LL28@erase@2:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [esi], ebx
	mov	ebx, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], ebx
	add	edx, 8
	add	esi, 8
	cmp	edx, edi
	jne	SHORT $LL28@erase@2
	pop	ebx
$LN26@erase@2:

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);
; 1049 : 			_Mylast = _Ptr;

	mov	DWORD PTR [ecx+8], esi
	pop	edi
$LN1@erase@2:
	pop	esi

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);
; 1055 : #endif
; 1056 : 		}

	ret	12					; 0000000cH
?erase@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@V?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@0@Z ENDP ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXXZ ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Tidy
; Function compile flags: /Ogtpy
;	COMDAT ?_Tidy@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXXZ PROC ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXXZ ENDP ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Tidy
_TEXT	ENDS
PUBLIC	??$_Umove@PAUCvSparseIDInfoGridEntry@@@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEPAUCvSparseIDInfoGridEntry@@PAU2@00@Z ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Umove<CvSparseIDInfoGridEntry *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Umove@PAUCvSparseIDInfoGridEntry@@@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEPAUCvSparseIDInfoGridEntry@@PAU2@00@Z
_TEXT	SEGMENT
$T220457 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$220461 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAUCvSparseIDInfoGridEntry@@@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEPAUCvSparseIDInfoGridEntry@@PAU2@00@Z PROC ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Umove<CvSparseIDInfoGridEntry *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$220461[esp]
	mov	BYTE PTR $T220457[esp+4], 0
	mov	eax, DWORD PTR $T220457[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *,std::allocator<CvSparseIDInfoGridEntry> >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@PAUCvSparseIDInfoGridEntry@@@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEPAUCvSparseIDInfoGridEntry@@PAU2@00@Z ENDP ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Umove<CvSparseIDInfoGridEntry *>
_TEXT	ENDS
PUBLIC	??1?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE@XZ ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::~vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE@XZ PROC ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::~vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE@XZ ENDP ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::~vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAEXXZ ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAEXXZ PROC ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::clear, COMDAT
; _this$ = ecx

; 1060 : 		erase(begin(), end());

	mov	edx, DWORD PTR [ecx+4]
	push	esi
	mov	esi, DWORD PTR [ecx+8]
	cmp	edx, esi
	je	SHORT $LN15@clear
	mov	eax, esi
	cmp	esi, esi
	je	SHORT $LN40@clear
	push	edi
$LL42@clear:
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], edi
	add	eax, 8
	add	edx, 8
	cmp	eax, esi
	jne	SHORT $LL42@clear
	pop	edi
$LN40@clear:
	mov	DWORD PTR [ecx+8], edx
$LN15@clear:
	pop	esi

; 1061 : 		}

	ret	0
?clear@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAEXXZ ENDP ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::clear
_TEXT	ENDS
PUBLIC	?_Insert_n@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@IABUCvSparseIDInfoGridEntry@@@Z ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Insert_n
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@IABUCvSparseIDInfoGridEntry@@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@IABUCvSparseIDInfoGridEntry@@@Z$2
__catchsym$?_Insert_n@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@IABUCvSparseIDInfoGridEntry@@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@IABUCvSparseIDInfoGridEntry@@@Z$0
__unwindtable$?_Insert_n@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@IABUCvSparseIDInfoGridEntry@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@IABUCvSparseIDInfoGridEntry@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@IABUCvSparseIDInfoGridEntry@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@IABUCvSparseIDInfoGridEntry@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Insert_n@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@IABUCvSparseIDInfoGridEntry@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@IABUCvSparseIDInfoGridEntry@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@IABUCvSparseIDInfoGridEntry@@@Z$5
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@IABUCvSparseIDInfoGridEntry@@@Z
_TEXT	SEGMENT
__Tmp$217637 = -24					; size = 8
__Tmp$217627 = -24					; size = 8
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$220845 = 8					; size = 1
__Cat$220773 = 8					; size = 1
__Where$ = 8						; size = 4
__Newvec$217612 = 12					; size = 4
__Count$ = 12						; size = 4
tv515 = 16						; size = 4
$T220841 = 16						; size = 1
$T220769 = 16						; size = 1
__Val$ = 16						; size = 4
?_Insert_n@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@IABUCvSparseIDInfoGridEntry@@@Z PROC ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@IABUCvSparseIDInfoGridEntry@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	mov	esi, ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	test	edx, edx
	jne	SHORT $LN29@Insert_n
	xor	ecx, ecx
	jmp	SHORT $LN30@Insert_n
$LN29@Insert_n:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, edx
	sar	eax, 3
	mov	ecx, eax
$LN30@Insert_n:

; 1162 : 
; 1163 : 		if (_Count == 0)

	mov	ebx, DWORD PTR __Count$[ebp]
	test	ebx, ebx
	je	$LN1@Insert_n

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	edi, DWORD PTR [esi+8]
	mov	eax, edi
	sub	eax, edx
	sar	eax, 3
	mov	edx, 536870911				; 1fffffffH
	sub	edx, eax
	cmp	edx, ebx
	jae	SHORT $LN12@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@KAXXZ ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Xlen
$LN87@Insert_n:
$LN12@Insert_n:

; 1167 : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+ebx]
	cmp	ecx, edx
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	edi, 536870911				; 1fffffffH
	sub	edi, eax
	cmp	edi, ecx
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR __Capacity$[ebp], 0
	mov	ecx, DWORD PTR __Capacity$[ebp]
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	add	ecx, eax
	mov	DWORD PTR __Capacity$[ebp], ecx
$LN18@Insert_n:

; 1171 : 			if (_Capacity < size() + _Count)

	cmp	ecx, edx
	jae	SHORT $LN9@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	DWORD PTR __Capacity$[ebp], edx
	mov	ecx, edx
$LN9@Insert_n:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ecx
	call	??$_Allocate@UCvSparseIDInfoGridEntry@@@std@@YAPAUCvSparseIDInfoGridEntry@@IPAU1@@Z ; std::_Allocate<CvSparseIDInfoGridEntry>

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edi, DWORD PTR __Where$[ebp]
	sub	edi, DWORD PTR [esi+4]

; 1175 : 			int _Ncopied = 0;
; 1176 : 
; 1177 : 			_TRY_BEGIN
; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	add	esp, 8
	push	ecx
	sar	edi, 3
	push	ebx
	lea	edx, DWORD PTR [eax+edi*8]
	push	edx
	mov	ecx, esi
	mov	DWORD PTR __Newvec$217612[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Ufill@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEPAUCvSparseIDInfoGridEntry@@PAU3@IABU3@@Z ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Ufill

; 1179 : 			++_Ncopied;
; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Cat$220773[ebp]
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR $T220769[ebp], 0
	mov	ecx, DWORD PTR $T220769[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Newvec$217612[ebp]
	push	edx
	mov	edx, DWORD PTR __Where$[ebp]
	push	esi
	push	ecx
	push	edx
	push	eax
	call	??$_Uninit_copy@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *,std::allocator<CvSparseIDInfoGridEntry> >

; 1182 : 			++_Ncopied;
; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR [esi+8]
	add	esp, 24					; 00000018H
	mov	BYTE PTR $T220841[ebp], 0
	mov	edx, DWORD PTR $T220841[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$220845[ebp]
	push	edx
	lea	ecx, DWORD PTR [edi+ebx]
	mov	edi, DWORD PTR __Newvec$217612[ebp]
	push	esi
	lea	ecx, DWORD PTR [edi+ecx*8]
	push	ecx
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Uninit_copy@PAUCvSparseIDInfoGridEntry@@PAU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *,std::allocator<CvSparseIDInfoGridEntry> >

; 1192 : 			_CATCH_END
; 1193 : 
; 1194 : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 3
	add	esp, 24					; 00000018H
	add	ebx, ecx

; 1195 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN81@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);
; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN81@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	lea	eax, DWORD PTR [edi+edx*8]

; 1206 : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [edi+ebx*8]
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], ecx

; 1207 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], edi

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Insert_n@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@IABUCvSparseIDInfoGridEntry@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)
; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1188 : 			if (0 < _Ncopied)
; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	edx, DWORD PTR __Newvec$217612[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
__catch$?_Insert_n@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@IABUCvSparseIDInfoGridEntry@@@Z$2:

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN88@Insert_n:
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	eax, DWORD PTR __Where$[ebp]
	mov	ecx, edi
	sub	ecx, eax
	sar	ecx, 3
	cmp	ecx, ebx
	jae	SHORT $LN3@Insert_n

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$217627[ebp+4], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	ecx, DWORD PTR [ebx*8]
	mov	DWORD PTR tv515[ebp], ecx
	add	ecx, eax
	push	ecx
	push	edi
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __Tmp$217627[ebp], edx
	call	??$_Umove@PAUCvSparseIDInfoGridEntry@@@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEPAUCvSparseIDInfoGridEntry@@PAU2@00@Z ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Umove<CvSparseIDInfoGridEntry *>

; 1215 : 
; 1216 : 			_TRY_BEGIN
; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, eax
	sub	ecx, DWORD PTR __Where$[ebp]
	lea	edx, DWORD PTR __Tmp$217627[ebp]
	sar	ecx, 3
	push	edx
	sub	ebx, ecx
	push	ebx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	?_Ufill@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEPAUCvSparseIDInfoGridEntry@@PAU3@IABU3@@Z ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Ufill

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1221 : 			_RERAISE;
; 1222 : 			_CATCH_END
; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR tv515[ebp]
	add	DWORD PTR [esi+8], eax
	mov	esi, DWORD PTR [esi+8]

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	edx, DWORD PTR __Tmp$217627[ebp]
	push	edx
	sub	esi, eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	esi
	push	eax
	call	??$fill@PAUCvSparseIDInfoGridEntry@@U1@@std@@YAXPAUCvSparseIDInfoGridEntry@@0ABU1@@Z ; std::fill<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry>
	add	esp, 12					; 0000000cH

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN3@Insert_n:

; 1232 : 			}
; 1233 : 		else
; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;
; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	lea	eax, DWORD PTR [ebx*8]
	push	edi
	mov	ebx, edi
	sub	ebx, eax
	push	edi
	mov	DWORD PTR __Tmp$217637[ebp], ecx
	push	ebx
	mov	ecx, esi
	mov	DWORD PTR __Tmp$217637[ebp+4], edx
	mov	DWORD PTR tv515[ebp], eax
	call	??$_Umove@PAUCvSparseIDInfoGridEntry@@@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEPAUCvSparseIDInfoGridEntry@@PAU2@00@Z ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Umove<CvSparseIDInfoGridEntry *>

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	push	edi
	mov	DWORD PTR [esi+8], eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	ebx
	push	eax
	call	??$_Unchecked_move_backward@PAUCvSparseIDInfoGridEntry@@PAU1@@stdext@@YAPAUCvSparseIDInfoGridEntry@@PAU1@00@Z ; stdext::_Unchecked_move_backward<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry *>

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[ebp]
	mov	edx, DWORD PTR tv515[ebp]
	lea	ecx, DWORD PTR __Tmp$217637[ebp]
	push	ecx
	add	edx, eax
	push	edx
	push	eax
	call	??$fill@PAUCvSparseIDInfoGridEntry@@U1@@std@@YAXPAUCvSparseIDInfoGridEntry@@0ABU1@@Z ; std::fill<CvSparseIDInfoGridEntry *,CvSparseIDInfoGridEntry>
	add	esp, 24					; 00000018H
$LN1@Insert_n:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN86@Insert_n:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@IABUCvSparseIDInfoGridEntry@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@IABUCvSparseIDInfoGridEntry@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@IABUCvSparseIDInfoGridEntry@@@Z ENDP ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Insert_n
PUBLIC	??0CvPlotManager@@QAE@XZ			; CvPlotManager::CvPlotManager
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0CvPlotManager@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CvPlotManager@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CvPlotManager@@QAE@XZ$1
__ehfuncinfo$??0CvPlotManager@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0CvPlotManager@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvplotmanager.cpp
xdata$x	ENDS
;	COMDAT ??0CvPlotManager@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CvPlotManager@@QAE@XZ PROC				; CvPlotManager::CvPlotManager, COMDAT
; _this$ = ecx

; 111  : {

	push	-1
	push	__ehhandler$??0CvPlotManager@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	xor	edi, edi
	lea	eax, DWORD PTR [esi+20]
	mov	DWORD PTR _this$[esp+24], esi
	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [esi+16], 8
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR __$EHRec$[esp+32], edi
	mov	DWORD PTR [esi+92], edi
	mov	DWORD PTR [esi+96], edi
	mov	DWORD PTR [esi+100], edi
	push	1
	push	8
	lea	ecx, DWORD PTR [esi+104]
	mov	BYTE PTR __$EHRec$[esp+40], 1
	call	??0?$FObjectPool@VCvIDInfoFixedVector@@@@QAE@I_N@Z ; FObjectPool<CvIDInfoFixedVector>::FObjectPool<CvIDInfoFixedVector>

; 112  : 	m_uiWidth = 0;
; 113  : 	m_uiHeight = 0;
; 114  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	DWORD PTR [esi], edi
	mov	DWORD PTR [esi+4], edi
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CvPlotManager@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CvIDInfoFixedVector@@QAE@XZ
__unwindfunclet$??0CvPlotManager@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	jmp	??1?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE@XZ ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::~vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >
__ehhandler$??0CvPlotManager@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0CvPlotManager@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CvPlotManager@@QAE@XZ ENDP				; CvPlotManager::CvPlotManager
PUBLIC	??1CvPlotManager@@QAE@XZ			; CvPlotManager::~CvPlotManager
;	COMDAT xdata$x
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffastvector.h
xdata$x	SEGMENT
__unwindtable$??1CvPlotManager@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CvPlotManager@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CvPlotManager@@QAE@XZ$1
__ehfuncinfo$??1CvPlotManager@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1CvPlotManager@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvplotmanager.cpp
xdata$x	ENDS
;	COMDAT ??1CvPlotManager@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CvPlotManager@@QAE@XZ PROC				; CvPlotManager::~CvPlotManager, COMDAT
; _this$ = ecx

; 118  : {

	push	-1
	push	__ehhandler$??1CvPlotManager@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi

; 119  : 	
; 120  : }

	lea	ecx, DWORD PTR [esi+104]
	mov	DWORD PTR __$EHRec$[esp+28], 1
	call	??1?$FObjectPool@VCvIDInfoFixedVector@@@@UAE@XZ ; FObjectPool<CvIDInfoFixedVector>::~FObjectPool<CvIDInfoFixedVector>
	mov	eax, DWORD PTR [esi+92]
	test	eax, eax
	je	SHORT $LN11@CvPlotMana
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN11@CvPlotMana:
	mov	DWORD PTR [esi+92], 0
	mov	DWORD PTR [esi+96], 0
	mov	DWORD PTR [esi+100], 0
	mov	eax, DWORD PTR [esi+8]
	add	esi, 20					; 00000014H
	cmp	eax, esi
	mov	DWORD PTR __$EHRec$[esp+28], -1
	pop	esi
	je	SHORT $LN18@CvPlotMana
	push	eax
	call	?FireFreeAlignedNoTracking@@YAXPAX@Z	; FireFreeAlignedNoTracking
	add	esp, 4
$LN18@CvPlotMana:
	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CvPlotManager@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1CvIDInfoFixedVector@@QAE@XZ
__unwindfunclet$??1CvPlotManager@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	jmp	??1?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE@XZ ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::~vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >
__ehhandler$??1CvPlotManager@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1CvPlotManager@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1CvPlotManager@@QAE@XZ ENDP				; CvPlotManager::~CvPlotManager
PUBLIC	?Uninit@CvPlotManager@@QAEXXZ			; CvPlotManager::Uninit
; Function compile flags: /Ogtpy
;	COMDAT ?Uninit@CvPlotManager@@QAEXXZ
_TEXT	SEGMENT
?Uninit@CvPlotManager@@QAEXXZ PROC			; CvPlotManager::Uninit, COMDAT
; _this$ = ecx

; 132  : 	m_aLayers.clear();

	mov	edx, DWORD PTR [ecx+92]
	push	esi
	mov	esi, DWORD PTR [ecx+96]
	cmp	edx, esi
	je	SHORT $LN17@Uninit
	mov	eax, esi
	cmp	esi, esi
	je	SHORT $LN42@Uninit
	push	edi
$LL44@Uninit:
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], edi
	add	eax, 8
	add	edx, 8
	cmp	eax, esi
	jne	SHORT $LL44@Uninit
	pop	edi
$LN42@Uninit:
	mov	DWORD PTR [ecx+96], edx
$LN17@Uninit:
	pop	esi

; 133  : }

	ret	0
?Uninit@CvPlotManager@@QAEXXZ ENDP			; CvPlotManager::Uninit
_TEXT	ENDS
PUBLIC	?insert@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@V?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@ABUCvSparseIDInfoGridEntry@@@Z ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::insert
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?insert@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@V?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@ABUCvSparseIDInfoGridEntry@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@V?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@ABUCvSparseIDInfoGridEntry@@@Z PROC ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	esi
	push	edi
	mov	edi, ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, eax
	test	ecx, -8					; fffffff8H
	mov	ecx, DWORD PTR __Where$[esp+4]
	jne	SHORT $LN3@insert
	xor	esi, esi
	jmp	SHORT $LN4@insert
$LN3@insert:
	mov	esi, ecx
	sub	esi, eax
	sar	esi, 3
$LN4@insert:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[esp+4]
	push	edx
	push	1
	push	ecx
	mov	ecx, edi
	call	?_Insert_n@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@IABUCvSparseIDInfoGridEntry@@@Z ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax+esi*8]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+4]
	pop	edi
	mov	DWORD PTR [eax], ecx
	pop	esi

; 879  : 		}

	ret	12					; 0000000cH
?insert@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAE?AV?$_Vector_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@V?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@ABUCvSparseIDInfoGridEntry@@@Z ENDP ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::insert
_TEXT	ENDS
PUBLIC	?push_back@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAEXABUCvSparseIDInfoGridEntry@@@Z ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::push_back
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAEXABUCvSparseIDInfoGridEntry@@@Z
_TEXT	SEGMENT
$T221467 = -4						; size = 1
__Cat$221471 = 8					; size = 1
__Val$ = 8						; size = 4
?push_back@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAEXABUCvSparseIDInfoGridEntry@@@Z PROC ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ecx
	push	esi
	mov	esi, ecx

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR [esi+4]
	push	edi
	test	ecx, ecx
	jne	SHORT $LN9@push_back@2
	xor	eax, eax
	jmp	SHORT $LN10@push_back@2
$LN9@push_back@2:
	mov	eax, DWORD PTR [esi+12]
	sub	eax, ecx
	sar	eax, 3
$LN10@push_back@2:
	mov	edi, DWORD PTR [esi+8]
	mov	edx, edi
	sub	edx, ecx
	sar	edx, 3
	cmp	edx, eax
	jae	SHORT $LN2@push_back@2

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	ecx, DWORD PTR __Cat$221471[esp+8]
	mov	edx, DWORD PTR __Val$[esp+8]
	mov	BYTE PTR $T221467[esp+12], 0
	mov	eax, DWORD PTR $T221467[esp+12]
	push	eax
	push	ecx
	push	esi
	push	edx
	push	1
	push	edi
	call	??$_Uninit_fill_n@PAUCvSparseIDInfoGridEntry@@IU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAXPAUCvSparseIDInfoGridEntry@@IABU1@AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvSparseIDInfoGridEntry *,unsigned int,CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >
	add	esp, 24					; 00000018H
	add	edi, 8
	mov	DWORD PTR [esi+8], edi
	pop	edi
	pop	esi

; 824  : 		}

	pop	ecx
	ret	4
$LN2@push_back@2:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	mov	eax, DWORD PTR __Val$[esp+8]
	push	eax
	push	1
	push	edi
	mov	ecx, esi
	call	?_Insert_n@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@IABUCvSparseIDInfoGridEntry@@@Z ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Insert_n
	pop	edi
	pop	esi

; 824  : 		}

	pop	ecx
	ret	4
?push_back@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@QAEXABUCvSparseIDInfoGridEntry@@@Z ENDP ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::push_back
_TEXT	ENDS
PUBLIC	?AddLayer@CvPlotManager@@IAEPAVCvSparseIDInfoGrid@@I@Z ; CvPlotManager::AddLayer
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?AddLayer@CvPlotManager@@IAEPAVCvSparseIDInfoGrid@@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddLayer@CvPlotManager@@IAEPAVCvSparseIDInfoGrid@@I@Z$0
__ehfuncinfo$?AddLayer@CvPlotManager@@IAEPAVCvSparseIDInfoGrid@@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AddLayer@CvPlotManager@@IAEPAVCvSparseIDInfoGrid@@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvplotmanager.cpp
xdata$x	ENDS
;	COMDAT ?AddLayer@CvPlotManager@@IAEPAVCvSparseIDInfoGrid@@I@Z
_TEXT	SEGMENT
$T221590 = -20						; size = 8
__$EHRec$ = -12						; size = 12
$T221813 = 8						; size = 1
__Cat$221817 = 8					; size = 1
$T221587 = 8						; size = 4
_uiLayerID$ = 8						; size = 4
?AddLayer@CvPlotManager@@IAEPAVCvSparseIDInfoGrid@@I@Z PROC ; CvPlotManager::AddLayer, COMDAT
; _this$ = ecx

; 168  : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?AddLayer@CvPlotManager@@IAEPAVCvSparseIDInfoGrid@@I@Z
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebp

; 169  : 	for (CvSparseIDInfoGridVector::const_iterator itr = m_aLayers.begin(); itr != m_aLayers.end(); ++itr)

	mov	ebp, DWORD PTR _uiLayerID$[esp+20]
	push	edi
	mov	edi, ecx
	mov	eax, DWORD PTR [edi+92]
	mov	ecx, DWORD PTR [edi+96]
	cmp	eax, ecx
	je	SHORT $LN2@AddLayer
	npad	6
$LL16@AddLayer:

; 170  : 	{
; 171  : 		if ((*itr).m_uiID == uiLayerID)

	cmp	DWORD PTR [eax], ebp
	je	SHORT $LN85@AddLayer
	add	eax, 8
	cmp	eax, ecx
	jne	SHORT $LL16@AddLayer
$LN2@AddLayer:
	push	esi

; 174  : 		}
; 175  : 	}
; 176  : 
; 177  : 	CvSparseIDInfoGrid* pkLayer = new CvSparseIDInfoGrid(m_uiWidth, m_uiHeight, &m_kAllocator);

	push	24					; 00000018H
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T221587[esp+28], esi
	mov	DWORD PTR __$EHRec$[esp+40], 0
	test	esi, esi
	je	SHORT $LN7@AddLayer
	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [esi+4], eax
	imul	eax, ecx
	mov	DWORD PTR [esi], ecx
	xor	ecx, ecx
	mov	DWORD PTR [esi+8], eax
	mov	edx, 4
	mul	edx
	seto	cl
	mov	DWORD PTR [esi+12], 0
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	ecx, DWORD PTR [esi+8]
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	0
	push	eax
	mov	DWORD PTR [esi+16], eax
	call	_memset
	lea	edx, DWORD PTR [edi+104]
	add	esp, 16					; 00000010H
	mov	DWORD PTR [esi+20], edx
	jmp	SHORT $LN8@AddLayer
$LN85@AddLayer:

; 172  : 		{
; 173  : 			return (*itr).m_pkGrid;

	mov	eax, DWORD PTR [eax+4]
	pop	edi
	pop	ebp

; 179  : 
; 180  : 	return pkLayer;
; 181  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	4
$LN7@AddLayer:

; 174  : 		}
; 175  : 	}
; 176  : 
; 177  : 	CvSparseIDInfoGrid* pkLayer = new CvSparseIDInfoGrid(m_uiWidth, m_uiHeight, &m_kAllocator);

	xor	esi, esi
$LN8@AddLayer:

; 178  : 	m_aLayers.push_back(CvSparseIDInfoGridEntry(uiLayerID, pkLayer));

	mov	ecx, DWORD PTR [edi+92]
	add	edi, 88					; 00000058H
	mov	DWORD PTR __$EHRec$[esp+40], -1
	mov	DWORD PTR $T221590[esp+32], ebp
	mov	DWORD PTR $T221590[esp+36], esi
	test	ecx, ecx
	jne	SHORT $LN44@AddLayer
	xor	eax, eax
	jmp	SHORT $LN45@AddLayer
$LN44@AddLayer:
	mov	eax, DWORD PTR [edi+12]
	sub	eax, ecx
	sar	eax, 3
$LN45@AddLayer:
	mov	ebp, DWORD PTR [edi+8]
	mov	edx, ebp
	sub	edx, ecx
	sar	edx, 3
	cmp	edx, eax
	jae	SHORT $LN37@AddLayer
	mov	BYTE PTR $T221813[esp+28], 0
	mov	eax, DWORD PTR $T221813[esp+28]
	mov	ecx, DWORD PTR __Cat$221817[esp+28]
	push	eax
	push	ecx
	push	edi
	lea	edx, DWORD PTR $T221590[esp+44]
	push	edx
	push	1
	push	ebp
	call	??$_Uninit_fill_n@PAUCvSparseIDInfoGridEntry@@IU1@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@YAXPAUCvSparseIDInfoGridEntry@@IABU1@AAV?$allocator@UCvSparseIDInfoGridEntry@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<CvSparseIDInfoGridEntry *,unsigned int,CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >
	add	esp, 24					; 00000018H
	add	ebp, 8
	mov	DWORD PTR [edi+8], ebp
	jmp	SHORT $LN78@AddLayer
$LN37@AddLayer:
	lea	eax, DWORD PTR $T221590[esp+32]
	push	eax
	push	1
	push	ebp
	mov	ecx, edi
	call	?_Insert_n@?$vector@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCvSparseIDInfoGridEntry@@V?$allocator@UCvSparseIDInfoGridEntry@@@std@@@2@IABUCvSparseIDInfoGridEntry@@@Z ; std::vector<CvSparseIDInfoGridEntry,std::allocator<CvSparseIDInfoGridEntry> >::_Insert_n
$LN78@AddLayer:

; 179  : 
; 180  : 	return pkLayer;
; 181  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	eax, esi
	pop	esi
	pop	edi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	add	esp, 20					; 00000014H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AddLayer@CvPlotManager@@IAEPAVCvSparseIDInfoGrid@@I@Z$0:
	mov	eax, DWORD PTR $T221587[ebp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?AddLayer@CvPlotManager@@IAEPAVCvSparseIDInfoGrid@@I@Z:
	mov	eax, OFFSET __ehfuncinfo$?AddLayer@CvPlotManager@@IAEPAVCvSparseIDInfoGrid@@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?AddLayer@CvPlotManager@@IAEPAVCvSparseIDInfoGrid@@I@Z ENDP ; CvPlotManager::AddLayer
PUBLIC	?AddUnit@CvPlotManager@@QAEXABUIDInfo@@HHI@Z	; CvPlotManager::AddUnit
; Function compile flags: /Ogtpy
;	COMDAT ?AddUnit@CvPlotManager@@QAEXABUIDInfo@@HHI@Z
_TEXT	SEGMENT
_kInfo$ = 8						; size = 4
_iX$ = 12						; size = 4
_iY$ = 16						; size = 4
_uiLayerID$ = 20					; size = 4
?AddUnit@CvPlotManager@@QAEXABUIDInfo@@HHI@Z PROC	; CvPlotManager::AddUnit, COMDAT
; _this$ = ecx

; 246  : 	CvSparseIDInfoGrid* pkLayer = AddLayer(uiLayerID);

	mov	eax, DWORD PTR _uiLayerID$[esp-4]
	push	eax
	call	?AddLayer@CvPlotManager@@IAEPAVCvSparseIDInfoGrid@@I@Z ; CvPlotManager::AddLayer

; 247  : 	if (pkLayer)

	test	eax, eax
	je	SHORT $LN1@AddUnit

; 248  : 	{
; 249  : 		pkLayer->Add(kInfo, iX, iY);

	mov	ecx, DWORD PTR _iY$[esp-4]
	mov	edx, DWORD PTR _iX$[esp-4]
	push	ecx
	mov	ecx, DWORD PTR _kInfo$[esp]
	push	edx
	push	ecx
	mov	ecx, eax
	call	?Add@CvSparseIDInfoGrid@@QAE_NABUIDInfo@@HH@Z ; CvSparseIDInfoGrid::Add
$LN1@AddUnit:

; 250  : 	}
; 251  : }

	ret	16					; 00000010H
?AddUnit@CvPlotManager@@QAEXABUIDInfo@@HHI@Z ENDP	; CvPlotManager::AddUnit
_TEXT	ENDS
END
