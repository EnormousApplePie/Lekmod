; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Desktop\Lekmod Files\Lekmod DLL versions\v29\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvArea.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtpy
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	push	edi
	mov	edi, DWORD PTR ___n$[esp]
	sub	edi, 1
	js	SHORT $LN1@vector
	push	ebx
	mov	ebx, DWORD PTR ___f$[esp+4]
	push	ebp
	mov	ebp, DWORD PTR ___s$[esp+8]
	push	esi
	mov	esi, DWORD PTR ___t$[esp+12]
	npad	7
$LL2@vector:
	mov	ecx, esi
	call	ebx
	add	esi, ebp
	sub	edi, 1
	jns	SHORT $LL2@vector
	pop	esi
	pop	ebp
	pop	ebx
$LN1@vector:
	pop	edi
	ret	16					; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?SetID@CvArea@@QAEXH@Z				; CvArea::SetID
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvarea.cpp
;	COMDAT ?SetID@CvArea@@QAEXH@Z
_TEXT	SEGMENT
_iID$ = 8						; size = 4
?SetID@CvArea@@QAEXH@Z PROC				; CvArea::SetID, COMDAT
; _this$ = ecx

; 144  : 	m_iID = iID;

	mov	eax, DWORD PTR _iID$[esp-4]
	mov	DWORD PTR [ecx+4], eax

; 145  : }

	ret	4
?SetID@CvArea@@QAEXH@Z ENDP				; CvArea::SetID
_TEXT	ENDS
PUBLIC	?countNumUniqueResourceTypes@CvArea@@QBEHXZ	; CvArea::countNumUniqueResourceTypes
EXTRN	?isOneArea@CvResourceInfo@@QBE_NXZ:PROC		; CvResourceInfo::isOneArea
EXTRN	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z:PROC ; CvGlobals::getResourceInfo
EXTRN	?getNumResourceInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumResourceInfos
EXTRN	?gGlobals@@3VCvGlobals@@A:BYTE			; gGlobals
; Function compile flags: /Ogtpy
;	COMDAT ?countNumUniqueResourceTypes@CvArea@@QBEHXZ
_TEXT	SEGMENT
?countNumUniqueResourceTypes@CvArea@@QBEHXZ PROC	; CvArea::countNumUniqueResourceTypes, COMDAT
; _this$ = ecx

; 206  : {

	push	ebx
	push	esi
	push	edi

; 207  : 	int iCount = 0;
; 208  : 	int numRIs = GC.getNumResourceInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	ebx, ebx
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	mov	edi, eax

; 209  : 
; 210  : 	for(int iI = 0; iI < numRIs; iI++)

	xor	esi, esi
	test	edi, edi
	jle	SHORT $LN9@countNumUn
	npad	9
$LL4@countNumUn:

; 211  : 	{
; 212  : 		CvResourceInfo* resource = GC.getResourceInfo((ResourceTypes)iI);

	push	esi
	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getResourceInfo@CvGlobals@@QAEPAVCvResourceInfo@@W4ResourceTypes@@@Z ; CvGlobals::getResourceInfo

; 213  : 		if(NULL != resource && resource->isOneArea())

	test	eax, eax
	je	SHORT $LN3@countNumUn
	mov	ecx, eax
	call	?isOneArea@CvResourceInfo@@QBE_NXZ	; CvResourceInfo::isOneArea
	test	al, al
	je	SHORT $LN3@countNumUn

; 214  : 		{
; 215  : 			iCount++;

	inc	ebx
$LN3@countNumUn:

; 209  : 
; 210  : 	for(int iI = 0; iI < numRIs; iI++)

	inc	esi
	cmp	esi, edi
	jl	SHORT $LL4@countNumUn
$LN9@countNumUn:
	pop	edi
	pop	esi

; 216  : 		}
; 217  : 	}
; 218  : 
; 219  : 	return iCount;

	mov	eax, ebx
	pop	ebx

; 220  : }

	ret	0
?countNumUniqueResourceTypes@CvArea@@QBEHXZ ENDP	; CvArea::countNumUniqueResourceTypes
_TEXT	ENDS
PUBLIC	?getNumTiles@CvArea@@QBEHXZ			; CvArea::getNumTiles
; Function compile flags: /Ogtpy
;	COMDAT ?getNumTiles@CvArea@@QBEHXZ
_TEXT	SEGMENT
?getNumTiles@CvArea@@QBEHXZ PROC			; CvArea::getNumTiles, COMDAT
; _this$ = ecx

; 225  : 	return m_iNumTiles;

	mov	eax, DWORD PTR [ecx+8]

; 226  : }

	ret	0
?getNumTiles@CvArea@@QBEHXZ ENDP			; CvArea::getNumTiles
_TEXT	ENDS
PUBLIC	?changeNumTiles@CvArea@@QAEXH@Z			; CvArea::changeNumTiles
; Function compile flags: /Ogtpy
;	COMDAT ?changeNumTiles@CvArea@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?changeNumTiles@CvArea@@QAEXH@Z PROC			; CvArea::changeNumTiles, COMDAT
; _this$ = ecx

; 231  : 	m_iNumTiles = (m_iNumTiles + iChange);

	mov	eax, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [ecx+8], eax

; 232  : 	CvAssert(m_iNumTiles >= 0);
; 233  : }

	ret	4
?changeNumTiles@CvArea@@QAEXH@Z ENDP			; CvArea::changeNumTiles
_TEXT	ENDS
PUBLIC	?getNumOwnedTiles@CvArea@@QBEHXZ		; CvArea::getNumOwnedTiles
; Function compile flags: /Ogtpy
;	COMDAT ?getNumOwnedTiles@CvArea@@QBEHXZ
_TEXT	SEGMENT
?getNumOwnedTiles@CvArea@@QBEHXZ PROC			; CvArea::getNumOwnedTiles, COMDAT
; _this$ = ecx

; 239  : 	return m_iNumOwnedTiles;

	mov	eax, DWORD PTR [ecx+12]

; 240  : }

	ret	0
?getNumOwnedTiles@CvArea@@QBEHXZ ENDP			; CvArea::getNumOwnedTiles
_TEXT	ENDS
PUBLIC	?getNumUnownedTiles@CvArea@@QBEHXZ		; CvArea::getNumUnownedTiles
; Function compile flags: /Ogtpy
;	COMDAT ?getNumUnownedTiles@CvArea@@QBEHXZ
_TEXT	SEGMENT
?getNumUnownedTiles@CvArea@@QBEHXZ PROC			; CvArea::getNumUnownedTiles, COMDAT
; _this$ = ecx

; 246  : 	return (m_iNumTiles - getNumOwnedTiles());

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+12]

; 247  : }

	ret	0
?getNumUnownedTiles@CvArea@@QBEHXZ ENDP			; CvArea::getNumUnownedTiles
_TEXT	ENDS
PUBLIC	?changeNumOwnedTiles@CvArea@@QAEXH@Z		; CvArea::changeNumOwnedTiles
; Function compile flags: /Ogtpy
;	COMDAT ?changeNumOwnedTiles@CvArea@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?changeNumOwnedTiles@CvArea@@QAEXH@Z PROC		; CvArea::changeNumOwnedTiles, COMDAT
; _this$ = ecx

; 253  : 	m_iNumOwnedTiles = (m_iNumOwnedTiles + iChange);

	mov	eax, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [ecx+12], eax

; 254  : 	CvAssert(getNumOwnedTiles() >= 0);
; 255  : 	CvAssert(getNumUnownedTiles() >= 0);
; 256  : }

	ret	4
?changeNumOwnedTiles@CvArea@@QAEXH@Z ENDP		; CvArea::changeNumOwnedTiles
_TEXT	ENDS
PUBLIC	?getNumRiverEdges@CvArea@@QBEHXZ		; CvArea::getNumRiverEdges
; Function compile flags: /Ogtpy
;	COMDAT ?getNumRiverEdges@CvArea@@QBEHXZ
_TEXT	SEGMENT
?getNumRiverEdges@CvArea@@QBEHXZ PROC			; CvArea::getNumRiverEdges, COMDAT
; _this$ = ecx

; 262  : 	return m_iNumRiverEdges;

	mov	eax, DWORD PTR [ecx+16]

; 263  : }

	ret	0
?getNumRiverEdges@CvArea@@QBEHXZ ENDP			; CvArea::getNumRiverEdges
_TEXT	ENDS
PUBLIC	?changeNumRiverEdges@CvArea@@QAEXH@Z		; CvArea::changeNumRiverEdges
; Function compile flags: /Ogtpy
;	COMDAT ?changeNumRiverEdges@CvArea@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?changeNumRiverEdges@CvArea@@QAEXH@Z PROC		; CvArea::changeNumRiverEdges, COMDAT
; _this$ = ecx

; 269  : 	m_iNumRiverEdges = (m_iNumRiverEdges + iChange);

	mov	eax, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [ecx+16], eax

; 270  : 	CvAssert(getNumRiverEdges() >= 0);
; 271  : }

	ret	4
?changeNumRiverEdges@CvArea@@QAEXH@Z ENDP		; CvArea::changeNumRiverEdges
_TEXT	ENDS
PUBLIC	?getNumUnits@CvArea@@QBEHXZ			; CvArea::getNumUnits
; Function compile flags: /Ogtpy
;	COMDAT ?getNumUnits@CvArea@@QBEHXZ
_TEXT	SEGMENT
?getNumUnits@CvArea@@QBEHXZ PROC			; CvArea::getNumUnits, COMDAT
; _this$ = ecx

; 277  : 	return m_iNumUnits;

	mov	eax, DWORD PTR [ecx+20]

; 278  : }

	ret	0
?getNumUnits@CvArea@@QBEHXZ ENDP			; CvArea::getNumUnits
_TEXT	ENDS
PUBLIC	?getNumCities@CvArea@@QBEHXZ			; CvArea::getNumCities
; Function compile flags: /Ogtpy
;	COMDAT ?getNumCities@CvArea@@QBEHXZ
_TEXT	SEGMENT
?getNumCities@CvArea@@QBEHXZ PROC			; CvArea::getNumCities, COMDAT
; _this$ = ecx

; 284  : 	return m_iNumCities;

	mov	eax, DWORD PTR [ecx+24]

; 285  : }

	ret	0
?getNumCities@CvArea@@QBEHXZ ENDP			; CvArea::getNumCities
_TEXT	ENDS
PUBLIC	?getTotalPopulation@CvArea@@QBEHXZ		; CvArea::getTotalPopulation
; Function compile flags: /Ogtpy
;	COMDAT ?getTotalPopulation@CvArea@@QBEHXZ
_TEXT	SEGMENT
?getTotalPopulation@CvArea@@QBEHXZ PROC			; CvArea::getTotalPopulation, COMDAT
; _this$ = ecx

; 291  : 	return m_iTotalPopulation;

	mov	eax, DWORD PTR [ecx+28]

; 292  : }

	ret	0
?getTotalPopulation@CvArea@@QBEHXZ ENDP			; CvArea::getTotalPopulation
_TEXT	ENDS
PUBLIC	?getNumStartingPlots@CvArea@@QBEHXZ		; CvArea::getNumStartingPlots
; Function compile flags: /Ogtpy
;	COMDAT ?getNumStartingPlots@CvArea@@QBEHXZ
_TEXT	SEGMENT
?getNumStartingPlots@CvArea@@QBEHXZ PROC		; CvArea::getNumStartingPlots, COMDAT
; _this$ = ecx

; 298  : 	return m_iNumStartingPlots;

	mov	eax, DWORD PTR [ecx+32]

; 299  : }

	ret	0
?getNumStartingPlots@CvArea@@QBEHXZ ENDP		; CvArea::getNumStartingPlots
_TEXT	ENDS
PUBLIC	?changeNumStartingPlots@CvArea@@QAEXH@Z		; CvArea::changeNumStartingPlots
; Function compile flags: /Ogtpy
;	COMDAT ?changeNumStartingPlots@CvArea@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?changeNumStartingPlots@CvArea@@QAEXH@Z PROC		; CvArea::changeNumStartingPlots, COMDAT
; _this$ = ecx

; 305  : 	m_iNumStartingPlots = m_iNumStartingPlots + iChange;

	mov	eax, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [ecx+32], eax

; 306  : 	CvAssert(getNumStartingPlots() >= 0);
; 307  : }

	ret	4
?changeNumStartingPlots@CvArea@@QAEXH@Z ENDP		; CvArea::changeNumStartingPlots
_TEXT	ENDS
PUBLIC	?GetNumNaturalWonders@CvArea@@QBEHXZ		; CvArea::GetNumNaturalWonders
; Function compile flags: /Ogtpy
;	COMDAT ?GetNumNaturalWonders@CvArea@@QBEHXZ
_TEXT	SEGMENT
?GetNumNaturalWonders@CvArea@@QBEHXZ PROC		; CvArea::GetNumNaturalWonders, COMDAT
; _this$ = ecx

; 314  : 	return m_iNumNaturalWonders;

	mov	eax, DWORD PTR [ecx+36]

; 315  : }

	ret	0
?GetNumNaturalWonders@CvArea@@QBEHXZ ENDP		; CvArea::GetNumNaturalWonders
_TEXT	ENDS
PUBLIC	?ChangeNumNaturalWonders@CvArea@@QAEXH@Z	; CvArea::ChangeNumNaturalWonders
; Function compile flags: /Ogtpy
;	COMDAT ?ChangeNumNaturalWonders@CvArea@@QAEXH@Z
_TEXT	SEGMENT
_iChange$ = 8						; size = 4
?ChangeNumNaturalWonders@CvArea@@QAEXH@Z PROC		; CvArea::ChangeNumNaturalWonders, COMDAT
; _this$ = ecx

; 321  : 	m_iNumNaturalWonders += iChange;

	mov	eax, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [ecx+36], eax

; 322  : }

	ret	4
?ChangeNumNaturalWonders@CvArea@@QAEXH@Z ENDP		; CvArea::ChangeNumNaturalWonders
_TEXT	ENDS
PUBLIC	?isWater@CvArea@@QBE_NXZ			; CvArea::isWater
; Function compile flags: /Ogtpy
;	COMDAT ?isWater@CvArea@@QBE_NXZ
_TEXT	SEGMENT
?isWater@CvArea@@QBE_NXZ PROC				; CvArea::isWater, COMDAT
; _this$ = ecx

; 328  : 	return m_bWater;

	mov	al, BYTE PTR [ecx+4228]

; 329  : }

	ret	0
?isWater@CvArea@@QBE_NXZ ENDP				; CvArea::isWater
_TEXT	ENDS
PUBLIC	?IsMountains@CvArea@@QBE_NXZ			; CvArea::IsMountains
; Function compile flags: /Ogtpy
;	COMDAT ?IsMountains@CvArea@@QBE_NXZ
_TEXT	SEGMENT
?IsMountains@CvArea@@QBE_NXZ PROC			; CvArea::IsMountains, COMDAT
; _this$ = ecx

; 335  : 	return m_bMountains;

	mov	al, BYTE PTR [ecx+4229]

; 336  : }

	ret	0
?IsMountains@CvArea@@QBE_NXZ ENDP			; CvArea::IsMountains
_TEXT	ENDS
PUBLIC	?SetMountains@CvArea@@QAEX_N@Z			; CvArea::SetMountains
; Function compile flags: /Ogtpy
;	COMDAT ?SetMountains@CvArea@@QAEX_N@Z
_TEXT	SEGMENT
_bValue$ = 8						; size = 1
?SetMountains@CvArea@@QAEX_N@Z PROC			; CvArea::SetMountains, COMDAT
; _this$ = ecx

; 341  : 	if(m_bMountains != bValue)

	mov	al, BYTE PTR _bValue$[esp-4]
	cmp	BYTE PTR [ecx+4229], al
	je	SHORT $LN1@SetMountai

; 342  : 	{
; 343  : 		m_bMountains = bValue;

	mov	BYTE PTR [ecx+4229], al
$LN1@SetMountai:

; 344  : 	}
; 345  : }

	ret	4
?SetMountains@CvArea@@QAEX_N@Z ENDP			; CvArea::SetMountains
_TEXT	ENDS
PUBLIC	?getUnitsPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z ; CvArea::getUnitsPerPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?getUnitsPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?getUnitsPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z PROC	; CvArea::getUnitsPerPlayer, COMDAT
; _this$ = ecx

; 352  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be >= 0");
; 353  : 	CvAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be < MAX_PLAYERS");
; 354  : 	if(eIndex < 0 || eIndex >= MAX_PLAYERS) return 0; // as set during reset()

	mov	eax, DWORD PTR _eIndex$[esp-4]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@getUnitsPe

; 355  : 
; 356  : 	return m_aiUnitsPerPlayer[eIndex];

	mov	eax, DWORD PTR [ecx+eax*4+44]

; 357  : }

	ret	4
$LN1@getUnitsPe:

; 352  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be >= 0");
; 353  : 	CvAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be < MAX_PLAYERS");
; 354  : 	if(eIndex < 0 || eIndex >= MAX_PLAYERS) return 0; // as set during reset()

	xor	eax, eax

; 357  : }

	ret	4
?getUnitsPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z ENDP	; CvArea::getUnitsPerPlayer
_TEXT	ENDS
PUBLIC	?changeUnitsPerPlayer@CvArea@@QAEXW4PlayerTypes@@H@Z ; CvArea::changeUnitsPerPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?changeUnitsPerPlayer@CvArea@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
?changeUnitsPerPlayer@CvArea@@QAEXW4PlayerTypes@@H@Z PROC ; CvArea::changeUnitsPerPlayer, COMDAT
; _this$ = ecx

; 363  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be >= 0");
; 364  : 	CvAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be < MAX_PLAYERS");
; 365  : 	if(eIndex < 0 || eIndex >= MAX_PLAYERS) return;

	mov	eax, DWORD PTR _eIndex$[esp-4]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@changeUnit

; 366  : 	m_iNumUnits = (m_iNumUnits + iChange);

	mov	edx, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [ecx+20], edx

; 367  : 	CvAssert(getNumUnits() >= 0);
; 368  : 	m_aiUnitsPerPlayer[eIndex] = (m_aiUnitsPerPlayer[eIndex] + iChange);

	add	DWORD PTR [ecx+eax*4+44], edx
$LN1@changeUnit:

; 369  : 	CvAssert(getUnitsPerPlayer(eIndex) >= 0);
; 370  : }

	ret	8
?changeUnitsPerPlayer@CvArea@@QAEXW4PlayerTypes@@H@Z ENDP ; CvArea::changeUnitsPerPlayer
_TEXT	ENDS
PUBLIC	?getCitiesPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z ; CvArea::getCitiesPerPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?getCitiesPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?getCitiesPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z PROC	; CvArea::getCitiesPerPlayer, COMDAT
; _this$ = ecx

; 399  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be >= 0");
; 400  : 	CvAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be < MAX_PLAYERS");
; 401  : 	if(eIndex < 0 || eIndex >= MAX_PLAYERS) return 0;

	mov	eax, DWORD PTR _eIndex$[esp-4]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@getCitiesP

; 402  : 
; 403  : 	return m_aiCitiesPerPlayer[eIndex];

	mov	eax, DWORD PTR [ecx+eax*4+364]

; 404  : }

	ret	4
$LN1@getCitiesP:

; 399  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be >= 0");
; 400  : 	CvAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be < MAX_PLAYERS");
; 401  : 	if(eIndex < 0 || eIndex >= MAX_PLAYERS) return 0;

	xor	eax, eax

; 404  : }

	ret	4
?getCitiesPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z ENDP	; CvArea::getCitiesPerPlayer
_TEXT	ENDS
PUBLIC	?changeCitiesPerPlayer@CvArea@@QAEXW4PlayerTypes@@H@Z ; CvArea::changeCitiesPerPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?changeCitiesPerPlayer@CvArea@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
?changeCitiesPerPlayer@CvArea@@QAEXW4PlayerTypes@@H@Z PROC ; CvArea::changeCitiesPerPlayer, COMDAT
; _this$ = ecx

; 410  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be >= 0");
; 411  : 	CvAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be < MAX_PLAYERS");
; 412  : 	if(eIndex < 0 || eIndex >= MAX_PLAYERS) return;

	mov	eax, DWORD PTR _eIndex$[esp-4]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@changeCiti

; 413  : 
; 414  : 	m_iNumCities = (m_iNumCities + iChange);

	mov	edx, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [ecx+24], edx

; 415  : 	CvAssert(getNumCities() >= 0);
; 416  : 	m_aiCitiesPerPlayer[eIndex] = (m_aiCitiesPerPlayer[eIndex] + iChange);

	add	DWORD PTR [ecx+eax*4+364], edx
$LN1@changeCiti:

; 417  : 	CvAssert(getCitiesPerPlayer(eIndex) >= 0);
; 418  : }

	ret	8
?changeCitiesPerPlayer@CvArea@@QAEXW4PlayerTypes@@H@Z ENDP ; CvArea::changeCitiesPerPlayer
_TEXT	ENDS
PUBLIC	?getPopulationPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z ; CvArea::getPopulationPerPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?getPopulationPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?getPopulationPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z PROC ; CvArea::getPopulationPerPlayer, COMDAT
; _this$ = ecx

; 425  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be >= 0");
; 426  : 	CvAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be < MAX_PLAYERS");
; 427  : 	if(eIndex < 0 || eIndex >= MAX_PLAYERS) return 0;

	mov	eax, DWORD PTR _eIndex$[esp-4]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@getPopulat

; 428  : 
; 429  : 	return m_aiPopulationPerPlayer[eIndex];

	mov	eax, DWORD PTR [ecx+eax*4+684]

; 430  : }

	ret	4
$LN1@getPopulat:

; 425  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be >= 0");
; 426  : 	CvAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be < MAX_PLAYERS");
; 427  : 	if(eIndex < 0 || eIndex >= MAX_PLAYERS) return 0;

	xor	eax, eax

; 430  : }

	ret	4
?getPopulationPerPlayer@CvArea@@QBEHW4PlayerTypes@@@Z ENDP ; CvArea::getPopulationPerPlayer
_TEXT	ENDS
PUBLIC	?changePopulationPerPlayer@CvArea@@QAEXW4PlayerTypes@@H@Z ; CvArea::changePopulationPerPlayer
; Function compile flags: /Ogtpy
;	COMDAT ?changePopulationPerPlayer@CvArea@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
?changePopulationPerPlayer@CvArea@@QAEXW4PlayerTypes@@H@Z PROC ; CvArea::changePopulationPerPlayer, COMDAT
; _this$ = ecx

; 436  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be >= 0");
; 437  : 	CvAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be < MAX_PLAYERS");
; 438  : 	if(eIndex < 0 || eIndex >= MAX_PLAYERS) return;

	mov	eax, DWORD PTR _eIndex$[esp-4]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@changePopu

; 439  : 
; 440  : 	m_iTotalPopulation = (m_iTotalPopulation + iChange);

	mov	edx, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [ecx+28], edx

; 441  : 	CvAssert(getTotalPopulation() >= 0);
; 442  : 	m_aiPopulationPerPlayer[eIndex] = (m_aiPopulationPerPlayer[eIndex] + iChange);

	add	DWORD PTR [ecx+eax*4+684], edx
$LN1@changePopu:

; 443  : 	CvAssert(getPopulationPerPlayer(eIndex) >= 0);
; 444  : }

	ret	8
?changePopulationPerPlayer@CvArea@@QAEXW4PlayerTypes@@H@Z ENDP ; CvArea::changePopulationPerPlayer
_TEXT	ENDS
PUBLIC	?getFreeSpecialist@CvArea@@QBEHW4PlayerTypes@@@Z ; CvArea::getFreeSpecialist
; Function compile flags: /Ogtpy
;	COMDAT ?getFreeSpecialist@CvArea@@QBEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?getFreeSpecialist@CvArea@@QBEHW4PlayerTypes@@@Z PROC	; CvArea::getFreeSpecialist, COMDAT
; _this$ = ecx

; 451  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be >= 0");
; 452  : 	CvAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be < MAX_PLAYERS");
; 453  : 	if(eIndex < 0 || eIndex >= MAX_PLAYERS) return 0;

	mov	eax, DWORD PTR _eIndex$[esp-4]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@getFreeSpe

; 454  : 
; 455  : 	return m_aiFreeSpecialist[eIndex];

	mov	eax, DWORD PTR [ecx+eax*4+1004]

; 456  : }

	ret	4
$LN1@getFreeSpe:

; 451  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be >= 0");
; 452  : 	CvAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be < MAX_PLAYERS");
; 453  : 	if(eIndex < 0 || eIndex >= MAX_PLAYERS) return 0;

	xor	eax, eax

; 456  : }

	ret	4
?getFreeSpecialist@CvArea@@QBEHW4PlayerTypes@@@Z ENDP	; CvArea::getFreeSpecialist
_TEXT	ENDS
PUBLIC	?changeFreeSpecialist@CvArea@@QAEXW4PlayerTypes@@H@Z ; CvArea::changeFreeSpecialist
; Function compile flags: /Ogtpy
;	COMDAT ?changeFreeSpecialist@CvArea@@QAEXW4PlayerTypes@@H@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
?changeFreeSpecialist@CvArea@@QAEXW4PlayerTypes@@H@Z PROC ; CvArea::changeFreeSpecialist, COMDAT
; _this$ = ecx

; 462  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be >= 0");
; 463  : 	CvAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be < MAX_PLAYERS");
; 464  : 	if(eIndex < 0 || eIndex >= MAX_PLAYERS) return;

	mov	eax, DWORD PTR _eIndex$[esp-4]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN2@changeFree

; 465  : 
; 466  : 	if(iChange != 0)

	mov	edx, DWORD PTR _iChange$[esp-4]
	test	edx, edx
	je	SHORT $LN2@changeFree

; 467  : 	{
; 468  : 		m_aiFreeSpecialist[eIndex] = (m_aiFreeSpecialist[eIndex] + iChange);

	add	DWORD PTR [ecx+eax*4+1004], edx
$LN2@changeFree:

; 469  : 		CvAssert(getFreeSpecialist(eIndex) >= 0);
; 470  : 	}
; 471  : }

	ret	8
?changeFreeSpecialist@CvArea@@QAEXW4PlayerTypes@@H@Z ENDP ; CvArea::changeFreeSpecialist
_TEXT	ENDS
PUBLIC	?getTotalFoundValue@CvArea@@QBEHXZ		; CvArea::getTotalFoundValue
; Function compile flags: /Ogtpy
;	COMDAT ?getTotalFoundValue@CvArea@@QBEHXZ
_TEXT	SEGMENT
?getTotalFoundValue@CvArea@@QBEHXZ PROC			; CvArea::getTotalFoundValue, COMDAT
; _this$ = ecx

; 478  : 	return m_iTotalFoundValue;

	mov	eax, DWORD PTR [ecx+40]

; 479  : }

	ret	0
?getTotalFoundValue@CvArea@@QBEHXZ ENDP			; CvArea::getTotalFoundValue
_TEXT	ENDS
PUBLIC	?setTotalFoundValue@CvArea@@QAEXH@Z		; CvArea::setTotalFoundValue
; Function compile flags: /Ogtpy
;	COMDAT ?setTotalFoundValue@CvArea@@QAEXH@Z
_TEXT	SEGMENT
_iNewValue$ = 8						; size = 4
?setTotalFoundValue@CvArea@@QAEXH@Z PROC		; CvArea::setTotalFoundValue, COMDAT
; _this$ = ecx

; 485  : 	m_iTotalFoundValue = iNewValue;

	mov	eax, DWORD PTR _iNewValue$[esp-4]
	mov	DWORD PTR [ecx+40], eax

; 486  : 	CvAssert(m_iTotalFoundValue >= 0);
; 487  : }

	ret	4
?setTotalFoundValue@CvArea@@QAEXH@Z ENDP		; CvArea::setTotalFoundValue
_TEXT	ENDS
PUBLIC	?getNumRevealedTiles@CvArea@@QBEHW4TeamTypes@@@Z ; CvArea::getNumRevealedTiles
; Function compile flags: /Ogtpy
;	COMDAT ?getNumRevealedTiles@CvArea@@QBEHW4TeamTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?getNumRevealedTiles@CvArea@@QBEHW4TeamTypes@@@Z PROC	; CvArea::getNumRevealedTiles, COMDAT
; _this$ = ecx

; 493  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be >= 0");
; 494  : 	CvAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be < MAX_PLAYERS");
; 495  : 	if(eIndex < 0 || eIndex >= MAX_PLAYERS) return 0;

	mov	eax, DWORD PTR _eIndex$[esp-4]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@getNumReve

; 496  : 
; 497  : 	return m_aiNumRevealedTiles[eIndex];

	mov	eax, DWORD PTR [ecx+eax*4+1324]

; 498  : }

	ret	4
$LN1@getNumReve:

; 493  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be >= 0");
; 494  : 	CvAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be < MAX_PLAYERS");
; 495  : 	if(eIndex < 0 || eIndex >= MAX_PLAYERS) return 0;

	xor	eax, eax

; 498  : }

	ret	4
?getNumRevealedTiles@CvArea@@QBEHW4TeamTypes@@@Z ENDP	; CvArea::getNumRevealedTiles
_TEXT	ENDS
PUBLIC	?getNumUnrevealedTiles@CvArea@@QBEHW4TeamTypes@@@Z ; CvArea::getNumUnrevealedTiles
; Function compile flags: /Ogtpy
;	COMDAT ?getNumUnrevealedTiles@CvArea@@QBEHW4TeamTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?getNumUnrevealedTiles@CvArea@@QBEHW4TeamTypes@@@Z PROC	; CvArea::getNumUnrevealedTiles, COMDAT
; _this$ = ecx

; 504  : 	return (m_iNumTiles - getNumRevealedTiles(eIndex));

	mov	eax, DWORD PTR _eIndex$[esp-4]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN3@getNumUnre
	mov	edx, DWORD PTR [ecx+eax*4+1324]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, edx

; 505  : }

	ret	4

; 504  : 	return (m_iNumTiles - getNumRevealedTiles(eIndex));

$LN3@getNumUnre:
	mov	eax, DWORD PTR [ecx+8]
	xor	edx, edx
	sub	eax, edx

; 505  : }

	ret	4
?getNumUnrevealedTiles@CvArea@@QBEHW4TeamTypes@@@Z ENDP	; CvArea::getNumUnrevealedTiles
_TEXT	ENDS
PUBLIC	?changeNumRevealedTiles@CvArea@@QAEXW4TeamTypes@@H@Z ; CvArea::changeNumRevealedTiles
; Function compile flags: /Ogtpy
;	COMDAT ?changeNumRevealedTiles@CvArea@@QAEXW4TeamTypes@@H@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
_iChange$ = 12						; size = 4
?changeNumRevealedTiles@CvArea@@QAEXW4TeamTypes@@H@Z PROC ; CvArea::changeNumRevealedTiles, COMDAT
; _this$ = ecx

; 511  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be >= 0");
; 512  : 	CvAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be < MAX_PLAYERS");
; 513  : 	if(eIndex < 0 || eIndex >= MAX_PLAYERS) return;

	mov	eax, DWORD PTR _eIndex$[esp-4]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@changeNumR

; 514  : 
; 515  : 	m_aiNumRevealedTiles[eIndex] = (m_aiNumRevealedTiles[eIndex] + iChange);

	mov	edx, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [ecx+eax*4+1324], edx
$LN1@changeNumR:

; 516  : 	CvAssert(getNumRevealedTiles(eIndex) >= 0);
; 517  : }

	ret	8
?changeNumRevealedTiles@CvArea@@QAEXW4TeamTypes@@H@Z ENDP ; CvArea::changeNumRevealedTiles
_TEXT	ENDS
PUBLIC	?getTargetCity@CvArea@@QBEPAVCvCity@@W4PlayerTypes@@@Z ; CvArea::getTargetCity
EXTRN	?getCity@@YAPAVCvCity@@UIDInfo@@@Z:PROC		; getCity
; Function compile flags: /Ogtpy
;	COMDAT ?getTargetCity@CvArea@@QBEPAVCvCity@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_eIndex$ = 8						; size = 4
?getTargetCity@CvArea@@QBEPAVCvCity@@W4PlayerTypes@@@Z PROC ; CvArea::getTargetCity, COMDAT
; _this$ = ecx

; 523  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be >= 0");
; 524  : 	CvAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be < MAX_PLAYERS");
; 525  : 	if(eIndex < 0 || eIndex >= MAX_PLAYERS) return 0;

	mov	eax, DWORD PTR _eIndex$[esp-4]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@getTargetC

; 526  : 
; 527  : 	return getCity(m_aTargetCities[eIndex]);

	mov	edx, DWORD PTR [ecx+eax*8+1648]
	mov	eax, DWORD PTR [ecx+eax*8+1644]
	push	edx
	push	eax
	call	?getCity@@YAPAVCvCity@@UIDInfo@@@Z	; getCity
	add	esp, 8

; 528  : }

	ret	4
$LN1@getTargetC:

; 523  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be >= 0");
; 524  : 	CvAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be < MAX_PLAYERS");
; 525  : 	if(eIndex < 0 || eIndex >= MAX_PLAYERS) return 0;

	xor	eax, eax

; 528  : }

	ret	4
?getTargetCity@CvArea@@QBEPAVCvCity@@W4PlayerTypes@@@Z ENDP ; CvArea::getTargetCity
_TEXT	ENDS
PUBLIC	?getYieldRateModifier@CvArea@@QBEHW4PlayerTypes@@W4YieldTypes@@@Z ; CvArea::getYieldRateModifier
; Function compile flags: /Ogtpy
;	COMDAT ?getYieldRateModifier@CvArea@@QBEHW4PlayerTypes@@W4YieldTypes@@@Z
_TEXT	SEGMENT
_eIndex1$ = 8						; size = 4
_eIndex2$ = 12						; size = 4
?getYieldRateModifier@CvArea@@QBEHW4PlayerTypes@@W4YieldTypes@@@Z PROC ; CvArea::getYieldRateModifier, COMDAT
; _this$ = ecx

; 552  : 	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be >= 0");
; 553  : 	CvAssertMsg(eIndex1 < MAX_PLAYERS, "eIndex1 is expected to be < MAX_PLAYERS");
; 554  : 	if(eIndex1 < 0 || eIndex1 >= MAX_PLAYERS) return 0;

	mov	eax, DWORD PTR _eIndex1$[esp-4]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN3@getYieldRa

; 555  : 
; 556  : 	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be >= 0");
; 557  : 	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be < NUM_YIELD_TYPES");
; 558  : 	if(eIndex2 < 0 || eIndex2 >= MAX_PLAYERS) return 0;

	mov	edx, DWORD PTR _eIndex2$[esp-4]
	cmp	edx, 63					; 0000003fH
	ja	SHORT $LN3@getYieldRa

; 559  : 
; 560  : 	return m_aaiYieldRateModifier[eIndex1][eIndex2];

	lea	eax, DWORD PTR [eax+eax*2]
	lea	edx, DWORD PTR [edx+eax*2]
	mov	eax, DWORD PTR [ecx+edx*4+2284]

; 561  : }

	ret	8
$LN3@getYieldRa:

; 552  : 	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be >= 0");
; 553  : 	CvAssertMsg(eIndex1 < MAX_PLAYERS, "eIndex1 is expected to be < MAX_PLAYERS");
; 554  : 	if(eIndex1 < 0 || eIndex1 >= MAX_PLAYERS) return 0;

	xor	eax, eax

; 561  : }

	ret	8
?getYieldRateModifier@CvArea@@QBEHW4PlayerTypes@@W4YieldTypes@@@Z ENDP ; CvArea::getYieldRateModifier
_TEXT	ENDS
PUBLIC	?getNumResources@CvArea@@QBEHW4ResourceTypes@@@Z ; CvArea::getNumResources
; Function compile flags: /Ogtpy
;	COMDAT ?getNumResources@CvArea@@QBEHW4ResourceTypes@@@Z
_TEXT	SEGMENT
_eResource$ = 8						; size = 4
?getNumResources@CvArea@@QBEHW4ResourceTypes@@@Z PROC	; CvArea::getNumResources, COMDAT
; _this$ = ecx

; 594  : 	CvAssertMsg(eResource >= 0, "eResource expected to be >= 0");
; 595  : 	CvAssertMsg(eResource < GC.getNumResourceInfos(), "eResource expected to be < GC.getNumResourceInfos");
; 596  : 	return m_paiNumResources[eResource];

	mov	eax, DWORD PTR [ecx+4204]
	mov	ecx, DWORD PTR _eResource$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 597  : }

	ret	4
?getNumResources@CvArea@@QBEHW4ResourceTypes@@@Z ENDP	; CvArea::getNumResources
_TEXT	ENDS
PUBLIC	?getNumTotalResources@CvArea@@QBEHXZ		; CvArea::getNumTotalResources
; Function compile flags: /Ogtpy
;	COMDAT ?getNumTotalResources@CvArea@@QBEHXZ
_TEXT	SEGMENT
_iTotal$ = -4						; size = 4
?getNumTotalResources@CvArea@@QBEHXZ PROC		; CvArea::getNumTotalResources, COMDAT
; _this$ = ecx

; 603  : {

	push	ecx
	push	ebx
	push	ebp
	push	esi
	mov	ebp, ecx
	push	edi
	xor	ebx, ebx

; 604  : 	int iTotal = 0;
; 605  : 
; 606  : 	int iNumResourceInfos = GC.getNumResourceInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	xor	esi, esi
	xor	edi, edi
	mov	DWORD PTR _iTotal$[esp+20], ebx
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos

; 607  : 	for(int iI = 0; iI < iNumResourceInfos; iI++)

	cmp	eax, 2
	jl	SHORT $LC9@getNumTota

; 608  : 	{
; 609  : 		iTotal += m_paiNumResources[iI];

	mov	ecx, DWORD PTR [ebp+4204]
	lea	edx, DWORD PTR [eax-2]
	shr	edx, 1
	inc	edx
	lea	ebx, DWORD PTR [edx+edx]
	npad	1
$LL10@getNumTota:
	add	esi, DWORD PTR [ecx]
	add	edi, DWORD PTR [ecx+4]
	add	ecx, 8
	sub	edx, 1
	jne	SHORT $LL10@getNumTota
$LC9@getNumTota:

; 607  : 	for(int iI = 0; iI < iNumResourceInfos; iI++)

	cmp	ebx, eax
	jge	SHORT $LN11@getNumTota

; 608  : 	{
; 609  : 		iTotal += m_paiNumResources[iI];

	mov	eax, DWORD PTR [ebp+4204]
	mov	ebx, DWORD PTR [eax+ebx*4]
	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
	pop	ebp

; 610  : 	}
; 611  : 
; 612  : 	return iTotal;

	add	eax, ebx
	pop	ebx

; 613  : }

	pop	ecx
	ret	0
$LN11@getNumTota:

; 608  : 	{
; 609  : 		iTotal += m_paiNumResources[iI];

	mov	ebx, DWORD PTR _iTotal$[esp+20]
	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
	pop	ebp

; 610  : 	}
; 611  : 
; 612  : 	return iTotal;

	add	eax, ebx
	pop	ebx

; 613  : }

	pop	ecx
	ret	0
?getNumTotalResources@CvArea@@QBEHXZ ENDP		; CvArea::getNumTotalResources
_TEXT	ENDS
PUBLIC	?changeNumResources@CvArea@@QAEXW4ResourceTypes@@H@Z ; CvArea::changeNumResources
; Function compile flags: /Ogtpy
;	COMDAT ?changeNumResources@CvArea@@QAEXW4ResourceTypes@@H@Z
_TEXT	SEGMENT
_eResource$ = 8						; size = 4
_iChange$ = 12						; size = 4
?changeNumResources@CvArea@@QAEXW4ResourceTypes@@H@Z PROC ; CvArea::changeNumResources, COMDAT
; _this$ = ecx

; 619  : 	CvAssertMsg(eResource >= 0, "eResource expected to be >= 0");
; 620  : 	CvAssertMsg(eResource < GC.getNumResourceInfos(), "eResource expected to be < GC.getNumResourceInfos");
; 621  : 	m_paiNumResources[eResource] = (m_paiNumResources[eResource] + iChange);

	mov	eax, DWORD PTR [ecx+4204]
	mov	ecx, DWORD PTR _eResource$[esp-4]
	mov	edx, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [eax+ecx*4], edx
	lea	eax, DWORD PTR [eax+ecx*4]

; 622  : 	CvAssert(getNumResources(eResource) >= 0);
; 623  : }

	ret	8
?changeNumResources@CvArea@@QAEXW4ResourceTypes@@H@Z ENDP ; CvArea::changeNumResources
_TEXT	ENDS
PUBLIC	?getNumImprovements@CvArea@@QBEHW4ImprovementTypes@@@Z ; CvArea::getNumImprovements
; Function compile flags: /Ogtpy
;	COMDAT ?getNumImprovements@CvArea@@QBEHW4ImprovementTypes@@@Z
_TEXT	SEGMENT
_eImprovement$ = 8					; size = 4
?getNumImprovements@CvArea@@QBEHW4ImprovementTypes@@@Z PROC ; CvArea::getNumImprovements, COMDAT
; _this$ = ecx

; 630  : 	CvAssertMsg(eImprovement >= 0, "eImprovement expected to be >= 0");
; 631  : 	CvAssertMsg(eImprovement < GC.getNumImprovementInfos(), "eImprovement expected to be < GC.getNumImprovementInfos");
; 632  : 	return m_paiNumImprovements[eImprovement];

	mov	eax, DWORD PTR [ecx+4208]
	mov	ecx, DWORD PTR _eImprovement$[esp-4]
	mov	eax, DWORD PTR [eax+ecx*4]

; 633  : }

	ret	4
?getNumImprovements@CvArea@@QBEHW4ImprovementTypes@@@Z ENDP ; CvArea::getNumImprovements
_TEXT	ENDS
PUBLIC	?changeNumImprovements@CvArea@@QAEXW4ImprovementTypes@@H@Z ; CvArea::changeNumImprovements
; Function compile flags: /Ogtpy
;	COMDAT ?changeNumImprovements@CvArea@@QAEXW4ImprovementTypes@@H@Z
_TEXT	SEGMENT
_eImprovement$ = 8					; size = 4
_iChange$ = 12						; size = 4
?changeNumImprovements@CvArea@@QAEXW4ImprovementTypes@@H@Z PROC ; CvArea::changeNumImprovements, COMDAT
; _this$ = ecx

; 639  : 	CvAssertMsg(eImprovement >= 0, "eImprovement expected to be >= 0");
; 640  : 	CvAssertMsg(eImprovement < GC.getNumImprovementInfos(), "eImprovement expected to be < GC.getNumImprovementInfos");
; 641  : 	m_paiNumImprovements[eImprovement] = (m_paiNumImprovements[eImprovement] + iChange);

	mov	eax, DWORD PTR [ecx+4208]
	mov	ecx, DWORD PTR _eImprovement$[esp-4]
	mov	edx, DWORD PTR _iChange$[esp-4]
	add	DWORD PTR [eax+ecx*4], edx
	lea	eax, DWORD PTR [eax+ecx*4]

; 642  : 	CvAssert(getNumImprovements(eImprovement) >= 0);
; 643  : }

	ret	8
?changeNumImprovements@CvArea@@QAEXW4ImprovementTypes@@H@Z ENDP ; CvArea::changeNumImprovements
_TEXT	ENDS
PUBLIC	?getAreaBoundaries@CvArea@@QBE?AUCvAreaBoundaries@@XZ ; CvArea::getAreaBoundaries
; Function compile flags: /Ogtpy
;	COMDAT ?getAreaBoundaries@CvArea@@QBE?AUCvAreaBoundaries@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?getAreaBoundaries@CvArea@@QBE?AUCvAreaBoundaries@@XZ PROC ; CvArea::getAreaBoundaries, COMDAT
; _this$ = ecx

; 648  : 	return m_Boundaries;

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR [ecx+4212]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4216]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+4220]
	mov	ecx, DWORD PTR [ecx+4224]
	mov	DWORD PTR [eax+8], edx
	mov	DWORD PTR [eax+12], ecx

; 649  : }

	ret	4
?getAreaBoundaries@CvArea@@QBE?AUCvAreaBoundaries@@XZ ENDP ; CvArea::getAreaBoundaries
_TEXT	ENDS
PUBLIC	?setAreaBoundaries@CvArea@@QAEXUCvAreaBoundaries@@@Z ; CvArea::setAreaBoundaries
; Function compile flags: /Ogtpy
;	COMDAT ?setAreaBoundaries@CvArea@@QAEXUCvAreaBoundaries@@@Z
_TEXT	SEGMENT
_newBoundaries$ = 8					; size = 16
?setAreaBoundaries@CvArea@@QAEXUCvAreaBoundaries@@@Z PROC ; CvArea::setAreaBoundaries, COMDAT
; _this$ = ecx

; 658  : 	m_Boundaries = newBoundaries;

	mov	eax, DWORD PTR _newBoundaries$[esp-4]
	mov	edx, DWORD PTR _newBoundaries$[esp]
	mov	DWORD PTR [ecx+4212], eax
	mov	eax, DWORD PTR _newBoundaries$[esp+4]
	mov	DWORD PTR [ecx+4216], edx
	mov	edx, DWORD PTR _newBoundaries$[esp+8]
	mov	DWORD PTR [ecx+4220], eax
	mov	DWORD PTR [ecx+4224], edx

; 659  : }

	ret	16					; 00000010H
?setAreaBoundaries@CvArea@@QAEXUCvAreaBoundaries@@@Z ENDP ; CvArea::setAreaBoundaries
_TEXT	ENDS
PUBLIC	??6@YAAAVFDataStream@@AAV0@ABVCvArea@@@Z	; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ??6@YAAAVFDataStream@@AAV0@ABVCvArea@@@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??6@YAAAVFDataStream@@AAV0@ABVCvArea@@@Z PROC		; operator<<, COMDAT

; 813  : 	readFrom.write(saveTo);

	mov	ecx, DWORD PTR _readFrom$[esp-4]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+4]
	push	esi
	mov	esi, DWORD PTR _saveTo$[esp]
	push	esi
	call	edx

; 814  : 	return saveTo;

	mov	eax, esi
	pop	esi

; 815  : }

	ret	0
??6@YAAAVFDataStream@@AAV0@ABVCvArea@@@Z ENDP		; operator<<
_TEXT	ENDS
PUBLIC	??5@YAAAVFDataStream@@AAV0@AAVCvArea@@@Z	; operator>>
; Function compile flags: /Ogtpy
;	COMDAT ??5@YAAAVFDataStream@@AAV0@AAVCvArea@@@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??5@YAAAVFDataStream@@AAV0@AAVCvArea@@@Z PROC		; operator>>, COMDAT

; 820  : 	writeTo.read(loadFrom);

	mov	ecx, DWORD PTR _writeTo$[esp-4]
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR _loadFrom$[esp]
	push	esi
	call	edx

; 821  : 	return loadFrom;

	mov	eax, esi
	pop	esi

; 822  : }

	ret	0
??5@YAAAVFDataStream@@AAV0@AAVCvArea@@@Z ENDP		; operator>>
_TEXT	ENDS
PUBLIC	??$max@H@std@@YAABHABH0@Z			; std::max<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$max@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@H@std@@YAABHABH0@Z PROC				; std::max<int>, COMDAT

; 3384 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN4@max
	mov	eax, ecx
$LN4@max:

; 3385 : 	}

	ret	0
??$max@H@std@@YAABHABH0@Z ENDP				; std::max<int>
_TEXT	ENDS
PUBLIC	??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z		; SAFE_DELETE_ARRAY<int>
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\ffiretypes.h
;	COMDAT ??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z
_TEXT	SEGMENT
_pkInstanceArray$ = 8					; size = 4
??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z PROC			; SAFE_DELETE_ARRAY<int>, COMDAT

; 311  : {

	push	esi

; 312  : 	delete[] pkInstanceArray;

	mov	esi, DWORD PTR _pkInstanceArray$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 313  : 	pkInstanceArray = NULL;

	mov	DWORD PTR [esi], 0
	pop	esi

; 314  : };

	ret	0
??$SAFE_DELETE_ARRAY@H@@YAXAAPAH@Z ENDP			; SAFE_DELETE_ARRAY<int>
_TEXT	ENDS
PUBLIC	??$min@H@std@@YAABHABH0@Z			; std::min<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$min@H@std@@YAABHABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@H@std@@YAABHABH0@Z PROC				; std::min<int>, COMDAT

; 3399 : 	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR __Left$[esp-4]
	cmp	edx, DWORD PTR [ecx]
	jl	SHORT $LN4@min
	mov	eax, ecx
$LN4@min:

; 3400 : 	}

	ret	0
??$min@H@std@@YAABHABH0@Z ENDP				; std::min<int>
_TEXT	ENDS
PUBLIC	??0IDInfo@@QAE@W4PlayerTypes@@H@Z		; IDInfo::IDInfo
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredllutil\include\cvstructs.h
;	COMDAT ??0IDInfo@@QAE@W4PlayerTypes@@H@Z
_TEXT	SEGMENT
_eOwner$ = 8						; size = 4
_iID$ = 12						; size = 4
??0IDInfo@@QAE@W4PlayerTypes@@H@Z PROC			; IDInfo::IDInfo, COMDAT
; _this$ = ecx

; 177  : 	IDInfo(PlayerTypes eOwner=NO_PLAYER, int iID=FFreeList::INVALID_INDEX) : eOwner(eOwner), iID(iID) {}

	mov	edx, DWORD PTR _iID$[esp-4]
	mov	eax, ecx
	mov	ecx, DWORD PTR _eOwner$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	ret	8
??0IDInfo@@QAE@W4PlayerTypes@@H@Z ENDP			; IDInfo::IDInfo
_TEXT	ENDS
PUBLIC	?reset@IDInfo@@QAEXXZ				; IDInfo::reset
; Function compile flags: /Ogtpy
;	COMDAT ?reset@IDInfo@@QAEXXZ
_TEXT	SEGMENT
?reset@IDInfo@@QAEXXZ PROC				; IDInfo::reset, COMDAT
; _this$ = ecx

; 193  : 		eOwner = NO_PLAYER;

	mov	DWORD PTR [ecx], -1

; 194  : 		iID = FFreeList::INVALID_INDEX;

	mov	DWORD PTR [ecx+4], -1

; 195  : 	}

	ret	0
?reset@IDInfo@@QAEXXZ ENDP				; IDInfo::reset
_TEXT	ENDS
PUBLIC	?getMap@CvGlobals@@QAEAAVCvMap@@XZ		; CvGlobals::getMap
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvglobals.h
;	COMDAT ?getMap@CvGlobals@@QAEAAVCvMap@@XZ
_TEXT	SEGMENT
?getMap@CvGlobals@@QAEAAVCvMap@@XZ PROC			; CvGlobals::getMap, COMDAT
; _this$ = ecx

; 175  : 		return *m_map;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+52]

; 176  : 	}

	ret	0
?getMap@CvGlobals@@QAEAAVCvMap@@XZ ENDP			; CvGlobals::getMap
_TEXT	ENDS
PUBLIC	?getGame@CvGlobals@@QAEAAVCvGame@@XZ		; CvGlobals::getGame
; Function compile flags: /Ogtpy
;	COMDAT ?getGame@CvGlobals@@QAEAAVCvGame@@XZ
_TEXT	SEGMENT
?getGame@CvGlobals@@QAEAAVCvGame@@XZ PROC		; CvGlobals::getGame, COMDAT
; _this$ = ecx

; 183  : 		return *m_game;    // inlined for perf reasons, do not use outside of dll

	mov	eax, DWORD PTR [ecx+48]

; 184  : 	}

	ret	0
?getGame@CvGlobals@@QAEAAVCvGame@@XZ ENDP		; CvGlobals::getGame
_TEXT	ENDS
PUBLIC	?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ ; CvGlobals::GetEngineUserInterface
; Function compile flags: /Ogtpy
;	COMDAT ?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ
_TEXT	SEGMENT
?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ PROC ; CvGlobals::GetEngineUserInterface, COMDAT
; _this$ = ecx

; 7713 : 		return m_pEngineUI;

	mov	eax, DWORD PTR [ecx+8568]

; 7714 : 	}

	ret	0
?GetEngineUserInterface@CvGlobals@@QAEPAVICvUserInterface2@@XZ ENDP ; CvGlobals::GetEngineUserInterface
_TEXT	ENDS
PUBLIC	?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z	; CvPlayerAI::getPlayer
EXTRN	?m_aPlayers@CvPlayerAI@@1PAV1@A:DWORD		; CvPlayerAI::m_aPlayers
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvplayerai.h
;	COMDAT ?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z
_TEXT	SEGMENT
_ePlayer$ = 8						; size = 4
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z PROC	; CvPlayerAI::getPlayer, COMDAT

; 28   : 		CvAssertMsg(ePlayer != NO_PLAYER, "Player is not assigned a valid value");
; 29   : 		CvAssertMsg(ePlayer < MAX_PLAYERS, "Player is not assigned a valid value");
; 30   : 		return m_aPlayers[ePlayer];

	mov	eax, DWORD PTR _ePlayer$[esp-4]
	imul	eax, 63236				; 0000f704H
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers

; 31   : 	}

	ret	0
?getPlayer@CvPlayerAI@@SAAAV1@W4PlayerTypes@@@Z ENDP	; CvPlayerAI::getPlayer
_TEXT	ENDS
PUBLIC	??0CvAreaBoundaries@@QAE@XZ			; CvAreaBoundaries::CvAreaBoundaries
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvarea.h
;	COMDAT ??0CvAreaBoundaries@@QAE@XZ
_TEXT	SEGMENT
??0CvAreaBoundaries@@QAE@XZ PROC			; CvAreaBoundaries::CvAreaBoundaries, COMDAT
; _this$ = ecx

; 24   : 	{

	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 25   : 	}

	ret	0
??0CvAreaBoundaries@@QAE@XZ ENDP			; CvAreaBoundaries::CvAreaBoundaries
_TEXT	ENDS
PUBLIC	?GetID@CvArea@@QBEHXZ				; CvArea::GetID
; Function compile flags: /Ogtpy
;	COMDAT ?GetID@CvArea@@QBEHXZ
_TEXT	SEGMENT
?GetID@CvArea@@QBEHXZ PROC				; CvArea::GetID, COMDAT
; _this$ = ecx

; 54   : 		return m_iID;

	mov	eax, DWORD PTR [ecx+4]

; 55   : 	}

	ret	0
?GetID@CvArea@@QBEHXZ ENDP				; CvArea::GetID
_TEXT	ENDS
PUBLIC	?getArea@CvPlot@@QBEHXZ				; CvPlot::getArea
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvplot.h
;	COMDAT ?getArea@CvPlot@@QBEHXZ
_TEXT	SEGMENT
?getArea@CvPlot@@QBEHXZ PROC				; CvPlot::getArea, COMDAT
; _this$ = ecx

; 324  : 		return m_iArea;

	mov	eax, DWORD PTR [ecx+356]

; 325  : 	}

	ret	0
?getArea@CvPlot@@QBEHXZ ENDP				; CvPlot::getArea
_TEXT	ENDS
PUBLIC	?numPlots@CvMap@@QBEHXZ				; CvMap::numPlots
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvmap.h
;	COMDAT ?numPlots@CvMap@@QBEHXZ
_TEXT	SEGMENT
?numPlots@CvMap@@QBEHXZ PROC				; CvMap::numPlots, COMDAT
; _this$ = ecx

; 170  : 		return m_iGridSize;

	mov	eax, DWORD PTR [ecx+4028]

; 171  : 	}

	ret	0
?numPlots@CvMap@@QBEHXZ ENDP				; CvMap::numPlots
_TEXT	ENDS
PUBLIC	?getGridHeight@CvMap@@QBEHXZ			; CvMap::getGridHeight
; Function compile flags: /Ogtpy
;	COMDAT ?getGridHeight@CvMap@@QBEHXZ
_TEXT	SEGMENT
?getGridHeight@CvMap@@QBEHXZ PROC			; CvMap::getGridHeight, COMDAT
; _this$ = ecx

; 206  : 		return m_iGridHeight;

	mov	eax, DWORD PTR [ecx+4024]

; 207  : 	}

	ret	0
?getGridHeight@CvMap@@QBEHXZ ENDP			; CvMap::getGridHeight
_TEXT	ENDS
PUBLIC	?isWrapX@CvMap@@QBE_NXZ				; CvMap::isWrapX
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapX@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapX@CvMap@@QBE_NXZ PROC				; CvMap::isWrapX, COMDAT
; _this$ = ecx

; 228  : 		return m_bWrapX;

	mov	al, BYTE PTR [ecx+4056]

; 229  : 	}

	ret	0
?isWrapX@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapX
_TEXT	ENDS
PUBLIC	?isWrapY@CvMap@@QBE_NXZ				; CvMap::isWrapY
; Function compile flags: /Ogtpy
;	COMDAT ?isWrapY@CvMap@@QBE_NXZ
_TEXT	SEGMENT
?isWrapY@CvMap@@QBE_NXZ PROC				; CvMap::isWrapY, COMDAT
; _this$ = ecx

; 233  : 		return m_bWrapY;

	mov	al, BYTE PTR [ecx+4057]

; 234  : 	}

	ret	0
?isWrapY@CvMap@@QBE_NXZ ENDP				; CvMap::isWrapY
_TEXT	ENDS
PUBLIC	?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z	; CvMap::plotByIndexUnchecked
; Function compile flags: /Ogtpy
;	COMDAT ?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z PROC	; CvMap::plotByIndexUnchecked, COMDAT
; _this$ = ecx

; 268  : 		return &m_pMapPlots[iIndex];

	mov	eax, DWORD PTR _iIndex$[esp-4]
	imul	eax, 484				; 000001e4H
	add	eax, DWORD PTR [ecx+4068]

; 269  : 	}

	ret	4
?plotByIndexUnchecked@CvMap@@QBEPAVCvPlot@@H@Z ENDP	; CvMap::plotByIndexUnchecked
_TEXT	ENDS
PUBLIC	??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z PROC ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR __Pos$[esp-4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 771  : 		}

	ret	4
??A?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@QBEABW4TeamTypes@@I@Z ENDP ; std::vector<enum TeamTypes,std::allocator<enum TeamTypes> >::operator[]
_TEXT	ENDS
PUBLIC	??$?6H@FDataStream@@QAEAAV0@ABH@Z		; FDataStream::operator<<<int>
EXTRN	?Write@FDataStream@@IAEXABH@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6H@FDataStream@@QAEAAV0@ABH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6H@FDataStream@@QAEAAV0@ABH@Z PROC			; FDataStream::operator<<<int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6H@FDataStream@@QAEAAV0@ABH@Z ENDP			; FDataStream::operator<<<int>
_TEXT	ENDS
PUBLIC	??$?5H@FDataStream@@QAEAAV0@AAH@Z		; FDataStream::operator>><int>
EXTRN	?Read@FDataStream@@IAEXAAH@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5H@FDataStream@@QAEAAV0@AAH@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5H@FDataStream@@QAEAAV0@AAH@Z PROC			; FDataStream::operator>><int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5H@FDataStream@@QAEAAV0@AAH@Z ENDP			; FDataStream::operator>><int>
_TEXT	ENDS
PUBLIC	??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fautovariable.h
;	COMDAT ??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ
_TEXT	SEGMENT
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ PROC ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &, COMDAT
; _this$ = ecx

; 194  : 	return m_value;

	lea	eax, DWORD PTR [ecx+4]

; 195  : }

	ret	0
??B?$FAutoVariable@W4PlayerTypes@@VCvPlayer@@@@QBEABW4PlayerTypes@@XZ ENDP ; FAutoVariable<enum PlayerTypes,CvPlayer>::operator enum PlayerTypes const &
_TEXT	ENDS
PUBLIC	??$?5_N@FDataStream@@QAEAAV0@AA_N@Z		; FDataStream::operator>><bool>
EXTRN	?Read@FDataStream@@IAEXAA_N@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5_N@FDataStream@@QAEAAV0@AA_N@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5_N@FDataStream@@QAEAAV0@AA_N@Z PROC		; FDataStream::operator>><bool>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5_N@FDataStream@@QAEAAV0@AA_N@Z ENDP		; FDataStream::operator>><bool>
_TEXT	ENDS
PUBLIC	??$?6_N@FDataStream@@QAEAAV0@AB_N@Z		; FDataStream::operator<<<bool>
EXTRN	?Write@FDataStream@@IAEXAB_N@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6_N@FDataStream@@QAEAAV0@AB_N@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6_N@FDataStream@@QAEAAV0@AB_N@Z PROC		; FDataStream::operator<<<bool>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6_N@FDataStream@@QAEAAV0@AB_N@Z ENDP		; FDataStream::operator<<<bool>
_TEXT	ENDS
PUBLIC	??$?5I@FDataStream@@QAEAAV0@AAI@Z		; FDataStream::operator>><unsigned int>
EXTRN	?Read@FDataStream@@IAEXAAI@Z:PROC		; FDataStream::Read
; Function compile flags: /Ogtpy
;	COMDAT ??$?5I@FDataStream@@QAEAAV0@AAI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?5I@FDataStream@@QAEAAV0@AAI@Z PROC			; FDataStream::operator>><unsigned int>, COMDAT
; _this$ = ecx

; 260  : 	// If the compiler produces an error here complaining about 
; 261  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 262  : 	// it could not find a specialization for the type supplied
; 263  : 	// in scope. If a specialization exists, be sure to include
; 264  : 	// the header (FStlContainerSerialization.h, for example), 
; 265  : 	// if not, implement :
; 266  : 	// FDataStream & operator>>(FDataStream &, YourCustomType &)
; 267  : 	Read( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 268  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 269  : }

	ret	4
??$?5I@FDataStream@@QAEAAV0@AAI@Z ENDP			; FDataStream::operator>><unsigned int>
_TEXT	ENDS
PUBLIC	??$?6I@FDataStream@@QAEAAV0@ABI@Z		; FDataStream::operator<<<unsigned int>
EXTRN	?Write@FDataStream@@IAEXABI@Z:PROC		; FDataStream::Write
; Function compile flags: /Ogtpy
;	COMDAT ??$?6I@FDataStream@@QAEAAV0@ABI@Z
_TEXT	SEGMENT
_kData$ = 8						; size = 4
??$?6I@FDataStream@@QAEAAV0@ABI@Z PROC			; FDataStream::operator<<<unsigned int>, COMDAT
; _this$ = ecx

; 246  : 	// If the compiler produces an error here complaining about 
; 247  : 	// YouMustImplementASerializeOperatorForThisTypeError then
; 248  : 	// it could not find a specialization for the type supplied
; 249  : 	// in scope. If a specialization exists, be sure to include
; 250  : 	// the header (FStlContainerSerialization.h, for example), 
; 251  : 	// if not, implement :
; 252  : 	// FDataStream & operator<<(FDataStream &, YourCustomType &)
; 253  : 	Write( kData );

	mov	eax, DWORD PTR _kData$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 254  : 	return ( *this );

	mov	eax, esi
	pop	esi

; 255  : }

	ret	4
??$?6I@FDataStream@@QAEAAV0@ABI@Z ENDP			; FDataStream::operator<<<unsigned int>
_TEXT	ENDS
PUBLIC	??_FIDInfo@@QAEXXZ				; IDInfo::`default constructor closure'
; Function compile flags: /Ogtpy
;	COMDAT ??_FIDInfo@@QAEXXZ
_TEXT	SEGMENT
??_FIDInfo@@QAEXXZ PROC					; IDInfo::`default constructor closure', COMDAT
; _this$ = ecx
	mov	DWORD PTR [ecx], -1
	mov	DWORD PTR [ecx+4], -1
	ret	0
??_FIDInfo@@QAEXXZ ENDP					; IDInfo::`default constructor closure'
_TEXT	ENDS
PUBLIC	?uninit@CvArea@@QAEXXZ				; CvArea::uninit
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvarea.cpp
;	COMDAT ?uninit@CvArea@@QAEXXZ
_TEXT	SEGMENT
?uninit@CvArea@@QAEXXZ PROC				; CvArea::uninit, COMDAT
; _this$ = ecx

; 60   : {

	push	esi
	mov	esi, ecx

; 61   : 	SAFE_DELETE_ARRAY(m_paiNumResources);

	mov	eax, DWORD PTR [esi+4204]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+4204], 0

; 62   : 	SAFE_DELETE_ARRAY(m_paiNumImprovements);

	mov	ecx, DWORD PTR [esi+4208]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 8
	mov	DWORD PTR [esi+4208], 0
	pop	esi

; 63   : }

	ret	0
?uninit@CvArea@@QAEXXZ ENDP				; CvArea::uninit
_TEXT	ENDS
PUBLIC	?reset@CvArea@@QAEXH_N0@Z			; CvArea::reset
EXTRN	?getNumImprovementInfos@CvGlobals@@QAEHXZ:PROC	; CvGlobals::getNumImprovementInfos
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
; Function compile flags: /Ogtpy
;	COMDAT ?reset@CvArea@@QAEXH_N0@Z
_TEXT	SEGMENT
_iID$ = 8						; size = 4
_bWater$ = 12						; size = 1
_bConstructorCall$ = 16					; size = 1
?reset@CvArea@@QAEXH_N0@Z PROC				; CvArea::reset, COMDAT
; _this$ = ecx

; 70   : {

	push	ebx
	push	esi
	mov	esi, ecx

; 71   : 	int iI, iJ;
; 72   : 
; 73   : 	//--------------------------------
; 74   : 	// Uninit class
; 75   : 	uninit();

	mov	eax, DWORD PTR [esi+4204]
	push	edi
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	xor	ebx, ebx
	mov	DWORD PTR [esi+4204], ebx
	mov	ecx, DWORD PTR [esi+4208]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]

; 76   : 
; 77   : 	m_iID = iID;
; 78   : 	m_iNumTiles = 0;
; 79   : 	m_iNumOwnedTiles = 0;
; 80   : 	m_iNumRiverEdges = 0;
; 81   : 	m_iNumUnits = 0;
; 82   : 	m_iNumCities = 0;
; 83   : 	m_iTotalPopulation = 0;
; 84   : 	m_iNumStartingPlots = 0;
; 85   : 	m_iNumNaturalWonders = 0;
; 86   : 	m_iTotalFoundValue = 0;
; 87   : 	m_Boundaries.m_iNorthEdge = 0;
; 88   : 	m_Boundaries.m_iSouthEdge = 0;
; 89   : 	m_Boundaries.m_iEastEdge = 0;
; 90   : 	m_Boundaries.m_iWestEdge = 0;
; 91   : 
; 92   : 	m_bWater = bWater;

	mov	al, BYTE PTR _bWater$[esp+16]
	mov	edx, DWORD PTR _iID$[esp+16]
	mov	DWORD PTR [esi+4208], ebx
	mov	BYTE PTR [esi+4228], al
	add	esp, 8
	mov	DWORD PTR [esi+4], edx
	mov	DWORD PTR [esi+8], ebx
	mov	DWORD PTR [esi+12], ebx
	mov	DWORD PTR [esi+16], ebx
	mov	DWORD PTR [esi+20], ebx
	mov	DWORD PTR [esi+24], ebx
	mov	DWORD PTR [esi+28], ebx
	mov	DWORD PTR [esi+32], ebx
	mov	DWORD PTR [esi+36], ebx
	mov	DWORD PTR [esi+40], ebx
	mov	DWORD PTR [esi+4212], ebx
	mov	DWORD PTR [esi+4216], ebx
	mov	DWORD PTR [esi+4220], ebx
	mov	DWORD PTR [esi+4224], ebx

; 93   : 	m_bMountains = false;

	mov	BYTE PTR [esi+4229], bl
	lea	eax, DWORD PTR [esi+364]
	lea	ecx, DWORD PTR [ebx+80]
$LL22@reset:

; 94   : 
; 95   : 	for(iI = 0; iI < REALLY_MAX_PLAYERS; iI++)
; 96   : 	{
; 97   : 		m_aiUnitsPerPlayer[iI] = 0;

	mov	DWORD PTR [eax-320], ebx

; 98   : 		m_aiCitiesPerPlayer[iI] = 0;

	mov	DWORD PTR [eax], ebx

; 99   : 		m_aiPopulationPerPlayer[iI] = 0;

	mov	DWORD PTR [eax+320], ebx

; 100  : 		m_aiFreeSpecialist[iI] = 0;

	mov	DWORD PTR [eax+640], ebx
	add	eax, 4
	sub	ecx, 1
	jne	SHORT $LL22@reset

; 101  : 	}
; 102  : 
; 103  : 	for(iI = 0; iI < REALLY_MAX_TEAMS; iI++)
; 104  : 	{
; 105  : 		m_aiNumRevealedTiles[iI] = 0;

	xor	eax, eax
	lea	edi, DWORD PTR [esi+1324]
	mov	ecx, 80					; 00000050H
	rep stosd

; 106  : 	}
; 107  : 
; 108  : 	for(iI = 0; iI < REALLY_MAX_PLAYERS; iI++)

	lea	eax, DWORD PTR [esi+1644]
	mov	ecx, 80					; 00000050H
	or	edx, -1
	npad	6
$LL16@reset:

; 109  : 	{
; 110  : 		m_aTargetCities[iI].reset();

	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], edx
	add	eax, 8
	sub	ecx, 1
	jne	SHORT $LL16@reset

; 111  : 	}
; 112  : 
; 113  : 	for(iI = 0; iI < REALLY_MAX_PLAYERS; iI++)
; 114  : 	{
; 115  : 		for(iJ = 0; iJ < NUM_YIELD_TYPES; iJ++)
; 116  : 		{
; 117  : 			m_aaiYieldRateModifier[iI][iJ] = 0;

	xor	eax, eax
	lea	edi, DWORD PTR [esi+2284]
	mov	ecx, 480				; 000001e0H
	rep stosd

; 118  : 		}
; 119  : 	}
; 120  : 
; 121  : 	if(!bConstructorCall)

	cmp	BYTE PTR _bConstructorCall$[esp+8], bl
	jne	SHORT $LN1@reset

; 122  : 	{
; 123  : 		CvAssertMsg((0 < GC.getNumResourceInfos()) && "GC.getNumResourceInfos() is not greater than zero but an array is being allocated in CvArea::reset", "GC.getNumResourceInfos() is not greater than zero but an array is being allocated in CvArea::reset");
; 124  : 		int numRIs = GC.getNumResourceInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos

; 125  : 		m_paiNumResources = FNEW(int[numRIs], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	mov	edi, eax
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+4204], eax
	add	esp, 4

; 126  : 		for(iI = 0; iI < numRIs; iI++)

	xor	eax, eax
	cmp	edi, ebx
	jle	SHORT $LN4@reset
$LL6@reset:

; 127  : 		{
; 128  : 			m_paiNumResources[iI] = 0;

	mov	ecx, DWORD PTR [esi+4204]
	mov	DWORD PTR [ecx+eax*4], ebx
	inc	eax
	cmp	eax, edi
	jl	SHORT $LL6@reset
$LN4@reset:

; 129  : 		}
; 130  : 
; 131  : 		CvAssertMsg((0 < GC.getNumImprovementInfos()) && "GC.getNumImprovementInfos() is not greater than zero but an array is being allocated in CvArea::reset", "GC.getNumImprovementInfos() is not greater than zero but an array is being allocated in CvArea::reset");
; 132  : 		int numIIs = GC.getNumImprovementInfos();

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumImprovementInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumImprovementInfos

; 133  : 		m_paiNumImprovements = FNEW(int[numIIs], c_eCiv5GameplayDLL, 0);

	xor	ecx, ecx
	mov	edi, eax
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [esi+4208], eax
	add	esp, 4

; 134  : 		for(iI = 0; iI < numIIs; iI++)

	xor	eax, eax
	cmp	edi, ebx
	jle	SHORT $LN1@reset
$LL3@reset:

; 135  : 		{
; 136  : 			m_paiNumImprovements[iI] = 0;

	mov	ecx, DWORD PTR [esi+4208]
	mov	DWORD PTR [ecx+eax*4], ebx
	inc	eax
	cmp	eax, edi
	jl	SHORT $LL3@reset
$LN1@reset:
	pop	edi
	pop	esi
	pop	ebx

; 137  : 		}
; 138  : 	}
; 139  : }

	ret	12					; 0000000cH
?reset@CvArea@@QAEXH_N0@Z ENDP				; CvArea::reset
_TEXT	ENDS
PUBLIC	?calculateTotalBestNatureYield@CvArea@@QBEHXZ	; CvArea::calculateTotalBestNatureYield
EXTRN	?calculateTotalBestNatureYield@CvPlot@@QBEHW4TeamTypes@@@Z:PROC ; CvPlot::calculateTotalBestNatureYield
; Function compile flags: /Ogtpy
;	COMDAT ?calculateTotalBestNatureYield@CvArea@@QBEHXZ
_TEXT	SEGMENT
_iCount$ = -4						; size = 4
?calculateTotalBestNatureYield@CvArea@@QBEHXZ PROC	; CvArea::calculateTotalBestNatureYield, COMDAT
; _this$ = ecx

; 149  : {

	push	ecx
	push	ebp
	push	edi

; 150  : 	CvPlot* pLoopPlot;
; 151  : 	int iCount;
; 152  : 	int iI;
; 153  : 
; 154  : 	iCount = 0;
; 155  : 
; 156  : 	CvMap& theMap = GC.getMap();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 157  : 	int iNumPlots = theMap.numPlots();

	mov	eax, DWORD PTR [edi+4028]
	mov	ebp, ecx
	xor	ecx, ecx
	mov	DWORD PTR _iCount$[esp+12], ecx

; 158  : 	for(iI = 0; iI < iNumPlots; iI++)

	test	eax, eax
	jle	SHORT $LN19@calculateT
	push	ebx
	push	esi
	xor	esi, esi
	mov	ebx, eax
$LL4@calculateT:

; 159  : 	{
; 160  : 		pLoopPlot = theMap.plotByIndexUnchecked(iI);

	mov	ecx, DWORD PTR [edi+4068]

; 161  : 
; 162  : 		if(pLoopPlot->getArea() == GetID())

	mov	eax, DWORD PTR [ecx+esi+356]
	add	ecx, esi
	cmp	eax, DWORD PTR [ebp+4]
	jne	SHORT $LN3@calculateT

; 163  : 		{
; 164  : 			iCount += pLoopPlot->calculateTotalBestNatureYield(NO_TEAM);

	push	-1
	call	?calculateTotalBestNatureYield@CvPlot@@QBEHW4TeamTypes@@@Z ; CvPlot::calculateTotalBestNatureYield
	add	DWORD PTR _iCount$[esp+20], eax
$LN3@calculateT:
	add	esi, 484				; 000001e4H
	sub	ebx, 1
	jne	SHORT $LL4@calculateT

; 165  : 		}
; 166  : 	}
; 167  : 
; 168  : 	return iCount;

	mov	eax, DWORD PTR _iCount$[esp+20]
	pop	esi
	pop	ebx
	pop	edi
	pop	ebp

; 169  : }

	pop	ecx
	ret	0
$LN19@calculateT:
	pop	edi

; 165  : 		}
; 166  : 	}
; 167  : 
; 168  : 	return iCount;

	mov	eax, ecx
	pop	ebp

; 169  : }

	pop	ecx
	ret	0
?calculateTotalBestNatureYield@CvArea@@QBEHXZ ENDP	; CvArea::calculateTotalBestNatureYield
_TEXT	ENDS
PUBLIC	?countCoastalLand@CvArea@@QBEHXZ		; CvArea::countCoastalLand
EXTRN	?isCoastalLand@CvPlot@@QBE_NH@Z:PROC		; CvPlot::isCoastalLand
; Function compile flags: /Ogtpy
;	COMDAT ?countCoastalLand@CvArea@@QBEHXZ
_TEXT	SEGMENT
_iCount$ = -4						; size = 4
?countCoastalLand@CvArea@@QBEHXZ PROC			; CvArea::countCoastalLand, COMDAT
; _this$ = ecx

; 174  : {

	push	ecx
	push	ebp
	mov	ebp, ecx

; 175  : 	CvPlot* pLoopPlot;
; 176  : 	int iCount;
; 177  : 	int iI;
; 178  : 
; 179  : 	if(isWater())

	cmp	BYTE PTR [ebp+4228], 0
	je	SHORT $LN6@countCoast

; 180  : 	{
; 181  : 		return 0;

	xor	eax, eax
	pop	ebp

; 202  : }

	pop	ecx
	ret	0
$LN6@countCoast:
	push	edi

; 182  : 	}
; 183  : 
; 184  : 	iCount = 0;
; 185  : 
; 186  : 	CvMap& theMap = GC.getMap();

	mov	edi, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 187  : 	int iNumPlots = theMap.numPlots();

	mov	eax, DWORD PTR [edi+4028]
	mov	DWORD PTR _iCount$[esp+12], 0

; 188  : 	for(iI = 0; iI < iNumPlots; iI++)

	test	eax, eax
	jle	SHORT $LN3@countCoast
	push	ebx
	push	esi
	xor	esi, esi
	mov	ebx, eax
$LL5@countCoast:

; 189  : 	{
; 190  : 		pLoopPlot = theMap.plotByIndexUnchecked(iI);

	mov	ecx, DWORD PTR [edi+4068]

; 191  : 
; 192  : 		if(pLoopPlot->getArea() == GetID())

	mov	eax, DWORD PTR [ecx+esi+356]
	add	ecx, esi
	cmp	eax, DWORD PTR [ebp+4]
	jne	SHORT $LN4@countCoast

; 193  : 		{
; 194  : 			if(pLoopPlot->isCoastalLand())

	push	-1
	call	?isCoastalLand@CvPlot@@QBE_NH@Z		; CvPlot::isCoastalLand
	test	al, al
	je	SHORT $LN4@countCoast

; 195  : 			{
; 196  : 				iCount++;

	inc	DWORD PTR _iCount$[esp+20]
$LN4@countCoast:

; 188  : 	for(iI = 0; iI < iNumPlots; iI++)

	add	esi, 484				; 000001e4H
	sub	ebx, 1
	jne	SHORT $LL5@countCoast
	pop	esi
	pop	ebx
$LN3@countCoast:

; 197  : 			}
; 198  : 		}
; 199  : 	}
; 200  : 
; 201  : 	return iCount;

	mov	eax, DWORD PTR _iCount$[esp+12]
	pop	edi
	pop	ebp

; 202  : }

	pop	ecx
	ret	0
?countCoastalLand@CvArea@@QBEHXZ ENDP			; CvArea::countCoastalLand
_TEXT	ENDS
PUBLIC	?setTargetCity@CvArea@@QAEXW4PlayerTypes@@PAVCvCity@@@Z ; CvArea::setTargetCity
EXTRN	?GetIDInfo@CvCity@@QBE?AUIDInfo@@XZ:PROC	; CvCity::GetIDInfo
; Function compile flags: /Ogtpy
;	COMDAT ?setTargetCity@CvArea@@QAEXW4PlayerTypes@@PAVCvCity@@@Z
_TEXT	SEGMENT
$T219025 = -8						; size = 8
_eIndex$ = 8						; size = 4
_pNewValue$ = 12					; size = 4
?setTargetCity@CvArea@@QAEXW4PlayerTypes@@PAVCvCity@@@Z PROC ; CvArea::setTargetCity, COMDAT
; _this$ = ecx

; 533  : {

	sub	esp, 8
	push	esi
	push	edi

; 534  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be >= 0");
; 535  : 	CvAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be < MAX_PLAYERS");
; 536  : 	if(eIndex < 0 || eIndex >= MAX_PLAYERS) return;

	mov	edi, DWORD PTR _eIndex$[esp+12]
	mov	esi, ecx
	cmp	edi, 63					; 0000003fH
	ja	SHORT $LN3@setTargetC

; 537  : 
; 538  : 	if(pNewValue != NULL)

	mov	ecx, DWORD PTR _pNewValue$[esp+12]
	test	ecx, ecx
	je	SHORT $LN2@setTargetC

; 539  : 	{
; 540  : 		m_aTargetCities[eIndex] = pNewValue->GetIDInfo();

	lea	eax, DWORD PTR $T219025[esp+16]
	push	eax
	call	?GetIDInfo@CvCity@@QBE?AUIDInfo@@XZ	; CvCity::GetIDInfo
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [esi+edi*8+1644], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+edi*8+1648], edx
	pop	edi
	pop	esi

; 545  : 	}
; 546  : }

	add	esp, 8
	ret	8
$LN2@setTargetC:

; 541  : 	}
; 542  : 	else
; 543  : 	{
; 544  : 		m_aTargetCities[eIndex].reset();

	or	eax, -1
	mov	DWORD PTR [esi+edi*8+1644], eax
	mov	DWORD PTR [esi+edi*8+1648], eax
$LN3@setTargetC:
	pop	edi
	pop	esi

; 545  : 	}
; 546  : }

	add	esp, 8
	ret	8
?setTargetCity@CvArea@@QAEXW4PlayerTypes@@PAVCvCity@@@Z ENDP ; CvArea::setTargetCity
_TEXT	ENDS
PUBLIC	?GetTopAndBottomLatitudes@CvArea@@QAEXAAH0@Z	; CvArea::GetTopAndBottomLatitudes
EXTRN	?getBottomLatitude@CvMap@@QAEHXZ:PROC		; CvMap::getBottomLatitude
EXTRN	?getTopLatitude@CvMap@@QAEHXZ:PROC		; CvMap::getTopLatitude
; Function compile flags: /Ogtpy
;	COMDAT ?GetTopAndBottomLatitudes@CvArea@@QAEXAAH0@Z
_TEXT	SEGMENT
_iTopLatitude$ = 8					; size = 4
_iBottomLatitude$ = 12					; size = 4
?GetTopAndBottomLatitudes@CvArea@@QAEXAAH0@Z PROC	; CvArea::GetTopAndBottomLatitudes, COMDAT
; _this$ = ecx

; 665  : 	int iGridHeight = GC.getMap().getGridHeight();

	mov	eax, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52

; 666  : 	if(GC.getMap().isWrapX() || !(GC.getMap().isWrapY()))

	cmp	BYTE PTR [eax+4056], 0
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR [eax+4024]
	jne	SHORT $LN2@GetTopAndB
	cmp	BYTE PTR [eax+4057], 0
	je	SHORT $LN2@GetTopAndB

; 670  : 	}
; 671  : 	else
; 672  : 	{
; 673  : 		iTopLatitude = ((m_Boundaries.m_iEastEdge * 100) / iGridHeight);

	mov	eax, DWORD PTR [ecx+4220]
	imul	eax, 100				; 00000064H
	cdq
	idiv	edi
	mov	esi, DWORD PTR _iTopLatitude$[esp+8]
	mov	DWORD PTR [esi], eax

; 674  : 		iBottomLatitude = ((m_Boundaries.m_iWestEdge * 100) / iGridHeight);

	mov	eax, DWORD PTR [ecx+4224]
	jmp	SHORT $LN22@GetTopAndB
$LN2@GetTopAndB:

; 667  : 	{
; 668  : 		iTopLatitude = ((m_Boundaries.m_iNorthEdge * 100) / iGridHeight);

	mov	eax, DWORD PTR [ecx+4212]
	imul	eax, 100				; 00000064H
	cdq
	idiv	edi
	mov	esi, DWORD PTR _iTopLatitude$[esp+8]
	mov	DWORD PTR [esi], eax

; 669  : 		iBottomLatitude = ((m_Boundaries.m_iSouthEdge * 100) / iGridHeight);

	mov	eax, DWORD PTR [ecx+4216]
$LN22@GetTopAndB:
	imul	eax, 100				; 00000064H
	cdq
	idiv	edi
	mov	edi, DWORD PTR _iBottomLatitude$[esp+8]
	mov	DWORD PTR [edi], eax

; 675  : 	}
; 676  : 
; 677  : 	int iMapTop = GC.getMap().getTopLatitude();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	call	?getTopLatitude@CvMap@@QAEHXZ		; CvMap::getTopLatitude

; 678  : 	int iMapBottom = GC.getMap().getBottomLatitude();

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+52
	mov	ebx, eax
	call	?getBottomLatitude@CvMap@@QAEHXZ	; CvMap::getBottomLatitude

; 679  : 
; 680  : 	iTopLatitude = ((iTopLatitude * (iMapTop - iMapBottom)) / 100);

	mov	edx, DWORD PTR [esi]
	mov	ecx, eax
	sub	ebx, ecx
	imul	edx, ebx
	mov	eax, 1374389535				; 51eb851fH
	imul	edx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR [esi], eax

; 681  : 	iBottomLatitude = ((iBottomLatitude * (iMapTop - iMapBottom)) / 100);

	mov	edx, DWORD PTR [edi]
	imul	edx, ebx
	mov	eax, 1374389535				; 51eb851fH
	imul	edx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR [edi], eax

; 682  : 
; 683  : 	iTopLatitude = abs(iTopLatitude + iMapBottom);

	mov	eax, DWORD PTR [esi]
	add	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR [esi], eax

; 684  : 	iBottomLatitude = abs(iBottomLatitude + iMapBottom);

	mov	eax, DWORD PTR [edi]
	add	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR [edi], eax
	pop	edi
	pop	esi
	pop	ebx

; 685  : }

	ret	8
?GetTopAndBottomLatitudes@CvArea@@QAEXAAH0@Z ENDP	; CvArea::GetTopAndBottomLatitudes
_TEXT	ENDS
PUBLIC	?GetAreaMaxLatitude@CvArea@@QAEHXZ		; CvArea::GetAreaMaxLatitude
; Function compile flags: /Ogtpy
;	COMDAT ?GetAreaMaxLatitude@CvArea@@QAEHXZ
_TEXT	SEGMENT
_iBottomLatitude$ = -8					; size = 4
_iTopLatitude$ = -4					; size = 4
?GetAreaMaxLatitude@CvArea@@QAEHXZ PROC			; CvArea::GetAreaMaxLatitude, COMDAT
; _this$ = ecx

; 690  : {

	sub	esp, 8

; 691  : 	int iTopLatitude, iBottomLatitude;
; 692  : 	GetTopAndBottomLatitudes(iTopLatitude, iBottomLatitude);

	lea	eax, DWORD PTR _iBottomLatitude$[esp+8]
	push	eax
	lea	edx, DWORD PTR _iTopLatitude$[esp+12]
	push	edx
	call	?GetTopAndBottomLatitudes@CvArea@@QAEXAAH0@Z ; CvArea::GetTopAndBottomLatitudes

; 693  : 
; 694  : 	return max(iTopLatitude, iBottomLatitude);

	mov	eax, DWORD PTR _iTopLatitude$[esp+8]
	cmp	eax, DWORD PTR _iBottomLatitude$[esp+8]
	lea	eax, DWORD PTR _iBottomLatitude$[esp+8]
	jl	SHORT $LN7@GetAreaMax
	lea	eax, DWORD PTR _iTopLatitude$[esp+8]
$LN7@GetAreaMax:
	mov	eax, DWORD PTR [eax]

; 695  : }

	add	esp, 8
	ret	0
?GetAreaMaxLatitude@CvArea@@QAEHXZ ENDP			; CvArea::GetAreaMaxLatitude
_TEXT	ENDS
PUBLIC	?GetAreaMinLatitude@CvArea@@QAEHXZ		; CvArea::GetAreaMinLatitude
; Function compile flags: /Ogtpy
;	COMDAT ?GetAreaMinLatitude@CvArea@@QAEHXZ
_TEXT	SEGMENT
_iBottomLatitude$ = -8					; size = 4
_iTopLatitude$ = -4					; size = 4
?GetAreaMinLatitude@CvArea@@QAEHXZ PROC			; CvArea::GetAreaMinLatitude, COMDAT
; _this$ = ecx

; 700  : {

	sub	esp, 8

; 701  : 	int iTopLatitude, iBottomLatitude;
; 702  : 	GetTopAndBottomLatitudes(iTopLatitude, iBottomLatitude);

	lea	eax, DWORD PTR _iBottomLatitude$[esp+8]
	push	eax
	lea	edx, DWORD PTR _iTopLatitude$[esp+12]
	push	edx
	call	?GetTopAndBottomLatitudes@CvArea@@QAEXAAH0@Z ; CvArea::GetTopAndBottomLatitudes

; 703  : 
; 704  : 	return min(iTopLatitude, iBottomLatitude);

	mov	eax, DWORD PTR _iBottomLatitude$[esp+8]
	cmp	eax, DWORD PTR _iTopLatitude$[esp+8]
	lea	eax, DWORD PTR _iBottomLatitude$[esp+8]
	jl	SHORT $LN7@GetAreaMin
	lea	eax, DWORD PTR _iTopLatitude$[esp+8]
$LN7@GetAreaMin:
	mov	eax, DWORD PTR [eax]

; 705  : }

	add	esp, 8
	ret	0
?GetAreaMinLatitude@CvArea@@QAEHXZ ENDP			; CvArea::GetAreaMinLatitude
_TEXT	ENDS
PUBLIC	??$?5H$0FA@@@YAAAVFDataStream@@AAV0@AAY0FA@H@Z	; operator>><int,80>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?5H$0FA@@@YAAAVFDataStream@@AAV0@AAY0FA@H@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5H$0FA@@@YAAAVFDataStream@@AAV0@AAY0FA@H@Z PROC	; operator>><int,80>, COMDAT

; 234  : {

	push	ebx
	push	esi

; 235  : 	size_t i = 0;
; 236  : 	for(i = 0; i < count; ++i)

	mov	esi, DWORD PTR _writeTo$[esp+4]
	push	edi
	mov	edi, DWORD PTR _loadFrom$[esp+8]
	mov	ebx, 80					; 00000050H
$LL3@operator:

; 237  : 	{
; 238  : 		loadFrom >> writeTo[i];

	push	esi
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	esi, 4
	sub	ebx, 1
	jne	SHORT $LL3@operator

; 239  : 	}
; 240  : 	return loadFrom;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 241  : }

	ret	0
??$?5H$0FA@@@YAAAVFDataStream@@AAV0@AAY0FA@H@Z ENDP	; operator>><int,80>
_TEXT	ENDS
PUBLIC	??$?5H$05@@YAAAVFDataStream@@AAV0@AAY05H@Z	; operator>><int,6>
; Function compile flags: /Ogtpy
;	COMDAT ??$?5H$05@@YAAAVFDataStream@@AAV0@AAY05H@Z
_TEXT	SEGMENT
_loadFrom$ = 8						; size = 4
_writeTo$ = 12						; size = 4
??$?5H$05@@YAAAVFDataStream@@AAV0@AAY05H@Z PROC		; operator>><int,6>, COMDAT

; 234  : {

	push	ebx
	push	esi

; 235  : 	size_t i = 0;
; 236  : 	for(i = 0; i < count; ++i)

	mov	esi, DWORD PTR _writeTo$[esp+4]
	push	edi
	mov	edi, DWORD PTR _loadFrom$[esp+8]
	mov	ebx, 6
$LL3@operator@2:

; 237  : 	{
; 238  : 		loadFrom >> writeTo[i];

	push	esi
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	esi, 4
	sub	ebx, 1
	jne	SHORT $LL3@operator@2

; 239  : 	}
; 240  : 	return loadFrom;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 241  : }

	ret	0
??$?5H$05@@YAAAVFDataStream@@AAV0@AAY05H@Z ENDP		; operator>><int,6>
_TEXT	ENDS
PUBLIC	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>
EXTRN	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z:PROC ; CvInfosSerializationHelper::ReadHashed
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvinfosserializationhelper.h
;	COMDAT ??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z
_TEXT	SEGMENT
_bValid$218425 = -13					; size = 1
_uiNumEntries$ = -12					; size = 4
_tValue$218428 = -8					; size = 4
_tValue$218433 = -4					; size = 4
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_iArraySize$ = 16					; size = 4
??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z PROC ; CvInfosSerializationHelper::ReadHashedDataArray<int>, COMDAT

; 248  : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	edi

; 249  : 	uint uiNumEntries;
; 250  : 
; 251  : 	kStream >> uiNumEntries;

	mov	edi, DWORD PTR _kStream$[esp+20]
	lea	eax, DWORD PTR _uiNumEntries$[esp+24]
	push	eax
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 252  : 
; 253  : 	for(uint iI = 0; iI < uiNumEntries; iI++)

	xor	ebx, ebx
	cmp	DWORD PTR _uiNumEntries$[esp+24], ebx
	jbe	SHORT $LN5@ReadHashed
	push	ebp
	mov	ebp, DWORD PTR _iArraySize$[esp+24]
	push	esi
$LL7@ReadHashed:

; 254  : 	{
; 255  : 		bool bValid;
; 256  : 		int iType = ReadHashed(kStream, &bValid);

	lea	ecx, DWORD PTR _bValid$218425[esp+32]
	push	ecx
	push	edi
	call	?ReadHashed@CvInfosSerializationHelper@@YAHAAVFDataStream@@PA_N@Z ; CvInfosSerializationHelper::ReadHashed
	mov	esi, eax
	add	esp, 8

; 257  : 		if(iType != -1)

	cmp	esi, -1
	je	SHORT $LN4@ReadHashed

; 258  : 		{
; 259  : 			TData tValue;
; 260  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$218428[esp+32]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 261  : 			if((int)iType < iArraySize)

	cmp	esi, ebp
	jge	SHORT $LN6@ReadHashed

; 262  : 				paArray[iType] = tValue;

	mov	eax, DWORD PTR _tValue$218428[esp+32]
	mov	ecx, DWORD PTR _paArray$[esp+28]
	mov	DWORD PTR [ecx+esi*4], eax

; 263  : 		}

	jmp	SHORT $LN6@ReadHashed
$LN4@ReadHashed:

; 264  : 		else if(!bValid)

	cmp	BYTE PTR _bValid$218425[esp+32], 0
	jne	SHORT $LN6@ReadHashed

; 265  : 		{
; 266  : 			TData tValue;
; 267  : 			kStream >> tValue;

	lea	edx, DWORD PTR _tValue$218433[esp+32]
	push	edx
	mov	ecx, edi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
$LN6@ReadHashed:
	inc	ebx
	cmp	ebx, DWORD PTR _uiNumEntries$[esp+32]
	jb	SHORT $LL7@ReadHashed
	pop	esi
	pop	ebp
$LN5@ReadHashed:
	pop	edi
	pop	ebx

; 268  : 		}
; 269  : 	}
; 270  : }

	add	esp, 16					; 00000010H
	ret	0
??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ENDP ; CvInfosSerializationHelper::ReadHashedDataArray<int>
_TEXT	ENDS
PUBLIC	??$?6H$0FA@@@YAAAVFDataStream@@AAV0@AAY0FA@$$CBH@Z ; operator<<<int,80>
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\fireplace\include\fireworks\fdatastream.h
;	COMDAT ??$?6H$0FA@@@YAAAVFDataStream@@AAV0@AAY0FA@$$CBH@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??$?6H$0FA@@@YAAAVFDataStream@@AAV0@AAY0FA@$$CBH@Z PROC	; operator<<<int,80>, COMDAT

; 223  : {

	push	ebx
	push	esi

; 224  : 	size_t i = 0;
; 225  : 	for(i = 0; i < count; ++i)

	mov	esi, DWORD PTR _readFrom$[esp+4]
	push	edi
	mov	edi, DWORD PTR _saveTo$[esp+8]
	mov	ebx, 80					; 00000050H
$LL3@operator@3:

; 226  : 	{
; 227  : 		saveTo << readFrom[i];

	push	esi
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	esi, 4
	sub	ebx, 1
	jne	SHORT $LL3@operator@3

; 228  : 	}
; 229  : 	return saveTo;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 230  : }

	ret	0
??$?6H$0FA@@@YAAAVFDataStream@@AAV0@AAY0FA@$$CBH@Z ENDP	; operator<<<int,80>
_TEXT	ENDS
PUBLIC	??$?6H$05@@YAAAVFDataStream@@AAV0@AAY05$$CBH@Z	; operator<<<int,6>
; Function compile flags: /Ogtpy
;	COMDAT ??$?6H$05@@YAAAVFDataStream@@AAV0@AAY05$$CBH@Z
_TEXT	SEGMENT
_saveTo$ = 8						; size = 4
_readFrom$ = 12						; size = 4
??$?6H$05@@YAAAVFDataStream@@AAV0@AAY05$$CBH@Z PROC	; operator<<<int,6>, COMDAT

; 223  : {

	push	ebx
	push	esi

; 224  : 	size_t i = 0;
; 225  : 	for(i = 0; i < count; ++i)

	mov	esi, DWORD PTR _readFrom$[esp+4]
	push	edi
	mov	edi, DWORD PTR _saveTo$[esp+8]
	mov	ebx, 6
$LL3@operator@4:

; 226  : 	{
; 227  : 		saveTo << readFrom[i];

	push	esi
	mov	ecx, edi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	esi, 4
	sub	ebx, 1
	jne	SHORT $LL3@operator@4

; 228  : 	}
; 229  : 	return saveTo;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 230  : }

	ret	0
??$?6H$05@@YAAAVFDataStream@@AAV0@AAY05$$CBH@Z ENDP	; operator<<<int,6>
_TEXT	ENDS
PUBLIC	??$WriteHashedDataArray@W4ResourceTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ; CvInfosSerializationHelper::WriteHashedDataArray<enum ResourceTypes,int>
EXTRN	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4ResourceTypes@@@Z:PROC ; CvInfosSerializationHelper::WriteHashed
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvinfosserializationhelper.h
;	COMDAT ??$WriteHashedDataArray@W4ResourceTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z
_TEXT	SEGMENT
_kStream$ = 8						; size = 4
_paArray$ = 12						; size = 4
_uiArraySize$ = 16					; size = 4
??$WriteHashedDataArray@W4ResourceTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z PROC ; CvInfosSerializationHelper::WriteHashedDataArray<enum ResourceTypes,int>, COMDAT

; 559  : {

	push	ebx

; 560  : 	kStream << uiArraySize;

	mov	ebx, DWORD PTR _kStream$[esp]
	push	esi
	lea	eax, DWORD PTR _uiArraySize$[esp+4]
	push	eax
	mov	ecx, ebx
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 561  : 
; 562  : 	for(uint iI = 0; iI < uiArraySize; iI++)

	xor	esi, esi
	cmp	DWORD PTR _uiArraySize$[esp+4], esi
	jbe	SHORT $LN2@WriteHashe
	push	edi
	mov	edi, DWORD PTR _paArray$[esp+8]
	npad	1
$LL4@WriteHashe:

; 563  : 	{
; 564  : 		const TType eType = static_cast<TType>(iI);
; 565  : 		if(WriteHashed(kStream, eType))

	push	esi
	push	ebx
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4ResourceTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	test	al, al
	je	SHORT $LN3@WriteHashe

; 566  : 		{
; 567  : 			kStream << paArray[iI];

	push	edi
	mov	ecx, ebx
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
$LN3@WriteHashe:
	inc	esi
	add	edi, 4
	cmp	esi, DWORD PTR _uiArraySize$[esp+8]
	jb	SHORT $LL4@WriteHashe
	pop	edi
$LN2@WriteHashe:
	pop	esi
	pop	ebx

; 568  : 		}
; 569  : 	}
; 570  : }

	ret	0
??$WriteHashedDataArray@W4ResourceTypes@@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHI@Z ENDP ; CvInfosSerializationHelper::WriteHashedDataArray<enum ResourceTypes,int>
_TEXT	ENDS
EXTRN	?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B:DWORD ; CvPreGame::sr_TeamTypes
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvpregame.h
;	COMDAT ?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z
_TEXT	SEGMENT
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z PROC ; CvPreGame::teamType, COMDAT
; _p$ = eax

; 299  : 	if(p >= 0 && p < MAX_PLAYERS)

	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN1@teamType

; 300  : 		return sr_TeamTypes[p];

	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 302  : }

	ret	0
$LN1@teamType:

; 301  : 	return NO_TEAM;

	or	eax, -1

; 302  : }

	ret	0
?teamType@CvPreGame@@YA?AW4TeamTypes@@W4PlayerTypes@@@Z ENDP ; CvPreGame::teamType
_TEXT	ENDS
PUBLIC	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ		; CvPlayer::getTeam
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvplayer.h
;	COMDAT ?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ
_TEXT	SEGMENT
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ PROC		; CvPlayer::getTeam, COMDAT
; _this$ = ecx

; 1178 : 		return CvPreGame::teamType(m_eID);

	mov	eax, DWORD PTR [ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN5@getTeam
	mov	ecx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 1179 : 	}

	ret	0

; 1178 : 		return CvPreGame::teamType(m_eID);

$LN5@getTeam:
	or	eax, -1

; 1179 : 	}

	ret	0
?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ ENDP		; CvPlayer::getTeam
_TEXT	ENDS
PUBLIC	??_7CvArea@@6B@					; CvArea::`vftable'
PUBLIC	??0CvArea@@QAE@XZ				; CvArea::CvArea
PUBLIC	??_R4CvArea@@6B@				; CvArea::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvArea@@@8				; CvArea `RTTI Type Descriptor'
PUBLIC	??_R3CvArea@@8					; CvArea::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvArea@@8					; CvArea::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvArea@@8				; CvArea::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?read@CvArea@@UAEXAAVFDataStream@@@Z		; CvArea::read
PUBLIC	?write@CvArea@@UBEXAAVFDataStream@@@Z		; CvArea::write
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
;	COMDAT ??_R1A@?0A@EA@CvArea@@8
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvarea.h
rdata$r	SEGMENT
??_R1A@?0A@EA@CvArea@@8 DD FLAT:??_R0?AVCvArea@@@8	; CvArea::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvArea@@8
rdata$r	ENDS
;	COMDAT ??_R2CvArea@@8
rdata$r	SEGMENT
??_R2CvArea@@8 DD FLAT:??_R1A@?0A@EA@CvArea@@8		; CvArea::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CvArea@@8
rdata$r	SEGMENT
??_R3CvArea@@8 DD 00H					; CvArea::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CvArea@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvArea@@@8
_DATA	SEGMENT
??_R0?AVCvArea@@@8 DD FLAT:??_7type_info@@6B@		; CvArea `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvArea@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvArea@@6B@
rdata$r	SEGMENT
??_R4CvArea@@6B@ DD 00H					; CvArea::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvArea@@@8
	DD	FLAT:??_R3CvArea@@8
rdata$r	ENDS
;	COMDAT ??_7CvArea@@6B@
CONST	SEGMENT
??_7CvArea@@6B@ DD FLAT:??_R4CvArea@@6B@		; CvArea::`vftable'
	DD	FLAT:?read@CvArea@@UAEXAAVFDataStream@@@Z
	DD	FLAT:?write@CvArea@@UBEXAAVFDataStream@@@Z
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\desktop\lekmod files\lekmod dll versions\v29\lekmod_dll\cvgamecoredll_expansion2\cvarea.cpp
CONST	ENDS
;	COMDAT ??0CvArea@@QAE@XZ
_TEXT	SEGMENT
??0CvArea@@QAE@XZ PROC					; CvArea::CvArea, COMDAT
; _this$ = ecx

; 29   : {

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvArea@@6B@
	lea	eax, DWORD PTR [esi+1644]
	mov	ecx, 79					; 0000004fH
	or	edx, -1
$LL4@CvArea:
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], edx
	add	eax, 8
	sub	ecx, 1
	jns	SHORT $LL4@CvArea
	xor	eax, eax

; 30   : 	m_paiNumResources = NULL;
; 31   : 	m_paiNumImprovements = NULL;
; 32   : 	reset(0, false, true);

	push	1
	push	eax
	mov	DWORD PTR [esi+4212], eax
	mov	DWORD PTR [esi+4216], eax
	mov	DWORD PTR [esi+4220], eax
	mov	DWORD PTR [esi+4224], eax
	push	eax
	mov	ecx, esi
	mov	DWORD PTR [esi+4204], eax
	mov	DWORD PTR [esi+4208], eax
	call	?reset@CvArea@@QAEXH_N0@Z		; CvArea::reset

; 33   : }

	mov	eax, esi
	pop	esi
	ret	0
??0CvArea@@QAE@XZ ENDP					; CvArea::CvArea
_TEXT	ENDS
PUBLIC	??1CvArea@@QAE@XZ				; CvArea::~CvArea
; Function compile flags: /Ogtpy
;	COMDAT ??1CvArea@@QAE@XZ
_TEXT	SEGMENT
??1CvArea@@QAE@XZ PROC					; CvArea::~CvArea, COMDAT
; _this$ = ecx

; 38   : {

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvArea@@6B@

; 39   : 	uninit();

	mov	eax, DWORD PTR [esi+4204]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [esi+4204], 0
	mov	ecx, DWORD PTR [esi+4208]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 8
	mov	DWORD PTR [esi+4208], 0
	pop	esi

; 40   : }

	ret	0
??1CvArea@@QAE@XZ ENDP					; CvArea::~CvArea
_TEXT	ENDS
PUBLIC	?init@CvArea@@QAEXH_N@Z				; CvArea::init
; Function compile flags: /Ogtpy
;	COMDAT ?init@CvArea@@QAEXH_N@Z
_TEXT	SEGMENT
_iID$ = 8						; size = 4
_bWater$ = 12						; size = 1
?init@CvArea@@QAEXH_N@Z PROC				; CvArea::init, COMDAT
; _this$ = ecx

; 46   : 	//--------------------------------
; 47   : 	// Init saved data
; 48   : 	reset(iID, bWater);

	mov	eax, DWORD PTR _bWater$[esp-4]
	mov	edx, DWORD PTR _iID$[esp-4]
	push	0
	push	eax
	push	edx
	call	?reset@CvArea@@QAEXH_N0@Z		; CvArea::reset

; 49   : 
; 50   : 	//--------------------------------
; 51   : 	// Init non-saved data
; 52   : 
; 53   : 	//--------------------------------
; 54   : 	// Init other game data
; 55   : }

	ret	8
?init@CvArea@@QAEXH_N@Z ENDP				; CvArea::init
_TEXT	ENDS
PUBLIC	?getEnemyUnits@CvArea@@QBEHW4PlayerTypes@@@Z	; CvArea::getEnemyUnits
EXTRN	?atWar@@YA_NW4TeamTypes@@0@Z:PROC		; atWar
; Function compile flags: /Ogtpy
;	COMDAT ?getEnemyUnits@CvArea@@QBEHW4PlayerTypes@@@Z
_TEXT	SEGMENT
$T219246 = 8						; size = 4
_eIndex$ = 8						; size = 4
?getEnemyUnits@CvArea@@QBEHW4PlayerTypes@@@Z PROC	; CvArea::getEnemyUnits, COMDAT
; _this$ = ecx

; 376  : 	CvAssertMsg(eIndex >= 0, "eIndex is expected to be >= 0");
; 377  : 	CvAssertMsg(eIndex < MAX_PLAYERS, "eIndex is expected to be < MAX_PLAYERS");
; 378  : 	int iRtnValue = 0;
; 379  : 
; 380  : 	TeamTypes eTeam = GET_PLAYER(eIndex).getTeam();

	mov	eax, DWORD PTR _eIndex$[esp-4]
	mov	edx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	imul	eax, 63236				; 0000f704H
	mov	eax, DWORD PTR [eax+edx+44]
	push	ebx
	push	ebp
	push	esi
	xor	ebp, ebp
	push	edi
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN13@getEnemyUn
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR $T219246[esp+12], eax
	jmp	SHORT $LN14@getEnemyUn
$LN13@getEnemyUn:
	mov	DWORD PTR $T219246[esp+12], -1
$LN14@getEnemyUn:

; 381  : 
; 382  : 	// Loop through each player
; 383  : 	for(int iI = 0; iI < MAX_PLAYERS; iI++)

	xor	edi, edi
	xor	esi, esi
	lea	ebx, DWORD PTR [ecx+44]
$LL35@getEnemyUn:

; 384  : 	{
; 385  : 		CvPlayer& kPlayer = GET_PLAYER((PlayerTypes)iI);
; 386  : 		if(atWar(kPlayer.getTeam(), eTeam))

	mov	ecx, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	mov	eax, DWORD PTR [esi+ecx+44]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN24@getEnemyUn
	mov	edx, DWORD PTR ?sr_TeamTypes@CvPreGame@@3ABV?$vector@W4TeamTypes@@V?$allocator@W4TeamTypes@@@std@@@std@@B ; CvPreGame::sr_TeamTypes
	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+eax*4]
	jmp	SHORT $LN25@getEnemyUn
$LN24@getEnemyUn:
	or	eax, -1
$LN25@getEnemyUn:
	mov	edx, DWORD PTR $T219246[esp+12]
	push	edx
	push	eax
	call	?atWar@@YA_NW4TeamTypes@@0@Z		; atWar
	add	esp, 8
	test	al, al
	je	SHORT $LN3@getEnemyUn

; 387  : 		{
; 388  : 			iRtnValue += getUnitsPerPlayer((PlayerTypes)iI);

	cmp	edi, 63					; 0000003fH
	ja	SHORT $LN29@getEnemyUn
	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN31@getEnemyUn
$LN29@getEnemyUn:
	xor	eax, eax
$LN31@getEnemyUn:
	add	ebp, eax
$LN3@getEnemyUn:

; 381  : 
; 382  : 	// Loop through each player
; 383  : 	for(int iI = 0; iI < MAX_PLAYERS; iI++)

	add	esi, 63236				; 0000f704H
	inc	edi
	add	ebx, 4
	cmp	esi, 4047104				; 003dc100H
	jl	SHORT $LL35@getEnemyUn
	pop	edi
	pop	esi

; 389  : 		}
; 390  : 	}
; 391  : 
; 392  : 	return iRtnValue;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 393  : }

	ret	4
?getEnemyUnits@CvArea@@QBEHW4PlayerTypes@@@Z ENDP	; CvArea::getEnemyUnits
_TEXT	ENDS
PUBLIC	?changeYieldRateModifier@CvArea@@QAEXW4PlayerTypes@@W4YieldTypes@@H@Z ; CvArea::changeYieldRateModifier
EXTRN	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ:PROC ; CvGame::getActiveTeam
EXTRN	?invalidateYieldRankCache@CvPlayer@@QAEXW4YieldTypes@@@Z:PROC ; CvPlayer::invalidateYieldRankCache
; Function compile flags: /Ogtpy
;	COMDAT ?changeYieldRateModifier@CvArea@@QAEXW4PlayerTypes@@W4YieldTypes@@H@Z
_TEXT	SEGMENT
_eIndex1$ = 8						; size = 4
_eIndex2$ = 12						; size = 4
_iChange$ = 16						; size = 4
?changeYieldRateModifier@CvArea@@QAEXW4PlayerTypes@@W4YieldTypes@@H@Z PROC ; CvArea::changeYieldRateModifier, COMDAT
; _this$ = ecx

; 567  : 	CvAssertMsg(eIndex1 >= 0, "eIndex1 is expected to be >= 0");
; 568  : 	CvAssertMsg(eIndex1 < MAX_PLAYERS, "eIndex1 is expected to be < MAX_PLAYERS");
; 569  : 	if(eIndex1 < 0 || eIndex1 >= MAX_PLAYERS) return;

	mov	eax, DWORD PTR _eIndex1$[esp-4]
	cmp	eax, 63					; 0000003fH
	ja	SHORT $LN3@changeYiel

; 570  : 
; 571  : 	CvAssertMsg(eIndex2 >= 0, "eIndex2 is expected to be >= 0");
; 572  : 	CvAssertMsg(eIndex2 < NUM_YIELD_TYPES, "eIndex2 is expected to be < NUM_YIELD_TYPES");
; 573  : 	if(eIndex2 < 0 || eIndex2 >= MAX_PLAYERS) return;

	mov	edx, DWORD PTR _eIndex2$[esp-4]
	cmp	edx, 63					; 0000003fH
	ja	SHORT $LN3@changeYiel
	push	esi

; 574  : 
; 575  : 	if(iChange != 0)

	mov	esi, DWORD PTR _iChange$[esp]
	test	esi, esi
	je	SHORT $LN15@changeYiel
	push	edi

; 576  : 	{
; 577  : 		m_aaiYieldRateModifier[eIndex1][eIndex2] = (m_aaiYieldRateModifier[eIndex1][eIndex2] + iChange);

	lea	edi, DWORD PTR [eax+eax*2]

; 578  : 
; 579  : 		CvPlayer& thisPlayer = GET_PLAYER(eIndex1);

	imul	eax, 63236				; 0000f704H
	lea	edi, DWORD PTR [edx+edi*2]
	add	DWORD PTR [ecx+edi*4+2284], esi
	add	eax, DWORD PTR ?m_aPlayers@CvPlayerAI@@1PAV1@A ; CvPlayerAI::m_aPlayers
	lea	ecx, DWORD PTR [ecx+edi*4+2284]
	mov	esi, eax

; 580  : 		thisPlayer.invalidateYieldRankCache(eIndex2);

	push	edx
	mov	ecx, esi
	call	?invalidateYieldRankCache@CvPlayer@@QAEXW4YieldTypes@@@Z ; CvPlayer::invalidateYieldRankCache

; 581  : 
; 582  : 		if(thisPlayer.getTeam() == GC.getGame().getActiveTeam())

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+48
	call	?getActiveTeam@CvGame@@QAE?AW4TeamTypes@@XZ ; CvGame::getActiveTeam
	mov	ecx, esi
	mov	edi, eax
	call	?getTeam@CvPlayer@@QBE?AW4TeamTypes@@XZ	; CvPlayer::getTeam
	cmp	eax, edi
	pop	edi
	jne	SHORT $LN15@changeYiel

; 583  : 		{
; 584  : 			GC.GetEngineUserInterface()->setDirty(CityInfo_DIRTY_BIT, true);

	mov	ecx, DWORD PTR ?gGlobals@@3VCvGlobals@@A+8568
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+260]
	push	1
	push	18					; 00000012H
	call	edx
$LN15@changeYiel:
	pop	esi
$LN3@changeYiel:

; 585  : 		}
; 586  : 	}
; 587  : }

	ret	12					; 0000000cH
?changeYieldRateModifier@CvArea@@QAEXW4PlayerTypes@@W4YieldTypes@@H@Z ENDP ; CvArea::changeYieldRateModifier
_TEXT	ENDS
EXTRN	?Read@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAH@Z:PROC ; ImprovementArrayHelpers::Read
; Function compile flags: /Ogtpy
;	COMDAT ?read@CvArea@@UAEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
tv694 = 8						; size = 4
_kStream$ = 8						; size = 4
?read@CvArea@@UAEXAAVFDataStream@@@Z PROC		; CvArea::read, COMDAT
; _this$ = ecx

; 709  : {

	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi

; 710  : 	int iI;
; 711  : 
; 712  : 	// Init saved data
; 713  : 	reset();

	push	0
	push	0
	push	0
	mov	edi, ecx
	call	?reset@CvArea@@QAEXH_N0@Z		; CvArea::reset

; 714  : 
; 715  : 	// Version number to maintain backwards compatibility
; 716  : 	uint uiVersion;
; 717  : 	kStream >> uiVersion;

	mov	esi, DWORD PTR _kStream$[esp+16]
	lea	eax, DWORD PTR _uiVersion$[esp+20]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 718  : 
; 719  : 	kStream >> m_iID;

	lea	ecx, DWORD PTR [edi+4]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 720  : 	kStream >> m_iNumTiles;

	lea	edx, DWORD PTR [edi+8]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 721  : 	kStream >> m_iNumOwnedTiles;

	lea	eax, DWORD PTR [edi+12]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 722  : 	kStream >> m_iNumRiverEdges;

	lea	ecx, DWORD PTR [edi+16]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 723  : 	kStream >> m_iNumUnits;

	lea	edx, DWORD PTR [edi+20]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 724  : 	kStream >> m_iNumCities;

	lea	eax, DWORD PTR [edi+24]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 725  : 	kStream >> m_iTotalPopulation;

	lea	ecx, DWORD PTR [edi+28]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 726  : 	kStream >> m_iNumStartingPlots;

	lea	edx, DWORD PTR [edi+32]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 727  : 	kStream >> m_iNumNaturalWonders;

	lea	eax, DWORD PTR [edi+36]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 728  : 	kStream >> m_iTotalFoundValue;

	lea	ecx, DWORD PTR [edi+40]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAI@Z		; FDataStream::Read

; 729  : 
; 730  : 	kStream >> m_Boundaries.m_iNorthEdge;

	lea	edx, DWORD PTR [edi+4212]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 731  : 	kStream >> m_Boundaries.m_iSouthEdge;

	lea	eax, DWORD PTR [edi+4216]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 732  : 	kStream >> m_Boundaries.m_iEastEdge;

	lea	ecx, DWORD PTR [edi+4220]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 733  : 	kStream >> m_Boundaries.m_iWestEdge;

	lea	edx, DWORD PTR [edi+4224]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 734  : 
; 735  : 	kStream >> m_bWater;

	lea	eax, DWORD PTR [edi+4228]
	push	eax
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read

; 736  : 	kStream >> m_bMountains;

	lea	ecx, DWORD PTR [edi+4229]
	push	ecx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAA_N@Z		; FDataStream::Read
	lea	ebx, DWORD PTR [edi+44]
	mov	ebp, 80					; 00000050H
	npad	4

; 737  : 
; 738  : 	kStream >> m_aiUnitsPerPlayer;

$LL45@read:
	push	ebx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL45@read

; 739  : 	kStream >> m_aiCitiesPerPlayer;

	lea	ebx, DWORD PTR [edi+364]
	mov	ebp, 80					; 00000050H
	npad	5
$LL52@read:
	push	ebx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL52@read

; 740  : 	kStream >> m_aiPopulationPerPlayer;

	lea	ebx, DWORD PTR [edi+684]
	mov	ebp, 80					; 00000050H
	npad	5
$LL59@read:
	push	ebx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL59@read

; 741  : 	kStream >> m_aiFreeSpecialist;

	lea	ebx, DWORD PTR [edi+1004]
	mov	ebp, 80					; 00000050H
	npad	5
$LL66@read:
	push	ebx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL66@read

; 742  : 	kStream >> m_aiNumRevealedTiles;

	lea	ebx, DWORD PTR [edi+1324]
	mov	ebp, 80					; 00000050H
	npad	5
$LL73@read:
	push	ebx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL73@read

; 743  : 
; 744  : 	for(iI=0; iI<MAX_PLAYERS; iI++)

	lea	ebx, DWORD PTR [edi+1648]
	mov	ebp, 64					; 00000040H
	npad	5
$LL6@read:

; 745  : 	{
; 746  : 		kStream >> (int&)m_aTargetCities[iI].eOwner;

	lea	edx, DWORD PTR [ebx-4]
	push	edx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read

; 747  : 		kStream >> m_aTargetCities[iI].iID;

	push	ebx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	ebx, 8
	sub	ebp, 1
	jne	SHORT $LL6@read

; 748  : 	}
; 749  : 
; 750  : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	lea	ebx, DWORD PTR [edi+2284]
	mov	DWORD PTR tv694[esp+16], 64		; 00000040H
	npad	7
$LL3@read:

; 751  : 	{
; 752  : 		kStream >> m_aaiYieldRateModifier[iI];

	mov	ebp, 6
$LL84@read:
	push	ebx
	mov	ecx, esi
	call	?Read@FDataStream@@IAEXAAH@Z		; FDataStream::Read
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL84@read

; 748  : 	}
; 749  : 
; 750  : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	sub	DWORD PTR tv694[esp+16], 1
	jne	SHORT $LL3@read

; 753  : 	}
; 754  : 
; 755  : 	CvInfosSerializationHelper::ReadHashedDataArray(kStream, m_paiNumResources, GC.getNumResourceInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	push	eax
	mov	eax, DWORD PTR [edi+4204]
	push	eax
	push	esi
	call	??$ReadHashedDataArray@H@CvInfosSerializationHelper@@YAXAAVFDataStream@@PAHH@Z ; CvInfosSerializationHelper::ReadHashedDataArray<int>

; 756  : 
; 757  : 	ImprovementArrayHelpers::Read(kStream, m_paiNumImprovements);

	mov	ecx, DWORD PTR [edi+4208]
	push	ecx
	push	esi
	call	?Read@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAH@Z ; ImprovementArrayHelpers::Read
	add	esp, 20					; 00000014H
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 758  : }

	pop	ecx
	ret	4
?read@CvArea@@UAEXAAVFDataStream@@@Z ENDP		; CvArea::read
_TEXT	ENDS
EXTRN	?Write@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAHH@Z:PROC ; ImprovementArrayHelpers::Write
EXTRN	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z:PROC ; operator<<
; Function compile flags: /Ogtpy
;	COMDAT ?write@CvArea@@UBEXAAVFDataStream@@@Z
_TEXT	SEGMENT
_uiVersion$ = -4					; size = 4
tv700 = 8						; size = 4
$T219604 = 8						; size = 4
_kStream$ = 8						; size = 4
?write@CvArea@@UBEXAAVFDataStream@@@Z PROC		; CvArea::write, COMDAT
; _this$ = ecx

; 763  : {

	push	ecx
	push	ebx
	push	ebp
	push	esi

; 764  : 	int iI;
; 765  : 
; 766  : 	// Current version number
; 767  : 	uint uiVersion = 1;
; 768  : 	kStream << uiVersion;

	mov	esi, DWORD PTR _kStream$[esp+12]
	push	edi
	lea	eax, DWORD PTR _uiVersion$[esp+20]
	mov	edi, ecx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR _uiVersion$[esp+24], 1
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 769  : 
; 770  : 	kStream << m_iID;

	lea	ecx, DWORD PTR [edi+4]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 771  : 	kStream << m_iNumTiles;

	lea	edx, DWORD PTR [edi+8]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 772  : 	kStream << m_iNumOwnedTiles;

	lea	eax, DWORD PTR [edi+12]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 773  : 	kStream << m_iNumRiverEdges;

	lea	ecx, DWORD PTR [edi+16]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 774  : 	kStream << m_iNumUnits;

	lea	edx, DWORD PTR [edi+20]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 775  : 	kStream << m_iNumCities;

	lea	eax, DWORD PTR [edi+24]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 776  : 	kStream << m_iTotalPopulation;

	lea	ecx, DWORD PTR [edi+28]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 777  : 	kStream << m_iNumStartingPlots;

	lea	edx, DWORD PTR [edi+32]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 778  : 	kStream << m_iNumNaturalWonders;

	lea	eax, DWORD PTR [edi+36]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 779  : 	kStream << m_iTotalFoundValue;

	lea	ecx, DWORD PTR [edi+40]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write

; 780  : 
; 781  : 	kStream << m_Boundaries.m_iNorthEdge;

	lea	edx, DWORD PTR [edi+4212]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 782  : 	kStream << m_Boundaries.m_iSouthEdge;

	lea	eax, DWORD PTR [edi+4216]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 783  : 	kStream << m_Boundaries.m_iEastEdge;

	lea	ecx, DWORD PTR [edi+4220]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 784  : 	kStream << m_Boundaries.m_iWestEdge;

	lea	edx, DWORD PTR [edi+4224]
	push	edx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write

; 785  : 
; 786  : 	kStream << m_bWater;

	lea	eax, DWORD PTR [edi+4228]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write

; 787  : 	kStream << m_bMountains;

	lea	ecx, DWORD PTR [edi+4229]
	push	ecx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXAB_N@Z		; FDataStream::Write
	lea	ebx, DWORD PTR [edi+44]
	mov	ebp, 80					; 00000050H
	npad	7

; 788  : 
; 789  : 	kStream << m_aiUnitsPerPlayer;

$LL45@write:
	push	ebx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL45@write

; 790  : 	kStream << m_aiCitiesPerPlayer;

	lea	ebx, DWORD PTR [edi+364]
	mov	ebp, 80					; 00000050H
	npad	5
$LL52@write:
	push	ebx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL52@write

; 791  : 	kStream << m_aiPopulationPerPlayer;

	lea	ebx, DWORD PTR [edi+684]
	mov	ebp, 80					; 00000050H
	npad	5
$LL59@write:
	push	ebx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL59@write

; 792  : 	kStream << m_aiFreeSpecialist;

	lea	ebx, DWORD PTR [edi+1004]
	mov	ebp, 80					; 00000050H
	npad	5
$LL66@write:
	push	ebx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL66@write

; 793  : 	kStream << m_aiNumRevealedTiles;

	lea	ebx, DWORD PTR [edi+1324]
	mov	ebp, 80					; 00000050H
	npad	5
$LL73@write:
	push	ebx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL73@write

; 794  : 
; 795  : 	for(iI=0; iI<MAX_PLAYERS; iI++)

	lea	ebx, DWORD PTR [edi+1648]
	mov	ebp, 64					; 00000040H
	npad	5
$LL6@write:

; 796  : 	{
; 797  : 		kStream << m_aTargetCities[iI].eOwner;

	lea	edx, DWORD PTR [ebx-4]
	push	edx
	push	esi
	call	??6@YAAAVFDataStream@@AAV0@ABW4PlayerTypes@@@Z ; operator<<
	add	esp, 8

; 798  : 		kStream << m_aTargetCities[iI].iID;

	push	ebx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	ebx, 8
	sub	ebp, 1
	jne	SHORT $LL6@write

; 799  : 	}
; 800  : 
; 801  : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	lea	ebx, DWORD PTR [edi+2284]
	mov	DWORD PTR tv700[esp+16], 64		; 00000040H
	npad	5
$LL3@write:

; 802  : 	{
; 803  : 		kStream << m_aaiYieldRateModifier[iI];

	mov	ebp, 6
$LL82@write:
	push	ebx
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
	add	ebx, 4
	sub	ebp, 1
	jne	SHORT $LL82@write

; 799  : 	}
; 800  : 
; 801  : 	for(iI = 0; iI < MAX_PLAYERS; iI++)

	sub	DWORD PTR tv700[esp+16], 1
	jne	SHORT $LL3@write

; 804  : 	}
; 805  : 
; 806  : 	CvInfosSerializationHelper::WriteHashedDataArray<ResourceTypes>(kStream, m_paiNumResources, GC.getNumResourceInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumResourceInfos@CvGlobals@@QAEHXZ	; CvGlobals::getNumResourceInfos
	mov	ebp, DWORD PTR [edi+4204]
	mov	DWORD PTR $T219604[esp+16], eax
	lea	eax, DWORD PTR $T219604[esp+16]
	push	eax
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABI@Z		; FDataStream::Write
	xor	ebx, ebx
	cmp	DWORD PTR $T219604[esp+16], ebx
	jbe	SHORT $LN88@write
$LL90@write:
	push	ebx
	push	esi
	call	?WriteHashed@CvInfosSerializationHelper@@YA_NAAVFDataStream@@W4ResourceTypes@@@Z ; CvInfosSerializationHelper::WriteHashed
	add	esp, 8
	test	al, al
	je	SHORT $LN89@write
	push	ebp
	mov	ecx, esi
	call	?Write@FDataStream@@IAEXABH@Z		; FDataStream::Write
$LN89@write:
	inc	ebx
	add	ebp, 4
	cmp	ebx, DWORD PTR $T219604[esp+16]
	jb	SHORT $LL90@write
$LN88@write:

; 807  : 	ImprovementArrayHelpers::Write(kStream, m_paiNumImprovements, GC.getNumImprovementInfos());

	mov	ecx, OFFSET ?gGlobals@@3VCvGlobals@@A	; gGlobals
	call	?getNumImprovementInfos@CvGlobals@@QAEHXZ ; CvGlobals::getNumImprovementInfos
	mov	ecx, DWORD PTR [edi+4208]
	push	eax
	push	ecx
	push	esi
	call	?Write@ImprovementArrayHelpers@@YAXAAVFDataStream@@PAHH@Z ; ImprovementArrayHelpers::Write
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 808  : }

	pop	ecx
	ret	4
?write@CvArea@@UBEXAAVFDataStream@@@Z ENDP		; CvArea::write
_TEXT	ENDS
END
