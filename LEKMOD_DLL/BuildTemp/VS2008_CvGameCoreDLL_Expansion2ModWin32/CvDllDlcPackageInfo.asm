; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	c:\Users\EnormousApplePie\Documents\GitHub\Lekmod\LEKMOD_DLL\CvGameCoreDLL_Expansion2\CvDllDlcPackageInfo.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_CIV5_XP2_DLL_VERSION DD FLAT:$SG217998
_DATA	ENDS
CONST	SEGMENT
$SG217998 DB	'1.0.0', 00H
	ORG $+2
_guidICvUnknown DD 0d89ba82fH
	DW	09fa3H
	DW	04696H
	DB	0b3H
	DB	0f4H
	DB	052H
	DB	0bdH
	DB	0b1H
	DB	01H
	DB	0cfH
	DB	0b2H
_guidICvEnumerator DD 0579a12e9H
	DW	03c70H
	DW	04276H
	DB	084H
	DB	060H
	DB	0c9H
	DB	041H
	DB	0a5H
	DB	0f9H
	DB	058H
	DB	05fH
_guidICvDlcPackageInfo1 DD 01a87b286H
	DW	05001H
	DW	04661H
	DB	09aH
	DB	089H
	DB	081H
	DB	026H
	DB	0afH
	DB	013H
	DB	027H
	DB	02H
CONST	ENDS
PUBLIC	??_7ICvUnknown@@6B@				; ICvUnknown::`vftable'
PUBLIC	??0ICvUnknown@@QAE@XZ				; ICvUnknown::ICvUnknown
PUBLIC	??_R4ICvUnknown@@6B@				; ICvUnknown::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVICvUnknown@@@8				; ICvUnknown `RTTI Type Descriptor'
PUBLIC	??_R3ICvUnknown@@8				; ICvUnknown::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ICvUnknown@@8				; ICvUnknown::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ICvUnknown@@8			; ICvUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	__purecall:PROC
;	COMDAT ??_R1A@?0A@EA@ICvUnknown@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ICvUnknown@@8 DD FLAT:??_R0?AVICvUnknown@@@8 ; ICvUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ICvUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R2ICvUnknown@@8
rdata$r	SEGMENT
??_R2ICvUnknown@@8 DD FLAT:??_R1A@?0A@EA@ICvUnknown@@8	; ICvUnknown::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3ICvUnknown@@8
rdata$r	SEGMENT
??_R3ICvUnknown@@8 DD 00H				; ICvUnknown::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2ICvUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVICvUnknown@@@8
_DATA	SEGMENT
??_R0?AVICvUnknown@@@8 DD FLAT:??_7type_info@@6B@	; ICvUnknown `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVICvUnknown@@', 00H
_DATA	ENDS
;	COMDAT ??_R4ICvUnknown@@6B@
rdata$r	SEGMENT
??_R4ICvUnknown@@6B@ DD 00H				; ICvUnknown::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVICvUnknown@@@8
	DD	FLAT:??_R3ICvUnknown@@8
rdata$r	ENDS
;	COMDAT ??_7ICvUnknown@@6B@
CONST	SEGMENT
??_7ICvUnknown@@6B@ DD FLAT:??_R4ICvUnknown@@6B@	; ICvUnknown::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0ICvUnknown@@QAE@XZ
_TEXT	SEGMENT
??0ICvUnknown@@QAE@XZ PROC				; ICvUnknown::ICvUnknown, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], OFFSET ??_7ICvUnknown@@6B@
	ret	0
??0ICvUnknown@@QAE@XZ ENDP				; ICvUnknown::ICvUnknown
_TEXT	ENDS
PUBLIC	??_7CvDllDlcPackageInfo@@6B@			; CvDllDlcPackageInfo::`vftable'
PUBLIC	??1CvDllDlcPackageInfo@@QAE@XZ			; CvDllDlcPackageInfo::~CvDllDlcPackageInfo
PUBLIC	??_R4CvDllDlcPackageInfo@@6B@			; CvDllDlcPackageInfo::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvDllDlcPackageInfo@@@8			; CvDllDlcPackageInfo `RTTI Type Descriptor'
PUBLIC	??_R3CvDllDlcPackageInfo@@8			; CvDllDlcPackageInfo::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvDllDlcPackageInfo@@8			; CvDllDlcPackageInfo::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvDllDlcPackageInfo@@8		; CvDllDlcPackageInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@ICvDlcPackageInfo1@@8		; ICvDlcPackageInfo1::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVICvDlcPackageInfo1@@@8			; ICvDlcPackageInfo1 `RTTI Type Descriptor'
PUBLIC	??_R3ICvDlcPackageInfo1@@8			; ICvDlcPackageInfo1::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ICvDlcPackageInfo1@@8			; ICvDlcPackageInfo1::`RTTI Base Class Array'
PUBLIC	?QueryInterface@CvDllDlcPackageInfo@@UAGPAXU_GUID@@@Z ; CvDllDlcPackageInfo::QueryInterface
PUBLIC	?Destroy@CvDllDlcPackageInfo@@EAGXXZ		; CvDllDlcPackageInfo::Destroy
PUBLIC	?GetPackageID@CvDllDlcPackageInfo@@UAG?AU_GUID@@XZ ; CvDllDlcPackageInfo::GetPackageID
;	COMDAT ??_R2ICvDlcPackageInfo1@@8
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvdlldlcpackageinfo.cpp
rdata$r	SEGMENT
??_R2ICvDlcPackageInfo1@@8 DD FLAT:??_R1A@?0A@EA@ICvDlcPackageInfo1@@8 ; ICvDlcPackageInfo1::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ICvUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R3ICvDlcPackageInfo1@@8
rdata$r	SEGMENT
??_R3ICvDlcPackageInfo1@@8 DD 00H			; ICvDlcPackageInfo1::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ICvDlcPackageInfo1@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVICvDlcPackageInfo1@@@8
_DATA	SEGMENT
??_R0?AVICvDlcPackageInfo1@@@8 DD FLAT:??_7type_info@@6B@ ; ICvDlcPackageInfo1 `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVICvDlcPackageInfo1@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@ICvDlcPackageInfo1@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ICvDlcPackageInfo1@@8 DD FLAT:??_R0?AVICvDlcPackageInfo1@@@8 ; ICvDlcPackageInfo1::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ICvDlcPackageInfo1@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CvDllDlcPackageInfo@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CvDllDlcPackageInfo@@8 DD FLAT:??_R0?AVCvDllDlcPackageInfo@@@8 ; CvDllDlcPackageInfo::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvDllDlcPackageInfo@@8
rdata$r	ENDS
;	COMDAT ??_R2CvDllDlcPackageInfo@@8
rdata$r	SEGMENT
??_R2CvDllDlcPackageInfo@@8 DD FLAT:??_R1A@?0A@EA@CvDllDlcPackageInfo@@8 ; CvDllDlcPackageInfo::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ICvDlcPackageInfo1@@8
	DD	FLAT:??_R1A@?0A@EA@ICvUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R3CvDllDlcPackageInfo@@8
rdata$r	SEGMENT
??_R3CvDllDlcPackageInfo@@8 DD 00H			; CvDllDlcPackageInfo::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CvDllDlcPackageInfo@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvDllDlcPackageInfo@@@8
_DATA	SEGMENT
??_R0?AVCvDllDlcPackageInfo@@@8 DD FLAT:??_7type_info@@6B@ ; CvDllDlcPackageInfo `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvDllDlcPackageInfo@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvDllDlcPackageInfo@@6B@
rdata$r	SEGMENT
??_R4CvDllDlcPackageInfo@@6B@ DD 00H			; CvDllDlcPackageInfo::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvDllDlcPackageInfo@@@8
	DD	FLAT:??_R3CvDllDlcPackageInfo@@8
rdata$r	ENDS
;	COMDAT ??_7CvDllDlcPackageInfo@@6B@
CONST	SEGMENT
??_7CvDllDlcPackageInfo@@6B@ DD FLAT:??_R4CvDllDlcPackageInfo@@6B@ ; CvDllDlcPackageInfo::`vftable'
	DD	FLAT:?QueryInterface@CvDllDlcPackageInfo@@UAGPAXU_GUID@@@Z
	DD	FLAT:?Destroy@CvDllDlcPackageInfo@@EAGXXZ
	DD	FLAT:?GetPackageID@CvDllDlcPackageInfo@@UAG?AU_GUID@@XZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??1CvDllDlcPackageInfo@@QAE@XZ
_TEXT	SEGMENT
??1CvDllDlcPackageInfo@@QAE@XZ PROC			; CvDllDlcPackageInfo::~CvDllDlcPackageInfo, COMDAT
; _this$ = ecx

; 20   : {

	mov	DWORD PTR [ecx], OFFSET ??_7CvDllDlcPackageInfo@@6B@

; 21   : }

	ret	0
??1CvDllDlcPackageInfo@@QAE@XZ ENDP			; CvDllDlcPackageInfo::~CvDllDlcPackageInfo
_TEXT	ENDS
PUBLIC	?IncrementReference@CvDllDlcPackageInfo@@QAEIXZ	; CvDllDlcPackageInfo::IncrementReference
; Function compile flags: /Ogtpy
;	COMDAT ?IncrementReference@CvDllDlcPackageInfo@@QAEIXZ
_TEXT	SEGMENT
?IncrementReference@CvDllDlcPackageInfo@@QAEIXZ PROC	; CvDllDlcPackageInfo::IncrementReference, COMDAT
; _this$ = ecx

; 37   : 	++m_uiRefCount;

	inc	DWORD PTR [ecx+4]

; 38   : 	return m_uiRefCount;

	mov	eax, DWORD PTR [ecx+4]

; 39   : }

	ret	0
?IncrementReference@CvDllDlcPackageInfo@@QAEIXZ ENDP	; CvDllDlcPackageInfo::IncrementReference
_TEXT	ENDS
PUBLIC	?GetReferenceCount@CvDllDlcPackageInfo@@QAEIXZ	; CvDllDlcPackageInfo::GetReferenceCount
; Function compile flags: /Ogtpy
;	COMDAT ?GetReferenceCount@CvDllDlcPackageInfo@@QAEIXZ
_TEXT	SEGMENT
?GetReferenceCount@CvDllDlcPackageInfo@@QAEIXZ PROC	; CvDllDlcPackageInfo::GetReferenceCount, COMDAT
; _this$ = ecx

; 57   : 	return m_uiRefCount;

	mov	eax, DWORD PTR [ecx+4]

; 58   : }

	ret	0
?GetReferenceCount@CvDllDlcPackageInfo@@QAEIXZ ENDP	; CvDllDlcPackageInfo::GetReferenceCount
_TEXT	ENDS
PUBLIC	??3CvDllDlcPackageInfo@@SAXPAX@Z		; CvDllDlcPackageInfo::operator delete
EXTRN	?Free@CvDllGameContext@@SAXPAX@Z:PROC		; CvDllGameContext::Free
; Function compile flags: /Ogtpy
;	COMDAT ??3CvDllDlcPackageInfo@@SAXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
??3CvDllDlcPackageInfo@@SAXPAX@Z PROC			; CvDllDlcPackageInfo::operator delete, COMDAT

; 67   : 	CvDllGameContext::Free(p);

	jmp	?Free@CvDllGameContext@@SAXPAX@Z	; CvDllGameContext::Free
??3CvDllDlcPackageInfo@@SAXPAX@Z ENDP			; CvDllDlcPackageInfo::operator delete
_TEXT	ENDS
PUBLIC	??2CvDllDlcPackageInfo@@SAPAXI@Z		; CvDllDlcPackageInfo::operator new
EXTRN	?Allocate@CvDllGameContext@@SAPAXI@Z:PROC	; CvDllGameContext::Allocate
; Function compile flags: /Ogtpy
;	COMDAT ??2CvDllDlcPackageInfo@@SAPAXI@Z
_TEXT	SEGMENT
_bytes$ = 8						; size = 4
??2CvDllDlcPackageInfo@@SAPAXI@Z PROC			; CvDllDlcPackageInfo::operator new, COMDAT

; 72   : 	return CvDllGameContext::Allocate(bytes);

	jmp	?Allocate@CvDllGameContext@@SAPAXI@Z	; CvDllGameContext::Allocate
??2CvDllDlcPackageInfo@@SAPAXI@Z ENDP			; CvDllDlcPackageInfo::operator new
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetPackageID@CvDllDlcPackageInfo@@UAG?AU_GUID@@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
?GetPackageID@CvDllDlcPackageInfo@@UAG?AU_GUID@@XZ PROC	; CvDllDlcPackageInfo::GetPackageID, COMDAT

; 77   : 	return m_packageId;

	mov	ecx, DWORD PTR _this$[esp-4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+8], edx
	mov	DWORD PTR [eax+12], ecx

; 78   : }

	ret	8
?GetPackageID@CvDllDlcPackageInfo@@UAG?AU_GUID@@XZ ENDP	; CvDllDlcPackageInfo::GetPackageID
_TEXT	ENDS
PUBLIC	??_7ICvEnumerator@@6B@				; ICvEnumerator::`vftable'
PUBLIC	??0ICvEnumerator@@QAE@XZ			; ICvEnumerator::ICvEnumerator
PUBLIC	??_R4ICvEnumerator@@6B@				; ICvEnumerator::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVICvEnumerator@@@8			; ICvEnumerator `RTTI Type Descriptor'
PUBLIC	??_R3ICvEnumerator@@8				; ICvEnumerator::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ICvEnumerator@@8				; ICvEnumerator::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ICvEnumerator@@8			; ICvEnumerator::`RTTI Base Class Descriptor at (0,-1,0,64)'
;	COMDAT ??_R1A@?0A@EA@ICvEnumerator@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ICvEnumerator@@8 DD FLAT:??_R0?AVICvEnumerator@@@8 ; ICvEnumerator::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ICvEnumerator@@8
rdata$r	ENDS
;	COMDAT ??_R2ICvEnumerator@@8
rdata$r	SEGMENT
??_R2ICvEnumerator@@8 DD FLAT:??_R1A@?0A@EA@ICvEnumerator@@8 ; ICvEnumerator::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ICvUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R3ICvEnumerator@@8
rdata$r	SEGMENT
??_R3ICvEnumerator@@8 DD 00H				; ICvEnumerator::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ICvEnumerator@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVICvEnumerator@@@8
_DATA	SEGMENT
??_R0?AVICvEnumerator@@@8 DD FLAT:??_7type_info@@6B@	; ICvEnumerator `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVICvEnumerator@@', 00H
_DATA	ENDS
;	COMDAT ??_R4ICvEnumerator@@6B@
rdata$r	SEGMENT
??_R4ICvEnumerator@@6B@ DD 00H				; ICvEnumerator::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVICvEnumerator@@@8
	DD	FLAT:??_R3ICvEnumerator@@8
rdata$r	ENDS
;	COMDAT ??_7ICvEnumerator@@6B@
CONST	SEGMENT
??_7ICvEnumerator@@6B@ DD FLAT:??_R4ICvEnumerator@@6B@	; ICvEnumerator::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0ICvEnumerator@@QAE@XZ
_TEXT	SEGMENT
??0ICvEnumerator@@QAE@XZ PROC				; ICvEnumerator::ICvEnumerator, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], OFFSET ??_7ICvEnumerator@@6B@
	ret	0
??0ICvEnumerator@@QAE@XZ ENDP				; ICvEnumerator::ICvEnumerator
_TEXT	ENDS
PUBLIC	?IncrementReference@CvDllDlcPackageInfoList@@QAEIXZ ; CvDllDlcPackageInfoList::IncrementReference
; Function compile flags: /Ogtpy
;	COMDAT ?IncrementReference@CvDllDlcPackageInfoList@@QAEIXZ
_TEXT	SEGMENT
?IncrementReference@CvDllDlcPackageInfoList@@QAEIXZ PROC ; CvDllDlcPackageInfoList::IncrementReference, COMDAT
; _this$ = ecx

; 105  : 	++m_uiRefCount;

	inc	DWORD PTR [ecx+4]

; 106  : 	return m_uiRefCount;

	mov	eax, DWORD PTR [ecx+4]

; 107  : }

	ret	0
?IncrementReference@CvDllDlcPackageInfoList@@QAEIXZ ENDP ; CvDllDlcPackageInfoList::IncrementReference
_TEXT	ENDS
PUBLIC	?GetReferenceCount@CvDllDlcPackageInfoList@@QAEIXZ ; CvDllDlcPackageInfoList::GetReferenceCount
; Function compile flags: /Ogtpy
;	COMDAT ?GetReferenceCount@CvDllDlcPackageInfoList@@QAEIXZ
_TEXT	SEGMENT
?GetReferenceCount@CvDllDlcPackageInfoList@@QAEIXZ PROC	; CvDllDlcPackageInfoList::GetReferenceCount, COMDAT
; _this$ = ecx

; 125  : 	return m_uiRefCount;

	mov	eax, DWORD PTR [ecx+4]

; 126  : }

	ret	0
?GetReferenceCount@CvDllDlcPackageInfoList@@QAEIXZ ENDP	; CvDllDlcPackageInfoList::GetReferenceCount
_TEXT	ENDS
PUBLIC	??3CvDllDlcPackageInfoList@@SAXPAX@Z		; CvDllDlcPackageInfoList::operator delete
; Function compile flags: /Ogtpy
;	COMDAT ??3CvDllDlcPackageInfoList@@SAXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
??3CvDllDlcPackageInfoList@@SAXPAX@Z PROC		; CvDllDlcPackageInfoList::operator delete, COMDAT

; 135  : 	CvDllGameContext::Free(p);

	jmp	?Free@CvDllGameContext@@SAXPAX@Z	; CvDllGameContext::Free
??3CvDllDlcPackageInfoList@@SAXPAX@Z ENDP		; CvDllDlcPackageInfoList::operator delete
_TEXT	ENDS
PUBLIC	??2CvDllDlcPackageInfoList@@SAPAXI@Z		; CvDllDlcPackageInfoList::operator new
; Function compile flags: /Ogtpy
;	COMDAT ??2CvDllDlcPackageInfoList@@SAPAXI@Z
_TEXT	SEGMENT
_bytes$ = 8						; size = 4
??2CvDllDlcPackageInfoList@@SAPAXI@Z PROC		; CvDllDlcPackageInfoList::operator new, COMDAT

; 140  : 	return CvDllGameContext::Allocate(bytes);

	jmp	?Allocate@CvDllGameContext@@SAPAXI@Z	; CvDllGameContext::Allocate
??2CvDllDlcPackageInfoList@@SAPAXI@Z ENDP		; CvDllDlcPackageInfoList::operator new
_TEXT	ENDS
PUBLIC	_IsEqualGUID
; Function compile flags: /Ogtpy
; File c:\program files\microsoft sdks\windows\v6.0a\include\guiddef.h
;	COMDAT _IsEqualGUID
_TEXT	SEGMENT
_rguid1$ = 8						; size = 4
_rguid2$ = 12						; size = 4
_IsEqualGUID PROC					; COMDAT

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	mov	ecx, DWORD PTR _rguid2$[esp-4]
	mov	edx, DWORD PTR _rguid1$[esp-4]
	mov	eax, 16					; 00000010H
	push	esi
	npad	2
$LL4@IsEqualGUI:
	mov	esi, DWORD PTR [edx]
	cmp	esi, DWORD PTR [ecx]
	jne	SHORT $LN5@IsEqualGUI
	sub	eax, 4
	add	ecx, 4
	add	edx, 4
	cmp	eax, 4
	jae	SHORT $LL4@IsEqualGUI
	xor	eax, eax
	xor	edx, edx
	test	eax, eax
	sete	dl
	pop	esi
	mov	eax, edx

; 162  : }

	ret	0
$LN5@IsEqualGUI:

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	movzx	eax, BYTE PTR [edx]
	movzx	esi, BYTE PTR [ecx]
	sub	eax, esi
	jne	SHORT $LN7@IsEqualGUI
	movzx	eax, BYTE PTR [edx+1]
	movzx	esi, BYTE PTR [ecx+1]
	sub	eax, esi
	jne	SHORT $LN7@IsEqualGUI
	movzx	eax, BYTE PTR [edx+2]
	movzx	esi, BYTE PTR [ecx+2]
	sub	eax, esi
	jne	SHORT $LN7@IsEqualGUI
	movzx	eax, BYTE PTR [edx+3]
	movzx	ecx, BYTE PTR [ecx+3]
	sub	eax, ecx
$LN7@IsEqualGUI:
	sar	eax, 31					; 0000001fH
	or	eax, 1
	xor	edx, edx
	test	eax, eax
	sete	dl
	pop	esi
	mov	eax, edx

; 162  : }

	ret	0
_IsEqualGUID ENDP
_TEXT	ENDS
PUBLIC	_==
; Function compile flags: /Ogtpy
;	COMDAT _==
_TEXT	SEGMENT
_guidOne$ = 8						; size = 4
_guidOther$ = 12					; size = 4
_==	PROC						; COMDAT

; 194  :     return IsEqualGUID(guidOne,guidOther);

	jmp	_IsEqualGUID
_==	ENDP
_TEXT	ENDS
PUBLIC	?Reset@CvDllDlcPackageInfoList@@UAGXXZ		; CvDllDlcPackageInfoList::Reset
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvdlldlcpackageinfo.cpp
;	COMDAT ?Reset@CvDllDlcPackageInfoList@@UAGXXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?Reset@CvDllDlcPackageInfoList@@UAGXXZ PROC		; CvDllDlcPackageInfoList::Reset, COMDAT

; 164  : 	m_iIndex = -1;

	mov	eax, DWORD PTR _this$[esp-4]
	mov	DWORD PTR [eax+24], -1

; 165  : }

	ret	4
?Reset@CvDllDlcPackageInfoList@@UAGXXZ ENDP		; CvDllDlcPackageInfoList::Reset
_TEXT	ENDS
PUBLIC	?size@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QBEIXZ ; std::vector<_GUID,std::allocator<_GUID> >::size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?size@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QBEIXZ PROC ; std::vector<_GUID,std::allocator<_GUID> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 4

; 727  : 		}

	ret	0
?size@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QBEIXZ ENDP ; std::vector<_GUID,std::allocator<_GUID> >::size
_TEXT	ENDS
PUBLIC	??A?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QBEABU_GUID@@I@Z ; std::vector<_GUID,std::allocator<_GUID> >::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??A?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QBEABU_GUID@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QBEABU_GUID@@I@Z PROC ; std::vector<_GUID,std::allocator<_GUID> >::operator[], COMDAT
; _this$ = ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR __Pos$[esp-4]
	shl	eax, 4
	add	eax, DWORD PTR [ecx+4]

; 771  : 		}

	ret	4
??A?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QBEABU_GUID@@I@Z ENDP ; std::vector<_GUID,std::allocator<_GUID> >::operator[]
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_empty@V?$allocator@U_GUID@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_empty<std::allocator<_GUID> >::~_Container_base_aux_alloc_empty<std::allocator<_GUID> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??1?$_Container_base_aux_alloc_empty@V?$allocator@U_GUID@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_empty@V?$allocator@U_GUID@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_empty<std::allocator<_GUID> >::~_Container_base_aux_alloc_empty<std::allocator<_GUID> >, COMDAT
; _this$ = ecx

; 627  : 	~_Container_base_aux_alloc_empty() { }

	ret	0
??1?$_Container_base_aux_alloc_empty@V?$allocator@U_GUID@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<_GUID> >::~_Container_base_aux_alloc_empty<std::allocator<_GUID> >
_TEXT	ENDS
PUBLIC	?_Nextnode@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@KAAAPAU_Node@?$_List_nod@U_GUID@@V?$allocator@U_GUID@@@std@@@2@PAU342@@Z ; std::list<_GUID,std::allocator<_GUID> >::_Nextnode
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ?_Nextnode@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@KAAAPAU_Node@?$_List_nod@U_GUID@@V?$allocator@U_GUID@@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Nextnode@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@KAAAPAU_Node@?$_List_nod@U_GUID@@V?$allocator@U_GUID@@@std@@@2@PAU342@@Z PROC ; std::list<_GUID,std::allocator<_GUID> >::_Nextnode, COMDAT

; 115  : 		return ((_Nodepref)(*_Pnode)._Next);

	mov	eax, DWORD PTR __Pnode$[esp-4]

; 116  : 		}

	ret	0
?_Nextnode@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@KAAAPAU_Node@?$_List_nod@U_GUID@@V?$allocator@U_GUID@@@std@@@2@PAU342@@Z ENDP ; std::list<_GUID,std::allocator<_GUID> >::_Nextnode
_TEXT	ENDS
PUBLIC	??0?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAE@PAU_Node@?$_List_nod@U_GUID@@V?$allocator@U_GUID@@@std@@@2@@Z ; std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0>::_Const_iterator<0>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAE@PAU_Node@?$_List_nod@U_GUID@@V?$allocator@U_GUID@@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
??0?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAE@PAU_Node@?$_List_nod@U_GUID@@V?$allocator@U_GUID@@@std@@@2@@Z PROC ; std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0>::_Const_iterator<0>, COMDAT
; _this$ = ecx

; 184  : 			{	// construct with node pointer _Pnode

	mov	eax, ecx
	mov	ecx, DWORD PTR __Pnode$[esp-4]
	mov	DWORD PTR [eax], ecx

; 185  : 			}

	ret	4
??0?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAE@PAU_Node@?$_List_nod@U_GUID@@V?$allocator@U_GUID@@@std@@@2@@Z ENDP ; std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0>::_Const_iterator<0>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_GUID@@@std@@QAEXPAU_GUID@@I@Z ; std::allocator<_GUID>::deallocate
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?deallocate@?$allocator@U_GUID@@@std@@QAEXPAU_GUID@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_GUID@@@std@@QAEXPAU_GUID@@I@Z PROC ; std::allocator<_GUID>::deallocate, COMDAT
; _this$ = ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	8
?deallocate@?$allocator@U_GUID@@@std@@QAEXPAU_GUID@@I@Z ENDP ; std::allocator<_GUID>::deallocate
_TEXT	ENDS
PUBLIC	??0?$allocator@U_GUID@@@std@@QAE@XZ		; std::allocator<_GUID>::allocator<_GUID>
; Function compile flags: /Ogtpy
;	COMDAT ??0?$allocator@U_GUID@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U_GUID@@@std@@QAE@XZ PROC		; std::allocator<_GUID>::allocator<_GUID>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	mov	eax, ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@U_GUID@@@std@@QAE@XZ ENDP		; std::allocator<_GUID>::allocator<_GUID>
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_empty@V?$allocator@U_GUID@@@std@@@std@@IAE@V?$allocator@U_GUID@@@1@@Z ; std::_Container_base_aux_alloc_empty<std::allocator<_GUID> >::_Container_base_aux_alloc_empty<std::allocator<_GUID> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??0?$_Container_base_aux_alloc_empty@V?$allocator@U_GUID@@@std@@@std@@IAE@V?$allocator@U_GUID@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??0?$_Container_base_aux_alloc_empty@V?$allocator@U_GUID@@@std@@@std@@IAE@V?$allocator@U_GUID@@@1@@Z PROC ; std::_Container_base_aux_alloc_empty<std::allocator<_GUID> >::_Container_base_aux_alloc_empty<std::allocator<_GUID> >, COMDAT
; _this$ = ecx

; 618  : 	explicit _Container_base_aux_alloc_empty(_Alloc) { }

	mov	eax, ecx
	ret	4
??0?$_Container_base_aux_alloc_empty@V?$allocator@U_GUID@@@std@@@std@@IAE@V?$allocator@U_GUID@@@1@@Z ENDP ; std::_Container_base_aux_alloc_empty<std::allocator<_GUID> >::_Container_base_aux_alloc_empty<std::allocator<_GUID> >
_TEXT	ENDS
PUBLIC	??0?$allocator@U_GUID@@@std@@QAE@ABV01@@Z	; std::allocator<_GUID>::allocator<_GUID>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U_GUID@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U_GUID@@@std@@QAE@ABV01@@Z PROC		; std::allocator<_GUID>::allocator<_GUID>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	mov	eax, ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	4
??0?$allocator@U_GUID@@@std@@QAE@ABV01@@Z ENDP		; std::allocator<_GUID>::allocator<_GUID>
_TEXT	ENDS
PUBLIC	??$_Iter_cat@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@0@@Z ; std::_Iter_cat<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Iter_cat@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@0@@Z PROC ; std::_Iter_cat<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0> >, COMDAT

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 955  : 	}

	ret	0
??$_Iter_cat@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@0@@Z ENDP ; std::_Iter_cat<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0> >
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAU_GUID@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU_GUID@@0@Z ; std::_Ptr_cat<_GUID *,_GUID *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@PAU_GUID@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU_GUID@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAU_GUID@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU_GUID@@0@Z PROC ; std::_Ptr_cat<_GUID *,_GUID *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAU_GUID@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU_GUID@@0@Z ENDP ; std::_Ptr_cat<_GUID *,_GUID *>
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U_GUID@@@std@@QBEIXZ	; std::allocator<_GUID>::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@U_GUID@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U_GUID@@@std@@QBEIXZ PROC		; std::allocator<_GUID>::max_size, COMDAT
; _this$ = ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 268435455				; 0fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@U_GUID@@@std@@QBEIXZ ENDP		; std::allocator<_GUID>::max_size
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAE@PAU_GUID@@@Z ; std::_Vector_const_iterator<_GUID,std::allocator<_GUID> >::_Vector_const_iterator<_GUID,std::allocator<_GUID> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAE@PAU_GUID@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAE@PAU_GUID@@@Z PROC ; std::_Vector_const_iterator<_GUID,std::allocator<_GUID> >::_Vector_const_iterator<_GUID,std::allocator<_GUID> >, COMDAT
; _this$ = ecx

; 84   : 	explicit _Vector_const_iterator(_Tptr _Ptr)

	mov	eax, ecx

; 85   : 		{	// construct with pointer _Ptr
; 86   : 		_Myptr = _Ptr;

	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 87   : 		}

	ret	4
??0?$_Vector_const_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAE@PAU_GUID@@@Z ENDP ; std::_Vector_const_iterator<_GUID,std::allocator<_GUID> >::_Vector_const_iterator<_GUID,std::allocator<_GUID> >
_TEXT	ENDS
PUBLIC	??$_Destroy@U_GUID@@@std@@YAXPAU_GUID@@@Z	; std::_Destroy<_GUID>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy@U_GUID@@@std@@YAXPAU_GUID@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_GUID@@@std@@YAXPAU_GUID@@@Z PROC		; std::_Destroy<_GUID>, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@U_GUID@@@std@@YAXPAU_GUID@@@Z ENDP		; std::_Destroy<_GUID>
_TEXT	ENDS
PUBLIC	?capacity@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QBEIXZ ; std::vector<_GUID,std::allocator<_GUID> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QBEIXZ PROC ; std::vector<_GUID,std::allocator<_GUID> >::capacity, COMDAT
; _this$ = ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	edx, DWORD PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN3@capacity
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+12]
	sub	eax, edx
	sar	eax, 4

; 636  : 		}

	ret	0
?capacity@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QBEIXZ ENDP ; std::vector<_GUID,std::allocator<_GUID> >::capacity
_TEXT	ENDS
PUBLIC	??$swap@U_GUID@@@std@@YAXAAU_GUID@@0@Z		; std::swap<_GUID>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$swap@U_GUID@@@std@@YAXAAU_GUID@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@U_GUID@@@std@@YAXAAU_GUID@@0@Z PROC		; std::swap<_GUID>, COMDAT

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@swap

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [eax]
	push	ebx
	mov	ebx, DWORD PTR [eax+12]
	push	ebp

; 21   : 
; 22   : 		_Left = _Right;

	mov	ebp, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi
	mov	edi, DWORD PTR [eax+8]
	mov	DWORD PTR [eax], ebp
	mov	ebp, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ebp
	mov	ebp, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ebp
	mov	ebp, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ebp

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx+8], edi
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [ecx+12], ebx
	pop	ebx
$LN1@swap:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@U_GUID@@@std@@YAXAAU_GUID@@0@Z ENDP		; std::swap<_GUID>
_TEXT	ENDS
PUBLIC	??E?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEAAV012@XZ ; std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0>::operator++
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ??E?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??E?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEAAV012@XZ PROC ; std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0>::operator++, COMDAT
; _this$ = ecx

; 235  : 			{	// preincrement

	mov	eax, ecx

; 236  : 
; 237  :  #if _HAS_ITERATOR_DEBUGGING
; 238  : 			if (this->_Mycont == 0
; 239  : 				|| _Ptr == 0
; 240  : 				|| _Ptr == ((_Myt *)this->_Mycont)->_Myhead)
; 241  : 				{
; 242  : 				_DEBUG_ERROR("list iterator not incrementable");
; 243  : 				_SCL_SECURE_TRAITS_OUT_OF_RANGE;
; 244  : 				}
; 245  :  #else
; 246  : 			_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container());
; 247  : 			_SCL_SECURE_TRAITS_VALIDATE_RANGE(_Ptr != ((_Myt *)(this->_Getmycont()))->_Myhead);
; 248  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 249  : 
; 250  : 			_Ptr = _Nextnode(_Ptr);

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 251  : 			return (*this);
; 252  : 			}

	ret	0
??E?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEAAV012@XZ ENDP ; std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0>::operator++
_TEXT	ENDS
PUBLIC	??8?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QBE_NABV012@@Z ; std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0>::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QBE_NABV012@@Z PROC ; std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0>::operator==, COMDAT
; _this$ = ecx

; 291  : 
; 292  :  #if _HAS_ITERATOR_DEBUGGING
; 293  : 			_Compat(_Right);
; 294  :  #else
; 295  : 			_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container() && this->_Same_container(_Right));
; 296  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 297  : 
; 298  : 			return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	sete	cl
	mov	al, cl

; 299  : 			}

	ret	4
??8?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QBE_NABV012@@Z ENDP ; std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0>::operator==
_TEXT	ENDS
PUBLIC	??$_Move_cat@PAU_GUID@@@std@@YA?AU_Undefined_move_tag@0@ABQAU_GUID@@@Z ; std::_Move_cat<_GUID *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Move_cat@PAU_GUID@@@std@@YA?AU_Undefined_move_tag@0@ABQAU_GUID@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAU_GUID@@@std@@YA?AU_Undefined_move_tag@0@ABQAU_GUID@@@Z PROC ; std::_Move_cat<_GUID *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAU_GUID@@@std@@YA?AU_Undefined_move_tag@0@ABQAU_GUID@@@Z ENDP ; std::_Move_cat<_GUID *>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@PAU_GUID@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@0@AAPAU_GUID@@@Z ; std::_Ptr_cat<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0>,_GUID *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ptr_cat@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@PAU_GUID@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@0@AAPAU_GUID@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@PAU_GUID@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@0@AAPAU_GUID@@@Z PROC ; std::_Ptr_cat<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0>,_GUID *>, COMDAT

; 1509 : 	{

	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1512 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@PAU_GUID@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@0@AAPAU_GUID@@@Z ENDP ; std::_Ptr_cat<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0>,_GUID *>
_TEXT	ENDS
PUBLIC	?_Myval@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@KAAAU_GUID@@PAU_Node@?$_List_nod@U_GUID@@V?$allocator@U_GUID@@@std@@@2@@Z ; std::list<_GUID,std::allocator<_GUID> >::_Myval
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ?_Myval@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@KAAAU_GUID@@PAU_Node@?$_List_nod@U_GUID@@V?$allocator@U_GUID@@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@KAAAU_GUID@@PAU_Node@?$_List_nod@U_GUID@@V?$allocator@U_GUID@@@std@@@2@@Z PROC ; std::list<_GUID,std::allocator<_GUID> >::_Myval, COMDAT

; 125  : 		return ((_Vref)(*_Pnode)._Myval);

	mov	eax, DWORD PTR __Pnode$[esp-4]
	add	eax, 8

; 126  : 		}

	ret	0
?_Myval@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@KAAAU_GUID@@PAU_Node@?$_List_nod@U_GUID@@V?$allocator@U_GUID@@@std@@@2@@Z ENDP ; std::list<_GUID,std::allocator<_GUID> >::_Myval
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	esi
	lea	eax, DWORD PTR __Message$[esp]
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[esp-4]

; 60   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	eax, DWORD PTR __Message$[esp+16]
	push	eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 31   : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
_TEXT	ENDS
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 35   : 		return (_Str.c_str());

	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN6@scalar@2
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@scalar@2:
	mov	eax, esi
	pop	esi
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
; Function compile flags: /Ogtpy
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 110  : 		}

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, esi
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN8@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN8@scalar@3:
	mov	eax, esi
	pop	esi
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?GetInterfaceId@ICvUnknown@@SG?AU_GUID@@XZ	; ICvUnknown::GetInterfaceId
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredllutil\include\cvdllinterfaces.h
;	COMDAT ?GetInterfaceId@ICvUnknown@@SG?AU_GUID@@XZ
_TEXT	SEGMENT
$T220995 = 8						; size = 4
?GetInterfaceId@ICvUnknown@@SG?AU_GUID@@XZ PROC		; ICvUnknown::GetInterfaceId, COMDAT

; 306  : 	static GUID DLLCALL GetInterfaceId(){ return guidICvUnknown; }

	mov	eax, DWORD PTR $T220995[esp-4]
	mov	ecx, DWORD PTR _guidICvUnknown
	mov	edx, DWORD PTR _guidICvUnknown+4
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _guidICvUnknown+8
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR _guidICvUnknown+12
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], edx
	ret	4
?GetInterfaceId@ICvUnknown@@SG?AU_GUID@@XZ ENDP		; ICvUnknown::GetInterfaceId
_TEXT	ENDS
PUBLIC	?GetInterfaceId@ICvEnumerator@@SG?AU_GUID@@XZ	; ICvEnumerator::GetInterfaceId
; Function compile flags: /Ogtpy
;	COMDAT ?GetInterfaceId@ICvEnumerator@@SG?AU_GUID@@XZ
_TEXT	SEGMENT
$T220999 = 8						; size = 4
?GetInterfaceId@ICvEnumerator@@SG?AU_GUID@@XZ PROC	; ICvEnumerator::GetInterfaceId, COMDAT

; 332  : 	static GUID DLLCALL GetInterfaceId(){ return guidICvEnumerator; }

	mov	eax, DWORD PTR $T220999[esp-4]
	mov	ecx, DWORD PTR _guidICvEnumerator
	mov	edx, DWORD PTR _guidICvEnumerator+4
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _guidICvEnumerator+8
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR _guidICvEnumerator+12
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], edx
	ret	4
?GetInterfaceId@ICvEnumerator@@SG?AU_GUID@@XZ ENDP	; ICvEnumerator::GetInterfaceId
_TEXT	ENDS
PUBLIC	?GetInterfaceId@ICvDlcPackageInfo1@@SG?AU_GUID@@XZ ; ICvDlcPackageInfo1::GetInterfaceId
; Function compile flags: /Ogtpy
;	COMDAT ?GetInterfaceId@ICvDlcPackageInfo1@@SG?AU_GUID@@XZ
_TEXT	SEGMENT
$T221003 = 8						; size = 4
?GetInterfaceId@ICvDlcPackageInfo1@@SG?AU_GUID@@XZ PROC	; ICvDlcPackageInfo1::GetInterfaceId, COMDAT

; 384  : 	static GUID DLLCALL GetInterfaceId() { return guidICvDlcPackageInfo1; }

	mov	eax, DWORD PTR $T221003[esp-4]
	mov	ecx, DWORD PTR _guidICvDlcPackageInfo1
	mov	edx, DWORD PTR _guidICvDlcPackageInfo1+4
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR _guidICvDlcPackageInfo1+8
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR _guidICvDlcPackageInfo1+12
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], edx
	ret	4
?GetInterfaceId@ICvDlcPackageInfo1@@SG?AU_GUID@@XZ ENDP	; ICvDlcPackageInfo1::GetInterfaceId
_TEXT	ENDS
PUBLIC	??_7ICvDlcPackageInfo1@@6B@			; ICvDlcPackageInfo1::`vftable'
PUBLIC	??0ICvDlcPackageInfo1@@QAE@XZ			; ICvDlcPackageInfo1::ICvDlcPackageInfo1
PUBLIC	??_R4ICvDlcPackageInfo1@@6B@			; ICvDlcPackageInfo1::`RTTI Complete Object Locator'
;	COMDAT ??_R4ICvDlcPackageInfo1@@6B@
rdata$r	SEGMENT
??_R4ICvDlcPackageInfo1@@6B@ DD 00H			; ICvDlcPackageInfo1::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVICvDlcPackageInfo1@@@8
	DD	FLAT:??_R3ICvDlcPackageInfo1@@8
rdata$r	ENDS
;	COMDAT ??_7ICvDlcPackageInfo1@@6B@
CONST	SEGMENT
??_7ICvDlcPackageInfo1@@6B@ DD FLAT:??_R4ICvDlcPackageInfo1@@6B@ ; ICvDlcPackageInfo1::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0ICvDlcPackageInfo1@@QAE@XZ
_TEXT	SEGMENT
??0ICvDlcPackageInfo1@@QAE@XZ PROC			; ICvDlcPackageInfo1::ICvDlcPackageInfo1, COMDAT
; _this$ = ecx
	mov	eax, ecx
	mov	DWORD PTR [eax], OFFSET ??_7ICvDlcPackageInfo1@@6B@
	ret	0
??0ICvDlcPackageInfo1@@QAE@XZ ENDP			; ICvDlcPackageInfo1::ICvDlcPackageInfo1
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvdlldlcpackageinfo.cpp
_TEXT	ENDS
;	COMDAT ?QueryInterface@CvDllDlcPackageInfo@@UAGPAXU_GUID@@@Z
_TEXT	SEGMENT
$T221015 = -16						; size = 16
$T221013 = -16						; size = 16
_this$ = 8						; size = 4
_guidInterface$ = 12					; size = 16
?QueryInterface@CvDllDlcPackageInfo@@UAGPAXU_GUID@@@Z PROC ; CvDllDlcPackageInfo::QueryInterface, COMDAT

; 24   : {

	sub	esp, 16					; 00000010H

; 25   : 	if(guidInterface == ICvUnknown::GetInterfaceId() ||
; 26   : 	        guidInterface == ICvDlcPackageInfo1::GetInterfaceId())

	mov	ecx, DWORD PTR _guidICvUnknown+4
	mov	edx, DWORD PTR _guidICvUnknown+8
	mov	eax, DWORD PTR _guidICvUnknown
	mov	DWORD PTR $T221013[esp+20], ecx
	lea	ecx, DWORD PTR $T221013[esp+16]
	mov	DWORD PTR $T221013[esp+24], edx
	mov	DWORD PTR $T221013[esp+16], eax
	mov	eax, DWORD PTR _guidICvUnknown+12
	push	ecx
	lea	edx, DWORD PTR _guidInterface$[esp+16]
	push	edx
	mov	DWORD PTR $T221013[esp+36], eax
	call	_IsEqualGUID
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1@QueryInter
	mov	ecx, DWORD PTR _guidICvDlcPackageInfo1+4
	mov	edx, DWORD PTR _guidICvDlcPackageInfo1+8
	mov	eax, DWORD PTR _guidICvDlcPackageInfo1
	mov	DWORD PTR $T221015[esp+20], ecx
	lea	ecx, DWORD PTR $T221015[esp+16]
	mov	DWORD PTR $T221015[esp+24], edx
	mov	DWORD PTR $T221015[esp+16], eax
	mov	eax, DWORD PTR _guidICvDlcPackageInfo1+12
	push	ecx
	lea	edx, DWORD PTR _guidInterface$[esp+16]
	push	edx
	mov	DWORD PTR $T221015[esp+36], eax
	call	_IsEqualGUID
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1@QueryInter

; 29   : 		return this;
; 30   : 	}
; 31   : 
; 32   : 	return NULL;
; 33   : }

	add	esp, 16					; 00000010H
	ret	20					; 00000014H
$LN1@QueryInter:

; 27   : 	{
; 28   : 		IncrementReference();

	mov	eax, DWORD PTR _this$[esp+12]
	inc	DWORD PTR [eax+4]

; 29   : 		return this;
; 30   : 	}
; 31   : 
; 32   : 	return NULL;
; 33   : }

	add	esp, 16					; 00000010H
	ret	20					; 00000014H
?QueryInterface@CvDllDlcPackageInfo@@UAGPAXU_GUID@@@Z ENDP ; CvDllDlcPackageInfo::QueryInterface
_TEXT	ENDS
PUBLIC	??_GCvDllDlcPackageInfo@@QAEPAXI@Z		; CvDllDlcPackageInfo::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvDllDlcPackageInfo@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvDllDlcPackageInfo@@QAEPAXI@Z PROC			; CvDllDlcPackageInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvDllDlcPackageInfo@@6B@
	je	SHORT $LN8@scalar@4
	push	esi
	call	?Free@CvDllGameContext@@SAXPAX@Z	; CvDllGameContext::Free
	add	esp, 4
$LN8@scalar@4:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvDllDlcPackageInfo@@QAEPAXI@Z ENDP			; CvDllDlcPackageInfo::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?QueryInterface@CvDllDlcPackageInfoList@@UAGPAXU_GUID@@@Z ; CvDllDlcPackageInfoList::QueryInterface
; Function compile flags: /Ogtpy
;	COMDAT ?QueryInterface@CvDllDlcPackageInfoList@@UAGPAXU_GUID@@@Z
_TEXT	SEGMENT
$T221049 = -16						; size = 16
$T221047 = -16						; size = 16
_this$ = 8						; size = 4
_guidInterface$ = 12					; size = 16
?QueryInterface@CvDllDlcPackageInfoList@@UAGPAXU_GUID@@@Z PROC ; CvDllDlcPackageInfoList::QueryInterface, COMDAT

; 92   : {

	sub	esp, 16					; 00000010H

; 93   : 	if(guidInterface == ICvUnknown::GetInterfaceId() ||
; 94   : 	        guidInterface == ICvEnumerator::GetInterfaceId())

	mov	ecx, DWORD PTR _guidICvUnknown+4
	mov	edx, DWORD PTR _guidICvUnknown+8
	mov	eax, DWORD PTR _guidICvUnknown
	mov	DWORD PTR $T221047[esp+20], ecx
	lea	ecx, DWORD PTR $T221047[esp+16]
	mov	DWORD PTR $T221047[esp+24], edx
	mov	DWORD PTR $T221047[esp+16], eax
	mov	eax, DWORD PTR _guidICvUnknown+12
	push	ecx
	lea	edx, DWORD PTR _guidInterface$[esp+16]
	push	edx
	mov	DWORD PTR $T221047[esp+36], eax
	call	_IsEqualGUID
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1@QueryInter@2
	mov	ecx, DWORD PTR _guidICvEnumerator+4
	mov	edx, DWORD PTR _guidICvEnumerator+8
	mov	eax, DWORD PTR _guidICvEnumerator
	mov	DWORD PTR $T221049[esp+20], ecx
	lea	ecx, DWORD PTR $T221049[esp+16]
	mov	DWORD PTR $T221049[esp+24], edx
	mov	DWORD PTR $T221049[esp+16], eax
	mov	eax, DWORD PTR _guidICvEnumerator+12
	push	ecx
	lea	edx, DWORD PTR _guidInterface$[esp+16]
	push	edx
	mov	DWORD PTR $T221049[esp+36], eax
	call	_IsEqualGUID
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN1@QueryInter@2

; 97   : 		return this;
; 98   : 	}
; 99   : 
; 100  : 	return NULL;
; 101  : }

	add	esp, 16					; 00000010H
	ret	20					; 00000014H
$LN1@QueryInter@2:

; 95   : 	{
; 96   : 		IncrementReference();

	mov	eax, DWORD PTR _this$[esp+12]
	inc	DWORD PTR [eax+4]

; 97   : 		return this;
; 98   : 	}
; 99   : 
; 100  : 	return NULL;
; 101  : }

	add	esp, 16					; 00000010H
	ret	20					; 00000014H
?QueryInterface@CvDllDlcPackageInfoList@@UAGPAXU_GUID@@@Z ENDP ; CvDllDlcPackageInfoList::QueryInterface
_TEXT	ENDS
PUBLIC	?MoveNext@CvDllDlcPackageInfoList@@UAG_NXZ	; CvDllDlcPackageInfoList::MoveNext
; Function compile flags: /Ogtpy
;	COMDAT ?MoveNext@CvDllDlcPackageInfoList@@UAG_NXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?MoveNext@CvDllDlcPackageInfoList@@UAG_NXZ PROC		; CvDllDlcPackageInfoList::MoveNext, COMDAT

; 145  : 	if(m_iIndex == -1)	// In the uninitialized state?

	mov	eax, DWORD PTR _this$[esp-4]
	mov	ecx, DWORD PTR [eax+24]
	cmp	ecx, -1
	jne	SHORT $LN2@MoveNext

; 146  : 	{
; 147  : 		if(m_packageIDs.size() > 0)	// Any in the list?

	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 4
	test	ecx, ecx
	jbe	SHORT $LN3@MoveNext

; 148  : 		{
; 149  : 			m_iIndex = 0;	// then we can start

	mov	DWORD PTR [eax+24], 0

; 150  : 			return true;

	mov	al, 1

; 160  : }

	ret	4
$LN3@MoveNext:

; 151  : 		}
; 152  : 		else
; 153  : 			return false;	// Nope, just leave as -1 and return false

	xor	al, al

; 160  : }

	ret	4
$LN2@MoveNext:

; 154  : 	}
; 155  : 
; 156  : 	if((size_t)m_iIndex < m_packageIDs.size())

	mov	edx, DWORD PTR [eax+16]
	sub	edx, DWORD PTR [eax+12]
	sar	edx, 4
	cmp	ecx, edx
	jae	SHORT $LN1@MoveNext

; 157  : 		m_iIndex++;

	inc	ecx
	mov	DWORD PTR [eax+24], ecx
$LN1@MoveNext:

; 158  : 
; 159  : 	return (size_t)m_iIndex < m_packageIDs.size();

	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 4
	cmp	DWORD PTR [eax+24], ecx
	sbb	eax, eax
	neg	eax

; 160  : }

	ret	4
?MoveNext@CvDllDlcPackageInfoList@@UAG_NXZ ENDP		; CvDllDlcPackageInfoList::MoveNext
_TEXT	ENDS
PUBLIC	?begin@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QBE?AV?$_Const_iterator@$0A@@12@XZ ; std::list<_GUID,std::allocator<_GUID> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ?begin@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QBE?AV?$_Const_iterator@$0A@@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QBE?AV?$_Const_iterator@$0A@@12@XZ PROC ; std::list<_GUID,std::allocator<_GUID> >::begin, COMDAT
; _this$ = ecx

; 565  : 		return (const_iterator(_Nextnode(_Myhead)));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 566  : 		}

	ret	4
?begin@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QBE?AV?$_Const_iterator@$0A@@12@XZ ENDP ; std::list<_GUID,std::allocator<_GUID> >::begin
_TEXT	ENDS
PUBLIC	?end@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QBE?AV?$_Const_iterator@$0A@@12@XZ ; std::list<_GUID,std::allocator<_GUID> >::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QBE?AV?$_Const_iterator@$0A@@12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QBE?AV?$_Const_iterator@$0A@@12@XZ PROC ; std::list<_GUID,std::allocator<_GUID> >::end, COMDAT
; _this$ = ecx

; 575  : 		return (const_iterator(_Myhead));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 576  : 		}

	ret	4
?end@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QBE?AV?$_Const_iterator@$0A@@12@XZ ENDP ; std::list<_GUID,std::allocator<_GUID> >::end
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAE@XZ ; std::_Vector_val<_GUID,std::allocator<_GUID> >::~_Vector_val<_GUID,std::allocator<_GUID> >
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Vector_val@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<_GUID,std::allocator<_GUID> >::~_Vector_val<_GUID,std::allocator<_GUID> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_Vector_val@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<_GUID,std::allocator<_GUID> >::~_Vector_val<_GUID,std::allocator<_GUID> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@IAE@V?$allocator@U_GUID@@@1@@Z ; std::_Vector_val<_GUID,std::allocator<_GUID> >::_Vector_val<_GUID,std::allocator<_GUID> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@IAE@V?$allocator@U_GUID@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@IAE@V?$allocator@U_GUID@@@1@@Z PROC ; std::_Vector_val<_GUID,std::allocator<_GUID> >::_Vector_val<_GUID,std::allocator<_GUID> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	mov	eax, ecx

; 426  : 		}

	ret	4
??0?$_Vector_val@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@IAE@V?$allocator@U_GUID@@@1@@Z ENDP ; std::_Vector_val<_GUID,std::allocator<_GUID> >::_Vector_val<_GUID,std::allocator<_GUID> >
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_GUID@@@std@@QAEXPAU_GUID@@@Z ; std::allocator<_GUID>::destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@U_GUID@@@std@@QAEXPAU_GUID@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_GUID@@@std@@QAEXPAU_GUID@@@Z PROC ; std::allocator<_GUID>::destroy, COMDAT
; _this$ = ecx

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	4
?destroy@?$allocator@U_GUID@@@std@@QAEXPAU_GUID@@@Z ENDP ; std::allocator<_GUID>::destroy
_TEXT	ENDS
PUBLIC	?max_size@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QBEIXZ ; std::vector<_GUID,std::allocator<_GUID> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QBEIXZ PROC ; std::vector<_GUID,std::allocator<_GUID> >::max_size, COMDAT
; _this$ = ecx

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 268435455				; 0fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QBEIXZ ENDP ; std::vector<_GUID,std::allocator<_GUID> >::max_size
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@KAXXZ ; std::vector<_GUID,std::allocator<_GUID> >::_Xlen
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@KAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@KAXXZ$2
__ehfuncinfo$?_Xlen@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@KAXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T221143 = -80						; size = 28
$T221142 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@KAXXZ PROC ; std::vector<_GUID,std::allocator<_GUID> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 68					; 00000044H

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T221143[esp+84]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	lea	ecx, DWORD PTR $T221142[esp+80]
	mov	DWORD PTR __$EHRec$[esp+88], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	lea	eax, DWORD PTR $T221143[esp+80]
	push	eax
	lea	ecx, DWORD PTR $T221142[esp+96]
	mov	BYTE PTR __$EHRec$[esp+92], 1
	mov	DWORD PTR $T221142[esp+84], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T221142[esp+84]
	push	ecx
	mov	BYTE PTR __$EHRec$[esp+96], 0
	mov	DWORD PTR $T221142[esp+88], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN13@Xlen:
$LN12@Xlen:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T221143[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?_Xlen@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@KAXXZ$2:
	lea	ecx, DWORD PTR $T221142[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$?_Xlen@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@KAXXZ ENDP ; std::vector<_GUID,std::allocator<_GUID> >::_Xlen
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+20]
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	add	edi, 12					; 0000000cH
	push	edi
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR __$EHRec$[esp+36], 0
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
; Function compile flags: /Ogtpy
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAE@PAU_GUID@@@Z ; std::_Vector_iterator<_GUID,std::allocator<_GUID> >::_Vector_iterator<_GUID,std::allocator<_GUID> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$_Vector_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAE@PAU_GUID@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAE@PAU_GUID@@@Z PROC ; std::_Vector_iterator<_GUID,std::allocator<_GUID> >::_Vector_iterator<_GUID,std::allocator<_GUID> >, COMDAT
; _this$ = ecx

; 333  : 		{	// construct with pointer _Ptr

	mov	eax, ecx
	mov	ecx, DWORD PTR __Ptr$[esp-4]
	mov	DWORD PTR [eax], ecx

; 334  : 		}

	ret	4
??0?$_Vector_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAE@PAU_GUID@@@Z ENDP ; std::_Vector_iterator<_GUID,std::allocator<_GUID> >::_Vector_iterator<_GUID,std::allocator<_GUID> >
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@U_GUID@@@std@@YAPAU_GUID@@IPAU1@@Z	; std::_Allocate<_GUID>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@U_GUID@@@std@@YAPAU_GUID@@IPAU1@@Z
_TEXT	SEGMENT
$T221189 = -12						; size = 12
$T221193 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_GUID@@@std@@YAPAU_GUID@@IPAU1@@Z PROC	; std::_Allocate<_GUID>, COMDAT

; 37   : 	if (_Count <= 0)

	mov	ecx, DWORD PTR __Count$[esp-4]
	sub	esp, 12					; 0000000cH
	test	ecx, ecx
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	xor	ecx, ecx
$LN1@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	shl	ecx, 4
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 12					; 0000000cH
	ret	0
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 16					; 00000010H
	jae	SHORT $LN1@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T221193[esp+8]
	push	eax
	lea	ecx, DWORD PTR $T221189[esp+16]
	mov	DWORD PTR $T221193[esp+12], 0
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T221189[esp+16]
	push	ecx
	mov	DWORD PTR $T221189[esp+20], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN9@Allocate:
$LN8@Allocate:
	int	3
??$_Allocate@U_GUID@@@std@@YAPAU_GUID@@IPAU1@@Z ENDP	; std::_Allocate<_GUID>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??$_Swap_adl@U_GUID@@@std@@YAXAAU_GUID@@0@Z	; std::_Swap_adl<_GUID>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
;	COMDAT ??$_Swap_adl@U_GUID@@@std@@YAXAAU_GUID@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Swap_adl@U_GUID@@@std@@YAXAAU_GUID@@0@Z PROC	; std::_Swap_adl<_GUID>, COMDAT

; 31   : 	swap(_Left, _Right);

	mov	eax, DWORD PTR __Left$[esp-4]
	mov	ecx, DWORD PTR __Right$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN3@Swap_adl
	mov	edx, DWORD PTR [eax]
	push	ebx
	mov	ebx, DWORD PTR [eax+12]
	push	ebp
	mov	ebp, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	push	edi
	mov	edi, DWORD PTR [eax+8]
	mov	DWORD PTR [eax], ebp
	mov	ebp, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ebp
	mov	ebp, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ebp
	mov	ebp, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ebp
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [ecx+8], edi
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [ecx+12], ebx
	pop	ebx
$LN3@Swap_adl:

; 32   : 	}

	ret	0
??$_Swap_adl@U_GUID@@@std@@YAXAAU_GUID@@0@Z ENDP	; std::_Swap_adl<_GUID>
_TEXT	ENDS
PUBLIC	??9?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QBE_NABV012@@Z ; std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0>::operator!=
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\list
;	COMDAT ??9?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QBE_NABV012@@Z PROC ; std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0>::operator!=, COMDAT
; _this$ = ecx

; 303  : 			return (!(*this == _Right));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR __Right$[esp-4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx]
	setne	cl
	mov	al, cl

; 304  : 			}

	ret	4
??9?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QBE_NABV012@@Z ENDP ; std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0>::operator!=
_TEXT	ENDS
PUBLIC	??D?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QBEABU_GUID@@XZ ; std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0>::operator*
; Function compile flags: /Ogtpy
;	COMDAT ??D?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QBEABU_GUID@@XZ
_TEXT	SEGMENT
??D?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QBEABU_GUID@@XZ PROC ; std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0>::operator*, COMDAT
; _this$ = ecx

; 212  : 
; 213  :  #if _HAS_ITERATOR_DEBUGGING
; 214  : 			if (this->_Mycont == 0
; 215  : 				|| _Ptr == 0
; 216  : 				|| _Ptr == ((_Myt *)this->_Mycont)->_Myhead)
; 217  : 				{
; 218  : 				_DEBUG_ERROR("list iterator not dereferencable");
; 219  : 				_SCL_SECURE_TRAITS_OUT_OF_RANGE;
; 220  : 				}
; 221  :  #else
; 222  : 			_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container());
; 223  : 			_SCL_SECURE_TRAITS_VALIDATE_RANGE(_Ptr != ((_Myt *)(this->_Getmycont()))->_Myhead);
; 224  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 225  : 
; 226  : 			return (_Myval(_Ptr));

	mov	eax, DWORD PTR [ecx]
	add	eax, 8

; 227  : 			}

	ret	0
??D?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QBEABU_GUID@@XZ ENDP ; std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0>::operator*
_TEXT	ENDS
PUBLIC	??$_Construct@U_GUID@@U1@@std@@YAXPAU_GUID@@ABU1@@Z ; std::_Construct<_GUID,_GUID>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Construct@U_GUID@@U1@@std@@YAXPAU_GUID@@ABU1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@U_GUID@@U1@@std@@YAXPAU_GUID@@ABU1@@Z PROC ; std::_Construct<_GUID,_GUID>, COMDAT

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN3@Construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ecx
$LN3@Construct:

; 53   : 	}

	ret	0
??$_Construct@U_GUID@@U1@@std@@YAXPAU_GUID@@ABU1@@Z ENDP ; std::_Construct<_GUID,_GUID>
_TEXT	ENDS
PUBLIC	??0CvDllDlcPackageInfo@@QAE@ABU_GUID@@@Z	; CvDllDlcPackageInfo::CvDllDlcPackageInfo
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvdlldlcpackageinfo.cpp
;	COMDAT ??0CvDllDlcPackageInfo@@QAE@ABU_GUID@@@Z
_TEXT	SEGMENT
_kGuid$ = 8						; size = 4
??0CvDllDlcPackageInfo@@QAE@ABU_GUID@@@Z PROC		; CvDllDlcPackageInfo::CvDllDlcPackageInfo, COMDAT
; _this$ = ecx

; 16   : {

	mov	eax, ecx
	mov	ecx, DWORD PTR _kGuid$[esp-4]
	mov	DWORD PTR [eax], OFFSET ??_7CvDllDlcPackageInfo@@6B@
	mov	DWORD PTR [eax+4], 1
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+16], edx
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+20], ecx

; 17   : }

	ret	4
??0CvDllDlcPackageInfo@@QAE@ABU_GUID@@@Z ENDP		; CvDllDlcPackageInfo::CvDllDlcPackageInfo
_TEXT	ENDS
PUBLIC	?DecrementReference@CvDllDlcPackageInfo@@QAEIXZ	; CvDllDlcPackageInfo::DecrementReference
; Function compile flags: /Ogtpy
;	COMDAT ?DecrementReference@CvDllDlcPackageInfo@@QAEIXZ
_TEXT	SEGMENT
?DecrementReference@CvDllDlcPackageInfo@@QAEIXZ PROC	; CvDllDlcPackageInfo::DecrementReference, COMDAT
; _this$ = ecx

; 43   : 	if(m_uiRefCount == 1)

	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, 1
	jne	SHORT $LN2@DecrementR

; 44   : 	{
; 45   : 		delete this;

	push	ecx
	mov	DWORD PTR [ecx], OFFSET ??_7CvDllDlcPackageInfo@@6B@
	call	?Free@CvDllGameContext@@SAXPAX@Z	; CvDllGameContext::Free
	add	esp, 4

; 46   : 		return 0;

	xor	eax, eax

; 51   : 		return m_uiRefCount;
; 52   : 	}
; 53   : }

	ret	0
$LN2@DecrementR:

; 47   : 	}
; 48   : 	else
; 49   : 	{
; 50   : 		--m_uiRefCount;

	dec	eax
	mov	DWORD PTR [ecx+4], eax

; 51   : 		return m_uiRefCount;
; 52   : 	}
; 53   : }

	ret	0
?DecrementReference@CvDllDlcPackageInfo@@QAEIXZ ENDP	; CvDllDlcPackageInfo::DecrementReference
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Destroy@CvDllDlcPackageInfo@@EAGXXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?Destroy@CvDllDlcPackageInfo@@EAGXXZ PROC		; CvDllDlcPackageInfo::Destroy, COMDAT

; 62   : 	DecrementReference();

	mov	eax, DWORD PTR _this$[esp-4]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, 1
	jne	SHORT $LN4@Destroy
	push	eax
	mov	DWORD PTR [eax], OFFSET ??_7CvDllDlcPackageInfo@@6B@
	call	?Free@CvDllGameContext@@SAXPAX@Z	; CvDllGameContext::Free
	add	esp, 4

; 63   : }

	ret	4

; 62   : 	DecrementReference();

$LN4@Destroy:
	dec	ecx
	mov	DWORD PTR [eax+4], ecx

; 63   : }

	ret	4
?Destroy@CvDllDlcPackageInfo@@EAGXXZ ENDP		; CvDllDlcPackageInfo::Destroy
_TEXT	ENDS
PUBLIC	?GetCurrent@CvDllDlcPackageInfoList@@UAGPAVICvUnknown@@XZ ; CvDllDlcPackageInfoList::GetCurrent
; Function compile flags: /Ogtpy
;	COMDAT ?GetCurrent@CvDllDlcPackageInfoList@@UAGPAVICvUnknown@@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?GetCurrent@CvDllDlcPackageInfoList@@UAGPAVICvUnknown@@XZ PROC ; CvDllDlcPackageInfoList::GetCurrent, COMDAT

; 168  : {

	push	esi

; 169  : 	if(m_iIndex > -1 && (size_t)m_iIndex < m_packageIDs.size())

	mov	esi, DWORD PTR _this$[esp]
	mov	eax, DWORD PTR [esi+24]
	cmp	eax, -1
	jle	SHORT $LN1@GetCurrent
	mov	ecx, DWORD PTR [esi+16]
	sub	ecx, DWORD PTR [esi+12]
	sar	ecx, 4
	cmp	eax, ecx
	jae	SHORT $LN1@GetCurrent

; 170  : 	{
; 171  : 		return new CvDllDlcPackageInfo(m_packageIDs[m_iIndex]);

	push	24					; 00000018H
	call	?Allocate@CvDllGameContext@@SAPAXI@Z	; CvDllGameContext::Allocate
	add	esp, 4
	test	eax, eax
	je	SHORT $LN1@GetCurrent
	mov	ecx, DWORD PTR [esi+24]
	shl	ecx, 4
	add	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [eax], OFFSET ??_7CvDllDlcPackageInfo@@6B@
	mov	DWORD PTR [eax+4], 1
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+16], edx
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+20], ecx
	pop	esi

; 175  : }

	ret	4
$LN1@GetCurrent:

; 172  : 	}
; 173  : 
; 174  : 	return NULL;

	xor	eax, eax
	pop	esi

; 175  : }

	ret	4
?GetCurrent@CvDllDlcPackageInfoList@@UAGPAVICvUnknown@@XZ ENDP ; CvDllDlcPackageInfoList::GetCurrent
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@U_GUID@@@std@@@std@@YAXPAU_GUID@@0AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<_GUID> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@U_GUID@@@std@@@std@@YAXPAU_GUID@@0AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@U_GUID@@@std@@@std@@YAXPAU_GUID@@0AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<_GUID> >, COMDAT

; 233  : 	for (; _First != _Last; ++_First)
; 234  : 		_Al.destroy(_First);
; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@U_GUID@@@std@@@std@@YAXPAU_GUID@@0AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<_GUID> >
_TEXT	ENDS
PUBLIC	?begin@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAE?AV?$_Vector_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@2@XZ ; std::vector<_GUID,std::allocator<_GUID> >::begin
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAE?AV?$_Vector_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAE?AV?$_Vector_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@2@XZ PROC ; std::vector<_GUID,std::allocator<_GUID> >::begin, COMDAT
; _this$ = ecx

; 667  : 		return (iterator(_Myfirst));

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 668  : 		}

	ret	4
?begin@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAE?AV?$_Vector_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@2@XZ ENDP ; std::vector<_GUID,std::allocator<_GUID> >::begin
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_GUID@@@std@@QAEPAU_GUID@@I@Z ; std::allocator<_GUID>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_GUID@@@std@@QAEPAU_GUID@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U_GUID@@@std@@QAEPAU_GUID@@I@Z PROC ; std::allocator<_GUID>::allocate, COMDAT
; _this$ = ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	0
	push	eax
	call	??$_Allocate@U_GUID@@@std@@YAPAU_GUID@@IPAU1@@Z ; std::_Allocate<_GUID>
	add	esp, 8

; 146  : 		}

	ret	4
?allocate@?$allocator@U_GUID@@@std@@QAEPAU_GUID@@I@Z ENDP ; std::allocator<_GUID>::allocate
_TEXT	ENDS
PUBLIC	?_Reverse@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXPAU_GUID@@0@Z ; std::vector<_GUID,std::allocator<_GUID> >::_Reverse
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Reverse@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXPAU_GUID@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Reverse@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXPAU_GUID@@0@Z PROC ; std::vector<_GUID,std::allocator<_GUID> >::_Reverse, COMDAT
; _this$ = ecx

; 998  : 		for (; _First != _Last && _First != --_Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	ecx, DWORD PTR __Last$[esp-4]
	cmp	eax, ecx
	je	SHORT $LN1@Reverse
	push	ebx
	push	ebp
	push	esi
	push	edi
$LL3@Reverse:
	sub	ecx, 16					; 00000010H
	cmp	eax, ecx
	je	SHORT $LN14@Reverse

; 999  : 			_STD _Swap_adl(*_First, *_Last);

	mov	ebp, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [eax+4]
	mov	edi, DWORD PTR [eax+8]
	mov	ebx, DWORD PTR [eax+12]
	mov	DWORD PTR [eax], ebp
	mov	ebp, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], ebp
	mov	ebp, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], ebp
	mov	ebp, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ebp
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], esi
	add	eax, 16					; 00000010H
	mov	DWORD PTR [ecx+8], edi
	mov	DWORD PTR [ecx+12], ebx
	cmp	eax, ecx
	jne	SHORT $LL3@Reverse
$LN14@Reverse:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
$LN1@Reverse:

; 1000 : 		}

	ret	8
?_Reverse@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXPAU_GUID@@0@Z ENDP ; std::vector<_GUID,std::allocator<_GUID> >::_Reverse
_TEXT	ENDS
PUBLIC	??$_Distance2@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@I@std@@YAXV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ; std::_Distance2<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0>,unsigned int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Distance2@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@I@std@@YAXV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Distance2@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@I@std@@YAXV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z PROC ; std::_Distance2<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0>,unsigned int>, COMDAT

; 1858 : 	for (; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN1@Distance2
	mov	ecx, DWORD PTR __Off$[esp-4]
$LL6@Distance2:

; 1859 : 		++_Off;

	inc	DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __First$[esp-4], eax
	cmp	eax, edx
	jne	SHORT $LL6@Distance2
$LN1@Distance2:

; 1860 : 	}

	ret	0
??$_Distance2@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@I@std@@YAXV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ENDP ; std::_Distance2<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0>,unsigned int>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@U_GUID@@@std@@QAEXPAU_GUID@@ABU3@@Z ; std::allocator<_GUID>::construct
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?construct@?$allocator@U_GUID@@@std@@QAEXPAU_GUID@@ABU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@U_GUID@@@std@@QAEXPAU_GUID@@ABU3@@Z PROC ; std::allocator<_GUID>::construct, COMDAT
; _this$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	test	eax, eax
	je	SHORT $LN5@construct
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ecx
$LN5@construct:

; 156  : 		}

	ret	8
?construct@?$allocator@U_GUID@@@std@@QAEXPAU_GUID@@ABU3@@Z ENDP ; std::allocator<_GUID>::construct
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAU_GUID@@PAU1@V?$allocator@U_GUID@@@std@@@std@@YAPAU_GUID@@PAU1@00AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<_GUID *,_GUID *,std::allocator<_GUID> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAU_GUID@@PAU1@V?$allocator@U_GUID@@@std@@@std@@YAPAU_GUID@@PAU1@00AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAU_GUID@@PAU1@V?$allocator@U_GUID@@@std@@@std@@YAPAU_GUID@@PAU1@00AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<_GUID *,_GUID *,std::allocator<_GUID> >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop
	push	esi
$LL6@Uninit_cop:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
$LN5@Uninit_cop:
	add	ecx, 16					; 00000010H
	add	eax, 16					; 00000010H
	cmp	ecx, edx
	jne	SHORT $LL6@Uninit_cop
	pop	esi
$LN4@Uninit_cop:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@PAU_GUID@@PAU1@V?$allocator@U_GUID@@@std@@@std@@YAPAU_GUID@@PAU1@00AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<_GUID *,_GUID *,std::allocator<_GUID> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@U_GUID@@@std@@@std@@YAXPAU_GUID@@0AAV?$allocator@U_GUID@@@0@@Z ; std::_Destroy_range<std::allocator<_GUID> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@U_GUID@@@std@@@std@@YAXPAU_GUID@@0AAV?$allocator@U_GUID@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@U_GUID@@@std@@@std@@YAXPAU_GUID@@0AAV?$allocator@U_GUID@@@0@@Z PROC ; std::_Destroy_range<std::allocator<_GUID> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@U_GUID@@@std@@@std@@YAXPAU_GUID@@0AAV?$allocator@U_GUID@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<_GUID> >
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@IAE_NI@Z ; std::vector<_GUID,std::allocator<_GUID> >::_Buy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
__Capacity$ = 8						; size = 4
?_Buy@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@IAE_NI@Z PROC ; std::vector<_GUID,std::allocator<_GUID> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	esi

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;
; 1104 : 		if (_Capacity == 0)

	mov	esi, DWORD PTR __Capacity$[esp]
	xor	eax, eax
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR [edi+8], eax
	mov	DWORD PTR [edi+12], eax
	cmp	esi, eax
	jne	SHORT $LN4@Buy
	pop	edi

; 1105 : 			return (false);

	xor	al, al
	pop	esi

; 1115 : 		}

	ret	4
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	cmp	esi, 268435455				; 0fffffffH
	jbe	SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@KAXXZ ; std::vector<_GUID,std::allocator<_GUID> >::_Xlen
$LN16@Buy:
$LN2@Buy:

; 1108 : 		else
; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	push	eax
	push	esi
	call	??$_Allocate@U_GUID@@@std@@YAPAU_GUID@@IPAU1@@Z ; std::_Allocate<_GUID>

; 1111 : 			_Mylast = _Myfirst;
; 1112 : 			_Myend = _Myfirst + _Capacity;

	shl	esi, 4
	add	esi, eax
	add	esp, 8
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR [edi+8], eax
	mov	DWORD PTR [edi+12], esi
	pop	edi

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
	pop	esi

; 1115 : 		}

	ret	4
$LN15@Buy:
?_Buy@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<_GUID,std::allocator<_GUID> >::_Buy
_TEXT	ENDS
PUBLIC	??$_Distance@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@I@std@@YAXV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@0@0AAI@Z ; std::_Distance<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0>,unsigned int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Distance@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@I@std@@YAXV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@0@0AAI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
??$_Distance@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@I@std@@YAXV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@0@0AAI@Z PROC ; std::_Distance<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0>,unsigned int>, COMDAT

; 1893 : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

	mov	eax, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	cmp	eax, edx
	je	SHORT $LN5@Distance
	mov	ecx, DWORD PTR __Off$[esp-4]
$LL10@Distance:
	inc	DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	cmp	eax, edx
	jne	SHORT $LL10@Distance
$LN5@Distance:

; 1894 : 	}

	ret	0
??$_Distance@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@I@std@@YAXV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@0@0AAI@Z ENDP ; std::_Distance<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0>,unsigned int>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@PAU_GUID@@V?$allocator@U_GUID@@@3@@std@@YAPAU_GUID@@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@0@0PAU1@AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0>,_GUID *,std::allocator<_GUID> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@PAU_GUID@@V?$allocator@U_GUID@@@3@@std@@YAPAU_GUID@@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@0@0PAU1@AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@PAU_GUID@@V?$allocator@U_GUID@@@3@@std@@YAPAU_GUID@@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@0@0PAU1@AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0>,_GUID *,std::allocator<_GUID> >, COMDAT

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;
; 128  : 
; 129  : 	_TRY_BEGIN
; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	mov	eax, DWORD PTR __Dest$[esp-4]
	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@2
	push	esi
$LL14@Uninit_cop@2:

; 131  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop@2
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+12], esi
$LN5@Uninit_cop@2:
	mov	ecx, DWORD PTR [ecx]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __First$[esp], ecx
	cmp	ecx, edx
	jne	SHORT $LL14@Uninit_cop@2
	pop	esi
$LN4@Uninit_cop@2:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)
; 134  : 		_Al.destroy(_Next);
; 135  : 	_RERAISE;
; 136  : 	_CATCH_END
; 137  : 	return (_Dest);
; 138  : 	}

	ret	0
??$_Uninit_copy@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@PAU_GUID@@V?$allocator@U_GUID@@@3@@std@@YAPAU_GUID@@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@0@0PAU1@AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0>,_GUID *,std::allocator<_GUID> >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAU_GUID@@PAU1@V?$allocator@U_GUID@@@std@@@stdext@@YAPAU_GUID@@PAU1@00AAV?$allocator@U_GUID@@@std@@@Z ; stdext::unchecked_uninitialized_copy<_GUID *,_GUID *,std::allocator<_GUID> >
; Function compile flags: /Ogtpy
;	COMDAT ??$unchecked_uninitialized_copy@PAU_GUID@@PAU1@V?$allocator@U_GUID@@@std@@@stdext@@YAPAU_GUID@@PAU1@00AAV?$allocator@U_GUID@@@std@@@Z
_TEXT	SEGMENT
$T221594 = -4						; size = 1
__Cat$221599 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAU_GUID@@PAU1@V?$allocator@U_GUID@@@std@@@stdext@@YAPAU_GUID@@PAU1@00AAV?$allocator@U_GUID@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<_GUID *,_GUID *,std::allocator<_GUID> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T221594[esp+4], 0
	mov	eax, DWORD PTR $T221594[esp+4]
	mov	ecx, DWORD PTR __Cat$221599[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAU_GUID@@PAU1@V?$allocator@U_GUID@@@std@@@std@@YAPAU_GUID@@PAU1@00AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<_GUID *,_GUID *,std::allocator<_GUID> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@PAU_GUID@@PAU1@V?$allocator@U_GUID@@@std@@@stdext@@YAPAU_GUID@@PAU1@00AAV?$allocator@U_GUID@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<_GUID *,_GUID *,std::allocator<_GUID> >
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@IAEXPAU_GUID@@0@Z ; std::vector<_GUID,std::allocator<_GUID> >::_Destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@IAEXPAU_GUID@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@IAEXPAU_GUID@@0@Z PROC ; std::vector<_GUID,std::allocator<_GUID> >::_Destroy, COMDAT
; _this$ = ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1120 : 		}

	ret	8
?_Destroy@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@IAEXPAU_GUID@@0@Z ENDP ; std::vector<_GUID,std::allocator<_GUID> >::_Destroy
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@PAU_GUID@@V?$allocator@U_GUID@@@3@@stdext@@YAPAU_GUID@@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@0PAU1@AAV?$allocator@U_GUID@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0>,_GUID *,std::allocator<_GUID> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@PAU_GUID@@V?$allocator@U_GUID@@@3@@stdext@@YAPAU_GUID@@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@0PAU1@AAV?$allocator@U_GUID@@@4@@Z
_TEXT	SEGMENT
$T221606 = -4						; size = 1
__Cat$221610 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@PAU_GUID@@V?$allocator@U_GUID@@@3@@stdext@@YAPAU_GUID@@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@0PAU1@AAV?$allocator@U_GUID@@@4@@Z PROC ; stdext::unchecked_uninitialized_copy<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0>,_GUID *,std::allocator<_GUID> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T221606[esp+4], 0
	mov	eax, DWORD PTR $T221606[esp+4]
	mov	ecx, DWORD PTR __Cat$221610[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@PAU_GUID@@V?$allocator@U_GUID@@@3@@std@@YAPAU_GUID@@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@0@0PAU1@AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0>,_GUID *,std::allocator<_GUID> >

; 823  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$unchecked_uninitialized_copy@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@PAU_GUID@@V?$allocator@U_GUID@@@3@@stdext@@YAPAU_GUID@@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@0PAU1@AAV?$allocator@U_GUID@@@4@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0>,_GUID *,std::allocator<_GUID> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAU_GUID@@PAU1@V?$allocator@U_GUID@@@std@@U_Undefined_move_tag@3@@std@@YAPAU_GUID@@PAU1@00AAV?$allocator@U_GUID@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<_GUID *,_GUID *,std::allocator<_GUID>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninit_move@PAU_GUID@@PAU1@V?$allocator@U_GUID@@@std@@U_Undefined_move_tag@3@@std@@YAPAU_GUID@@PAU1@00AAV?$allocator@U_GUID@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T221624 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$221628 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAU_GUID@@PAU1@V?$allocator@U_GUID@@@std@@U_Undefined_move_tag@3@@std@@YAPAU_GUID@@PAU1@00AAV?$allocator@U_GUID@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<_GUID *,_GUID *,std::allocator<_GUID>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	ecx, DWORD PTR __Cat$221628[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T221624[esp+4], 0
	mov	eax, DWORD PTR $T221624[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAU_GUID@@PAU1@V?$allocator@U_GUID@@@std@@@std@@YAPAU_GUID@@PAU1@00AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<_GUID *,_GUID *,std::allocator<_GUID> >

; 208  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Uninit_move@PAU_GUID@@PAU1@V?$allocator@U_GUID@@@std@@U_Undefined_move_tag@3@@std@@YAPAU_GUID@@PAU1@00AAV?$allocator@U_GUID@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<_GUID *,_GUID *,std::allocator<_GUID>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@IAEXXZ ; std::vector<_GUID,std::allocator<_GUID> >::_Tidy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@IAEXXZ PROC ; std::vector<_GUID,std::allocator<_GUID> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN4@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);
; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 1135 : 		}

	ret	0
?_Tidy@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@IAEXXZ ENDP ; std::vector<_GUID,std::allocator<_GUID> >::_Tidy
_TEXT	ENDS
PUBLIC	??$_Ucopy@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@IAEPAU_GUID@@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@0PAU2@@Z ; std::vector<_GUID,std::allocator<_GUID> >::_Ucopy<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Ucopy@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@IAEPAU_GUID@@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@0PAU2@@Z
_TEXT	SEGMENT
$T221651 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$221654 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Ucopy@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@IAEPAU_GUID@@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@0PAU2@@Z PROC ; std::vector<_GUID,std::allocator<_GUID> >::_Ucopy<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0> >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$221654[esp]
	mov	BYTE PTR $T221651[esp+4], 0
	mov	eax, DWORD PTR $T221651[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@PAU_GUID@@V?$allocator@U_GUID@@@3@@std@@YAPAU_GUID@@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@0@0PAU1@AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0>,_GUID *,std::allocator<_GUID> >

; 1142 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Ucopy@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@IAEPAU_GUID@@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@0PAU2@@Z ENDP ; std::vector<_GUID,std::allocator<_GUID> >::_Ucopy<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAU_GUID@@PAU1@V?$allocator@U_GUID@@@std@@@stdext@@YAPAU_GUID@@PAU1@00AAV?$allocator@U_GUID@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<_GUID *,_GUID *,std::allocator<_GUID> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAU_GUID@@PAU1@V?$allocator@U_GUID@@@std@@@stdext@@YAPAU_GUID@@PAU1@00AAV?$allocator@U_GUID@@@std@@@Z
_TEXT	SEGMENT
$T221688 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$221692 = 16					; size = 1
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAU_GUID@@PAU1@V?$allocator@U_GUID@@@std@@@stdext@@YAPAU_GUID@@PAU1@00AAV?$allocator@U_GUID@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<_GUID *,_GUID *,std::allocator<_GUID> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$221692[esp]
	mov	edx, DWORD PTR __Al$[esp]
	mov	BYTE PTR $T221688[esp+4], 0
	mov	eax, DWORD PTR $T221688[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAU_GUID@@PAU1@V?$allocator@U_GUID@@@std@@@std@@YAPAU_GUID@@PAU1@00AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<_GUID *,_GUID *,std::allocator<_GUID> >

; 865  : 	}

	add	esp, 28					; 0000001cH
	ret	0
??$_Unchecked_uninitialized_move@PAU_GUID@@PAU1@V?$allocator@U_GUID@@@std@@@stdext@@YAPAU_GUID@@PAU1@00AAV?$allocator@U_GUID@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<_GUID *,_GUID *,std::allocator<_GUID> >
_TEXT	ENDS
PUBLIC	??1?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAE@XZ ; std::vector<_GUID,std::allocator<_GUID> >::~vector<_GUID,std::allocator<_GUID> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??1?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAE@XZ PROC ; std::vector<_GUID,std::allocator<_GUID> >::~vector<_GUID,std::allocator<_GUID> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN6@vector
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN6@vector:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0
	pop	esi

; 560  : 		}

	ret	0
??1?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAE@XZ ENDP ; std::vector<_GUID,std::allocator<_GUID> >::~vector<_GUID,std::allocator<_GUID> >
_TEXT	ENDS
PUBLIC	??$_Umove@PAU_GUID@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@IAEPAU_GUID@@PAU2@00@Z ; std::vector<_GUID,std::allocator<_GUID> >::_Umove<_GUID *>
; Function compile flags: /Ogtpy
;	COMDAT ??$_Umove@PAU_GUID@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@IAEPAU_GUID@@PAU2@00@Z
_TEXT	SEGMENT
$T221758 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$221762 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAU_GUID@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@IAEPAU_GUID@@PAU2@00@Z PROC ; std::vector<_GUID,std::allocator<_GUID> >::_Umove<_GUID *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	edx, DWORD PTR __Cat$221762[esp]
	mov	BYTE PTR $T221758[esp+4], 0
	mov	eax, DWORD PTR $T221758[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	edx
	mov	edx, DWORD PTR __First$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+12]
	push	eax
	push	ecx
	push	edx
	call	??$_Uninit_copy@PAU_GUID@@PAU1@V?$allocator@U_GUID@@@std@@@std@@YAPAU_GUID@@PAU1@00AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<_GUID *,_GUID *,std::allocator<_GUID> >

; 1149 : 		}

	add	esp, 28					; 0000001cH
	ret	12					; 0000000cH
??$_Umove@PAU_GUID@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@IAEPAU_GUID@@PAU2@00@Z ENDP ; std::vector<_GUID,std::allocator<_GUID> >::_Umove<_GUID *>
_TEXT	ENDS
PUBLIC	??_7CvDllDlcPackageInfoList@@6B@		; CvDllDlcPackageInfoList::`vftable'
PUBLIC	??1CvDllDlcPackageInfoList@@QAE@XZ		; CvDllDlcPackageInfoList::~CvDllDlcPackageInfoList
PUBLIC	??_R4CvDllDlcPackageInfoList@@6B@		; CvDllDlcPackageInfoList::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCvDllDlcPackageInfoList@@@8		; CvDllDlcPackageInfoList `RTTI Type Descriptor'
PUBLIC	??_R3CvDllDlcPackageInfoList@@8			; CvDllDlcPackageInfoList::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CvDllDlcPackageInfoList@@8			; CvDllDlcPackageInfoList::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CvDllDlcPackageInfoList@@8	; CvDllDlcPackageInfoList::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?Destroy@CvDllDlcPackageInfoList@@EAGXXZ	; CvDllDlcPackageInfoList::Destroy
;	COMDAT ??_R1A@?0A@EA@CvDllDlcPackageInfoList@@8
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
rdata$r	SEGMENT
??_R1A@?0A@EA@CvDllDlcPackageInfoList@@8 DD FLAT:??_R0?AVCvDllDlcPackageInfoList@@@8 ; CvDllDlcPackageInfoList::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CvDllDlcPackageInfoList@@8
rdata$r	ENDS
;	COMDAT ??_R2CvDllDlcPackageInfoList@@8
rdata$r	SEGMENT
??_R2CvDllDlcPackageInfoList@@8 DD FLAT:??_R1A@?0A@EA@CvDllDlcPackageInfoList@@8 ; CvDllDlcPackageInfoList::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ICvEnumerator@@8
	DD	FLAT:??_R1A@?0A@EA@ICvUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R3CvDllDlcPackageInfoList@@8
rdata$r	SEGMENT
??_R3CvDllDlcPackageInfoList@@8 DD 00H			; CvDllDlcPackageInfoList::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CvDllDlcPackageInfoList@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCvDllDlcPackageInfoList@@@8
_DATA	SEGMENT
??_R0?AVCvDllDlcPackageInfoList@@@8 DD FLAT:??_7type_info@@6B@ ; CvDllDlcPackageInfoList `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCvDllDlcPackageInfoList@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CvDllDlcPackageInfoList@@6B@
rdata$r	SEGMENT
??_R4CvDllDlcPackageInfoList@@6B@ DD 00H		; CvDllDlcPackageInfoList::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCvDllDlcPackageInfoList@@@8
	DD	FLAT:??_R3CvDllDlcPackageInfoList@@8
rdata$r	ENDS
;	COMDAT ??_7CvDllDlcPackageInfoList@@6B@
CONST	SEGMENT
??_7CvDllDlcPackageInfoList@@6B@ DD FLAT:??_R4CvDllDlcPackageInfoList@@6B@ ; CvDllDlcPackageInfoList::`vftable'
	DD	FLAT:?QueryInterface@CvDllDlcPackageInfoList@@UAGPAXU_GUID@@@Z
	DD	FLAT:?Destroy@CvDllDlcPackageInfoList@@EAGXXZ
	DD	FLAT:?MoveNext@CvDllDlcPackageInfoList@@UAG_NXZ
	DD	FLAT:?Reset@CvDllDlcPackageInfoList@@UAGXXZ
	DD	FLAT:?GetCurrent@CvDllDlcPackageInfoList@@UAGPAVICvUnknown@@XZ
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvdlldlcpackageinfo.cpp
CONST	ENDS
;	COMDAT ??1CvDllDlcPackageInfoList@@QAE@XZ
_TEXT	SEGMENT
??1CvDllDlcPackageInfoList@@QAE@XZ PROC			; CvDllDlcPackageInfoList::~CvDllDlcPackageInfoList, COMDAT
; _this$ = ecx

; 88   : {

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvDllDlcPackageInfoList@@6B@

; 89   : }

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN9@CvDllDlcPa
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN9@CvDllDlcPa:
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	pop	esi
	ret	0
??1CvDllDlcPackageInfoList@@QAE@XZ ENDP			; CvDllDlcPackageInfoList::~CvDllDlcPackageInfoList
_TEXT	ENDS
PUBLIC	??_GCvDllDlcPackageInfoList@@QAEPAXI@Z		; CvDllDlcPackageInfoList::`scalar deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_GCvDllDlcPackageInfoList@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCvDllDlcPackageInfoList@@QAEPAXI@Z PROC		; CvDllDlcPackageInfoList::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvDllDlcPackageInfoList@@6B@
	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN11@scalar@5
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN11@scalar@5:
	test	BYTE PTR ___flags$[esp], 1
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	je	SHORT $LN15@scalar@5
	push	esi
	call	?Free@CvDllGameContext@@SAXPAX@Z	; CvDllGameContext::Free
	add	esp, 4
$LN15@scalar@5:
	mov	eax, esi
	pop	esi
	ret	4
??_GCvDllDlcPackageInfoList@@QAEPAXI@Z ENDP		; CvDllDlcPackageInfoList::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??$_Insert@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Vector_const_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@1@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@1Uforward_iterator_tag@1@@Z ; std::vector<_GUID,std::allocator<_GUID> >::_Insert<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$??$_Insert@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Vector_const_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@1@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@1Uforward_iterator_tag@1@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Vector_const_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@1@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@1Uforward_iterator_tag@1@@Z$0
__unwindtable$??$_Insert@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Vector_const_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@1@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@1Uforward_iterator_tag@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Insert@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Vector_const_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@1@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@1Uforward_iterator_tag@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Vector_const_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@1@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@1Uforward_iterator_tag@1@@Z$2
__ehfuncinfo$??$_Insert@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Vector_const_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@1@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@1Uforward_iterator_tag@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Insert@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Vector_const_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@1@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@1Uforward_iterator_tag@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Vector_const_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@1@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@1Uforward_iterator_tag@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??$_Insert@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Vector_const_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@1@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@1Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT
$T222148 = -24						; size = 1
$T222110 = -24						; size = 1
$T222039 = -24						; size = 1
$T222012 = -24						; size = 1
__Newvec$220206 = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$222151 = 8					; size = 1
__Cat$222114 = 8					; size = 1
__Cat$222042 = 8					; size = 1
__Cat$222016 = 8					; size = 1
__Where$ = 8						; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Insert@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Vector_const_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@1@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@1Uforward_iterator_tag@1@@Z PROC ; std::vector<_GUID,std::allocator<_GUID> >::_Insert<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0> >, COMDAT
; _this$ = ecx

; 925  : 		void _Insert(const_iterator _Where,

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Insert@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Vector_const_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@1@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@1Uforward_iterator_tag@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH

; 926  : 			_Iter _First, _Iter _Last, forward_iterator_tag)
; 927  : 		{	// insert [_First, _Last) at _Where, forward iterators
; 928  : 
; 929  :  #if _HAS_ITERATOR_DEBUGGING
; 930  : 		if (_Where._Mycont != this
; 931  : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 932  : 			_DEBUG_ERROR("vector insert iterator outside range");
; 933  : 		_DEBUG_RANGE(_First, _Last);
; 934  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 935  : 
; 936  : 		size_type _Count = 0;
; 937  : 		_Distance(_First, _Last, _Count);

	mov	eax, DWORD PTR __First$[ebp]
	push	ebx
	push	esi
	push	edi
	mov	esi, ecx
	mov	ecx, DWORD PTR __Last$[ebp]
	xor	edi, edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	cmp	eax, ecx
	je	SHORT $LN22@Insert
	npad	1
$LL27@Insert:
	mov	eax, DWORD PTR [eax]
	inc	edi
	cmp	eax, ecx
	jne	SHORT $LL27@Insert
$LN22@Insert:

; 938  : 		size_type _Capacity = capacity();

	mov	edx, DWORD PTR [esi+4]
	test	edx, edx
	jne	SHORT $LN37@Insert
	xor	ebx, ebx
	jmp	SHORT $LN38@Insert
$LN37@Insert:
	mov	ebx, DWORD PTR [esi+12]
	sub	ebx, edx
	sar	ebx, 4
$LN38@Insert:

; 939  : 
; 940  : 		if (_Count == 0)

	test	edi, edi
	je	$LN1@Insert

; 941  : 			;
; 942  : 		else if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR [esi+8]
	mov	eax, ecx
	sub	eax, edx
	sar	eax, 4
	mov	edx, 268435455				; 0fffffffH
	sub	edx, eax
	cmp	edx, edi
	jae	SHORT $LN7@Insert

; 943  : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@KAXXZ ; std::vector<_GUID,std::allocator<_GUID> >::_Xlen
$LN108@Insert:
$LN7@Insert:

; 944  : 		else if (_Capacity < size() + _Count)

	lea	edx, DWORD PTR [eax+edi]
	cmp	ebx, edx
	jae	$LN5@Insert

; 945  : 			{	// not enough room, reallocate
; 946  : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 947  : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ebx
	shr	eax, 1
	mov	ecx, 268435455				; 0fffffffH
	sub	ecx, eax
	cmp	ecx, ebx
	jae	SHORT $LN12@Insert
	xor	ebx, ebx
	jmp	SHORT $LN13@Insert
$LN12@Insert:
	add	ebx, eax
$LN13@Insert:

; 948  : 			if (_Capacity < size() + _Count)

	cmp	ebx, edx
	jae	SHORT $LN4@Insert

; 949  : 				_Capacity = size() + _Count;

	mov	ebx, edx
$LN4@Insert:

; 950  : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	push	0
	push	ebx
	call	??$_Allocate@U_GUID@@@std@@YAPAU_GUID@@IPAU1@@Z ; std::_Allocate<_GUID>

; 951  : 			pointer _Ptr = _Newvec;
; 952  : 
; 953  : 			_TRY_BEGIN
; 954  : 			_Ptr = _Umove(_Myfirst, _VEC_ITER_BASE(_Where),
; 955  : 				_Newvec);	// copy prefix

	mov	ecx, DWORD PTR [esi+4]
	mov	BYTE PTR $T222012[ebp], 0
	mov	edx, DWORD PTR $T222012[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$222016[ebp]
	push	edx
	push	esi
	push	eax
	mov	DWORD PTR __Newvec$220206[ebp], eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	push	ecx
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	??$_Uninit_copy@PAU_GUID@@PAU1@V?$allocator@U_GUID@@@std@@@std@@YAPAU_GUID@@PAU1@00AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<_GUID *,_GUID *,std::allocator<_GUID> >

; 956  : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff

	mov	edx, DWORD PTR __Cat$222042[ebp]
	add	esp, 32					; 00000020H
	mov	BYTE PTR $T222039[ebp], 0
	mov	ecx, DWORD PTR $T222039[ebp]
	push	ecx
	mov	ecx, DWORD PTR __First$[ebp]
	push	edx
	push	esi
	push	eax
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	push	ecx
	call	??$_Uninit_copy@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@PAU_GUID@@V?$allocator@U_GUID@@@3@@std@@YAPAU_GUID@@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@0@0PAU1@AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0>,_GUID *,std::allocator<_GUID> >

; 957  : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast, _Ptr);	// copy suffix

	mov	ecx, DWORD PTR [esi+8]
	add	esp, 24					; 00000018H
	mov	BYTE PTR $T222110[ebp], 0
	mov	edx, DWORD PTR $T222110[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$222114[ebp]
	push	edx
	push	esi
	push	eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	ecx
	push	eax
	call	??$_Uninit_copy@PAU_GUID@@PAU1@V?$allocator@U_GUID@@@std@@@std@@YAPAU_GUID@@PAU1@00AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<_GUID *,_GUID *,std::allocator<_GUID> >

; 962  : 			_CATCH_END
; 963  : 
; 964  : 			_Count += size();

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	sub	ecx, eax
	sar	ecx, 4
	add	esp, 24					; 00000018H
	add	edi, ecx

; 965  : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN95@Insert

; 966  : 				{	// destroy and deallocate old array
; 967  : 				_Destroy(_Myfirst, _Mylast);
; 968  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN95@Insert:

; 969  : 				}
; 970  : 
; 971  :  #if _HAS_ITERATOR_DEBUGGING
; 972  : 			this->_Orphan_all();
; 973  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 974  : 
; 975  : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Newvec$220206[ebp]
	shl	ebx, 4
	add	ebx, eax

; 976  : 			_Mylast = _Newvec + _Count;

	shl	edi, 4
	add	edi, eax
	mov	DWORD PTR [esi+12], ebx
	mov	DWORD PTR [esi+8], edi

; 977  : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+4], eax

; 988  : 
; 989  :  #if _HAS_ITERATOR_DEBUGGING
; 990  : 			_Orphan_range(_Where._Myptr, _Mylast);
; 991  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 992  : 
; 993  : 			}
; 994  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
__catch$??$_Insert@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Vector_const_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@1@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@1Uforward_iterator_tag@1@@Z$0:

; 958  : 			_CATCH_ALL
; 959  : 			_Destroy(_Newvec, _Ptr);
; 960  : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	edx, DWORD PTR __Newvec$220206[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 961  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN109@Insert:
$LN5@Insert:

; 978  : 			}
; 979  : 		else
; 980  : 			{	// new stuff fits, append and rotate into place
; 981  : 			_Ucopy(_First, _Last, _Mylast);

	mov	edx, DWORD PTR __Cat$222151[ebp]
	mov	BYTE PTR $T222148[ebp], 0
	mov	eax, DWORD PTR $T222148[ebp]
	push	eax
	mov	eax, DWORD PTR __Last$[ebp]
	push	edx
	push	esi
	push	ecx
	mov	ecx, DWORD PTR __First$[ebp]
	push	eax
	push	ecx
	call	??$_Uninit_copy@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@PAU_GUID@@V?$allocator@U_GUID@@@3@@std@@YAPAU_GUID@@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@0@0PAU1@AAV?$allocator@U_GUID@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0>,_GUID *,std::allocator<_GUID> >

; 982  : 
; 983  : 			_Reverse(_Where._Myptr, _Mylast);

	mov	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR __Where$[ebp]
	add	esp, 24					; 00000018H
	push	edx
	push	eax
	mov	ecx, esi
	call	?_Reverse@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXPAU_GUID@@0@Z ; std::vector<_GUID,std::allocator<_GUID> >::_Reverse

; 984  : 			_Reverse(_Mylast, _Mylast + _Count);

	mov	eax, DWORD PTR [esi+8]
	shl	edi, 4
	lea	ecx, DWORD PTR [edi+eax]
	push	ecx
	push	eax
	mov	ecx, esi
	call	?_Reverse@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXPAU_GUID@@0@Z ; std::vector<_GUID,std::allocator<_GUID> >::_Reverse

; 985  : 			_Reverse(_Where._Myptr, _Mylast + _Count);

	mov	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR __Where$[ebp]
	add	edx, edi
	push	edx
	push	eax
	mov	ecx, esi
	call	?_Reverse@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXPAU_GUID@@0@Z ; std::vector<_GUID,std::allocator<_GUID> >::_Reverse

; 986  : 
; 987  : 			_Mylast += _Count;

	add	DWORD PTR [esi+8], edi
$LN1@Insert:

; 988  : 
; 989  :  #if _HAS_ITERATOR_DEBUGGING
; 990  : 			_Orphan_range(_Where._Myptr, _Mylast);
; 991  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 992  : 
; 993  : 			}
; 994  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN107@Insert:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Insert@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Vector_const_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@1@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@1Uforward_iterator_tag@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Insert@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Vector_const_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@1@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@1Uforward_iterator_tag@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Insert@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Vector_const_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@1@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@1Uforward_iterator_tag@1@@Z ENDP ; std::vector<_GUID,std::allocator<_GUID> >::_Insert<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0> >
PUBLIC	?DecrementReference@CvDllDlcPackageInfoList@@QAEIXZ ; CvDllDlcPackageInfoList::DecrementReference
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvdlldlcpackageinfo.cpp
;	COMDAT ?DecrementReference@CvDllDlcPackageInfoList@@QAEIXZ
_TEXT	SEGMENT
?DecrementReference@CvDllDlcPackageInfoList@@QAEIXZ PROC ; CvDllDlcPackageInfoList::DecrementReference, COMDAT
; _this$ = ecx

; 110  : {

	push	esi
	mov	esi, ecx

; 111  : 	if(m_uiRefCount == 1)

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 1
	jne	SHORT $LN2@DecrementR@2

; 112  : 	{
; 113  : 		delete this;

	mov	DWORD PTR [esi], OFFSET ??_7CvDllDlcPackageInfoList@@6B@
	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN17@DecrementR@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN17@DecrementR@2:
	push	esi
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	call	?Free@CvDllGameContext@@SAXPAX@Z	; CvDllGameContext::Free
	add	esp, 4

; 114  : 		return 0;

	xor	eax, eax
	pop	esi

; 119  : 		return m_uiRefCount;
; 120  : 	}
; 121  : }

	ret	0
$LN2@DecrementR@2:

; 115  : 	}
; 116  : 	else
; 117  : 	{
; 118  : 		--m_uiRefCount;

	dec	eax
	mov	DWORD PTR [esi+4], eax
	pop	esi

; 119  : 		return m_uiRefCount;
; 120  : 	}
; 121  : }

	ret	0
?DecrementReference@CvDllDlcPackageInfoList@@QAEIXZ ENDP ; CvDllDlcPackageInfoList::DecrementReference
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Destroy@CvDllDlcPackageInfoList@@EAGXXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?Destroy@CvDllDlcPackageInfoList@@EAGXXZ PROC		; CvDllDlcPackageInfoList::Destroy, COMDAT

; 129  : {

	push	esi

; 130  : 	DecrementReference();

	mov	esi, DWORD PTR _this$[esp]
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, 1
	jne	SHORT $LN4@Destroy@2
	mov	DWORD PTR [esi], OFFSET ??_7CvDllDlcPackageInfoList@@6B@
	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN19@Destroy@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN19@Destroy@2:
	push	esi
	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	call	?Free@CvDllGameContext@@SAXPAX@Z	; CvDllGameContext::Free
	add	esp, 4
	pop	esi

; 131  : }

	ret	4

; 130  : 	DecrementReference();

$LN4@Destroy@2:
	dec	eax
	mov	DWORD PTR [esi+4], eax
	pop	esi

; 131  : }

	ret	4
?Destroy@CvDllDlcPackageInfoList@@EAGXXZ ENDP		; CvDllDlcPackageInfoList::Destroy
_TEXT	ENDS
PUBLIC	??$insert@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Vector_const_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@1@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@1@Z ; std::vector<_GUID,std::allocator<_GUID> >::insert<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$insert@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Vector_const_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@1@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@1@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__First$ = 12						; size = 4
$T222304 = 16						; size = 1
__Last$ = 16						; size = 4
??$insert@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Vector_const_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@1@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@1@Z PROC ; std::vector<_GUID,std::allocator<_GUID> >::insert<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0> >, COMDAT
; _this$ = ecx

; 888  : 		{	// insert [_First, _Last) at _Where
; 889  : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));

	mov	eax, DWORD PTR $T222304[esp-4]
	mov	edx, DWORD PTR __Last$[esp-4]
	push	eax
	mov	eax, DWORD PTR __First$[esp]
	push	edx
	mov	edx, DWORD PTR __Where$[esp+4]
	push	eax
	push	edx
	call	??$_Insert@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Vector_const_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@1@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@1Uforward_iterator_tag@1@@Z ; std::vector<_GUID,std::allocator<_GUID> >::_Insert<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0> >

; 890  : 		}

	ret	12					; 0000000cH
??$insert@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Vector_const_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@1@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@1@Z ENDP ; std::vector<_GUID,std::allocator<_GUID> >::insert<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0> >
_TEXT	ENDS
PUBLIC	??$_Construct@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@0Uinput_iterator_tag@1@@Z ; std::vector<_GUID,std::allocator<_GUID> >::_Construct<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$??$_Construct@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@0Uinput_iterator_tag@1@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Construct@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@0Uinput_iterator_tag@1@@Z$0
__unwindtable$??$_Construct@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@0Uinput_iterator_tag@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Construct@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@0Uinput_iterator_tag@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Construct@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@0Uinput_iterator_tag@1@@Z$2
__ehfuncinfo$??$_Construct@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@0Uinput_iterator_tag@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Construct@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@0Uinput_iterator_tag@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Construct@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@0Uinput_iterator_tag@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??$_Construct@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@0Uinput_iterator_tag@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
$T222414 = 12						; size = 1
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Construct@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@0Uinput_iterator_tag@1@@Z PROC ; std::vector<_GUID,std::allocator<_GUID> >::_Construct<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0> >, COMDAT
; _this$ = ecx

; 532  : 		void _Construct(_Iter _First,

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Construct@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@0Uinput_iterator_tag@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8

; 533  : 			_Iter _Last, input_iterator_tag)
; 534  : 		{	// initialize with [_First, _Last), input iterators
; 535  : 		_Buy(0);
; 536  : 		_TRY_BEGIN
; 537  : 		insert(begin(), _First, _Last);

	mov	edx, DWORD PTR $T222414[ebp]
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	push	edx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	edx, DWORD PTR __First$[ebp]
	xor	eax, eax
	push	edx
	push	eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR [ecx+4], eax
	mov	DWORD PTR [ecx+8], eax
	mov	DWORD PTR [ecx+12], eax
	mov	DWORD PTR __$EHRec$[ebp+12], eax
	call	??$_Insert@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Vector_const_iterator@U_GUID@@V?$allocator@U_GUID@@@std@@@1@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@1Uforward_iterator_tag@1@@Z ; std::vector<_GUID,std::allocator<_GUID> >::_Insert<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0> >

; 541  : 		_CATCH_END
; 542  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$??$_Construct@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@0Uinput_iterator_tag@1@@Z$0:

; 538  : 		_CATCH_ALL
; 539  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@IAEXXZ ; std::vector<_GUID,std::allocator<_GUID> >::_Tidy

; 540  : 		_RERAISE;

	xor	eax, eax
	push	eax
	push	eax
	call	__CxxThrowException@8
$LN45@Construct@2:
$LN44@Construct@2:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Construct@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@0Uinput_iterator_tag@1@@Z:
	mov	eax, OFFSET __ehfuncinfo$??$_Construct@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@0Uinput_iterator_tag@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@0Uinput_iterator_tag@1@@Z ENDP ; std::vector<_GUID,std::allocator<_GUID> >::_Construct<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0> >
PUBLIC	??$?0V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAE@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@0@Z ; std::vector<_GUID,std::allocator<_GUID> >::vector<_GUID,std::allocator<_GUID> ><std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0> >
; Function compile flags: /Ogtpy
;	COMDAT ??$?0V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAE@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
$T222435 = 12						; size = 1
__Last$ = 12						; size = 4
??$?0V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAE@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@0@Z PROC ; std::vector<_GUID,std::allocator<_GUID> >::vector<_GUID,std::allocator<_GUID> ><std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0> >, COMDAT
; _this$ = ecx

; 514  : 		_Construct(_First, _Last, _Iter_cat(_First));

	mov	eax, DWORD PTR $T222435[esp-4]
	mov	edx, DWORD PTR __First$[esp-4]
	push	esi
	mov	esi, ecx
	mov	ecx, DWORD PTR __Last$[esp]
	push	eax
	push	ecx
	push	edx
	mov	ecx, esi
	call	??$_Construct@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@0Uinput_iterator_tag@1@@Z ; std::vector<_GUID,std::allocator<_GUID> >::_Construct<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0> >

; 515  : 		}

	mov	eax, esi
	pop	esi
	ret	8
??$?0V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAE@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@0@Z ENDP ; std::vector<_GUID,std::allocator<_GUID> >::vector<_GUID,std::allocator<_GUID> ><std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0> >
_TEXT	ENDS
PUBLIC	??0CvDllDlcPackageInfoList@@QAE@ABV?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@Z ; CvDllDlcPackageInfoList::CvDllDlcPackageInfoList
; Function compile flags: /Ogtpy
; File c:\users\enormousapplepie\documents\github\lekmod\lekmod_dll\cvgamecoredll_expansion2\cvdlldlcpackageinfo.cpp
;	COMDAT ??0CvDllDlcPackageInfoList@@QAE@ABV?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@Z
_TEXT	SEGMENT
$T222543 = 8						; size = 1
_packageIDs$ = 8					; size = 4
??0CvDllDlcPackageInfoList@@QAE@ABV?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@Z PROC ; CvDllDlcPackageInfoList::CvDllDlcPackageInfoList, COMDAT
; _this$ = ecx

; 84   : {

	mov	edx, DWORD PTR $T222543[esp-4]
	mov	eax, DWORD PTR _packageIDs$[esp-4]
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7CvDllDlcPackageInfoList@@6B@
	mov	DWORD PTR [esi+4], 1
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	push	ecx
	lea	ecx, DWORD PTR [esi+8]
	call	??$_Construct@V?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@?$vector@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@QAEXV?$_Const_iterator@$0A@@?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@1@0Uinput_iterator_tag@1@@Z ; std::vector<_GUID,std::allocator<_GUID> >::_Construct<std::list<_GUID,std::allocator<_GUID> >::_Const_iterator<0> >
	mov	DWORD PTR [esi+24], -1

; 85   : }

	mov	eax, esi
	pop	esi
	ret	4
??0CvDllDlcPackageInfoList@@QAE@ABV?$list@U_GUID@@V?$allocator@U_GUID@@@std@@@std@@@Z ENDP ; CvDllDlcPackageInfoList::CvDllDlcPackageInfoList
_TEXT	ENDS
END
